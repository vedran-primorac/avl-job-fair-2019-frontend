{"version":3,"sources":["webpack:///webpack/bootstrap d88f2625f392b477a126","webpack:///./node_modules/@progress/kendo-ui/js/kendo.drawing.js","webpack:///./node_modules/@progress/kendo-ui/js/drawing/kendo-drawing.js","webpack:///./node_modules/@progress/kendo-ui/js/kendo.color.js","webpack:///./node_modules/@progress/kendo-ui/js/kendo.core.js","webpack:///./node_modules/jquery/dist/jquery.js","webpack:///./node_modules/@progress/kendo-ui/js/kendo.data.js","webpack:///./node_modules/@progress/kendo-ui/js/kendo.userevents.js","webpack:///./node_modules/@progress/kendo-ui/js/kendo.popup.js","webpack:///./node_modules/@progress/kendo-ui/js/drawing/util.js","webpack:///./node_modules/@progress/kendo-ui/js/drawing/surface-tooltip.js","webpack:///./node_modules/@progress/kendo-ui/js/dataviz/core/kendo-core.js","webpack:///./node_modules/@progress/kendo-ui/js/kendo.dataviz.themes.js","webpack:///./node_modules/@progress/kendo-ui/js/dataviz/themes/chart-base-theme.js","webpack:///./node_modules/@progress/kendo-ui/js/dataviz/chart/kendo-chart.js","webpack:///./src/avl-xy-chart/avl-xy-chart.ts","webpack:///./node_modules/@progress/kendo-ui/js/kendo.data.odata.js","webpack:///./node_modules/@progress/kendo-ui/js/kendo.data.xml.js","webpack:///./node_modules/@progress/kendo-ui/js/util/text-metrics.js","webpack:///./node_modules/@progress/kendo-ui/js/drawing/surface.js","webpack:///./node_modules/@progress/kendo-ui/js/drawing/html.js","webpack:///./node_modules/@progress/kendo-ui/js/dataviz/core/core.js","webpack:///./node_modules/@progress/kendo-ui/js/dataviz/themes/auto-theme.js","webpack:///./node_modules/@progress/kendo-ui/js/dataviz/themes/themes.js","webpack:///./node_modules/@progress/kendo-ui/js/kendo.dataviz.chart.js","webpack:///./node_modules/@progress/kendo-ui/js/dataviz/chart/chart.js","webpack:///./node_modules/@progress/kendo-ui/js/kendo.dataviz.core.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AC7DA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAgB;;AAE1C,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAyB;;AAEnD,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAA2B;;AAErD,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAmB;;AAE7C,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAgB;;AAE1C,OAAO;;AAEP,UAAU,E;;;;;;;ACzHV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,4BAA4B,QAAQ;;AAEpC;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,QAAQ;;AAEhC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,0BAA0B;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,aAAa;;AAE1C;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA,iCAAiC,aAAa;;AAE9C;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,OAAO;AACnC,4BAA4B,OAAO;AACnC,4BAA4B,OAAO;AACnC,4BAA4B,OAAO;AACnC,4BAA4B,OAAO;AACnC,4BAA4B,OAAO;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,oCAAoC,iBAAiB;;AAErD;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA,iCAAiC,iBAAiB;;AAElD;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,oCAAoC,iBAAiB;;AAErD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA,iCAAiC,sBAAsB;AACvD,+BAA+B,mBAAmB;;AAElD;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,4BAA4B,OAAO;;AAEnC;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iCAAiC,wBAAwB;;AAEzD;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA,iCAAiC,iBAAiB;AAClD,iCAAiC,eAAe;;AAEhD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,kCAAkC,cAAc;;AAEhD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA,0CAA0C,0CAA0C;;AAEpF;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iCAAiC,sBAAsB;AACvD,iCAAiC,YAAY;;AAE7C;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,OAAO;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mCAAmC,2BAA2B;AAC9D,kCAAkC,cAAc;;AAEhD;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,gCAAgC,uBAAuB;;AAEvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iCAAiC,sBAAsB;AACvD,kCAAkC,cAAc;;AAEhD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2BAA2B,cAAc;;AAEjF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,YAAY;;AAE5C;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;AACA,MAAM;;AAEN;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,UAAU;AACzC,8BAA8B,SAAS;;AAEvC;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,4FAA4F;AAC5F,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,YAAY;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mCAAmC,wBAAwB;AAC3D,kCAAkC,cAAc;;AAEhD;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;AAEA,4BAA4B,wBAAwB;AACpD;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,wBAAwB;AAC3D,kCAAkC,cAAc;;AAEhD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA,+BAA+B,mBAAmB;AAClD,kCAAkC,cAAc;;AAEhD;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,qBAAqB;AACjD;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,UAAU;AACzC;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,mCAAmC,uBAAuB;AAC1D,kCAAkC,cAAc;;AAEhD;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA,sBAAsB,uBAAuB;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2BAA2B;AAC5D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC,cAAc;;AAEhD;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,gCAAgC,YAAY;;AAE5C;AACA,0BAA0B,oBAAoB;AAC9C;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA,kCAAkC,cAAc;;AAEhD;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC;AACnC;AACA,MAAM;;AAEN,yBAAyB;;AAEzB,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA,mCAAmC,wBAAwB,WAAW;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,EAAE;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN,mCAAmC;;AAEnC,2BAA2B;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;;AAEA;AACA,MAAM;;AAEN,wBAAwB;;AAExB;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,+CAA+C;AAC/C;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA,MAAM,YAAY,EAAE;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,0CAA0C,cAAc,kBAAkB;AAC1E;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,4CAA4C,iBAAiB;AAC7D;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,kCAAkC,wBAAwB,WAAW;;AAErE;AACA;AACA;;AAEA,4BAA4B,sBAAsB;AAClD;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA,yCAAyC;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,gCAAgC;AAChC;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,4BAA4B,kBAAkB;AAC9C;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA,MAAM;;AAEN;AACA,mFAAmF;AACnF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,8BAA8B,+BAA+B;AAC7D;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA,4DAA4D,cAAc;AAC1E;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,4CAA4C,cAAc;AAC1D,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,yCAAyC;;AAEzC;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,wCAAwC,6BAA6B;AACrE;AACA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA,wCAAwC,wCAAwC;AAChF;AACA;AACA,wCAAwC,uCAAuC;AAC/E;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,GAAG;AACjD;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,0BAA0B;AAC1B,sBAAsB;AACtB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qCAAqC;AACpE,kBAAkB;AAClB,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,eAAe;AACvD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,EAAE,0CAA0C;;AAE5C;AACA;AACA;AACA;AACA,mEAAmE,aAAa;AAChF;AACA;AACA;AACA,EAAE,0CAA0C;;AAE5C;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,sCAAsC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB;;AAEA;AACA,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB;AACA;;AAEA;AACA,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,EAAE;AACrD;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAyB,EAAE;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB,kBAAkB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,eAAe;AACvC;AACA,cAAc;;AAEd;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,6CAA6C;AAC7C,6CAA6C;AAC7C,gDAAgD;AAChD,+CAA+C;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kBAAkB;AAClB,oCAAoC,0BAA0B;AAC9D;AACA;AACA,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,GAAG;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,0BAA0B,EAAE;AAC1F,4DAA4D,0BAA0B,EAAE;AACxF,gEAAgE,0BAA0B,EAAE;AAC5F;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,2DAA2D;AAC3D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,UAAU,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wBAAwB,EAAE;AACtF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;AACV;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF,EAAE;;AAEF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAQ;;AAElC,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAgB;;AAE1C,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAsB;;AAEhD,OAAO;;AAEP,UAAU,E;;;;;;;AC75TV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAc;;AAExC,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,2BAA2B;;AAEpE;AACA;;AAEA;AACA,uBAAuB,GAAG;;AAE1B,wBAAwB,aAAa,EAAE;;AAEvC,wBAAwB,aAAa,EAAE;;AAEvC,wBAAwB,+BAA+B,EAAE;;AAEzD,0BAA0B,aAAa,EAAE;;AAEzC,wBAAwB,2BAA2B,EAAE;;AAErD;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,iCAAiC,oBAAoB;AACrD;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,2DAA2D;AAC3D,6CAA6C;AAC7C,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA,0BAA0B,WAAW;;AAErC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,OAAO,OAAO;AAC7C,+BAA+B,OAAO,OAAO;AAC7C,+BAA+B,OAAO,OAAO;AAC7C,+BAA+B,OAAO,OAAO;AAC7C,+BAA+B,OAAO,OAAO;AAC7C,gCAAgC,OAAO,OAAO;AAC9C;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,4BAA4B,EAAE,WAAW,EAAE,WAAW,EAAE;AACxD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8BAA8B,sBAAsB;AACpD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,IAAI,SAAS,IAAI,SAAS,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,eAAe,EAAE,KAAK,EAAE,KAAK,EAAE;AAC/B;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,eAAe,EAAE,KAAK,EAAE,KAAK,EAAE;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,EAAE;;AAEF,EAAE;;AAEF,OAAO;;AAEP,UAAU,E;;;;;;;ACznBV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAQ;;AAElC,OAAO;;AAEP;AACA;;AAEA,iGAAiG,8CAA8C;AAC/I;AACA,EAAE;;AAEF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,aAAa,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,qBAAqB;AACrB;AACA,2BAA2B,WAAW,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,yBAAyB;AACzB;;AAEA;;AAEA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD,cAAc;AACpE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD,cAAc;AACpE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,sDAAsD,cAAc;AACpE;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA,eAAe;AACf,2BAA2B,aAAa;AACxC;AACA;AACA;;AAEA;AACA,6BAA6B,IAAI,KAAK;AACtC,mCAAmC;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,cAAc;AAC9D;AACA;;AAEA;AACA,UAAU;AACV;AACA,qCAAqC;AACrC;AACA;AACA;AACA,uFAAuF;AACvF;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qEAAqE;;AAErE;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA,0BAA0B,oBAAoB;AAC9C;AACA;;AAEA,+CAA+C,MAAM;;AAErD,kDAAkD;;AAElD;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,kEAAkE,EAAE,mBAAmB,EAAE;AACzF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,sBAAsB;;;AAGtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C,mBAAmB,wDAAwD;AAC3E,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,WAAW;AACvC;AACA;;AAEA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6BAA6B,UAAU;AACvC;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mGAAmG;AACnG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mDAAmD,cAAc;AACjE;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAc;AACd;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,8BAA8B,cAAc;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAsD,cAAc;AACpE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA,qCAAqC;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,4DAA4D,2DAA2D;AACvH,6DAA6D,4DAA4D;AACzH;AACA,EAAE;;;AAGF;AACA;AACA;AACA,yCAAyC,IAAI;AAC7C,wCAAwC,IAAI,KAAK,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB,qBAAqB,IAAI;AACzB,qBAAqB,EAAE;AACvB,UAAU;AACV,4BAA4B;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,iEAAiE,eAAe;AAChF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,YAAY;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,cAAc;AAC7B;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,oEAAoE;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,cAAc;AACpC;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uEAAuE,kEAAkE;AACzI,yEAAyE,+BAA+B;;AAExG;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,0BAA0B,UAAU;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,YAAY;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA,wBAAwB;;AAExB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,sDAAsD,kBAAkB,OAAO,WAAW;AAC1F,wCAAwC;AACxC;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4EAA4E,cAAc,EAAE;;AAE5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH;AAClH,uIAAuI;;AAEvI;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mDAAmD;AACnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,aAAa;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV,2CAA2C;;AAE3C;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;;AAEd,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA,cAAc;;AAEd;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,4HAA4H;;AAE5H;;AAEA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,mBAAmB;AACnC,iBAAiB,kBAAkB;AACnC,gBAAgB,gBAAgB;AAChC,cAAc,kBAAkB;AAChC,eAAe,oBAAoB;AACnC,kBAAkB,iBAAiB;AACnC,gBAAgB,iBAAiB;AACjC,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,8BAA8B,iDAAiD;AAC/E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY,qDAAqD,EAAE;;AAE7E;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA,cAAc;;AAEd;AACA;AACA,cAAc;;AAEd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,0BAA0B,0BAA0B,+BAA+B,6BAA6B;AACtK;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,cAAc;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,4EAA4E;AAC5E;AACA;;AAEA;AACA,iEAAiE;AACjE;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,kCAAkC,EAAE;AACpC,+BAA+B;AAC/B,qCAAqC;AACrC,qCAAqC;AACrC,uBAAuB,aAAa,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA,wBAAwB,QAAQ;AAChC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA,wDAAwD,SAAS;AACjE;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,oCAAoC,YAAY,eAAe,EAAE;AACjE;;AAEA,qDAAqD;;AAErD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV,8BAA8B;;AAE9B;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,sBAAsB;AACtB;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB;AACjB;;AAEA;;AAEA;AACA,gCAAgC,gBAAgB;AAChD,gCAAgC,WAAW,MAAM;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,OAAO;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,wDAAwD,cAAc;AACtE;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,cAAc;AAChE;AACA;;AAEA,sCAAsC;AACtC;;AAEA;AACA;;AAEA;AACA,sCAAsC;AACtC,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD,EAAE,gCAAgC,EAAE;AAC7F;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,gCAAgC;AAChC;;AAEA,2EAA2E,SAAS;AACpF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gFAAgF,EAAE,MAAM,EAAE;AAC1F;;AAEA;;AAEA;AACA,gFAAgF,EAAE,MAAM,EAAE;AAC1F;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,gCAAgC,oBAAoB,aAAa,EAAE,+BAA+B;;AAElG;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV,kBAAkB;;AAElB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA,sBAAsB;AACtB,uBAAuB;AACvB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;;AAEN;AACA;AACA,uBAAuB,cAAc;;AAErC;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD,YAAY;AACpE;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAiE;AACjE;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;;AAGA,oCAAoC,2BAA2B,EAAE;AACjE;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,wBAAwB;AACxB,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;;AAEd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;;AAEd;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iDAAiD,UAAU;AAC3D;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,4BAA4B,+BAA+B;AAC3D;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iCAAiC;;AAE/E;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC,sDAAsD;AACtD;AACA;AACA,cAAc,mDAAmD;AACjE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD,gDAAgD,uCAAuC,EAAE;AACzF;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,uBAAuB,EAAE;AACzB;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;;AAEA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gCAAgC;;AAEhC;AACA,6CAA6C;AAC7C;AACA;AACA;;AAEA,kCAAkC,qBAAqB;AACvD;AACA;AACA,kDAAkD,oBAAoB;AACtE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,YAAY;AACZ,UAAU;;AAEV;AACA;;AAEA,EAAE;;AAEF;;AAEA,EAAE;;AAEF,6BAA6B;;AAE7B,OAAO;;AAEP,UAAU,E;;;;;;;AC54IV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,YAAY;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF,oBAAoB;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,SAAS;AAClB;AACA;;AAEA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,YAAY;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,YAAY;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA,gBAAgB,IAAI;;AAEpB;AACA;;AAEA;;AAEA;AACA;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,GAAG;AACH,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,SAAS;;AAET;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ,6BAA6B;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,eAAe;;AAEf,SAAS;;AAET;AACA,QAAQ,iCAAiC;AACzC,QAAQ,oBAAoB;AAC5B,QAAQ,sCAAsC;AAC9C,QAAQ;AACR,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,gBAAgB,aAAa,EAAE;AAC/B;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO;AACP;AACA;AACA;AACA;AACA,6DAA6D;;AAE7D;AACA;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gEAAgE;;AAEhE;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E,sCAAsC,2BAA2B;AACjE;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,UAAU,UAAU;AACpB;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,UAAU,cAAc;AACxB;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,YAAY,uEAAuE;AACnF;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,SAAS;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,2DAA2D;;AAE3D;AACA;AACA,oFAAoF;;AAEpF;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,QAAQ,SAAS;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,SAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,QAAQ,SAAS;AACjB;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iDAAiD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD;AACjD,UAAU,wCAAwC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA,CAAC;;;;AAID;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA,QAAQ,GAAG;AACX;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;;;AAIA;;AAEA;;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,OAAO;AACjB,0BAA0B,wBAAwB;;AAElD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA,0CAA0C;AAC1C,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;;;;AAIA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU,cAAc;AACxB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA,OAAO;AACP,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,sCAAsC;AAC9E,oCAAoC,uCAAuC;AAC3E,oCAAoC,sCAAsC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC,qCAAqC;AACrC,oCAAoC;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA,EAAE;AACF;;;;;AAKA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,aAAa;AACpC,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,SAAS;AAC7B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ,gBAAgB;AACxB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;;AAEA;;AAEA;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAE;AACF;;AAEA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA,QAAQ,OAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,OAAO;AACf;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,gBAAgB;AAClB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW;;AAEX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA,oDAAoD;AACpD;;AAEA;AACA;;AAEA,cAAc,sBAAsB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+DAA+D;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,cAAc;;AAExB;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uCAAuC;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uDAAuD;AAC9E;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;;AAGD;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,OAAO;AACjB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,+BAA+B;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA,SAAS,qCAAqC;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;;AAEA,SAAS,8BAA8B;AACvC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,YAAY,OAAO;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,WAAW;AACpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+CAA+C,cAAc,WAAW;AACxE,mBAAmB,UAAU;AAC7B;AACA,sBAAsB,cAAc,sBAAsB,gBAAgB;AAC1E,gBAAgB,WAAW,YAAY;AACvC,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;;AAGD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,+DAA+D;AAC3E;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,QAAQ,OAAO;;AAEf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA,UAAU,OAAO;AACjB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA,QAAQ,OAAO;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,gBAAgB;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iDAAiD,0BAA0B;AAC3E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,gBAAgB;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,2BAA2B;AAC3B;AACA,qBAAqB;AACrB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA,QAAQ,gBAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA,SAAS,gBAAgB;AACzB;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE;AACF;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,cAAc;AAClC,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,SAAS;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B,WAAW,kBAAkB;AAC7B,cAAc;AACd,CAAC;AACD;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAQ,mBAAmB;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;AAKD;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;AAKD;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;AAKD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA,iCAAiC;AACjC;AACA;;AAEA,IAAI;AACJ;;AAEA,IAAI;AACJ;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA,WAAW,SAAS;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;AAKD;;;AAGA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC;AACA;AACA;;AAEA;;AAEA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA,UAAU,KAAK;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;;AAEA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qCAAqC;;AAEpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,EAAE;;AAEF;AACA;AACA;AACA;;AAEA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,KAAK;AACL;;AAEA,WAAW;AACX,GAAG;AACH;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB,gDAAgD;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;;AAEA;;AAEA;AACA;;AAEA;AACA,iBAAiB;AACjB,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC;;AAElC;AACA,sBAAsB;AACtB,2BAA2B;;AAE3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,IAAI;AACJ;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;AAKD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;AAKD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,CAAC;;;;;AAKD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;AAKD;AACA;AACA;AACA,EAAE;AACF;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;;AAEnB;AACA;;AAEA;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA,cAAc,sDAAsD;AACpE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;AAGD;AACA,cAAc,mCAAmC;AACjD,eAAe,6DAA6D;AAC5E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF,CAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;;;;AAKD;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK,IAA0C;AAC/C,CAAC,iCAAkB,EAAE,mCAAE;AACvB;AACA,EAAE;AAAA,oGAAE;AACJ;;;;;AAKA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA,CAAC;;;;;;;;AC3nUD;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAc;;AAExC,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA,0BAA0B,cAAc;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kDAAkD,cAAc;AAChE;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB;AAClB;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA,UAAU;;AAEV;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA,mBAAmB,UAAU;AAC7B;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,8BAA8B,mBAAmB;AACjD;AACA;;AAEA;AACA,8CAA8C,aAAa,EAAE;AAC7D,UAAU;AACV;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,4BAA4B;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA,gCAAgC,eAAe;;AAE/C;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD,6BAA6B;;AAEpF;AACA;AACA,qEAAqE,aAAa,EAAE;AACpF;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;;AAEA,8CAA8C;AAC9C;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC;;AAEnC;AACA,sCAAsC,iCAAiC;AACvE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,uCAAuC;AACvC;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,sCAAsC,aAAa,EAAE;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,aAAa,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wDAAwD,cAAc;AACtE;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA,yDAAyD,cAAc;AACvE;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,sBAAsB,cAAc;AACpC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,kBAAkB,qBAAqB;AACvC;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,cAAc;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB;AAClB;;AAEA;AACA;AACA,yDAAyD,yBAAyB;AAClF;;AAEA,mDAAmD,gBAAgB,EAAE;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD,cAAc;AACjE;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB;AACrB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,qDAAqD,yBAAyB;AAC9E;;AAEA,8CAA8C,SAAS,iEAAiE,EAAE;AAC1H;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2DAA2D,cAAc;AACzE;AACA;;AAEA,sCAAsC,uCAAuC;AAC7E;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA,gDAAgD,cAAc;AAC9D;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D,4EAA4E;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA,8CAA8C,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,oDAAoD,cAAc;AAClE;AACA;;AAEA;;AAEA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,cAAc;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC;AACtC,yCAAyC;;AAEzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,qCAAqC,oBAAoB;AACzD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA,4CAA4C,cAAc;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,cAAc;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,cAAc;AAC1D;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C,iCAAiC;AACjC,0CAA0C;AAC1C,oCAAoC;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA,cAAc;AACd;AACA,oCAAoC,0BAA0B;AAC9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD,oBAAoB;AAC1E;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA,4CAA4C,cAAc;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,cAAc;AACjE;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;;AAEA;AACA;;AAEA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA,sCAAsC,yBAAyB;AAC/D;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,uCAAuC,sBAAsB;AAC7D;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,oBAAoB;AACtD;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;;AAEA,8BAA8B,oBAAoB;AAClD;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB;AACtD;AACA;AACA;;AAEA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;;AAEA;;AAEA,mCAAmC,iBAAiB;;AAEpD;AACA,kBAAkB;AAClB,cAAc;AACd;;AAEA,+BAA+B,iBAAiB;AAChD;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gDAAgD,cAAc;AAC9D;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,iCAAiC;;AAExE;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd,2DAA2D,uBAAuB,EAAE;AACpF;;AAEA;AACA;AACA;;AAEA,kDAAkD,cAAc;AAChE;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,UAAU;;AAEV;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;;AAEA,yCAAyC,iBAAiB;;AAE1D;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,kBAAkB;AAClB;AACA,sCAAsC,uBAAuB;AAC7D;AACA;;AAEA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,6CAA6C,aAAa;;AAE1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,QAAQ,oBAAoB,EAAE;AACjF;AACA,cAAc;AACd,oDAAoD,cAAc;AAClE,mDAAmD,uBAAuB;AAC1E;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,+DAA+D,eAAe;AAC9E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;;AAEA;;AAEA;AACA;AACA,0BAA0B;AAC1B,sBAAsB;AACtB;;AAEA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA,cAAc;;AAEd;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,uCAAuC,+BAA+B;;AAEtE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,8BAA8B;AAC5D;AACA;AACA;;AAEA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;;AAEA,kCAAkC,mBAAmB;AACrD;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,kCAAkC,8BAA8B;AAChE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,gCAAgC,sEAAsE;AACtG,gDAAgD,0BAA0B,EAAE;AAC5E,UAAU;;AAEV;AACA;AACA,uCAAuC,EAAE;AACzC,kCAAkC,qDAAqD;AACvF,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,kCAAkC;AAClC;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,0CAA0C,gFAAgF;AAC1H;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,2CAA2C,sBAAsB;AACjE;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,uDAAuD,cAAc;AACrE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,cAAc;AACd;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA,2DAA2D,eAAe;AAC1E;AACA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,eAAe;AAC1D,uCAAuC,qBAAqB;AAC5D;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,8BAA8B,yBAAyB;AACvD;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,8BAA8B,YAAY;AAC1C;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0BAA0B,uBAAuB;AACjD,UAAU;;AAEV;AACA;;AAEA;AACA,8BAA8B,aAAa;AAC3C;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,eAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,kDAAkD;AAClD,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD,kBAAkB;AACxE;AACA;AACA;;AAEA,4CAA4C,kBAAkB;AAC9D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iFAAiF,wBAAwB;AACzG,kCAAkC;AAClC;AACA,iFAAiF,oCAAoC;AACrH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,iEAAiE;AAC/F;AACA;AACA;;AAEA;;AAEA,2CAA2C,+BAA+B;;AAE1E;;AAEA;;AAEA;;AAEA,gEAAgE,cAAc;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oDAAoD,0BAA0B,EAAE;AAChF;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB,gDAAgD;AAChD;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,0BAA0B;AAC1B;AACA;AACA,sBAAsB;AACtB,kBAAkB;AAClB,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,eAAe;AACjE;AACA;AACA;AACA,sBAAsB;AACtB;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA,kDAAkD,cAAc;AAChE;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA,4DAA4D,cAAc;AAC1E;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;;AAEA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,+DAA+D;;AAE/D;AACA,gFAAgF,6BAA6B;;AAE7G;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB,mGAAmG,aAAa;AAChH,kBAAkB;AAClB,uDAAuD;AACvD;;AAEA,iDAAiD;AACjD;;AAEA;AACA;AACA;AACA,UAAU;AACV,6CAA6C,2BAA2B;AACxE;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,cAAc;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA,sEAAsE,UAAU,gBAAgB,EAAE;AAClG;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,cAAc;AAC7D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,cAAc;AAC1D;AACA;AACA;;AAEA,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC;AACvC;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;;AAEA,0DAA0D,GAAG,UAAU,+BAA+B,EAAE;;AAExG;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,8BAA8B,uDAAuD;AAC7G;;AAEA;AACA,0BAA0B,uBAAuB;AACjD,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2DAA2D,aAAa;AACxE;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,8BAA8B,mBAAmB;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,gDAAgD,cAAc;AAC9D;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6CAA6C,cAAc;AAC3D,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,8CAA8C,gBAAgB;;AAE9D,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;;AAEd;AACA;AACA,cAAc;;AAEd;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,6CAA6C,cAAc;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB,iDAAiD,eAAe;AAChE;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,uCAAuC;;AAErF;AACA;AACA,mDAAmD,uCAAuC;AAC1F,kBAAkB;AAClB;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB;AAC9D;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,wDAAwD,iBAAiB;AACzE,kBAAkB;AAClB;AACA,yDAAyD,6BAA6B;AACtF,kBAAkB;AAClB;AACA,wDAAwD,6BAA6B;AACrF,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,oDAAoD,kDAAkD;AACtG;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,UAAU;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,EAAE;;AAEF;;AAEA,EAAE;;;AAGF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAoB;;AAE9C,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAkB;;AAE5C,OAAO;;AAEP,UAAU,E;;;;;;;AC3sKV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAc;;AAExC,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,+DAA+D;;AAE/D;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA,kCAAkC,QAAQ;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA,kCAAkC,QAAQ;;AAE1C;AACA;;AAEA,+CAA+C;;AAE/C;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,cAAc,cAAc;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uEAAuE,gBAAgB;;AAEvF;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;;AAEA,0DAA0D,gBAAgB;AAC1E,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA,8DAA8D,WAAW;AACzE;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;;AAEA;AACA,qDAAqD;AACrD,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,4BAA4B;AACtD;AACA;AACA;;AAEA,0BAA0B,sBAAsB;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,EAAE;;;AAGF,OAAO;;AAEP,UAAU,E;;;;;;;AChsBV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAc;;AAExC,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4GAA4G;;AAE5G;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;;AAElB;;AAEA;AACA,sCAAsC,QAAQ,YAAY,EAAE,UAAU,wBAAwB,EAAE;AAChG;;AAEA;AACA;AACA,uCAAuC,oBAAoB,EAAE;AAC7D;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,yBAAyB;AACzB;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,0BAA0B,8CAA8C;AACxE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA,6DAA6D;AAC7D;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA,yDAAyD;AACzD;;AAEA;;AAEA;AACA;AACA;;AAEA,yCAAyC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,4CAA4C;AAC5C;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;;AAElB;;AAEA;AACA,kCAAkC,wBAAwB;AAC1D,kBAAkB;AAClB,gDAAgD;AAChD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,sCAAsC,WAAW;AACjD,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kDAAkD,cAAc;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8BAA8B,8BAA8B;AAC5D,cAAc;AACd;AACA;;AAEA;AACA;AACA,yGAAyG;;AAEzG;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gDAAgD;AAChD,iDAAiD;AACjD;;AAEA,oCAAoC;AACpC,qCAAqC;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;;;;AAIF;;AAEA,EAAE;;;AAGF,OAAO;;AAEP,UAAU,E;;;;;;;ACh5BV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN,EAAE;;AAEF;;AAEA,EAAE;;AAEF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAe;;AAEzC,OAAO;;AAEP,UAAU,E;;;;;;;ACpGV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAiB;;AAE3C,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,mDAAmD;AACnD,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,8DAA8D;AACtH;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,uDAAuD,+CAA+C;AACtG;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uCAAuC;AACzF;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,MAAM;;AAEN;;AAEA,EAAE;;AAEF,EAAE;;AAEF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAgB;;AAE1C,OAAO;;AAEP,UAAU,E;;;;;;;ACxaV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAqB;;AAE/C,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAkB;;AAE5C,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,0BAA0B;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,0BAA0B;AACpD;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,oBAAoB;;AAEzD,oBAAoB;;AAEpB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,cAAc,EAAE;;AAEvD,iCAAiC,cAAc,EAAE;;AAEjD,kCAAkC,wBAAwB;AAC1D;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,+BAA+B,WAAW,MAAM;;AAEhD;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd,UAAU;AACV;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,kCAAkC,cAAc;;AAEhD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA;;AAEA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,cAAc;;AAE5C;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEF;AACA,4BAA4B,UAAU,YAAY;;AAElD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;AACtC,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,EAAE;;AAEF,6BAA6B;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;;AAEA,qCAAqC;AACrC,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN,kCAAkC;;AAElC;AACA,0CAA0C;AAC1C;AACA,MAAM;;AAEN;AACA;;AAEA,0CAA0C;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oDAAoD,iDAAiD,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,mCAAmC;;AAEnC;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,eAAe;AACf,gBAAgB;AAChB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4BAA4B;AACxE,cAAc;AACd,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gEAAgE;AAChE;AACA;AACA,MAAM,OAAO;AACb;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV,8CAA8C;AAC9C;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,YAAY;AAChC,sCAAsC;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,wBAAwB;AAC3D;AACA;AACA;AACA;;AAEA,kCAAkC,0BAA0B;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,mEAAmE,qBAAqB;;AAExF;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA,UAAU;AACV;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,8CAA8C,oDAAoD;AAClG,uCAAuC,EAAE,YAAY,8BAA8B;;AAEnF;AACA;;AAEA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA,8BAA8B,gBAAgB;;AAE9C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA,6DAA6D;;AAE7D;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wDAAwD;;AAExD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC,mCAAmC;;AAE1E;;AAEA;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;;AAEA,gDAAgD;AAChD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;;AAEV,gDAAgD;AAChD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,wCAAwC,EAAE;AAC1C;AACA;AACA,UAAU;AACV;;AAEA,+DAA+D,sCAAsC,EAAE;;AAEvG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,iBAAiB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,wBAAwB,kBAAkB;AAC1C,qCAAqC;AACrC;;AAEA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,cAAc;;AAEd;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV,6DAA6D,0DAA0D,EAAE;;AAEzH,0BAA0B,wBAAwB;AAClD;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,qBAAqB;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,0BAA0B,yBAAyB;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,0BAA0B,qFAAqF;AAC/G,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC,kBAAkB;;AAErD;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN,mCAAmC;;AAEnC;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,oBAAoB;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,YAAY;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA,gCAAgC,eAAe;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,UAAU;AACV;;AAEA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,iBAAiB;AACjB,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,eAAe;AACvC;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA,uCAAuC,gEAAgE;AACvG;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,UAAU,GAAG,mBAAmB;;AAEhC;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAA+D,iBAAiB;AAChF;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,gBAAgB;AAChD;AACA,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,oEAAoE;;AAEpE;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,qCAAqC,oBAAoB;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,cAAc;AACzC;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,gEAAgE,uCAAuC,EAAE;AACzG,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;;AAEV,wBAAwB,sBAAsB;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA,qCAAqC,oBAAoB;;AAEzD;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,6BAA6B,WAAW;;AAExC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,uCAAuC,4BAA4B,gBAAgB;AACnF;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB,UAAU;AAClE,iCAAiC,uBAAuB,UAAU;AAClE;;AAEA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,0CAA0C,yBAAyB;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA,kCAAkC,sBAAsB;AACxD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,yBAAyB;AAC9D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,EAAE;;AAEF,EAAE;;AAEF,OAAO;;AAEP,UAAU,E;;;;;;;AC54NV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAsB;;AAEhD,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;;;AAGF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAmC;;AAE7D,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAA6B;;AAEvD,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAyB;;AAEnD,OAAO;;AAEP,UAAU,E;;;;;;;ACnHV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAA0B;;AAEpD,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE,EAAE;;AAEJ,iCAAiC;AACjC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE;;AAEJ,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE,EAAE;;AAEJ,oCAAoC;AACpC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE,EAAE;;AAEJ,8BAA8B;AAC9B;AACA;AACA,EAAE,EAAE;;AAEJ,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,EAAE,EAAE;;AAEJ,iCAAiC;AACjC;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,EAAE,EAAE;;AAEJ,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE;;AAEJ,sCAAsC;AACtC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE,EAAE;;AAEJ,iCAAiC;AACjC;AACA;AACA,EAAE,EAAE;;AAEJ,gCAAgC;AAChC;AACA,EAAE,EAAE;;AAEJ,+BAA+B;AAC/B;AACA,EAAE,EAAE;;AAEJ,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,EAAE,EAAE;;AAEJ,oCAAoC;AACpC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE,EAAE;;AAEJ,oCAAoC;AACpC;AACA;AACA,MAAM;AACN;AACA,EAAE,EAAE;;AAEJ,mCAAmC;AACnC;AACA;AACA,EAAE,EAAE;;AAEJ,sCAAsC;AACtC;AACA;AACA,EAAE,EAAE;;AAEJ,sCAAsC;AACtC;AACA,EAAE,EAAE;;AAEJ,oCAAoC;AACpC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE,EAAE;;AAEJ,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE;;AAEJ,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE;;AAEJ,0CAA0C;AAC1C;AACA;AACA;AACA,MAAM;AACN,oCAAoC;AACpC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE;;AAEJ,0BAA0B;AAC1B;AACA,EAAE,EAAE;;AAEJ,2BAA2B;AAC3B;AACA;AACA;AACA,EAAE,EAAE;;AAEJ;AACA,8BAA8B,cAAc;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,EAAE;;AAEF,EAAE;;AAEF,EAAE;;AAEF,OAAO;;AAEP,UAAU,E;;;;;;;AC1ZV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAA0B;;AAEpD,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAqB;;AAE/C,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,gCAAgC,cAAc;;AAE9C;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,sCAAsC,yBAAyB;AAC/D,sCAAsC,kBAAkB;;AAExD,wBAAwB,wBAAwB;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,uBAAuB,eAAe,mBAAmB;AACzD;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,4BAA4B,YAAY;AACxC;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,oCAAoC,oBAAoB;;AAExD;;AAEA;AACA;;AAEA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,4BAA4B,YAAY;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0BAA0B,yBAAyB;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA,4BAA4B,YAAY;AACxC,6BAA6B,gBAAgB;;AAE7C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,kEAAkE,EAAE;AACpE;AACA,cAAc;AACd;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,qCAAqC,gBAAgB;;AAErD;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,2BAA2B;AACvD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;;AAEA,8BAA8B,6BAA6B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,2BAA2B;AAC3B,+BAA+B,aAAa;AAC5C,+BAA+B,cAAc;AAC7C;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,iDAAiD;;AAEjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB;AACjB,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,sBAAsB;;AAEtB;AACA;AACA,0EAA0E;AAC1E;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN,mCAAmC,EAAE;;AAErC;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,wBAAwB;AACvD;AACA;;AAEA,iCAAiC,oBAAoB;AACrD,qCAAqC,0BAA0B;AAC/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA,iCAAiC,0BAA0B;AAC3D;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,kCAAkC,oBAAoB;;AAEtD;AACA;AACA;;AAEA;AACA,MAAM;;AAEN,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;AACV;;AAEA;AACA,MAAM;;AAEN;AACA,kCAAkC;AAClC,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0BAA0B,qBAAqB;AAC/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;;AAEA,kCAAkC,sBAAsB;AACxD;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,sBAAsB;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;;AAEA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,4BAA4B,2BAA2B;AACvD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,2CAA2C;AAC3C;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA,6CAA6C,oCAAoC,EAAE;AACnF,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kBAAkB;;AAElB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6DAA6D,wBAAwB;AACrF;AACA,cAAc;;AAEd;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB,EAAE;AACrB,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+BAA+B,UAAU;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA,gEAAgE,wBAAwB;AACxF;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,2CAA2C,IAAI;AAC/C,6CAA6C,IAAI;AACjD,6CAA6C,IAAI;AACjD,4CAA4C,IAAI;AAChD,8CAA8C,IAAI;AAClD;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,2CAA2C,IAAI;AAC/C,8CAA8C,IAAI;AAClD,2CAA2C,IAAI;AAC/C,+CAA+C,IAAI;AACnD,6CAA6C,IAAI;AACjD,2CAA2C,IAAI;AAC/C,8CAA8C,IAAI;AAClD;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA,qEAAqE;AACrE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,sBAAsB;;AAEtB;AACA;AACA,0EAA0E;AAC1E;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,qCAAqC;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,2CAA2C;AAC3C;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,mBAAmB,EAAE,GAAG,EAAE;AAC1B,MAAM;AACN;AACA,mBAAmB,EAAE,GAAG,EAAE;AAC1B,MAAM;AACN;AACA,EAAE;AACF;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA,EAAE;;AAEF,0CAA0C;AAC1C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,+BAA+B;AACjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN,mCAAmC;;AAEnC;AACA,EAAE;;AAEF;AACA;AACA,mBAAmB,EAAE;AACrB,MAAM;AACN;AACA,mBAAmB,EAAE;AACrB;AACA,EAAE;;AAEF;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA,4BAA4B,EAAE,eAAe,EAAE;AAC/C;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE,cAAc;AACd;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;;AAEA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,8BAA8B,mBAAmB,8BAA8B;AAC/E;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,oDAAoD;AACpD;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,cAAc;AACd;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA,4BAA4B,sBAAsB;AAClD;AACA;;AAEA,8BAA8B,0BAA0B;AACxD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN,6BAA6B,EAAE;;AAE/B;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,yBAAyB,SAAS,iCAAiC,SAAS;AAC5E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,gCAAgC,oBAAoB;;AAEpD,wBAAwB,kBAAkB;AAC1C;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,4CAA4C,QAAQ;AACpD,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,6BAA6B,uBAAuB;AACpD;AACA,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,0BAA0B,yBAAyB;AACnD;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,mBAAmB;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;;AAEA;AACA,gCAAgC,iBAAiB;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,qBAAqB;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,mBAAmB;AAC7C;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,0BAA0B,mBAAmB;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,wBAAwB,eAAe;AACvC;;AAEA,4BAA4B,eAAe;AAC3C;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,0BAA0B,oBAAoB;AAC9C;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA,MAAM;;AAEN;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,yBAAyB,aAAa;AAC3E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA,wBAAwB,YAAY;AACpC;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,4BAA4B;AACpD;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,yBAAyB;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,wCAAwC;AACxC,sCAAsC;;AAEtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF,4CAA4C;AAC5C;AACA,mBAAmB,EAAE,IAAI,EAAE;AAC3B,MAAM;AACN;AACA,mBAAmB,EAAE;AACrB;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,wEAAwE;;AAExE;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,6BAA6B,EAAE;AAC/B,2BAA2B,EAAE;;AAE7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,iFAAiF;AACjF;AACA;AACA,UAAU;;AAEV,6EAA6E;AAC7E;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,kBAAkB;AAClB;;AAEA;AACA,wCAAwC;AACxC;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,MAAM;AACN;AACA,mBAAmB,EAAE,IAAI,EAAE;AAC3B;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA,sDAAsD,wBAAwB,EAAE;AAChF,MAAM;;AAEN;AACA,sDAAsD,sBAAsB,EAAE;AAC9E;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA,8CAA8C;AAC9C;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,iGAAiG;AACjG;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA,mDAAmD;AACnD,iDAAiD;AACjD;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,0BAA0B;AACzD;AACA;AACA;;AAEA,qCAAqC,8BAA8B;AACnE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;;AAEN;AACA,6CAA6C,mBAAmB;AAChE,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,+BAA+B,0BAA0B;AACzD;AACA;;AAEA;AACA;AACA,sCAAsC,yBAAyB;AAC/D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;;AAEN;AACA,gCAAgC,oBAAoB;;AAEpD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,+CAA+C,gCAAgC,4BAA4B;AAC3G,uCAAuC,4BAA4B,gBAAgB;AACnF;AACA,6CAA6C;AAC7C,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,mDAAmD,4BAA4B,EAAE;AACjF,0CAA0C;AAC1C,8CAA8C;AAC9C,mCAAmC;;AAEnC;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,8BAA8B;AAC3D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,oCAAoC;AACrE;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;;AAEA;AACA;AACA,yDAAyD,6BAA6B,iBAAiB;AACvG;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA,mCAAmC;AACnC;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;;AAEA;AACA;AACA,2FAA2F,mBAAmB,IAAI;AAClH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,mBAAmB;AACjD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,wBAAwB;AACxB;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qCAAqC;AACrC,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,0BAA0B,mBAAmB;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA,oDAAoD,6EAA6E;AACjI;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA,yCAAyC;;AAEzC;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;AACA,UAAU;AACV;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,mBAAmB;;AAE1D;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;;AAEA;;AAEA,wBAAwB,WAAW;AACnC;;AAEA,6DAA6D;AAC7D;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,sBAAsB,yBAAyB;;AAE/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,qCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,uBAAuB,IAAI;AAC3B,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,gCAAgC,oBAAoB;;AAEpD;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,qDAAqD,6BAA6B,EAAE;AACpF;AACA;AACA,qDAAqD,6BAA6B,EAAE;AACpF,0CAA0C;AAC1C;AACA,oCAAoC,sBAAsB;;AAE1D;AACA,MAAM;;AAEN;AACA;AACA;AACA,yCAAyC,0CAA0C;AACnF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,6CAA6C,0CAA0C;AACvF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,wCAAwC,0CAA0C;AAClF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,uCAAuC,8CAA8C,YAAY,qBAAqB;AACtH;AACA;AACA,yCAAyC,mBAAmB,IAAI;AAChE;AACA;AACA;;AAEA,+BAA+B,0BAA0B;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;;AAEV;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,6DAA6D;AAC7D;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,8DAA8D,+BAA+B,mBAAmB;AAChH;AACA;AACA;;AAEA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,GAAG,8FAA8F;AAC3G,MAAM;;AAEN;AACA,2CAA2C,kBAAkB,sBAAsB;AACnF;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,+CAA+C,gCAAgC,oBAAoB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB,WAAW;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,wBAAwB,WAAW;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,oBAAoB;AACpB;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;AACA,2CAA2C,kBAAkB,sBAAsB;AACnF;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA,wCAAwC,2CAA2C;AACnF;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA,iCAAiC;AACjC,UAAU;AACV;AACA,iCAAiC;AACjC;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,+CAA+C,kBAAkB;;AAEjE;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;;AAEA,EAAE;;AAEF;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,8BAA8B,YAAY;AAC1C,8BAA8B;AAC9B,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,mDAAmD,iBAAiB;;AAEpE;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,yDAAyD,iBAAiB;;AAE1E;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,mDAAmD,iBAAiB;;AAEpE;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA,EAAE;;AAEF;AACA,cAAc;AACd;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C,kCAAkC;AAClC,cAAc;AACd;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B,cAAc;AACd;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,MAAM;;AAEN;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,MAAM;AACN;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,4BAA4B;AACxE,cAAc;AACd,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA,8DAA8D,+BAA+B,mBAAmB;AAChH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW,6BAA6B;;AAEtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,GAAG,8FAA8F;AAC3G,MAAM;;AAEN;AACA,0CAA0C;AAC1C;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;;AAEd;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA,wBAAwB;;AAExB,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,cAAc;;AAEhD;AACA;AACA;AACA;;AAEA;;AAEA,oCAAoC;AACpC,8CAA8C;AAC9C;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C,0CAA0C;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA,MAAM;;AAEN;AACA,iBAAiB;AACjB;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd,uEAAuE;AACvE,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA,wCAAwC,2BAA2B;AACnE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;;AAEd,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA,yCAAyC;AACzC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA,iCAAiC,qBAAqB;AACtD;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,+BAA+B,WAAW;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,gEAAgE;AAC3G;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gDAAgD,uCAAuC;AACvF;AACA;AACA,UAAU;AACV;AACA;;AAEA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,gDAAgD,uCAAuC;AACvF;AACA,yCAAyC,uCAAuC;AAChF;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,iBAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA,+CAA+C;AAC/C;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,8CAA8C;AAC9C;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA,wBAAwB,uBAAuB;AAC/C;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;;AAEA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,yBAAyB;AACxD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,qCAAqC,qBAAqB;AAC1D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd,UAAU;AACV;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA,8CAA8C;;AAE9C;AACA;AACA,kDAAkD;AAClD;AACA,MAAM;;AAEN;AACA;AACA;AACA,qCAAqC;;AAErC;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;;AAEA;AACA,4CAA4C;;AAE5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;;AAEA;AACA,2CAA2C;AAC3C,mCAAmC;AACnC;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,0BAA0B,mBAAmB;AAC7C,yBAAyB;AACzB,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;;AAEA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,2DAA2D;AAC3D,4CAA4C;;AAE5C;AACA;;AAEA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA,cAAc,WAAW;AACzB;AACA;AACA,cAAc,2BAA2B;AACzC;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,iCAAiC;;AAEhE,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+BAA+B,iCAAiC;;AAEhE;AACA;AACA;;AAEA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;;AAEA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,MAAM;AACN,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,mBAAmB;AACnB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,kBAAkB;AAClB,iBAAiB;AACjB,cAAc;AACd,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,EAAE;;AAEF,EAAE;;AAEF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAkB;;AAE5C,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAmB;;AAE7C,OAAO;;AAEP,UAAU,E;;;;;;;;;;;;;;;;ACnnbG;AACb,8CAA8C,cAAc;AAC5D,mBAAO,CAAC,EAAqC;AAC7C,mBAAO,CAAC,GAAqC;AAC7C,mBAAO,CAAC,GAA2C;AACnD,mBAAO,CAAC,GAAsC;AAC9C,mBAAO,CAAC,GAAsC;AAC9C,mBAAO,CAAC,GAAwC;AAChD,mBAAO,CAAC,EAA6C;AACrD,mBAAO,CAAC,GAA+C;AACvD,mBAAO,CAAC,GAA8C;AACtD,UAAU,mBAAO,CAAC,GAAQ;AAC1B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,eAAe;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uBAAuB,+BAA+B,oCAAoC,mBAAmB,8BAA8B,iCAAiC,8BAA8B,2BAA2B,8BAA8B;AAC9S;AACA,iBAAiB,EAAE,0BAA0B,6BAA6B,mBAAmB,GAAG;AAChG;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjIA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAc;;AAExC,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,4CAA4C;AAC5C;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,EAAE,EAAE,EAAE;AACnD,kBAAkB;AAClB,6CAA6C,EAAE,EAAE,EAAE;AACnD,kBAAkB;AAClB;AACA;AACA,qCAAqC,EAAE;AACvC;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA,wCAAwC,4BAA4B;AACpE;AACA,0BAA0B;AAC1B,iDAAiD,sBAAsB;AACvE;AACA,sBAAsB;AACtB,oCAAoC,EAAE;AACtC;;AAEA;AACA;AACA,wCAAwC,EAAE,EAAE,EAAE;AAC9C,0BAA0B;AAC1B,wCAAwC,EAAE,iBAAiB,EAAE;AAC7D;AACA;AACA,gDAAgD,EAAE,EAAE,EAAE,GAAG,EAAE;AAC3D;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oCAAoC,EAAE,EAAE,EAAE;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,oDAAoD;AACpD;AACA,kBAAkB;AAClB;AACA;AACA;AACA,oDAAoD;AACpD;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN,EAAE;;AAEF;;AAEA,EAAE;;;AAGF,OAAO;;AAEP,UAAU,E;;;;;;;ACvYV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAc;;AAExC,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4DAA4D,kCAAkC;AAC9F;AACA,8BAA8B;AAC9B,0CAA0C;AAC1C;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;;AAEA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,oDAAoD;;AAEpD;AACA;AACA;;AAEA;AACA;AACA,8BAA8B;AAC9B;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,sBAAsB;AAChD;AACA;AACA;;AAEA,4CAA4C,MAAM;AAClD;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yDAAyD,cAAc;AACvE;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,EAAE;;AAEF;;AAEA,EAAE;;;AAGF,OAAO;;AAEP,UAAU,E;;;;;;;ACrVV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAAe;;AAEzC,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA,sBAAsB;;AAEtB;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sEAAsE,yBAAyB,wBAAwB,yBAAyB;AAChJ,sCAAsC,sBAAsB,sBAAsB;AAClF,+CAA+C,+BAA+B,4BAA4B;AAC1G;;AAEA;AACA;;AAEA;AACA,mCAAmC;AACnC,MAAM;;AAEN;AACA,kCAAkC,cAAc;;AAEhD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,MAAM;;AAEN;AACA;AACA,uDAAuD,0BAA0B;AACjF,mDAAmD,mDAAmD,iBAAiB;;AAEvH;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF,EAAE;;AAEF,EAAE;;AAEF,OAAO;;AAEP,UAAU,E;;;;;;;AChRV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAiB;;AAE3C,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD;;AAElD,yCAAyC;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,yFAAyF;AACzF;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,EAAE;;AAEF,EAAE;;AAEF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAmB;;AAE7C,OAAO;;AAEP,UAAU,E;;;;;;;AChPV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,EAAE;;AAEF,EAAE;;;AAGF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAiB;;AAE3C,OAAO;;AAEP,UAAU,E;;;;;;;AChGV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,MAAM;;AAEN;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF,EAAE;;AAEF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAc;;AAExC,OAAO;;AAEP,UAAU,E;;;;;;;ACzKV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAA0B;;AAEpD,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA,UAAU;;AAEV;;AAEA;;AAEA;AACA;;AAEA;;AAEA,EAAE;;;AAGF,OAAO;;AAEP,UAAU,E;;;;;;;AC5PV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,yCAAyC;AACzC,2CAA2C;AAC3C,2CAA2C;;AAE3C;AACA;AACA,kDAAkD;AAClD,kDAAkD;AAClD,+CAA+C;AAC/C,uDAAuD;AACvD,qDAAqD;AACrD,+CAA+C;AAC/C,+CAA+C;;AAE/C;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;;AAGN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA,UAAU;;AAEV;AACA,MAAM;;;;AAIN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA,UAAU;AACV,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA,EAAE;;AAEF;;AAEA,EAAE;;;AAGF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAoB;;AAE9C,OAAO;;AAEP,UAAU,E;;;;;;;ACr0HV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA;AACA;AACA;AACA,EAAE;;AAEF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA,EAAE;;;AAGF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAA6B;;AAEvD,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAuB;;AAEjD,OAAO;;AAEP,UAAU,E;;;;;;;ACxGV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C;;AAE1C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B,uBAAuB;AACvB,6BAA6B;AAC7B;AACA,+BAA+B;AAC/B;AACA;AACA,wBAAwB;AACxB;AACA,0BAA0B;AAC1B,yBAAyB;AACzB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,uBAAuB;AACvB;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,wCAAwC,aAAa;AACrD,UAAU;;AAEV;AACA,wCAAwC,eAAe;AACvD,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;;AAEV;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA,UAAU;;AAEV;AACA;AACA,gDAAgD;;AAEhD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA,uDAAuD;AACvD;AACA,cAAc;AACd,UAAU;;AAEV;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,yBAAyB;AACxD;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,yBAAyB;AACxD;;AAEA;AACA;AACA,yEAAyE;;AAEzE;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,6BAA6B;AAC1D;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,oBAAoB;AACzD;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,2BAA2B;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,sBAAsB;AAChD,wCAAwC;;AAExC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C,oBAAoB,mBAAmB;AACjF,sCAAsC,sCAAsC,GAAG;AAC/E,8CAA8C,6CAA6C;AAC3F,gCAAgC,sCAAsC;AACtE;;AAEA;;AAEA;AACA;;AAEA,0DAA0D,EAAE,cAAc,EAAE;AAC5E;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA,yCAAyC;AACzC,UAAU;;AAEV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kCAAkC,mBAAmB,OAAO;AAC5D,0CAA0C;AAC1C;AACA,yCAAyC;AACzC;AACA,yBAAyB;AACzB,wCAAwC;AACxC,wDAAwD,4BAA4B,OAAO,QAAQ,GAAG;AACtG,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA,+BAA+B,IAAI;AACnC,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,qCAAqC;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;;AAEtD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,UAAU;;AAEV;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,qCAAqC;AAC/D,UAAU;;AAEV;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;;AAEA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU;;AAEV;AACA;AACA;AACA;;AAEA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF;;AAEA,EAAE;;;AAGF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAe;;AAEzC,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAkB;;AAE5C,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,EAA0B;;AAEpD,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAA4B;;AAEtD,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAqB;;AAE/C,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAwB;;AAElD,OAAO;;AAEP,UAAU,E;;;;;;;ACr3CV;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;;AAEA;;;AAGA,OAAO;;AAEP;AACA;;AAEA,8BAA8B,mDAAmD;;;AAGjF,OAAO;;AAEP;AACA;;AAEA,iGAAiG;AACjG;AACA;AACA;AACA;AACA,EAAE;;AAEF,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE;;AAEF,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAA2B;;AAErD,OAAO;;AAEP;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAqB;;AAE/C,OAAO;;AAEP,UAAU,E","file":"avl-xy-chart\\avl-xy-chart.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 512);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d88f2625f392b477a126","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1104);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1104:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t        __webpack_require__(1105),\n\t        __webpack_require__(1106),\n\t        __webpack_require__(1107),\n\t        __webpack_require__(1108),\n\t        __webpack_require__(1109)\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t    var __meta__ = { // jshint ignore:line\n\t        id: \"drawing\",\n\t        name: \"Drawing API\",\n\t        category: \"framework\",\n\t        description: \"The Kendo UI low-level drawing API\",\n\t        depends: [ \"core\", \"color\", \"popup\" ]\n\t    };\n\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 1105:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./drawing/util\");\n\n/***/ }),\n\n/***/ 1106:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./drawing/kendo-drawing\");\n\n/***/ }),\n\n/***/ 1107:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./drawing/surface-tooltip\");\n\n/***/ }),\n\n/***/ 1108:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./drawing/surface\");\n\n/***/ }),\n\n/***/ 1109:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./drawing/html\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.drawing.js\n// module id = 168\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(911);\n\tmodule.exports = __webpack_require__(911);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 911:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(912), __webpack_require__(913), __webpack_require__(914) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function ($) {\r\n\r\n\t/* jshint eqnull:true */\r\n\t/* jshint -W069 */\r\n\t/* jshint latedef: nofunc */\r\n\r\n\twindow.kendo = window.kendo || {};\r\n\tvar kendoDrawing = kendo.drawing;\r\n\tvar kendoDrawingUtil = kendoDrawing.util;\r\n\tvar Class = kendo.Class;\r\n\tvar kendoUtil = kendo.util;\r\n\tvar support = kendo.support;\r\n\tvar supportBrowser = support.browser;\r\n\r\n\tvar createPromise = kendoDrawingUtil.createPromise;\r\n\tvar promiseAll = kendoDrawingUtil.promiseAll;\r\n\r\n\tvar ObserversMixin = {\r\n\t    extend: function(proto) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var method in this) {\r\n\t            if (method !== \"extend\") {\r\n\t                proto[method] = this$1[method];\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    observers: function() {\r\n\t        this._observers = this._observers || [];\r\n\t        return this._observers;\r\n\t    },\r\n\r\n\t    addObserver: function(element) {\r\n\t        if (!this._observers) {\r\n\t            this._observers = [ element ];\r\n\t        } else {\r\n\t            this._observers.push(element);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\r\n\t    removeObserver: function(element) {\r\n\t        var observers = this.observers();\r\n\t        var index = observers.indexOf(element);\r\n\t        if (index !== -1) {\r\n\t            observers.splice(index, 1);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\r\n\t    trigger: function(methodName, event) {\r\n\t        var observers = this._observers;\r\n\r\n\t        if (observers && !this._suspended) {\r\n\t            for (var idx = 0; idx < observers.length; idx++) {\r\n\t                var observer = observers[idx];\r\n\t                if (observer[methodName]) {\r\n\t                    observer[methodName](event);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        if (e === void 0) { e = {}; }\r\n\r\n\t        e.element = this;\r\n\t        this.trigger(\"optionsChange\", e);\r\n\t    },\r\n\r\n\t    geometryChange: function() {\r\n\t        this.trigger(\"geometryChange\", {\r\n\t            element: this\r\n\t        });\r\n\t    },\r\n\r\n\t    suspend: function() {\r\n\t        this._suspended = (this._suspended || 0) + 1;\r\n\t        return this;\r\n\t    },\r\n\r\n\t    resume: function() {\r\n\t        this._suspended = Math.max((this._suspended || 0) - 1, 0);\r\n\t        return this;\r\n\t    },\r\n\r\n\t    _observerField: function(field, value) {\r\n\t        if (this[field]) {\r\n\t            this[field].removeObserver(this);\r\n\t        }\r\n\t        this[field] = value;\r\n\t        value.addObserver(this);\r\n\t    }\r\n\t};\r\n\r\n\tfunction append(first, second) {\r\n\t    first.push.apply(first, second);\r\n\t    return first;\r\n\t}\r\n\r\n\t/* eslint-disable key-spacing,no-multi-spaces,no-param-reassign */\r\n\r\n\tvar literals = {\r\n\t    1    : \"i\",       10   : \"x\",       100  : \"c\",\r\n\t    2    : \"ii\",      20   : \"xx\",      200  : \"cc\",\r\n\t    3    : \"iii\",     30   : \"xxx\",     300  : \"ccc\",\r\n\t    4    : \"iv\",      40   : \"xl\",      400  : \"cd\",\r\n\t    5    : \"v\",       50   : \"l\",       500  : \"d\",\r\n\t    6    : \"vi\",      60   : \"lx\",      600  : \"dc\",\r\n\t    7    : \"vii\",     70   : \"lxx\",     700  : \"dcc\",\r\n\t    8    : \"viii\",    80   : \"lxxx\",    800  : \"dccc\",\r\n\t    9    : \"ix\",      90   : \"xc\",      900  : \"cm\",\r\n\t    1000 : \"m\"\r\n\t};\r\n\r\n\tfunction arabicToRoman(n) {\r\n\t    var values = [ 1000,\r\n\t                   900 , 800, 700, 600, 500, 400, 300, 200, 100,\r\n\t                   90  , 80 , 70 , 60 , 50 , 40 , 30 , 20 , 10 ,\r\n\t                   9   , 8  , 7  , 6  , 5  , 4  , 3  , 2  , 1 ];\r\n\r\n\t    var roman = \"\";\r\n\t    while (n > 0) {\r\n\t        if (n < values[0]) {\r\n\t            values.shift();\r\n\t        } else {\r\n\t            roman += literals[values[0]];\r\n\t            n -= values[0];\r\n\t        }\r\n\t    }\r\n\t    return roman;\r\n\t}\r\n\r\n\tvar UNDEFINED = \"undefined\";\r\n\r\n\tfunction defined(value) {\r\n\t    return typeof value !== UNDEFINED;\r\n\t}\r\n\r\n\tvar defId = 1;\r\n\r\n\tfunction definitionId() {\r\n\t    return \"kdef\" + defId++;\r\n\t}\r\n\r\n\tvar DEG_TO_RAD = Math.PI / 180;\r\n\tvar MAX_NUM = Number.MAX_VALUE;\r\n\tvar MIN_NUM = -Number.MAX_VALUE;\r\n\r\n\tfunction deg(radians) {\r\n\t    return radians / DEG_TO_RAD;\r\n\t}\r\n\r\n\tvar KEY_STR = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n\tvar fromCharCode = String.fromCharCode;\r\n\r\n\tfunction encodeUTF8(input) {\r\n\t    var output = \"\";\r\n\r\n\t    for (var i = 0; i < input.length; i++) {\r\n\t        var c = input.charCodeAt(i);\r\n\r\n\t        if (c < 0x80) {\r\n\t            // One byte\r\n\t            output += fromCharCode(c);\r\n\t        } else if (c < 0x800) {\r\n\t            // Two bytes\r\n\t            output += fromCharCode(0xC0 | (c >>> 6));\r\n\t            output += fromCharCode(0x80 | (c & 0x3f));\r\n\t        } else if (c < 0x10000) {\r\n\t            // Three bytes\r\n\t            output += fromCharCode(0xE0 | (c >>> 12));\r\n\t            output += fromCharCode(0x80 | (c >>> 6 & 0x3f));\r\n\t            output += fromCharCode(0x80 | (c & 0x3f));\r\n\t        }\r\n\t    }\r\n\r\n\t    return output;\r\n\t}\r\n\r\n\tfunction encodeBase64(input) {\r\n\t    var output = \"\";\r\n\t    var i = 0;\r\n\r\n\t    var utfInput = encodeUTF8(input);\r\n\r\n\t    while (i < utfInput.length) {\r\n\t        var chr1 = utfInput.charCodeAt(i++);\r\n\t        var chr2 = utfInput.charCodeAt(i++);\r\n\t        var chr3 = utfInput.charCodeAt(i++);\r\n\r\n\t        var enc1 = chr1 >> 2;\r\n\t        var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n\t        var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n\t        var enc4 = chr3 & 63;\r\n\r\n\t        if (isNaN(chr2)) {\r\n\t            enc3 = enc4 = 64;\r\n\t        } else if (isNaN(chr3)) {\r\n\t            enc4 = 64;\r\n\t        }\r\n\r\n\t        output = output +\r\n\t            KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) +\r\n\t            KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);\r\n\t    }\r\n\r\n\t    return output;\r\n\t}\r\n\r\n\tfunction eventCoordinates(e) {\r\n\t    if (defined((e.x || {}).location)) {\r\n\t        return {\r\n\t            x: e.x.location,\r\n\t            y: e.y.location\r\n\t        };\r\n\t    }\r\n\r\n\t    return {\r\n\t        x: e.pageX || e.clientX || 0,\r\n\t        y: e.pageY || e.clientY || 0\r\n\t    };\r\n\t}\r\n\r\n\tfunction eventElement(e) {\r\n\t    if (e === void 0) { e = {}; }\r\n\r\n\t    return e.touch ? e.touch.initialTouch : e.target;\r\n\t}\r\n\r\n\tfunction isTransparent(color) {\r\n\t    return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !defined(color);\r\n\t}\r\n\r\n\tfunction last(array) {\r\n\t    if (array) {\r\n\t        return array[array.length - 1];\r\n\t    }\r\n\t}\r\n\r\n\tfunction limitValue(value, min, max) {\r\n\t    return Math.max(Math.min(value, max), min);\r\n\t}\r\n\r\n\t/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\r\n\t/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\r\n\t/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty */\r\n\t/* eslint-disable no-param-reassign, no-var, block-scoped-var */\r\n\r\n\t// mergeSort is stable.\r\n\tfunction mergeSort(a, cmp) {\r\n\t    if (a.length < 2) {\r\n\t        return a.slice();\r\n\t    }\r\n\t    function merge(a, b) {\r\n\t        var r = [], ai = 0, bi = 0, i = 0;\r\n\t        while (ai < a.length && bi < b.length) {\r\n\t            if (cmp(a[ai], b[bi]) <= 0) {\r\n\t                r[i++] = a[ai++];\r\n\t            } else {\r\n\t                r[i++] = b[bi++];\r\n\t            }\r\n\t        }\r\n\t        if (ai < a.length) {\r\n\t            r.push.apply(r, a.slice(ai));\r\n\t        }\r\n\t        if (bi < b.length) {\r\n\t            r.push.apply(r, b.slice(bi));\r\n\t        }\r\n\t        return r;\r\n\t    }\r\n\t    return (function sort(a) {\r\n\t        if (a.length <= 1) {\r\n\t            return a;\r\n\t        }\r\n\t        var m = Math.floor(a.length / 2);\r\n\t        var left = a.slice(0, m);\r\n\t        var right = a.slice(m);\r\n\t        left = sort(left);\r\n\t        right = sort(right);\r\n\t        return merge(left, right);\r\n\t    })(a);\r\n\t}\r\n\r\n\tfunction rad(degrees) {\r\n\t    return degrees * DEG_TO_RAD;\r\n\t}\r\n\r\n\tfunction pow(p) {\r\n\t    if (p) {\r\n\t        return Math.pow(10, p);\r\n\t    }\r\n\r\n\t    return 1;\r\n\t}\r\n\r\n\tfunction round(value, precision) {\r\n\t    var power = pow(precision);\r\n\t    return Math.round(value * power) / power;\r\n\t}\r\n\r\n\tfunction valueOrDefault(value, defaultValue) {\r\n\t    return defined(value) ? value : defaultValue;\r\n\t}\r\n\r\n\tfunction bindEvents(element, events) {\r\n\t    for (var eventName in events) {\r\n\t        var eventNames = eventName.trim().split(\" \");\r\n\t        for (var idx = 0; idx < eventNames.length; idx++) {\r\n\t            element.addEventListener(eventNames[idx], events[eventName], false);\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction elementOffset(element) {\r\n\t    var box = element.getBoundingClientRect();\r\n\r\n\t    var documentElement = document.documentElement;\r\n\r\n\t    return {\r\n\t        top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),\r\n\t        left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)\r\n\t    };\r\n\t}\r\n\r\n\tfunction elementStyles(element, styles) {\r\n\t    var result = {};\r\n\t    var style = window.getComputedStyle(element);\r\n\t    var stylesArray = Array.isArray(styles) ? styles : [ styles ];\r\n\r\n\t    for (var idx = 0; idx < stylesArray.length; idx++) {\r\n\t        var field = stylesArray[idx];\r\n\t        result[field] = style[field];\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction getPixels(value) {\r\n\t    if (isNaN(value)) {\r\n\t        return value;\r\n\t    }\r\n\t    return value + \"px\";\r\n\t}\r\n\r\n\tfunction elementSize(element, size) {\r\n\t    if (size) {\r\n\t        var width = size.width;\r\n\t        var height = size.height;\r\n\r\n\t        if (defined(width)) {\r\n\t            element.style.width = getPixels(width);\r\n\t        }\r\n\r\n\t        if (defined(height)) {\r\n\t            element.style.height = getPixels(height);\r\n\t        }\r\n\r\n\t    } else {\r\n\t        var size$1 = elementStyles(element, [ 'width', 'height' ]);\r\n\r\n\t        return {\r\n\t            width: parseInt(size$1.width, 10),\r\n\t            height: parseInt(size$1.height, 10)\r\n\t        };\r\n\t    }\r\n\t}\r\n\r\n\tfunction unbindEvents(element, events) {\r\n\t    if (events === void 0) { events = {}; }\r\n\r\n\t    for (var name in events) {\r\n\t        var eventNames = name.trim().split(\" \");\r\n\t        for (var idx = 0; idx < eventNames.length; idx++) {\r\n\t            element.removeEventListener(eventNames[idx], events[name], false);\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tvar util = {\r\n\t\tappend: append,\r\n\t\tarabicToRoman: arabicToRoman,\r\n\t\tcreatePromise: createPromise,\r\n\t\tdefined: defined,\r\n\t\tdefinitionId: definitionId,\r\n\t\tdeg: deg,\r\n\t\tencodeBase64: encodeBase64,\r\n\t\teventCoordinates: eventCoordinates,\r\n\t\teventElement: eventElement,\r\n\t\tisTransparent: isTransparent,\r\n\t\tlast: last,\r\n\t\tlimitValue: limitValue,\r\n\t\tmergeSort: mergeSort,\r\n\t\tpromiseAll: promiseAll,\r\n\t\trad: rad,\r\n\t\tround: round,\r\n\t\tvalueOrDefault: valueOrDefault,\r\n\t\tbindEvents: bindEvents,\r\n\t\telementOffset: elementOffset,\r\n\t\telementSize: elementSize,\r\n\t\telementStyles: elementStyles,\r\n\t\tunbindEvents: unbindEvents,\r\n\t\tDEG_TO_RAD: DEG_TO_RAD,\r\n\t\tMAX_NUM: MAX_NUM,\r\n\t\tMIN_NUM: MIN_NUM\r\n\t};\r\n\r\n\tvar toString = {}.toString;\r\n\r\n\tvar OptionsStore = Class.extend({\r\n\t    init: function(options, prefix) {\r\n\t        var this$1 = this;\r\n\t        if (prefix === void 0) { prefix = \"\"; }\r\n\r\n\t        this.prefix = prefix;\r\n\r\n\t        for (var field in options) {\r\n\t            var member = options[field];\r\n\t            member = this$1._wrap(member, field);\r\n\t            this$1[field] = member;\r\n\t        }\r\n\t    },\r\n\r\n\t    get: function(field) {\r\n\t        var parts = field.split(\".\");\r\n\t        var result = this;\r\n\r\n\t        while (parts.length && result) {\r\n\t            var part = parts.shift();\r\n\t            result = result[part];\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    set: function(field, value) {\r\n\t        var current = this.get(field);\r\n\r\n\t        if (current !== value) {\r\n\t            this._set(field, this._wrap(value, field));\r\n\t            this.optionsChange({\r\n\t                field: this.prefix + field,\r\n\t                value: value\r\n\t            });\r\n\t        }\r\n\t    },\r\n\r\n\t    _set: function(field, value) {\r\n\t        var this$1 = this;\r\n\r\n\t        var composite = field.indexOf(\".\") >= 0;\r\n\t        var parentObj = this;\r\n\t        var fieldName = field;\r\n\r\n\t        if (composite) {\r\n\t            var parts = fieldName.split(\".\");\r\n\t            var prefix = this.prefix;\r\n\r\n\t            while (parts.length > 1) {\r\n\t                fieldName = parts.shift();\r\n\t                prefix += fieldName + \".\";\r\n\r\n\t                var obj = parentObj[fieldName];\r\n\r\n\t                if (!obj) {\r\n\t                    obj = new OptionsStore({}, prefix);\r\n\t                    obj.addObserver(this$1);\r\n\t                    parentObj[fieldName] = obj;\r\n\t                }\r\n\t                parentObj = obj;\r\n\t            }\r\n\t            fieldName = parts[0];\r\n\t        }\r\n\r\n\t        parentObj._clear(fieldName);\r\n\t        parentObj[fieldName] = value;\r\n\t    },\r\n\r\n\t    _clear: function(field) {\r\n\t        var current = this[field];\r\n\t        if (current && current.removeObserver) {\r\n\t            current.removeObserver(this);\r\n\t        }\r\n\t    },\r\n\r\n\t    _wrap: function(object, field) {\r\n\t        var type = toString.call(object);\r\n\t        var wrapped = object;\r\n\r\n\t        if (wrapped !== null && defined(wrapped) && type === \"[object Object]\") {\r\n\t            if (!(object instanceof OptionsStore) && !(object instanceof Class)) {\r\n\t                wrapped = new OptionsStore(wrapped, this.prefix + field + \".\");\r\n\t            }\r\n\r\n\t            wrapped.addObserver(this);\r\n\t        }\r\n\r\n\t        return wrapped;\r\n\t    }\r\n\t});\r\n\r\n\tObserversMixin.extend(OptionsStore.prototype);\r\n\r\n\tfunction setAccessor(field) {\r\n\t    return function(value) {\r\n\t        if (this[field] !== value) {\r\n\t            this[field] = value;\r\n\t            this.geometryChange();\r\n\t        }\r\n\r\n\t        return this;\r\n\t    };\r\n\t}\r\n\r\n\tfunction getAccessor(field) {\r\n\t    return function() {\r\n\t        return this[field];\r\n\t    };\r\n\t}\r\n\r\n\tfunction defineAccessors(fn, fields) {\r\n\t    for (var i = 0; i < fields.length; i++) {\r\n\t        var name = fields[i];\r\n\t        var capitalized = name.charAt(0).toUpperCase() +\r\n\t                          name.substring(1, name.length);\r\n\r\n\t        fn[\"set\" + capitalized] = setAccessor(name);\r\n\t        fn[\"get\" + capitalized] = getAccessor(name);\r\n\t    }\r\n\t}\r\n\r\n\tvar Matrix = Class.extend({\r\n\t    init: function(a, b, c, d, e, f) {\r\n\t        if (a === void 0) { a = 0; }\r\n\t        if (b === void 0) { b = 0; }\r\n\t        if (c === void 0) { c = 0; }\r\n\t        if (d === void 0) { d = 0; }\r\n\t        if (e === void 0) { e = 0; }\r\n\t        if (f === void 0) { f = 0; }\r\n\r\n\t        this.a = a;\r\n\t        this.b = b;\r\n\t        this.c = c;\r\n\t        this.d = d;\r\n\t        this.e = e;\r\n\t        this.f = f;\r\n\t    },\r\n\r\n\t    multiplyCopy: function(matrix) {\r\n\t        return new Matrix(\r\n\t            this.a * matrix.a + this.c * matrix.b,\r\n\t            this.b * matrix.a + this.d * matrix.b,\r\n\t            this.a * matrix.c + this.c * matrix.d,\r\n\t            this.b * matrix.c + this.d * matrix.d,\r\n\t            this.a * matrix.e + this.c * matrix.f + this.e,\r\n\t            this.b * matrix.e + this.d * matrix.f + this.f\r\n\t        );\r\n\t    },\r\n\r\n\t    invert: function() {\r\n\t        var ref = this;\r\n\t        var a = ref.a;\r\n\t        var b = ref.b;\r\n\t        var d = ref.c;\r\n\t        var e = ref.d;\r\n\t        var g = ref.e;\r\n\t        var h = ref.f;\r\n\t        var det = a * e - b * d;\r\n\r\n\t        if (det === 0) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        return new Matrix(e / det, -b / det, -d / det, a / det,\r\n\t                          (d * h - e * g) / det, (b * g - a * h) / det);\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);\r\n\t    },\r\n\r\n\t    equals: function(other) {\r\n\t        if (!other) {\r\n\t            return false;\r\n\t        }\r\n\r\n\t        return this.a === other.a && this.b === other.b &&\r\n\t               this.c === other.c && this.d === other.d &&\r\n\t               this.e === other.e && this.f === other.f;\r\n\t    },\r\n\r\n\t    round: function(precision) {\r\n\t        this.a = round(this.a, precision);\r\n\t        this.b = round(this.b, precision);\r\n\t        this.c = round(this.c, precision);\r\n\t        this.d = round(this.d, precision);\r\n\t        this.e = round(this.e, precision);\r\n\t        this.f = round(this.f, precision);\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    toArray: function(precision) {\r\n\t        var result = [ this.a, this.b, this.c, this.d, this.e, this.f ];\r\n\r\n\t        if (defined(precision)) {\r\n\t            for (var i = 0; i < result.length; i++) {\r\n\t                result[i] = round(result[i], precision);\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    toString: function(precision, separator) {\r\n\t        if (separator === void 0) { separator = \",\"; }\r\n\r\n\t        return this.toArray(precision).join(separator);\r\n\t    }\r\n\t});\r\n\r\n\tMatrix.translate = function(x, y) {\r\n\t    return new Matrix(1, 0, 0, 1, x, y);\r\n\t};\r\n\r\n\tMatrix.unit = function() {\r\n\t    return new Matrix(1, 0, 0, 1, 0, 0);\r\n\t};\r\n\r\n\tMatrix.rotate = function(angle, x, y) {\r\n\t    var matrix = new Matrix();\r\n\t    matrix.a = Math.cos(rad(angle));\r\n\t    matrix.b = Math.sin(rad(angle));\r\n\t    matrix.c = -matrix.b;\r\n\t    matrix.d = matrix.a;\r\n\t    matrix.e = (x - x * matrix.a + y * matrix.b) || 0;\r\n\t    matrix.f = (y - y * matrix.a - x * matrix.b) || 0;\r\n\r\n\t    return matrix;\r\n\t};\r\n\r\n\tMatrix.scale = function(scaleX, scaleY) {\r\n\t    return new Matrix(scaleX, 0, 0, scaleY, 0, 0);\r\n\t};\r\n\r\n\tMatrix.IDENTITY = Matrix.unit();\r\n\r\n\tfunction toMatrix(transformation) {\r\n\t    if (transformation && typeof transformation.matrix === \"function\") {\r\n\t        return transformation.matrix();\r\n\t    }\r\n\r\n\t    return transformation;\r\n\t}\r\n\r\n\tvar Point = Class.extend({\r\n\t    init: function(x, y) {\r\n\r\n\t        this.x = x || 0;\r\n\t        this.y = y || 0;\r\n\t    },\r\n\r\n\t    equals: function(other) {\r\n\t        return other && other.x === this.x && other.y === this.y;\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Point(this.x, this.y);\r\n\t    },\r\n\r\n\t    rotate: function(angle, origin) {\r\n\t        var originPoint = Point.create(origin) || Point.ZERO;\r\n\r\n\t        return this.transform(Matrix.rotate(angle, originPoint.x, originPoint.y));\r\n\t    },\r\n\r\n\t    translate: function(x, y) {\r\n\t        this.x += x;\r\n\t        this.y += y;\r\n\r\n\t        this.geometryChange();\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    translateWith: function(point) {\r\n\t        return this.translate(point.x, point.y);\r\n\t    },\r\n\r\n\t    move: function(x, y) {\r\n\t        this.x = this.y = 0;\r\n\t        return this.translate(x, y);\r\n\t    },\r\n\r\n\t    scale: function(scaleX, scaleY) {\r\n\t        if (scaleY === void 0) { scaleY = scaleX; }\r\n\r\n\t        this.x *= scaleX;\r\n\t        this.y *= scaleY;\r\n\r\n\t        this.geometryChange();\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    scaleCopy: function(scaleX, scaleY) {\r\n\t        return this.clone().scale(scaleX, scaleY);\r\n\t    },\r\n\r\n\t    transform: function(transformation) {\r\n\t        var matrix = toMatrix(transformation);\r\n\t        var ref = this;\r\n\t        var x = ref.x;\r\n\t        var y = ref.y;\r\n\r\n\t        this.x = matrix.a * x + matrix.c * y + matrix.e;\r\n\t        this.y = matrix.b * x + matrix.d * y + matrix.f;\r\n\r\n\t        this.geometryChange();\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    transformCopy: function(transformation) {\r\n\t        var point = this.clone();\r\n\r\n\t        if (transformation) {\r\n\t            point.transform(transformation);\r\n\t        }\r\n\r\n\t        return point;\r\n\t    },\r\n\r\n\t    distanceTo: function(point) {\r\n\t        var dx = this.x - point.x;\r\n\t        var dy = this.y - point.y;\r\n\r\n\t        return Math.sqrt(dx * dx + dy * dy);\r\n\t    },\r\n\r\n\t    round: function(digits) {\r\n\t        this.x = round(this.x, digits);\r\n\t        this.y = round(this.y, digits);\r\n\r\n\t        this.geometryChange();\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    toArray: function(digits) {\r\n\t        var doRound = defined(digits);\r\n\t        var x = doRound ? round(this.x, digits) : this.x;\r\n\t        var y = doRound ? round(this.y, digits) : this.y;\r\n\r\n\t        return [ x, y ];\r\n\t    },\r\n\r\n\t    toString: function(digits, separator) {\r\n\t        if (separator === void 0) { separator = \" \"; }\r\n\r\n\t        var ref = this;\r\n\t        var x = ref.x;\r\n\t        var y = ref.y;\r\n\r\n\t        if (defined(digits)) {\r\n\t            x = round(x, digits);\r\n\t            y = round(y, digits);\r\n\t        }\r\n\r\n\t        return x + separator + y;\r\n\t    }\r\n\t});\r\n\r\n\tPoint.create = function(arg0, arg1) {\r\n\t    if (defined(arg0)) {\r\n\t        if (arg0 instanceof Point) {\r\n\t            return arg0;\r\n\t        } else if (arguments.length === 1 && arg0.length === 2) {\r\n\t            return new Point(arg0[0], arg0[1]);\r\n\t        }\r\n\r\n\t        return new Point(arg0, arg1);\r\n\t    }\r\n\t};\r\n\r\n\tPoint.min = function() {\r\n\t    var arguments$1 = arguments;\r\n\r\n\t    var minX = MAX_NUM;\r\n\t    var minY = MAX_NUM;\r\n\r\n\t    for (var i = 0; i < arguments.length; i++) {\r\n\t        var point = arguments$1[i];\r\n\t        minX = Math.min(point.x, minX);\r\n\t        minY = Math.min(point.y, minY);\r\n\t    }\r\n\r\n\t    return new Point(minX, minY);\r\n\t};\r\n\r\n\tPoint.max = function() {\r\n\t    var arguments$1 = arguments;\r\n\r\n\t    var maxX = MIN_NUM;\r\n\t    var maxY = MIN_NUM;\r\n\r\n\t    for (var i = 0; i < arguments.length; i++) {\r\n\t        var point = arguments$1[i];\r\n\t        maxX = Math.max(point.x, maxX);\r\n\t        maxY = Math.max(point.y, maxY);\r\n\t    }\r\n\r\n\t    return new Point(maxX, maxY);\r\n\t};\r\n\r\n\tPoint.minPoint = function() {\r\n\t    return new Point(MIN_NUM, MIN_NUM);\r\n\t};\r\n\r\n\tPoint.maxPoint = function() {\r\n\t    return new Point(MAX_NUM, MAX_NUM);\r\n\t};\r\n\r\n\tif (Object.defineProperties) {\r\n\t    Object.defineProperties(Point, {\r\n\t        ZERO: {\r\n\t            get: function() {\r\n\t                return new Point(0, 0);\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t}\r\n\r\n\tdefineAccessors(Point.prototype, [ \"x\", \"y\" ]);\r\n\tObserversMixin.extend(Point.prototype);\r\n\r\n\tvar Size = Class.extend({\r\n\t    init: function(width, height) {\r\n\r\n\t        this.width = width || 0;\r\n\t        this.height = height || 0;\r\n\t    },\r\n\r\n\t    equals: function(other) {\r\n\t        return other && other.width === this.width && other.height === this.height;\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Size(this.width, this.height);\r\n\t    },\r\n\r\n\t    toArray: function(digits) {\r\n\t        var doRound = defined(digits);\r\n\t        var width = doRound ? round(this.width, digits) : this.width;\r\n\t        var height = doRound ? round(this.height, digits) : this.height;\r\n\r\n\t        return [ width, height ];\r\n\t    }\r\n\t});\r\n\r\n\tSize.create = function(arg0, arg1) {\r\n\t    if (defined(arg0)) {\r\n\t        if (arg0 instanceof Size) {\r\n\t            return arg0;\r\n\t        } else if (arguments.length === 1 && arg0.length === 2) {\r\n\t            return new Size(arg0[0], arg0[1]);\r\n\t        }\r\n\r\n\t        return new Size(arg0, arg1);\r\n\t    }\r\n\t};\r\n\r\n\tif (Object.defineProperties) {\r\n\t    Object.defineProperties(Size, {\r\n\t        ZERO: {\r\n\t            get: function() {\r\n\t                return new Size(0, 0);\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t}\r\n\r\n\tdefineAccessors(Size.prototype, [ \"width\", \"height\" ]);\r\n\tObserversMixin.extend(Size.prototype);\r\n\r\n\tvar Rect = Class.extend({\r\n\t    init: function(origin, size) {\r\n\t        if (origin === void 0) { origin = new Point(); }\r\n\t        if (size === void 0) { size = new Size(); }\r\n\r\n\t        this.setOrigin(origin);\r\n\t        this.setSize(size);\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Rect(\r\n\t            this.origin.clone(),\r\n\t            this.size.clone()\r\n\t        );\r\n\t    },\r\n\r\n\t    equals: function(other) {\r\n\t        return other &&\r\n\t               other.origin.equals(this.origin) &&\r\n\t               other.size.equals(this.size);\r\n\t    },\r\n\r\n\t    setOrigin: function(value) {\r\n\t        this._observerField(\"origin\", Point.create(value));\r\n\t        this.geometryChange();\r\n\t        return this;\r\n\t    },\r\n\r\n\t    getOrigin: function() {\r\n\t        return this.origin;\r\n\t    },\r\n\r\n\t    setSize: function(value) {\r\n\t        this._observerField(\"size\", Size.create(value));\r\n\t        this.geometryChange();\r\n\t        return this;\r\n\t    },\r\n\r\n\t    getSize: function() {\r\n\t        return this.size;\r\n\t    },\r\n\r\n\t    width: function() {\r\n\t        return this.size.width;\r\n\t    },\r\n\r\n\t    height: function() {\r\n\t        return this.size.height;\r\n\t    },\r\n\r\n\t    topLeft: function() {\r\n\t        return this.origin.clone();\r\n\t    },\r\n\r\n\t    bottomRight: function() {\r\n\t        return this.origin.clone().translate(this.width(), this.height());\r\n\t    },\r\n\r\n\t    topRight: function() {\r\n\t        return this.origin.clone().translate(this.width(), 0);\r\n\t    },\r\n\r\n\t    bottomLeft: function() {\r\n\t        return this.origin.clone().translate(0, this.height());\r\n\t    },\r\n\r\n\t    center: function() {\r\n\t        return this.origin.clone().translate(this.width() / 2, this.height() / 2);\r\n\t    },\r\n\r\n\t    bbox: function(matrix) {\r\n\t        var tl = this.topLeft().transformCopy(matrix);\r\n\t        var tr = this.topRight().transformCopy(matrix);\r\n\t        var br = this.bottomRight().transformCopy(matrix);\r\n\t        var bl = this.bottomLeft().transformCopy(matrix);\r\n\r\n\t        return Rect.fromPoints(tl, tr, br, bl);\r\n\t    },\r\n\r\n\t    transformCopy: function(m) {\r\n\t        return Rect.fromPoints(\r\n\t            this.topLeft().transform(m),\r\n\t            this.bottomRight().transform(m)\r\n\t        );\r\n\t    },\r\n\r\n\t    expand: function(x, y) {\r\n\t        if (y === void 0) { y = x; }\r\n\r\n\t        this.size.width += 2 * x;\r\n\t        this.size.height += 2 * y;\r\n\r\n\t        this.origin.translate(-x, -y);\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    expandCopy: function(x, y) {\r\n\t        return this.clone().expand(x, y);\r\n\t    },\r\n\r\n\t    containsPoint: function(point) {\r\n\t        var origin = this.origin;\r\n\t        var bottomRight = this.bottomRight();\r\n\t        return !(point.x < origin.x || point.y < origin.y || bottomRight.x < point.x || bottomRight.y < point.y);\r\n\t    },\r\n\r\n\t    _isOnPath: function(point, width) {\r\n\t        var rectOuter = this.expandCopy(width, width);\r\n\t        var rectInner = this.expandCopy(-width, -width);\r\n\r\n\t        return rectOuter.containsPoint(point) && !rectInner.containsPoint(point);\r\n\t    }\r\n\t});\r\n\r\n\tRect.fromPoints = function() {\r\n\t    var topLeft = Point.min.apply(null, arguments);\r\n\t    var bottomRight = Point.max.apply(null, arguments);\r\n\t    var size = new Size(\r\n\t        bottomRight.x - topLeft.x,\r\n\t        bottomRight.y - topLeft.y\r\n\t    );\r\n\r\n\t    return new Rect(topLeft, size);\r\n\t};\r\n\r\n\tRect.union = function(a, b) {\r\n\t    return Rect.fromPoints(\r\n\t        Point.min(a.topLeft(), b.topLeft()),\r\n\t        Point.max(a.bottomRight(), b.bottomRight())\r\n\t    );\r\n\t};\r\n\r\n\tRect.intersect = function(a, b) {\r\n\t    var rect1 = {\r\n\t        left: a.topLeft().x,\r\n\t        top: a.topLeft().y,\r\n\t        right: a.bottomRight().x,\r\n\t        bottom: a.bottomRight().y\r\n\t    };\r\n\r\n\t    var rect2 = {\r\n\t        left: b.topLeft().x,\r\n\t        top: b.topLeft().y,\r\n\t        right: b.bottomRight().x,\r\n\t        bottom: b.bottomRight().y\r\n\t    };\r\n\r\n\t    if (rect1.left <= rect2.right &&\r\n\t        rect2.left <= rect1.right &&\r\n\t        rect1.top <= rect2.bottom &&\r\n\t        rect2.top <= rect1.bottom) {\r\n\t        return Rect.fromPoints(\r\n\t            new Point(Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)),\r\n\t            new Point(Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom))\r\n\t        );\r\n\t    }\r\n\t};\r\n\r\n\tObserversMixin.extend(Rect.prototype);\r\n\r\n\tvar Transformation = Class.extend({\r\n\t    init: function(matrix) {\r\n\t        if (matrix === void 0) { matrix = Matrix.unit(); }\r\n\r\n\t        this._matrix = matrix;\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Transformation(\r\n\t            this._matrix.clone()\r\n\t        );\r\n\t    },\r\n\r\n\t    equals: function(other) {\r\n\t        return other &&\r\n\t               other._matrix.equals(this._matrix);\r\n\t    },\r\n\r\n\t    translate: function(x, y) {\r\n\t        this._matrix = this._matrix.multiplyCopy(Matrix.translate(x, y));\r\n\r\n\t        this._optionsChange();\r\n\t        return this;\r\n\t    },\r\n\r\n\t    scale: function(scaleX, scaleY, origin) {\r\n\t        if (scaleY === void 0) { scaleY = scaleX; }\r\n\t        if (origin === void 0) { origin = null; }\r\n\r\n\t        var originPoint = origin;\r\n\r\n\t        if (originPoint) {\r\n\t            originPoint = Point.create(originPoint);\r\n\t            this._matrix = this._matrix.multiplyCopy(Matrix.translate(originPoint.x, originPoint.y));\r\n\t        }\r\n\r\n\t        this._matrix = this._matrix.multiplyCopy(Matrix.scale(scaleX, scaleY));\r\n\r\n\t        if (originPoint) {\r\n\t            this._matrix = this._matrix.multiplyCopy(Matrix.translate(-originPoint.x, -originPoint.y));\r\n\t        }\r\n\r\n\t        this._optionsChange();\r\n\t        return this;\r\n\t    },\r\n\r\n\t    rotate: function(angle, origin) {\r\n\t        var originPoint = Point.create(origin) || Point.ZERO;\r\n\r\n\t        this._matrix = this._matrix.multiplyCopy(Matrix.rotate(angle, originPoint.x, originPoint.y));\r\n\r\n\t        this._optionsChange();\r\n\t        return this;\r\n\t    },\r\n\r\n\t    multiply: function(transformation) {\r\n\t        var matrix = toMatrix(transformation);\r\n\r\n\t        this._matrix = this._matrix.multiplyCopy(matrix);\r\n\r\n\t        this._optionsChange();\r\n\t        return this;\r\n\t    },\r\n\r\n\t    matrix: function(value) {\r\n\t        if (value) {\r\n\t            this._matrix = value;\r\n\t            this._optionsChange();\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this._matrix;\r\n\t    },\r\n\r\n\t    _optionsChange: function() {\r\n\t        this.optionsChange({\r\n\t            field: \"transform\",\r\n\t            value: this\r\n\t        });\r\n\t    }\r\n\t});\r\n\r\n\tObserversMixin.extend(Transformation.prototype);\r\n\r\n\tfunction transform(matrix) {\r\n\t    if (matrix === null) {\r\n\t        return null;\r\n\t    }\r\n\r\n\t    if (matrix instanceof Transformation) {\r\n\t        return matrix;\r\n\t    }\r\n\r\n\t    return new Transformation(matrix);\r\n\t}\r\n\r\n\tvar Element$1 = Class.extend({\r\n\t    init: function(options) {\r\n\r\n\t        this._initOptions(options);\r\n\t    },\r\n\r\n\t    _initOptions: function(options) {\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        var clip = options.clip;\r\n\t        var transform$$1 = options.transform;\r\n\r\n\t        if (transform$$1) {\r\n\t            options.transform = transform(transform$$1);\r\n\t        }\r\n\r\n\t        if (clip && !clip.id) {\r\n\t            clip.id = definitionId();\r\n\t        }\r\n\r\n\t        this.options = new OptionsStore(options);\r\n\t        this.options.addObserver(this);\r\n\t    },\r\n\r\n\t    transform: function(value) {\r\n\t        if (defined(value)) {\r\n\t            this.options.set(\"transform\", transform(value));\r\n\t        } else {\r\n\t            return this.options.get(\"transform\");\r\n\t        }\r\n\t    },\r\n\r\n\t    parentTransform: function() {\r\n\t        var element = this;\r\n\t        var parentMatrix;\r\n\r\n\t        while (element.parent) {\r\n\t            element = element.parent;\r\n\t            var transformation = element.transform();\r\n\t            if (transformation) {\r\n\t                parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || Matrix.unit());\r\n\t            }\r\n\t        }\r\n\r\n\t        if (parentMatrix) {\r\n\t            return transform(parentMatrix);\r\n\t        }\r\n\t    },\r\n\r\n\t    currentTransform: function(parentTransform) {\r\n\t        if (parentTransform === void 0) { parentTransform = this.parentTransform(); }\r\n\r\n\t        var elementTransform = this.transform();\r\n\t        var elementMatrix = toMatrix(elementTransform);\r\n\r\n\t        var parentMatrix = toMatrix(parentTransform);\r\n\t        var combinedMatrix;\r\n\r\n\t        if (elementMatrix && parentMatrix) {\r\n\t            combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);\r\n\t        } else {\r\n\t            combinedMatrix = elementMatrix || parentMatrix;\r\n\t        }\r\n\r\n\t        if (combinedMatrix) {\r\n\t            return transform(combinedMatrix);\r\n\t        }\r\n\t    },\r\n\r\n\t    visible: function(value) {\r\n\t        if (defined(value)) {\r\n\t            this.options.set(\"visible\", value);\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this.options.get(\"visible\") !== false;\r\n\t    },\r\n\r\n\t    clip: function(value) {\r\n\t        var options = this.options;\r\n\t        if (defined(value)) {\r\n\t            if (value && !value.id) {\r\n\t                value.id = definitionId();\r\n\t            }\r\n\t            options.set(\"clip\", value);\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return options.get(\"clip\");\r\n\t    },\r\n\r\n\t    opacity: function(value) {\r\n\t        if (defined(value)) {\r\n\t            this.options.set(\"opacity\", value);\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return valueOrDefault(this.options.get(\"opacity\"), 1);\r\n\t    },\r\n\r\n\t    clippedBBox: function(transformation) {\r\n\t        var bbox = this._clippedBBox(transformation);\r\n\t        if (bbox) {\r\n\t            var clip = this.clip();\r\n\t            return clip ? Rect.intersect(bbox, clip.bbox(transformation)) : bbox;\r\n\t        }\r\n\t    },\r\n\r\n\t    containsPoint: function(point, parentTransform) {\r\n\t        if (this.visible()) {\r\n\t            var transform$$1 = this.currentTransform(parentTransform);\r\n\t            var transformedPoint = point;\r\n\t            if (transform$$1) {\r\n\t                transformedPoint = point.transformCopy(transform$$1.matrix().invert());\r\n\t            }\r\n\t            return (this._hasFill() && this._containsPoint(transformedPoint)) || (this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint));\r\n\t        }\r\n\t        return false;\r\n\t    },\r\n\r\n\t    _hasFill: function() {\r\n\t        var fill = this.options.fill;\r\n\t        return fill && !isTransparent(fill.color);\r\n\t    },\r\n\r\n\t    _hasStroke: function() {\r\n\t        var stroke = this.options.stroke;\r\n\t        return stroke && stroke.width > 0 && !isTransparent(stroke.color);\r\n\t    },\r\n\r\n\t    _clippedBBox: function(transformation) {\r\n\t        return this.bbox(transformation);\r\n\t    }\r\n\t});\r\n\r\n\tElement$1.prototype.nodeType = \"Element\";\r\n\r\n\tObserversMixin.extend(Element$1.prototype);\r\n\r\n\tfunction ellipseExtremeAngles(center, rx, ry, matrix) {\r\n\t    var extremeX = 0;\r\n\t    var extremeY = 0;\r\n\r\n\t    if (matrix) {\r\n\t        extremeX = Math.atan2(matrix.c * ry, matrix.a * rx);\r\n\t        if (matrix.b !== 0) {\r\n\t            extremeY = Math.atan2(matrix.d * ry, matrix.b * rx);\r\n\t        }\r\n\t    }\r\n\r\n\t    return {\r\n\t        x: extremeX,\r\n\t        y: extremeY\r\n\t    };\r\n\t}\r\n\r\n\tvar PI_DIV_2 = Math.PI / 2;\r\n\r\n\tvar Circle$2 = Class.extend({\r\n\t    init: function(center, radius) {\r\n\t        if (center === void 0) { center = new Point(); }\r\n\t        if (radius === void 0) { radius = 0; }\r\n\r\n\t        this.setCenter(center);\r\n\t        this.setRadius(radius);\r\n\t    },\r\n\r\n\t    setCenter: function(value) {\r\n\t        this._observerField(\"center\", Point.create(value));\r\n\t        this.geometryChange();\r\n\t        return this;\r\n\t    },\r\n\r\n\t    getCenter: function() {\r\n\t        return this.center;\r\n\t    },\r\n\r\n\t    equals: function(other) {\r\n\t        return other &&\r\n\t               other.center.equals(this.center) &&\r\n\t               other.radius === this.radius;\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Circle$2(this.center.clone(), this.radius);\r\n\t    },\r\n\r\n\t    pointAt: function(angle) {\r\n\t        return this._pointAt(rad(angle));\r\n\t    },\r\n\r\n\t    bbox: function(matrix) {\r\n\t        var this$1 = this;\r\n\r\n\t        var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);\r\n\t        var minPoint = Point.maxPoint();\r\n\t        var maxPoint = Point.minPoint();\r\n\r\n\t        for (var i = 0; i < 4; i++) {\r\n\t            var currentPointX = this$1._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\r\n\t            var currentPointY = this$1._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\r\n\t            var currentPoint = new Point(currentPointX.x, currentPointY.y);\r\n\r\n\t            minPoint = Point.min(minPoint, currentPoint);\r\n\t            maxPoint = Point.max(maxPoint, currentPoint);\r\n\t        }\r\n\r\n\t        return Rect.fromPoints(minPoint, maxPoint);\r\n\t    },\r\n\r\n\t    _pointAt: function(angle) {\r\n\t        var ref = this;\r\n\t        var center = ref.center;\r\n\t        var radius = ref.radius;\r\n\r\n\t        return new Point(\r\n\t            center.x + radius * Math.cos(angle),\r\n\t            center.y + radius * Math.sin(angle)\r\n\t        );\r\n\t    },\r\n\r\n\t    containsPoint: function(point) {\r\n\t        var ref = this;\r\n\t        var center = ref.center;\r\n\t        var radius = ref.radius;\r\n\t        var inCircle = Math.pow(point.x - center.x, 2) +\r\n\t            Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\r\n\t        return inCircle;\r\n\t    },\r\n\r\n\t    _isOnPath: function(point, width) {\r\n\t        var ref = this;\r\n\t        var center = ref.center;\r\n\t        var radius = ref.radius;\r\n\t        var pointDistance = center.distanceTo(point);\r\n\r\n\t        return radius - width <= pointDistance && pointDistance <= radius + width;\r\n\t    }\r\n\t});\r\n\r\n\tdefineAccessors(Circle$2.prototype, [ \"radius\" ]);\r\n\tObserversMixin.extend(Circle$2.prototype);\r\n\r\n\tvar GRADIENT = \"Gradient\";\r\n\r\n\tvar Paintable = {\r\n\t    extend: function(proto) {\r\n\t        proto.fill = this.fill;\r\n\t        proto.stroke = this.stroke;\r\n\t    },\r\n\r\n\t    fill: function(color, opacity) {\r\n\t        var options = this.options;\r\n\r\n\t        if (defined(color)) {\r\n\t            if (color && color.nodeType !== GRADIENT) {\r\n\t                var newFill = {\r\n\t                    color: color\r\n\t                };\r\n\t                if (defined(opacity)) {\r\n\t                    newFill.opacity = opacity;\r\n\t                }\r\n\t                options.set(\"fill\", newFill);\r\n\t            } else {\r\n\t                options.set(\"fill\", color);\r\n\t            }\r\n\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return options.get(\"fill\");\r\n\t    },\r\n\r\n\t    stroke: function(color, width, opacity) {\r\n\t        if (defined(color)) {\r\n\t            this.options.set(\"stroke.color\", color);\r\n\r\n\t            if (defined(width)) {\r\n\t                this.options.set(\"stroke.width\", width);\r\n\t            }\r\n\r\n\t            if (defined(opacity)) {\r\n\t                this.options.set(\"stroke.opacity\", opacity);\r\n\t            }\r\n\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this.options.get(\"stroke\");\r\n\t    }\r\n\t};\r\n\r\n\tvar IDENTITY_MATRIX_HASH = Matrix.IDENTITY.toString();\r\n\r\n\tvar Measurable = {\r\n\t    extend: function(proto) {\r\n\t        proto.bbox = this.bbox;\r\n\t        proto.geometryChange = this.geometryChange;\r\n\t    },\r\n\r\n\t    bbox: function(transformation) {\r\n\t        var combinedMatrix = toMatrix(this.currentTransform(transformation));\r\n\t        var matrixHash = combinedMatrix ? combinedMatrix.toString() : IDENTITY_MATRIX_HASH;\r\n\t        var bbox;\r\n\r\n\t        if (this._bboxCache && this._matrixHash === matrixHash) {\r\n\t            bbox = this._bboxCache.clone();\r\n\t        } else {\r\n\t            bbox = this._bbox(combinedMatrix);\r\n\t            this._bboxCache = bbox ? bbox.clone() : null;\r\n\t            this._matrixHash = matrixHash;\r\n\t        }\r\n\r\n\t        var strokeWidth = this.options.get(\"stroke.width\");\r\n\t        if (strokeWidth && bbox) {\r\n\t            bbox.expand(strokeWidth / 2);\r\n\t        }\r\n\r\n\t        return bbox;\r\n\t    },\r\n\r\n\t    geometryChange: function() {\r\n\t        delete this._bboxCache;\r\n\t        this.trigger(\"geometryChange\", {\r\n\t            element: this\r\n\t        });\r\n\t    }\r\n\t};\r\n\r\n\tfunction geometryAccessor(name) {\r\n\t    var fieldName = \"_\" + name;\r\n\t    return function(value) {\r\n\t        if (defined(value)) {\r\n\t            this._observerField(fieldName, value);\r\n\t            this.geometryChange();\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this[fieldName];\r\n\t    };\r\n\t}\r\n\r\n\tfunction defineGeometryAccessors(fn, names) {\r\n\t    for (var i = 0; i < names.length; i++) {\r\n\t        fn[names[i]] = geometryAccessor(names[i]);\r\n\t    }\r\n\t}\r\n\r\n\tvar DEFAULT_STROKE = \"#000\";\r\n\r\n\tvar Circle = Element$1.extend({\r\n\t    init: function(geometry, options) {\r\n\t        if (geometry === void 0) { geometry = new Circle$2(); }\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        Element$1.fn.init.call(this, options);\r\n\t        this.geometry(geometry);\r\n\r\n\t        if (!defined(this.options.stroke)) {\r\n\t            this.stroke(DEFAULT_STROKE);\r\n\t        }\r\n\t    },\r\n\r\n\t    rawBBox: function() {\r\n\t        return this._geometry.bbox();\r\n\t    },\r\n\r\n\t    _bbox: function(matrix) {\r\n\t        return this._geometry.bbox(matrix);\r\n\t    },\r\n\r\n\t    _containsPoint: function(point) {\r\n\t        return this.geometry().containsPoint(point);\r\n\t    },\r\n\r\n\t    _isOnPath: function(point) {\r\n\t        return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\r\n\t    }\r\n\t});\r\n\r\n\tCircle.prototype.nodeType = \"Circle\";\r\n\r\n\tPaintable.extend(Circle.prototype);\r\n\tMeasurable.extend(Circle.prototype);\r\n\tdefineGeometryAccessors(Circle.prototype, [ \"geometry\" ]);\r\n\r\n\tvar PRECISION = 10;\r\n\r\n\tfunction close(a, b, tolerance) {\r\n\t    if (tolerance === void 0) { tolerance = PRECISION; }\r\n\r\n\t    return round(Math.abs(a - b), tolerance) === 0;\r\n\t}\r\n\r\n\tfunction closeOrLess(a, b, tolerance) {\r\n\t    return a < b || close(a, b, tolerance);\r\n\t}\r\n\r\n\tfunction lineIntersection(p0, p1, p2, p3) {\r\n\t    var s1x = p1.x - p0.x;\r\n\t    var s2x = p3.x - p2.x;\r\n\t    var s1y = p1.y - p0.y;\r\n\t    var s2y = p3.y - p2.y;\r\n\t    var nx = p0.x - p2.x;\r\n\t    var ny = p0.y - p2.y;\r\n\t    var d = s1x * s2y - s2x * s1y;\r\n\t    var s = (s1x * ny - s1y * nx) / d;\r\n\t    var t = (s2x * ny - s2y * nx) / d;\r\n\r\n\t    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\r\n\t        return new Point(p0.x + t * s1x, p0.y + t * s1y);\r\n\t    }\r\n\t}\r\n\r\n\tvar MAX_INTERVAL = 45;\r\n\tvar pow$1 = Math.pow;\r\n\r\n\tvar Arc$2 = Class.extend({\r\n\t    init: function(center, options) {\r\n\t        if (center === void 0) { center = new Point(); }\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        this.setCenter(center);\r\n\r\n\t        this.radiusX = options.radiusX;\r\n\t        this.radiusY = options.radiusY || options.radiusX;\r\n\t        this.startAngle = options.startAngle;\r\n\t        this.endAngle = options.endAngle;\r\n\t        this.anticlockwise = options.anticlockwise || false;\r\n\t        this.xRotation = options.xRotation;\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Arc$2(this.center, {\r\n\t            radiusX: this.radiusX,\r\n\t            radiusY: this.radiusY,\r\n\t            startAngle: this.startAngle,\r\n\t            endAngle: this.endAngle,\r\n\t            anticlockwise: this.anticlockwise\r\n\t        });\r\n\t    },\r\n\r\n\t    setCenter: function(value) {\r\n\t        this._observerField(\"center\", Point.create(value));\r\n\t        this.geometryChange();\r\n\t        return this;\r\n\t    },\r\n\r\n\t    getCenter: function() {\r\n\t        return this.center;\r\n\t    },\r\n\r\n\t    pointAt: function(angle) {\r\n\t        var center = this.center;\r\n\t        var radian = rad(angle);\r\n\r\n\t        return new Point(\r\n\t            center.x + this.radiusX * Math.cos(radian),\r\n\t            center.y + this.radiusY * Math.sin(radian)\r\n\t        );\r\n\t    },\r\n\r\n\t    curvePoints: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var startAngle = this.startAngle;\r\n\t        var dir = this.anticlockwise ? -1 : 1;\r\n\t        var curvePoints = [ this.pointAt(startAngle) ];\r\n\t        var interval = this._arcInterval();\r\n\t        var intervalAngle = interval.endAngle - interval.startAngle;\r\n\t        var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\r\n\t        var subIntervalAngle = intervalAngle / subIntervalsCount;\r\n\t        var currentAngle = startAngle;\r\n\t        var transformation;\r\n\t        if (this.xRotation) {\r\n\t            transformation = transform().rotate(this.xRotation, this.center);\r\n\t        }\r\n\r\n\t        for (var i = 1; i <= subIntervalsCount; i++) {\r\n\t            var nextAngle = currentAngle + dir * subIntervalAngle;\r\n\t            var points = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);\r\n\r\n\t            curvePoints.push(points.cp1, points.cp2, points.p2);\r\n\t            currentAngle = nextAngle;\r\n\t        }\r\n\r\n\t        return curvePoints;\r\n\t    },\r\n\r\n\t    bbox: function(matrix) {\r\n\t        var this$1 = this;\r\n\r\n\t        var interval = this._arcInterval();\r\n\t        var startAngle = interval.startAngle;\r\n\t        var endAngle = interval.endAngle;\r\n\t        var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\r\n\t        var extremeX = deg(extremeAngles.x);\r\n\t        var extremeY = deg(extremeAngles.y);\r\n\t        var endPoint = this.pointAt(endAngle).transformCopy(matrix);\r\n\t        var currentAngleX = bboxStartAngle(extremeX, startAngle);\r\n\t        var currentAngleY = bboxStartAngle(extremeY, startAngle);\r\n\t        var currentPoint = this.pointAt(startAngle).transformCopy(matrix);\r\n\t        var minPoint = Point.min(currentPoint, endPoint);\r\n\t        var maxPoint = Point.max(currentPoint, endPoint);\r\n\r\n\t        while (currentAngleX < endAngle || currentAngleY < endAngle) {\r\n\t            var currentPointX = (void 0);\r\n\t            if (currentAngleX < endAngle) {\r\n\t                currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);\r\n\t                currentAngleX += 90;\r\n\t            }\r\n\r\n\t            var currentPointY = (void 0);\r\n\t            if (currentAngleY < endAngle) {\r\n\t                currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);\r\n\t                currentAngleY += 90;\r\n\t            }\r\n\r\n\t            currentPoint = new Point(currentPointX.x, currentPointY.y);\r\n\t            minPoint = Point.min(minPoint, currentPoint);\r\n\t            maxPoint = Point.max(maxPoint, currentPoint);\r\n\t        }\r\n\r\n\t        return Rect.fromPoints(minPoint, maxPoint);\r\n\t    },\r\n\r\n\t    _arcInterval: function() {\r\n\t        var ref = this;\r\n\t        var startAngle = ref.startAngle;\r\n\t        var endAngle = ref.endAngle;\r\n\t        var anticlockwise = ref.anticlockwise;\r\n\r\n\t        if (anticlockwise) {\r\n\t            var oldStart = startAngle;\r\n\t            startAngle = endAngle;\r\n\t            endAngle = oldStart;\r\n\t        }\r\n\r\n\t        if (startAngle > endAngle || (anticlockwise && startAngle === endAngle)) {\r\n\t            endAngle += 360;\r\n\t        }\r\n\r\n\t        return {\r\n\t            startAngle: startAngle,\r\n\t            endAngle: endAngle\r\n\t        };\r\n\t    },\r\n\r\n\t    _intervalCurvePoints: function(startAngle, endAngle, transformation) {\r\n\t        var p1 = this.pointAt(startAngle);\r\n\t        var p2 = this.pointAt(endAngle);\r\n\t        var p1Derivative = this._derivativeAt(startAngle);\r\n\t        var p2Derivative = this._derivativeAt(endAngle);\r\n\t        var t = (rad(endAngle) - rad(startAngle)) / 3;\r\n\t        var cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\r\n\t        var cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\r\n\t        if (transformation) {\r\n\t            p1.transform(transformation);\r\n\t            p2.transform(transformation);\r\n\t            cp1.transform(transformation);\r\n\t            cp2.transform(transformation);\r\n\t        }\r\n\r\n\t        return {\r\n\t            p1: p1,\r\n\t            cp1: cp1,\r\n\t            cp2: cp2,\r\n\t            p2: p2\r\n\t        };\r\n\t    },\r\n\r\n\t    _derivativeAt: function(angle) {\r\n\t        var radian = rad(angle);\r\n\r\n\t        return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\r\n\t    },\r\n\r\n\t    containsPoint: function(point) {\r\n\t        var interval = this._arcInterval();\r\n\t        var intervalAngle = interval.endAngle - interval.startAngle;\r\n\t        var ref = this;\r\n\t        var center = ref.center;\r\n\t        var radiusX = ref.radiusX;\r\n\t        var radiusY = ref.radiusY;\r\n\t        var distance = center.distanceTo(point);\r\n\t        var angleRad = Math.atan2(point.y - center.y, point.x - center.x);\r\n\t        var pointRadius = (radiusX * radiusY) /\r\n\t            Math.sqrt(pow$1(radiusX, 2) * pow$1(Math.sin(angleRad), 2) + pow$1(radiusY, 2) * pow$1(Math.cos(angleRad), 2));\r\n\t        var startPoint = this.pointAt(this.startAngle).round(PRECISION);\r\n\t        var endPoint = this.pointAt(this.endAngle).round(PRECISION);\r\n\t        var intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\r\n\t        var containsPoint;\r\n\r\n\t        if (intervalAngle < 180) {\r\n\t            containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\r\n\t        } else {\r\n\t            var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\r\n\t            if (angle !== 360) {\r\n\t                angle = (360 + angle) % 360;\r\n\t            }\r\n\r\n\t            var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\r\n\t            containsPoint = (inAngleRange && closeOrLess(distance, pointRadius)) || (!inAngleRange && (!intersection || intersection.equals(point)));\r\n\t        }\r\n\t        return containsPoint;\r\n\t    },\r\n\r\n\t    _isOnPath: function(point, width) {\r\n\t        var interval = this._arcInterval();\r\n\t        var center = this.center;\r\n\t        var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\r\n\t        if (angle !== 360) {\r\n\t            angle = (360 + angle) % 360;\r\n\t        }\r\n\r\n\t        var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\r\n\r\n\t        return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\r\n\t    }\r\n\t});\r\n\r\n\tArc$2.fromPoints = function(start, end, rx, ry, largeArc, swipe, rotation) {// eslint-disable-line max-params\r\n\t    var arcParameters = normalizeArcParameters({\r\n\t        x1: start.x,\r\n\t        y1: start.y,\r\n\t        x2: end.x,\r\n\t        y2: end.y,\r\n\t        rx: rx,\r\n\t        ry: ry,\r\n\t        largeArc: largeArc,\r\n\t        swipe: swipe,\r\n\t        rotation: rotation\r\n\t    });\r\n\r\n\t    return new Arc$2(arcParameters.center, {\r\n\t        startAngle: arcParameters.startAngle,\r\n\t        endAngle: arcParameters.endAngle,\r\n\t        radiusX: arcParameters.radiusX,\r\n\t        radiusY: arcParameters.radiusY,\r\n\t        xRotation: arcParameters.xRotation,\r\n\t        anticlockwise: swipe === 0\r\n\t    });\r\n\t};\r\n\r\n\tdefineAccessors(Arc$2.prototype, [ \"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\" ]);\r\n\tObserversMixin.extend(Arc$2.prototype);\r\n\r\n\tfunction calculateAngle(cx, cy, rx, ry, x, y) {\r\n\t    var cos = round((x - cx) / rx, 3);\r\n\t    var sin = round((y - cy) / ry, 3);\r\n\r\n\t    return round(deg(Math.atan2(sin, cos)));\r\n\t}\r\n\r\n\tfunction normalizeArcParameters(parameters) {\r\n\t    var x1 = parameters.x1;\r\n\t    var y1 = parameters.y1;\r\n\t    var x2 = parameters.x2;\r\n\t    var y2 = parameters.y2;\r\n\t    var rx = parameters.rx;\r\n\t    var ry = parameters.ry;\r\n\t    var largeArc = parameters.largeArc;\r\n\t    var swipe = parameters.swipe;\r\n\t    var rotation = parameters.rotation; if (rotation === void 0) { rotation = 0; }\r\n\r\n\t    var radians = rad(rotation);\r\n\t    var cosine = Math.cos(radians);\r\n\t    var sine = Math.sin(radians);\r\n\r\n\t    var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\r\n\t    var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\r\n\r\n\t    var sign = largeArc !== swipe ? 1 : -1;\r\n\r\n\t    var xt2 = Math.pow(xT, 2);\r\n\t    var yt2 = Math.pow(yT, 2);\r\n\t    var rx2 = Math.pow(rx, 2);\r\n\t    var ry2 = Math.pow(ry, 2);\r\n\r\n\t    var delta = xt2 / rx2 + yt2 / ry2;\r\n\r\n\t    if (delta > 1) {\r\n\t        delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\r\n\t        rx = delta * rx;\r\n\t        rx2 = Math.pow(rx, 2);\r\n\r\n\t        ry = delta * ry;\r\n\t        ry2 = Math.pow(ry, 2);\r\n\t    }\r\n\r\n\t    var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));\r\n\t    // due to rounding errors the value could become NaN even after radii correction\r\n\t    if (isNaN(constT)) {\r\n\t        constT = 0;\r\n\t    }\r\n\r\n\t    var cxT = constT * (rx * yT) / ry;\r\n\t    var cyT = - constT * (ry * xT) / rx;\r\n\r\n\t    var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\r\n\t    var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\r\n\r\n\t    var uX = (xT - cxT) / rx;\r\n\t    var uY = (yT - cyT) / ry;\r\n\t    var vX = -(xT + cxT) / rx;\r\n\t    var vY = -(yT + cyT) / ry;\r\n\r\n\t    var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\r\n\r\n\t    var angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\r\n\t    var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\r\n\r\n\t    if (!swipe && angle > 0) {\r\n\t        angle -= 360;\r\n\t    }\r\n\r\n\t    if (swipe && angle < 0) {\r\n\t        angle += 360;\r\n\t    }\r\n\t    var endAngle = startAngle + angle;\r\n\t    var signEndAngle = endAngle >= 0 ? 1 : -1;\r\n\t    endAngle = (Math.abs(endAngle) % 360) * signEndAngle;\r\n\r\n\t    return {\r\n\t        center: new Point(cx, cy),\r\n\t        startAngle: startAngle,\r\n\t        endAngle: endAngle,\r\n\t        radiusX: rx,\r\n\t        radiusY: ry,\r\n\t        xRotation: rotation\r\n\t    };\r\n\t}\r\n\r\n\tfunction bboxStartAngle(angle, start) {\r\n\t    var startAngle = angle;\r\n\r\n\t    while (startAngle < start) {\r\n\t        startAngle += 90;\r\n\t    }\r\n\r\n\t    return startAngle;\r\n\t}\r\n\r\n\tvar push = [].push;\r\n\tvar pop = [].pop;\r\n\tvar splice = [].splice;\r\n\tvar shift = [].shift;\r\n\tvar slice = [].slice;\r\n\tvar unshift = [].unshift;\r\n\r\n\tvar ElementsArray = Class.extend({\r\n\t    init: function(array) {\r\n\t        if (array === void 0) { array = []; }\r\n\r\n\t        this.length = 0;\r\n\t        this._splice(0, array.length, array);\r\n\t    },\r\n\r\n\t    elements: function(value) {\r\n\t        if (value) {\r\n\t            this._splice(0, this.length, value);\r\n\r\n\t            this._change();\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this.slice(0);\r\n\t    },\r\n\r\n\t    push: function() {\r\n\t        var elements = arguments;\r\n\t        var result = push.apply(this, elements);\r\n\r\n\t        this._add(elements);\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    slice: function() {\r\n\t        return slice.call(this);\r\n\t    },\r\n\r\n\t    pop: function() {\r\n\t        var length = this.length;\r\n\t        var result = pop.apply(this);\r\n\r\n\t        if (length) {\r\n\t            this._remove([ result ]);\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    splice: function(index, howMany) {\r\n\t        var elements = slice.call(arguments, 2);\r\n\t        var result = this._splice(index, howMany, elements);\r\n\r\n\t        this._change();\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    shift: function() {\r\n\t        var length = this.length;\r\n\t        var result = shift.apply(this);\r\n\r\n\t        if (length) {\r\n\t            this._remove([ result ]);\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    unshift: function() {\r\n\t        var elements = arguments;\r\n\t        var result = unshift.apply(this, elements);\r\n\r\n\t        this._add(elements);\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    indexOf: function(element) {\r\n\t        var this$1 = this;\r\n\r\n\t        var length = this.length;\r\n\r\n\t        for (var idx = 0; idx < length; idx++) {\r\n\t            if (this$1[idx] === element) {\r\n\t                return idx;\r\n\t            }\r\n\t        }\r\n\t        return -1;\r\n\t    },\r\n\r\n\t    _splice: function(index, howMany, elements) {\r\n\t        var result = splice.apply(this, [ index, howMany ].concat(elements));\r\n\r\n\t        this._clearObserver(result);\r\n\t        this._setObserver(elements);\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    _add: function(elements) {\r\n\t        this._setObserver(elements);\r\n\t        this._change();\r\n\t    },\r\n\r\n\t    _remove: function(elements) {\r\n\t        this._clearObserver(elements);\r\n\t        this._change();\r\n\t    },\r\n\r\n\t    _setObserver: function(elements) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var idx = 0; idx < elements.length; idx++) {\r\n\t            elements[idx].addObserver(this$1);\r\n\t        }\r\n\t    },\r\n\r\n\t    _clearObserver: function(elements) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var idx = 0; idx < elements.length; idx++) {\r\n\t            elements[idx].removeObserver(this$1);\r\n\t        }\r\n\t    },\r\n\r\n\t    _change: function() {}\r\n\t});\r\n\r\n\tObserversMixin.extend(ElementsArray.prototype);\r\n\r\n\tvar GeometryElementsArray = ElementsArray.extend({\r\n\t    _change: function() {\r\n\t        this.geometryChange();\r\n\t    }\r\n\t});\r\n\r\n\tfunction pointAccessor(name) {\r\n\t    var fieldName = \"_\" + name;\r\n\t    return function(value) {\r\n\t        if (defined(value)) {\r\n\t            this._observerField(fieldName, Point.create(value));\r\n\t            this.geometryChange();\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this[fieldName];\r\n\t    };\r\n\t}\r\n\r\n\tfunction definePointAccessors(fn, names) {\r\n\t    for (var i = 0; i < names.length; i++) {\r\n\t        fn[names[i]] = pointAccessor(names[i]);\r\n\t    }\r\n\t}\r\n\r\n\tfunction isOutOfEndPoint(endPoint, controlPoint, point) {\r\n\t    var angle = deg(Math.atan2(controlPoint.y - endPoint.y, controlPoint.x - endPoint.x));\r\n\t    var rotatedPoint = point.transformCopy(transform().rotate(-angle, endPoint));\r\n\r\n\t    return rotatedPoint.x < endPoint.x;\r\n\t}\r\n\r\n\tfunction calculateCurveAt(t, field, points) {\r\n\t    var t1 = 1 - t;\r\n\t    return Math.pow(t1, 3) * points[0][field] +\r\n\t        3 * Math.pow(t1, 2) * t * points[1][field] +\r\n\t        3 * Math.pow(t, 2) * t1 * points[2][field] +\r\n\t        Math.pow(t, 3) * points[3][field];\r\n\t}\r\n\r\n\tfunction toCubicPolynomial(points, field) {\r\n\t    return [ -points[0][field] + 3 * points[1][field] - 3 * points[2][field] + points[3][field],\r\n\t        3 * (points[0][field] - 2 * points[1][field] + points[2][field]),\r\n\t        3 * (-points[0][field] + points[1][field]),\r\n\t        points[0][field]\r\n\t    ];\r\n\t}\r\n\r\n\tvar ComplexNumber = Class.extend({\r\n\t    init: function(real, img) {\r\n\t        if (real === void 0) { real = 0; }\r\n\t        if (img === void 0) { img = 0; }\r\n\r\n\t        this.real = real;\r\n\t        this.img = img;\r\n\t    },\r\n\r\n\t    add: function(cNumber) {\r\n\t        return new ComplexNumber(round(this.real + cNumber.real, PRECISION), round(this.img + cNumber.img, PRECISION));\r\n\t    },\r\n\r\n\t    addConstant: function(value) {\r\n\t        return new ComplexNumber(this.real + value, this.img);\r\n\t    },\r\n\r\n\t    negate: function() {\r\n\t        return new ComplexNumber(-this.real, -this.img);\r\n\t    },\r\n\r\n\t    multiply: function(cNumber) {\r\n\t        return new ComplexNumber(this.real * cNumber.real - this.img * cNumber.img,\r\n\t            this.real * cNumber.img + this.img * cNumber.real);\r\n\t    },\r\n\r\n\t    multiplyConstant: function(value) {\r\n\t        return new ComplexNumber(this.real * value, this.img * value);\r\n\t    },\r\n\r\n\t    nthRoot: function(n) {\r\n\t        var rad$$1 = Math.atan2(this.img, this.real);\r\n\t        var r = Math.sqrt(Math.pow(this.img, 2) + Math.pow(this.real, 2));\r\n\t        var nthR = Math.pow(r, 1 / n);\r\n\r\n\t        return new ComplexNumber(nthR * Math.cos(rad$$1 / n), nthR * Math.sin(rad$$1 / n)); //Moivre's formula\r\n\t    },\r\n\r\n\t    equals: function(cNumber) {\r\n\t        return this.real === cNumber.real && this.img === cNumber.img;\r\n\t    },\r\n\r\n\t    isReal: function() {\r\n\t        return this.img === 0;\r\n\t    }\r\n\t});\r\n\r\n\tfunction numberSign(x) {\r\n\t    return x < 0 ? -1 : 1;\r\n\t}\r\n\r\n\tfunction solveQuadraticEquation(a, b, c) {\r\n\t    var squareRoot = Math.sqrt(Math.pow(b, 2) - 4 * a * c);\r\n\t    return [\r\n\t        (-b + squareRoot) / (2 * a),\r\n\t        (-b - squareRoot) / (2 * a)\r\n\t    ];\r\n\t}\r\n\r\n\t//Cardano's formula\r\n\tfunction solveCubicEquation(a, b, c, d) {\r\n\t    if (a === 0) {\r\n\t        return solveQuadraticEquation(b, c, d);\r\n\t    }\r\n\r\n\t    var p = (3 * a * c - Math.pow(b, 2)) / (3 * Math.pow(a, 2));\r\n\t    var q = (2 * Math.pow(b, 3) - 9 * a * b * c + 27 * Math.pow(a, 2) * d) / (27 * Math.pow(a, 3));\r\n\t    var Q = Math.pow(p / 3, 3) + Math.pow(q / 2, 2);\r\n\t    var i = new ComplexNumber(0,1);\r\n\t    var b3a = -b / (3 * a);\r\n\t    var x1, x2, y1, y2, y3, z1, z2;\r\n\r\n\t    if (Q < 0) {\r\n\t        x1 = new ComplexNumber(-q / 2, Math.sqrt(-Q)).nthRoot(3);\r\n\t        x2 = new ComplexNumber(-q / 2, - Math.sqrt(-Q)).nthRoot(3);\r\n\t    } else {\r\n\t        x1 = -q / 2 + Math.sqrt(Q);\r\n\t        x1 = new ComplexNumber(numberSign(x1) * Math.pow(Math.abs(x1), 1 / 3));\r\n\t        x2 = -q / 2 - Math.sqrt(Q);\r\n\t        x2 = new ComplexNumber(numberSign(x2) * Math.pow(Math.abs(x2), 1 / 3));\r\n\t    }\r\n\r\n\t    y1 = x1.add(x2);\r\n\r\n\t    z1 = x1.add(x2).multiplyConstant(-1 / 2);\r\n\t    z2 = x1.add(x2.negate()).multiplyConstant(Math.sqrt(3) / 2);\r\n\r\n\t    y2 = z1.add(i.multiply(z2));\r\n\t    y3 = z1.add(i.negate().multiply(z2));\r\n\r\n\t    var result = [];\r\n\r\n\t    if (y1.isReal()) {\r\n\t        result.push(round(y1.real + b3a, PRECISION));\r\n\t    }\r\n\t    if (y2.isReal()) {\r\n\t        result.push(round(y2.real + b3a, PRECISION));\r\n\t    }\r\n\t    if (y3.isReal()) {\r\n\t        result.push(round(y3.real + b3a, PRECISION));\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction hasRootsInRange(points, point, field, rootField, range) {\r\n\t    var polynomial = toCubicPolynomial(points, rootField);\r\n\t    var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point[rootField]);\r\n\t    var intersection;\r\n\r\n\t    for (var idx = 0; idx < roots.length; idx++) {\r\n\t        if (0 <= roots[idx] && roots[idx] <= 1) {\r\n\t            intersection = calculateCurveAt(roots[idx], field, points);\r\n\t            if (Math.abs(intersection - point[field]) <= range) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction curveIntersectionsCount(points, point, bbox) {\r\n\t    var polynomial = toCubicPolynomial(points, \"x\");\r\n\t    var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point.x);\r\n\t    var rayIntersection, intersectsRay;\r\n\t    var count = 0;\r\n\t    for (var i = 0; i < roots.length; i++) {\r\n\t        rayIntersection = calculateCurveAt(roots[i], \"y\", points);\r\n\t        intersectsRay = close(rayIntersection, point.y) || rayIntersection > point.y;\r\n\t        if (intersectsRay && (((roots[i] === 0 || roots[i] === 1) && bbox.bottomRight().x > point.x) || (0 < roots[i] && roots[i] < 1))) {\r\n\t            count++;\r\n\t        }\r\n\t    }\r\n\r\n\t    return count;\r\n\t}\r\n\r\n\tfunction lineIntersectionsCount(a, b, point) {\r\n\t    var intersects;\r\n\t    if (a.x !== b.x) {\r\n\t        var minX = Math.min(a.x, b.x);\r\n\t        var maxX = Math.max(a.x, b.x);\r\n\t        var minY = Math.min(a.y, b.y);\r\n\t        var maxY = Math.max(a.y, b.y);\r\n\t        var inRange = minX <= point.x && point.x < maxX;\r\n\r\n\t        if (minY === maxY) {\r\n\t            intersects = point.y <= minY && inRange;\r\n\t        } else {\r\n\t            intersects = inRange && (((maxY - minY) * ((a.x - b.x) * (a.y - b.y) > 0 ? point.x - minX : maxX - point.x)) / (maxX - minX) + minY - point.y) >= 0;\r\n\t        }\r\n\t    }\r\n\r\n\t    return intersects ? 1 : 0;\r\n\t}\r\n\r\n\tvar Segment = Class.extend({\r\n\t    init: function(anchor, controlIn, controlOut) {\r\n\r\n\t        this.anchor(anchor || new Point());\r\n\t        this.controlIn(controlIn);\r\n\t        this.controlOut(controlOut);\r\n\t    },\r\n\r\n\t    bboxTo: function(toSegment, matrix) {\r\n\t        var segmentAnchor = this.anchor().transformCopy(matrix);\r\n\t        var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\r\n\t        var rect;\r\n\r\n\t        if (this.controlOut() && toSegment.controlIn()) {\r\n\t            rect = this._curveBoundingBox(\r\n\t                segmentAnchor, this.controlOut().transformCopy(matrix),\r\n\t                toSegment.controlIn().transformCopy(matrix), toSegmentAnchor\r\n\t            );\r\n\t        } else {\r\n\t            rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\r\n\t        }\r\n\r\n\t        return rect;\r\n\t    },\r\n\r\n\t    _lineBoundingBox: function(p1, p2) {\r\n\t        return Rect.fromPoints(p1, p2);\r\n\t    },\r\n\r\n\t    _curveBoundingBox: function(p1, cp1, cp2, p2) {\r\n\t        var points = [ p1, cp1, cp2, p2 ];\r\n\t        var extremesX = this._curveExtremesFor(points, \"x\");\r\n\t        var extremesY = this._curveExtremesFor(points, \"y\");\r\n\t        var xLimits = arrayLimits([ extremesX.min, extremesX.max, p1.x, p2.x ]);\r\n\t        var yLimits = arrayLimits([ extremesY.min, extremesY.max, p1.y, p2.y ]);\r\n\r\n\t        return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\r\n\t    },\r\n\r\n\t    _curveExtremesFor: function(points, field) {\r\n\t        var extremes = this._curveExtremes(\r\n\t            points[0][field], points[1][field],\r\n\t            points[2][field], points[3][field]\r\n\t        );\r\n\r\n\t        return {\r\n\t            min: calculateCurveAt(extremes.min, field, points),\r\n\t            max: calculateCurveAt(extremes.max, field, points)\r\n\t        };\r\n\t    },\r\n\r\n\t    _curveExtremes: function(x1, x2, x3, x4) {\r\n\t        var a = x1 - 3 * x2 + 3 * x3 - x4;\r\n\t        var b = - 2 * (x1 - 2 * x2 + x3);\r\n\t        var c = x1 - x2;\r\n\t        var sqrt = Math.sqrt(b * b - 4 * a * c);\r\n\t        var t1 = 0;\r\n\t        var t2 = 1;\r\n\r\n\t        if (a === 0) {\r\n\t            if (b !== 0) {\r\n\t                t1 = t2 = -c / b;\r\n\t            }\r\n\t        } else if (!isNaN(sqrt)) {\r\n\t            t1 = (- b + sqrt) / (2 * a);\r\n\t            t2 = (- b - sqrt) / (2 * a);\r\n\t        }\r\n\r\n\t        var min = Math.max(Math.min(t1, t2), 0);\r\n\t        if (min < 0 || min > 1) {\r\n\t            min = 0;\r\n\t        }\r\n\r\n\t        var max = Math.min(Math.max(t1, t2), 1);\r\n\t        if (max > 1 || max < 0) {\r\n\t            max = 1;\r\n\t        }\r\n\r\n\t        return {\r\n\t            min: min,\r\n\t            max: max\r\n\t        };\r\n\t    },\r\n\r\n\t    _intersectionsTo: function(segment, point) {\r\n\t        var intersectionsCount;\r\n\t        if (this.controlOut() && segment.controlIn()) {\r\n\t            intersectionsCount = curveIntersectionsCount([ this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor() ], point, this.bboxTo(segment));\r\n\t        } else {\r\n\t            intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\r\n\t        }\r\n\t        return intersectionsCount;\r\n\t    },\r\n\r\n\t    _isOnCurveTo: function(segment, point, width, endSegment) {\r\n\t        var bbox = this.bboxTo(segment).expand(width, width);\r\n\t        if (bbox.containsPoint(point)) {\r\n\t            var p1 = this.anchor();\r\n\t            var p2 = this.controlOut();\r\n\t            var p3 = segment.controlIn();\r\n\t            var p4 = segment.anchor();\r\n\r\n\t            if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\r\n\t                return !isOutOfEndPoint(p1, p2, point);\r\n\t            } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\r\n\t                return !isOutOfEndPoint(p4, p3, point);\r\n\t            }\r\n\r\n\t            //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\r\n\t            var points = [ p1, p2, p3, p4 ];\r\n\t            if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\r\n\t                return true;\r\n\t            }\r\n\t            var rotation = transform().rotate(45, point);\r\n\t            var rotatedPoints = [ p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation) ];\r\n\t            return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\r\n\t        }\r\n\t    },\r\n\r\n\t    _isOnLineTo: function(segment, point, width) {\r\n\t        var p1 = this.anchor();\r\n\t        var p2 = segment.anchor();\r\n\t        var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\r\n\t        var rect = new Rect([ p1.x, p1.y - width / 2 ], [ p1.distanceTo(p2), width ]);\r\n\t        return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\r\n\t    },\r\n\r\n\t    _isOnPathTo: function(segment, point, width, endSegment) {\r\n\t        var isOnPath;\r\n\t        if (this.controlOut() && segment.controlIn()) {\r\n\t            isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\r\n\t        } else {\r\n\t            isOnPath = this._isOnLineTo(segment, point, width);\r\n\t        }\r\n\t        return isOnPath;\r\n\t    }\r\n\t});\r\n\r\n\tdefinePointAccessors(Segment.prototype, [ \"anchor\", \"controlIn\", \"controlOut\" ]);\r\n\tObserversMixin.extend(Segment.prototype);\r\n\r\n\tfunction arrayLimits(arr) {\r\n\t    var length = arr.length;\r\n\t    var min = MAX_NUM;\r\n\t    var max = MIN_NUM;\r\n\r\n\t    for (var i = 0; i < length; i ++) {\r\n\t        max = Math.max(max, arr[i]);\r\n\t        min = Math.min(min, arr[i]);\r\n\t    }\r\n\r\n\t    return {\r\n\t        min: min,\r\n\t        max: max\r\n\t    };\r\n\t}\r\n\r\n\tvar Path = Element$1.extend({\r\n\t    init: function(options) {\r\n\t        Element$1.fn.init.call(this, options);\r\n\t        this.segments = new GeometryElementsArray();\r\n\t        this.segments.addObserver(this);\r\n\r\n\t        if (!defined(this.options.stroke)) {\r\n\t            this.stroke(\"#000\");\r\n\r\n\t            if (!defined(this.options.stroke.lineJoin)) {\r\n\t                this.options.set(\"stroke.lineJoin\", \"miter\");\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    moveTo: function(x, y) {\r\n\t        this.suspend();\r\n\t        this.segments.elements([]);\r\n\t        this.resume();\r\n\r\n\t        this.lineTo(x, y);\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    lineTo: function(x, y) {\r\n\t        var point = defined(y) ? new Point(x, y) : x;\r\n\t        var segment = new Segment(point);\r\n\r\n\t        this.segments.push(segment);\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    curveTo: function(controlOut, controlIn, point) {\r\n\t        if (this.segments.length > 0) {\r\n\t            var lastSegment = last(this.segments);\r\n\t            var segment = new Segment(point, controlIn);\r\n\t            this.suspend();\r\n\t            lastSegment.controlOut(controlOut);\r\n\t            this.resume();\r\n\r\n\t            this.segments.push(segment);\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    arc: function(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\r\n\t        if (this.segments.length > 0) {\r\n\t            var lastSegment = last(this.segments);\r\n\t            var anchor = lastSegment.anchor();\r\n\t            var start = rad(startAngle);\r\n\t            var center = new Point(anchor.x - radiusX * Math.cos(start),\r\n\t                anchor.y - radiusY * Math.sin(start));\r\n\t            var arc = new Arc$2(center, {\r\n\t                startAngle: startAngle,\r\n\t                endAngle: endAngle,\r\n\t                radiusX: radiusX,\r\n\t                radiusY: radiusY,\r\n\t                anticlockwise: anticlockwise\r\n\t            });\r\n\r\n\t            this._addArcSegments(arc);\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    arcTo: function(end, rx, ry, largeArc, swipe, rotation) {\r\n\t        if (this.segments.length > 0) {\r\n\t            var lastSegment = last(this.segments);\r\n\t            var anchor = lastSegment.anchor();\r\n\t            var arc = Arc$2.fromPoints(anchor, end, rx, ry, largeArc, swipe, rotation);\r\n\r\n\t            this._addArcSegments(arc);\r\n\t        }\r\n\t        return this;\r\n\t    },\r\n\r\n\t    _addArcSegments: function(arc) {\r\n\t        var this$1 = this;\r\n\r\n\t        this.suspend();\r\n\r\n\t        var curvePoints = arc.curvePoints();\r\n\r\n\t        for (var i = 1; i < curvePoints.length; i += 3) {\r\n\t            this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\r\n\t        }\r\n\r\n\t        this.resume();\r\n\t        this.geometryChange();\r\n\t    },\r\n\r\n\t    close: function() {\r\n\t        this.options.closed = true;\r\n\t        this.geometryChange();\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    rawBBox: function() {\r\n\t        return this._bbox();\r\n\t    },\r\n\r\n\t    _containsPoint: function(point) {\r\n\t        var segments = this.segments;\r\n\t        var length = segments.length;\r\n\t        var intersectionsCount = 0;\r\n\t        var previous, current;\r\n\r\n\t        for (var idx = 1; idx < length; idx++) {\r\n\t            previous = segments[idx - 1];\r\n\t            current = segments[idx];\r\n\t            intersectionsCount += previous._intersectionsTo(current, point);\r\n\t        }\r\n\r\n\t        if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\r\n\t            intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\r\n\t        }\r\n\r\n\t        return intersectionsCount % 2 !== 0;\r\n\t    },\r\n\r\n\t    _isOnPath: function(point, width) {\r\n\t        var segments = this.segments;\r\n\t        var length = segments.length;\r\n\t        var pathWidth = width || this.options.stroke.width;\r\n\r\n\t        if (length > 1) {\r\n\t            if (segments[0]._isOnPathTo(segments[1], point, pathWidth, \"start\")) {\r\n\t                return true;\r\n\t            }\r\n\r\n\t            for (var idx = 2; idx <= length - 2; idx++) {\r\n\t                if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, \"end\")) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t        return false;\r\n\t    },\r\n\r\n\t    _bbox: function(matrix) {\r\n\t        var segments = this.segments;\r\n\t        var length = segments.length;\r\n\t        var boundingBox;\r\n\r\n\t        if (length === 1) {\r\n\t            var anchor = segments[0].anchor().transformCopy(matrix);\r\n\t            boundingBox = new Rect(anchor, Size.ZERO);\r\n\t        } else if (length > 0) {\r\n\t            for (var i = 1; i < length; i++) {\r\n\t                var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\r\n\t                if (boundingBox) {\r\n\t                    boundingBox = Rect.union(boundingBox, segmentBox);\r\n\t                } else {\r\n\t                    boundingBox = segmentBox;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return boundingBox;\r\n\t    }\r\n\t});\r\n\r\n\tPath.fromRect = function(rect, options) {\r\n\t    return new Path(options)\r\n\t        .moveTo(rect.topLeft())\r\n\t        .lineTo(rect.topRight())\r\n\t        .lineTo(rect.bottomRight())\r\n\t        .lineTo(rect.bottomLeft())\r\n\t        .close();\r\n\t};\r\n\r\n\tPath.fromPoints = function(points, options) {\r\n\t    if (points) {\r\n\t        var path = new Path(options);\r\n\r\n\t        for (var i = 0; i < points.length; i++) {\r\n\t            var point = Point.create(points[i]);\r\n\t            if (point) {\r\n\t                if (i === 0) {\r\n\t                    path.moveTo(point);\r\n\t                } else {\r\n\t                    path.lineTo(point);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return path;\r\n\t    }\r\n\t};\r\n\r\n\tPath.fromArc = function(arc, options) {\r\n\t    var path = new Path(options);\r\n\t    var startAngle = arc.startAngle;\r\n\t    var start = arc.pointAt(startAngle);\r\n\t    path.moveTo(start.x, start.y);\r\n\t    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\r\n\t    return path;\r\n\t};\r\n\r\n\tPath.prototype.nodeType = \"Path\";\r\n\r\n\tPaintable.extend(Path.prototype);\r\n\tMeasurable.extend(Path.prototype);\r\n\r\n\tvar DEFAULT_STROKE$1 = \"#000\";\r\n\r\n\tvar Arc = Element$1.extend({\r\n\t    init: function(geometry, options) {\r\n\t        if (geometry === void 0) { geometry = new Arc$2(); }\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        Element$1.fn.init.call(this, options);\r\n\r\n\t        this.geometry(geometry);\r\n\r\n\t        if (!defined(this.options.stroke)) {\r\n\t            this.stroke(DEFAULT_STROKE$1);\r\n\t        }\r\n\t    },\r\n\r\n\t    _bbox: function(matrix) {\r\n\t        return this._geometry.bbox(matrix);\r\n\t    },\r\n\r\n\t    rawBBox: function() {\r\n\t        return this.geometry().bbox();\r\n\t    },\r\n\r\n\t    toPath: function() {\r\n\t        var path = new Path();\r\n\t        var curvePoints = this.geometry().curvePoints();\r\n\r\n\t        if (curvePoints.length > 0) {\r\n\t            path.moveTo(curvePoints[0].x, curvePoints[0].y);\r\n\r\n\t            for (var i = 1; i < curvePoints.length; i += 3) {\r\n\t                path.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\r\n\t            }\r\n\t        }\r\n\r\n\t        return path;\r\n\t    },\r\n\r\n\t    _containsPoint: function(point) {\r\n\t        return this.geometry().containsPoint(point);\r\n\t    },\r\n\r\n\t    _isOnPath: function(point) {\r\n\t        return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\r\n\t    }\r\n\t});\r\n\r\n\tArc.prototype.nodeType = \"Arc\";\r\n\r\n\tPaintable.extend(Arc.prototype);\r\n\tMeasurable.extend(Arc.prototype);\r\n\tdefineGeometryAccessors(Arc.prototype, [ \"geometry\" ]);\r\n\r\n\tfunction elementsBoundingBox(elements, applyTransform, transformation) {\r\n\t    var boundingBox;\r\n\r\n\t    for (var i = 0; i < elements.length; i++) {\r\n\t        var element = elements[i];\r\n\t        if (element.visible()) {\r\n\t            var elementBoundingBox = applyTransform ? element.bbox(transformation) : element.rawBBox();\r\n\t            if (elementBoundingBox) {\r\n\t                if (boundingBox) {\r\n\t                    boundingBox = Rect.union(boundingBox, elementBoundingBox);\r\n\t                } else {\r\n\t                    boundingBox = elementBoundingBox;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    return boundingBox;\r\n\t}\r\n\r\n\tfunction elementsClippedBoundingBox(elements, transformation) {\r\n\t    var boundingBox;\r\n\r\n\t    for (var i = 0; i < elements.length; i++) {\r\n\t        var element = elements[i];\r\n\t        if (element.visible()) {\r\n\t            var elementBoundingBox = element.clippedBBox(transformation);\r\n\t            if (elementBoundingBox) {\r\n\t                if (boundingBox) {\r\n\t                    boundingBox = Rect.union(boundingBox, elementBoundingBox);\r\n\t                } else {\r\n\t                    boundingBox = elementBoundingBox;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    return boundingBox;\r\n\t}\r\n\r\n\tvar MultiPath = Element$1.extend({\r\n\t    init: function(options) {\r\n\t        Element$1.fn.init.call(this, options);\r\n\t        this.paths = new GeometryElementsArray();\r\n\t        this.paths.addObserver(this);\r\n\r\n\t        if (!defined(this.options.stroke)) {\r\n\t            this.stroke(\"#000\");\r\n\t        }\r\n\t    },\r\n\r\n\t    moveTo: function(x, y) {\r\n\t        var path = new Path();\r\n\t        path.moveTo(x, y);\r\n\r\n\t        this.paths.push(path);\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    lineTo: function(x, y) {\r\n\t        if (this.paths.length > 0) {\r\n\t            last(this.paths).lineTo(x, y);\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    curveTo: function(controlOut, controlIn, point) {\r\n\t        if (this.paths.length > 0) {\r\n\t            last(this.paths).curveTo(controlOut, controlIn, point);\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    arc: function(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\r\n\t        if (this.paths.length > 0) {\r\n\t            last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    arcTo: function(end, rx, ry, largeArc, swipe, rotation) {\r\n\t        if (this.paths.length > 0) {\r\n\t            last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    close: function() {\r\n\t        if (this.paths.length > 0) {\r\n\t            last(this.paths).close();\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    _bbox: function(matrix) {\r\n\t        return elementsBoundingBox(this.paths, true, matrix);\r\n\t    },\r\n\r\n\t    rawBBox: function() {\r\n\t        return elementsBoundingBox(this.paths, false);\r\n\t    },\r\n\r\n\t    _containsPoint: function(point) {\r\n\t        var paths = this.paths;\r\n\r\n\t        for (var idx = 0; idx < paths.length; idx++) {\r\n\t            if (paths[idx]._containsPoint(point)) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t        return false;\r\n\t    },\r\n\r\n\t    _isOnPath: function(point) {\r\n\t        var paths = this.paths;\r\n\t        var width = this.options.stroke.width;\r\n\r\n\t        for (var idx = 0; idx < paths.length; idx++) {\r\n\t            if (paths[idx]._isOnPath(point, width)) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t        return false;\r\n\t    },\r\n\r\n\t    _clippedBBox: function(transformation) {\r\n\t        return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\r\n\t    }\r\n\t});\r\n\r\n\tMultiPath.prototype.nodeType = \"MultiPath\";\r\n\r\n\tPaintable.extend(MultiPath.prototype);\r\n\tMeasurable.extend(MultiPath.prototype);\r\n\r\n\tvar DEFAULT_FONT = \"12px sans-serif\";\r\n\tvar DEFAULT_FILL = \"#000\";\r\n\r\n\tvar Text = Element$1.extend({\r\n\t    init: function(content, position, options) {\r\n\t        if (position === void 0) { position = new Point(); }\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        Element$1.fn.init.call(this, options);\r\n\r\n\t        this.content(content);\r\n\t        this.position(position);\r\n\r\n\t        if (!this.options.font) {\r\n\t            this.options.font = DEFAULT_FONT;\r\n\t        }\r\n\r\n\t        if (!defined(this.options.fill)) {\r\n\t            this.fill(DEFAULT_FILL);\r\n\t        }\r\n\t    },\r\n\r\n\t    content: function(value) {\r\n\t        if (defined(value)) {\r\n\t            this.options.set(\"content\", value);\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this.options.get(\"content\");\r\n\t    },\r\n\r\n\t    measure: function() {\r\n\t        var metrics = kendoUtil.measureText(this.content(), {\r\n\t            font: this.options.get(\"font\")\r\n\t        });\r\n\r\n\t        return metrics;\r\n\t    },\r\n\r\n\t    rect: function() {\r\n\t        var size = this.measure();\r\n\t        var pos = this.position().clone();\r\n\t        return new Rect(pos, [ size.width, size.height ]);\r\n\t    },\r\n\r\n\t    bbox: function(transformation) {\r\n\t        var combinedMatrix = toMatrix(this.currentTransform(transformation));\r\n\t        return this.rect().bbox(combinedMatrix);\r\n\t    },\r\n\r\n\t    rawBBox: function() {\r\n\t        return this.rect().bbox();\r\n\t    },\r\n\r\n\t    _containsPoint: function(point) {\r\n\t        return this.rect().containsPoint(point);\r\n\t    }\r\n\t});\r\n\r\n\tText.prototype.nodeType = \"Text\";\r\n\r\n\tPaintable.extend(Text.prototype);\r\n\r\n\tdefinePointAccessors(Text.prototype, [ \"position\" ]);\r\n\r\n\tvar Image$1 = Element$1.extend({\r\n\t    init: function(src, rect, options) {\r\n\t        if (rect === void 0) { rect = new Rect(); }\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        Element$1.fn.init.call(this, options);\r\n\r\n\t        this.src(src);\r\n\t        this.rect(rect);\r\n\t    },\r\n\r\n\t    src: function(value) {\r\n\t        if (defined(value)) {\r\n\t            this.options.set(\"src\", value);\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this.options.get(\"src\");\r\n\t    },\r\n\r\n\t    bbox: function(transformation) {\r\n\t        var combinedMatrix = toMatrix(this.currentTransform(transformation));\r\n\t        return this._rect.bbox(combinedMatrix);\r\n\t    },\r\n\r\n\t    rawBBox: function() {\r\n\t        return this._rect.bbox();\r\n\t    },\r\n\r\n\t    _containsPoint: function(point) {\r\n\t        return this._rect.containsPoint(point);\r\n\t    },\r\n\r\n\t    _hasFill: function() {\r\n\t        return this.src();\r\n\t    }\r\n\t});\r\n\r\n\tImage$1.prototype.nodeType = \"Image\";\r\n\r\n\tdefineGeometryAccessors(Image$1.prototype, [ \"rect\" ]);\r\n\r\n\tvar Traversable = {\r\n\t    extend: function(proto, childrenField) {\r\n\t        proto.traverse = function(callback) {\r\n\t            var children = this[childrenField];\r\n\r\n\t            for (var i = 0; i < children.length; i++) {\r\n\t                var child = children[i];\r\n\r\n\t                if (child.traverse) {\r\n\t                    child.traverse(callback);\r\n\t                } else {\r\n\t                    callback(child);\r\n\t                }\r\n\t            }\r\n\r\n\t            return this;\r\n\t        };\r\n\t    }\r\n\t};\r\n\r\n\tvar Group = Element$1.extend({\r\n\t    init: function(options) {\r\n\t        Element$1.fn.init.call(this, options);\r\n\t        this.children = [];\r\n\t    },\r\n\r\n\t    childrenChange: function(action, items, index) {\r\n\t        this.trigger(\"childrenChange\",{\r\n\t            action: action,\r\n\t            items: items,\r\n\t            index: index\r\n\t        });\r\n\t    },\r\n\r\n\t    append: function() {\r\n\t        append(this.children, arguments);\r\n\t        this._reparent(arguments, this);\r\n\r\n\t        this.childrenChange(\"add\", arguments);\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    insert: function(index, element) {\r\n\t        this.children.splice(index, 0, element);\r\n\t        element.parent = this;\r\n\r\n\t        this.childrenChange(\"add\", [ element ], index);\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    insertAt: function(element, index) {\r\n\t        return this.insert(index, element);\r\n\t    },\r\n\r\n\t    remove: function(element) {\r\n\t        var index = this.children.indexOf(element);\r\n\t        if (index >= 0) {\r\n\t            this.children.splice(index, 1);\r\n\t            element.parent = null;\r\n\t            this.childrenChange(\"remove\", [ element ], index);\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    removeAt: function(index) {\r\n\t        if (0 <= index && index < this.children.length) {\r\n\t            var element = this.children[index];\r\n\t            this.children.splice(index, 1);\r\n\t            element.parent = null;\r\n\t            this.childrenChange(\"remove\", [ element ], index);\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    clear: function() {\r\n\t        var items = this.children;\r\n\t        this.children = [];\r\n\t        this._reparent(items, null);\r\n\r\n\t        this.childrenChange(\"remove\", items, 0);\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    bbox: function(transformation) {\r\n\t        return elementsBoundingBox(this.children, true, this.currentTransform(transformation));\r\n\t    },\r\n\r\n\t    rawBBox: function() {\r\n\t        return elementsBoundingBox(this.children, false);\r\n\t    },\r\n\r\n\t    _clippedBBox: function(transformation) {\r\n\t        return elementsClippedBoundingBox(this.children, this.currentTransform(transformation));\r\n\t    },\r\n\r\n\t    currentTransform: function(transformation) {\r\n\t        return Element$1.prototype.currentTransform.call(this, transformation) || null;\r\n\t    },\r\n\r\n\t    containsPoint: function(point, parentTransform) {\r\n\t        if (this.visible()) {\r\n\t            var children = this.children;\r\n\t            var transform = this.currentTransform(parentTransform);\r\n\t            for (var idx = 0; idx < children.length; idx++) {\r\n\t                if (children[idx].containsPoint(point, transform)) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return false;\r\n\t    },\r\n\r\n\t    _reparent: function(elements, newParent) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var i = 0; i < elements.length; i++) {\r\n\t            var child = elements[i];\r\n\t            var parent = child.parent;\r\n\t            if (parent && parent !== this$1 && parent.remove) {\r\n\t                parent.remove(child);\r\n\t            }\r\n\r\n\t            child.parent = newParent;\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tGroup.prototype.nodeType = \"Group\";\r\n\r\n\tTraversable.extend(Group.prototype, \"children\");\r\n\r\n\tfunction translateToPoint(point, bbox, element) {\r\n\t    var transofrm = element.transform() || transform();\r\n\t    var matrix = transofrm.matrix();\r\n\t    matrix.e += point.x - bbox.origin.x;\r\n\t    matrix.f += point.y - bbox.origin.y;\r\n\r\n\t    transofrm.matrix(matrix);\r\n\t    element.transform(transofrm);\r\n\t}\r\n\r\n\tfunction alignStart(size, rect, align, axis, sizeField) {\r\n\t    var start;\r\n\t    if (align === \"start\") {\r\n\t        start = rect.origin[axis];\r\n\t    } else if (align === \"end\") {\r\n\t        start = rect.origin[axis] + rect.size[sizeField] - size;\r\n\t    } else {\r\n\t        start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;\r\n\t    }\r\n\r\n\t    return start;\r\n\t}\r\n\r\n\tfunction alignStartReverse(size, rect, align, axis, sizeField) {\r\n\t    var start;\r\n\t    if (align === \"start\") {\r\n\t        start = rect.origin[axis] + rect.size[sizeField] - size;\r\n\t    } else if (align === \"end\") {\r\n\t        start = rect.origin[axis];\r\n\t    } else {\r\n\t        start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;\r\n\t    }\r\n\r\n\t    return start;\r\n\t}\r\n\r\n\tvar DEFAULT_OPTIONS = {\r\n\t    alignContent: \"start\",\r\n\t    justifyContent: \"start\",\r\n\t    alignItems: \"start\",\r\n\t    spacing: 0,\r\n\t    orientation: \"horizontal\",\r\n\t    lineSpacing: 0,\r\n\t    wrap: true,\r\n\t    revers: false\r\n\t};\r\n\r\n\tvar forEach = function (elements, callback) {\r\n\t    elements.forEach(callback);\r\n\t};\r\n\r\n\tvar forEachReverse = function (elements, callback) {\r\n\t    var length = elements.length;\r\n\r\n\t    for (var idx = length - 1; idx >= 0; idx--) {\r\n\t        callback(elements[idx], idx);\r\n\t    }\r\n\t};\r\n\r\n\tvar Layout = Group.extend({\r\n\t    init: function(rect, options) {\r\n\t        Group.fn.init.call(this, $.extend({}, DEFAULT_OPTIONS, options));\r\n\t        this._rect = rect;\r\n\t        this._fieldMap = {};\r\n\t    },\r\n\r\n\t    rect: function(value) {\r\n\t        if (value) {\r\n\t            this._rect = value;\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this._rect;\r\n\t    },\r\n\r\n\t    _initMap: function() {\r\n\t        var options = this.options;\r\n\t        var fieldMap = this._fieldMap;\r\n\t        if (options.orientation === \"horizontal\") {\r\n\t            fieldMap.sizeField = \"width\";\r\n\t            fieldMap.groupsSizeField = \"height\";\r\n\t            fieldMap.groupAxis = \"x\";\r\n\t            fieldMap.groupsAxis = \"y\";\r\n\t        } else {\r\n\t            fieldMap.sizeField = \"height\";\r\n\t            fieldMap.groupsSizeField = \"width\";\r\n\t            fieldMap.groupAxis = \"y\";\r\n\t            fieldMap.groupsAxis = \"x\";\r\n\t        }\r\n\r\n\t        if (options.reverse) {\r\n\t            this.forEach = forEachReverse;\r\n\t            this.justifyAlign = alignStartReverse;\r\n\t        } else {\r\n\t            this.forEach = forEach;\r\n\t            this.justifyAlign = alignStart;\r\n\t        }\r\n\t    },\r\n\r\n\t    reflow: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        if (!this._rect || this.children.length === 0) {\r\n\t            return;\r\n\t        }\r\n\t        this._initMap();\r\n\r\n\t        if (this.options.transform) {\r\n\t            this.transform(null);\r\n\t        }\r\n\r\n\t        var options = this.options;\r\n\t        var rect = this._rect;\r\n\t        var ref = this._initGroups();\r\n\t        var groups = ref.groups;\r\n\t        var groupsSize = ref.groupsSize;\r\n\t        var ref$1 = this._fieldMap;\r\n\t        var sizeField = ref$1.sizeField;\r\n\t        var groupsSizeField = ref$1.groupsSizeField;\r\n\t        var groupAxis = ref$1.groupAxis;\r\n\t        var groupsAxis = ref$1.groupsAxis;\r\n\t        var groupOrigin = new Point();\r\n\t        var elementOrigin = new Point();\r\n\t        var size = new Size();\r\n\t        var groupStart = alignStart(groupsSize, rect, options.alignContent, groupsAxis, groupsSizeField);\r\n\t        var elementStart, group, groupBox;\r\n\r\n\t        var arrangeElements = function (bbox, idx) {\r\n\t            var element = group.elements[idx];\r\n\r\n\t            elementOrigin[groupAxis] = elementStart;\r\n\t            elementOrigin[groupsAxis] = alignStart(bbox.size[groupsSizeField], groupBox, options.alignItems, groupsAxis, groupsSizeField);\r\n\t            translateToPoint(elementOrigin, bbox, element);\r\n\t            elementStart += bbox.size[sizeField] + options.spacing;\r\n\t        };\r\n\r\n\t        for (var groupIdx = 0; groupIdx < groups.length; groupIdx++) {\r\n\t            group = groups[groupIdx];\r\n\t            groupOrigin[groupAxis] = elementStart = this$1.justifyAlign(group.size, rect, options.justifyContent, groupAxis, sizeField);\r\n\t            groupOrigin[groupsAxis] = groupStart;\r\n\t            size[sizeField] = group.size;\r\n\t            size[groupsSizeField] = group.lineSize;\r\n\t            groupBox = new Rect(groupOrigin, size);\r\n\t            this$1.forEach(group.bboxes, arrangeElements);\r\n\r\n\t            groupStart += group.lineSize + options.lineSpacing;\r\n\t        }\r\n\r\n\t        if (!options.wrap && group.size > rect.size[sizeField]) {\r\n\t            var scale = rect.size[sizeField] / groupBox.size[sizeField];\r\n\t            var scaledStart = groupBox.topLeft().scale(scale, scale);\r\n\t            var scaledSize = groupBox.size[groupsSizeField] * scale;\r\n\t            var newStart = alignStart(scaledSize, rect, options.alignContent, groupsAxis, groupsSizeField);\r\n\t            var transform$$1 = transform();\r\n\t            if (groupAxis === \"x\") {\r\n\t                transform$$1.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);\r\n\t            } else {\r\n\t                transform$$1.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);\r\n\t            }\r\n\t            transform$$1.scale(scale, scale);\r\n\r\n\t            this.transform(transform$$1);\r\n\t        }\r\n\t    },\r\n\r\n\t    _initGroups: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var children = ref.children;\r\n\t        var lineSpacing = options.lineSpacing;\r\n\t        var wrap = options.wrap;\r\n\t        var spacing = options.spacing;\r\n\t        var sizeField = this._fieldMap.sizeField;\r\n\t        var group = this._newGroup();\r\n\t        var groups = [];\r\n\t        var addGroup = function() {\r\n\t            groups.push(group);\r\n\t            groupsSize += group.lineSize + lineSpacing;\r\n\t        };\r\n\t        var groupsSize = -lineSpacing;\r\n\r\n\t        for (var idx = 0; idx < children.length; idx++) {\r\n\t            var element = children[idx];\r\n\t            var bbox = children[idx].clippedBBox();\r\n\t            if (element.visible() && bbox) {\r\n\t                if (wrap && group.size + bbox.size[sizeField] + spacing > this$1._rect.size[sizeField]) {\r\n\t                    if (group.bboxes.length === 0) {\r\n\t                        this$1._addToGroup(group, bbox, element);\r\n\t                        addGroup();\r\n\t                        group = this$1._newGroup();\r\n\t                    } else {\r\n\t                        addGroup();\r\n\t                        group = this$1._newGroup();\r\n\t                        this$1._addToGroup(group, bbox, element);\r\n\t                    }\r\n\t                } else {\r\n\t                    this$1._addToGroup(group, bbox, element);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (group.bboxes.length) {\r\n\t            addGroup();\r\n\t        }\r\n\r\n\t        return {\r\n\t            groups: groups,\r\n\t            groupsSize: groupsSize\r\n\t        };\r\n\t    },\r\n\r\n\t    _addToGroup: function(group, bbox, element) {\r\n\t        group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;\r\n\t        group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);\r\n\t        group.bboxes.push(bbox);\r\n\t        group.elements.push(element);\r\n\t    },\r\n\r\n\t    _newGroup: function() {\r\n\t        return {\r\n\t            lineSize: 0,\r\n\t            size: -this.options.spacing,\r\n\t            bboxes: [],\r\n\t            elements: []\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tvar Rect$2 = Element$1.extend({\r\n\t    init: function(geometry, options) {\r\n\t        if (geometry === void 0) { geometry = new Rect(); }\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        Element$1.fn.init.call(this, options);\r\n\t        this.geometry(geometry);\r\n\r\n\t        if (!defined(this.options.stroke)) {\r\n\t            this.stroke(\"#000\");\r\n\t        }\r\n\t    },\r\n\r\n\t    _bbox: function(matrix) {\r\n\t        return this._geometry.bbox(matrix);\r\n\t    },\r\n\r\n\t    rawBBox: function() {\r\n\t        return this._geometry.bbox();\r\n\t    },\r\n\r\n\t    _containsPoint: function(point) {\r\n\t        return this._geometry.containsPoint(point);\r\n\t    },\r\n\r\n\t    _isOnPath: function(point) {\r\n\t        return this.geometry()._isOnPath(point, this.options.stroke.width / 2);\r\n\t    }\r\n\t});\r\n\r\n\tRect$2.prototype.nodeType = \"Rect\";\r\n\r\n\tPaintable.extend(Rect$2.prototype);\r\n\tMeasurable.extend(Rect$2.prototype);\r\n\tdefineGeometryAccessors(Rect$2.prototype, [ \"geometry\" ]);\r\n\r\n\tfunction alignElements(elements, rect, alignment, axis, sizeField) {\r\n\t    for (var idx = 0; idx < elements.length; idx++) {\r\n\t        var bbox = elements[idx].clippedBBox();\r\n\t        if (bbox) {\r\n\t            var point = bbox.origin.clone();\r\n\t            point[axis] = alignStart(bbox.size[sizeField], rect, alignment || \"start\", axis, sizeField);\r\n\t            translateToPoint(point, bbox, elements[idx]);\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction align(elements, rect, alignment) {\r\n\t    alignElements(elements, rect, alignment, \"x\", \"width\");\r\n\t}\r\n\r\n\tfunction vAlign(elements, rect, alignment) {\r\n\t    alignElements(elements, rect, alignment, \"y\", \"height\");\r\n\t}\r\n\r\n\tfunction stackElements(elements, stackAxis, otherAxis, sizeField) {\r\n\t    if (elements.length > 1) {\r\n\t        var origin = new Point();\r\n\t        var previousBBox = elements[0].bbox;\r\n\r\n\t        for (var idx = 1; idx < elements.length; idx++) {\r\n\t            var element = elements[idx].element;\r\n\t            var bbox = elements[idx].bbox;\r\n\t            origin[stackAxis] = previousBBox.origin[stackAxis] + previousBBox.size[sizeField];\r\n\t            origin[otherAxis] = bbox.origin[otherAxis];\r\n\t            translateToPoint(origin, bbox, element);\r\n\t            bbox.origin[stackAxis] = origin[stackAxis];\r\n\t            previousBBox = bbox;\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction createStackElements(elements) {\r\n\t    var stackElements = [];\r\n\r\n\t    for (var idx = 0; idx < elements.length; idx++) {\r\n\t        var element = elements[idx];\r\n\t        var bbox = element.clippedBBox();\r\n\t        if (bbox) {\r\n\t            stackElements.push({\r\n\t                element: element,\r\n\t                bbox: bbox\r\n\t            });\r\n\t        }\r\n\t    }\r\n\r\n\t    return stackElements;\r\n\t}\r\n\r\n\tfunction stack(elements) {\r\n\t    stackElements(createStackElements(elements), \"x\", \"y\", \"width\");\r\n\t}\r\n\r\n\tfunction vStack(elements) {\r\n\t    stackElements(createStackElements(elements), \"y\", \"x\", \"height\");\r\n\t}\r\n\r\n\tfunction getStacks(elements, rect, sizeField) {\r\n\t    var maxSize = rect.size[sizeField];\r\n\t    var stacks = [];\r\n\t    var stack = [];\r\n\t    var stackSize = 0;\r\n\t    var element, bbox;\r\n\r\n\t    var addElementToStack = function() {\r\n\t        stack.push({\r\n\t            element: element,\r\n\t            bbox: bbox\r\n\t        });\r\n\t    };\r\n\r\n\t    for (var idx = 0; idx < elements.length; idx++) {\r\n\t        element = elements[idx];\r\n\r\n\t        bbox = element.clippedBBox();\r\n\t        if (bbox) {\r\n\t            var size = bbox.size[sizeField];\r\n\t            if (stackSize + size > maxSize) {\r\n\t                if (stack.length) {\r\n\t                    stacks.push(stack);\r\n\t                    stack = [];\r\n\t                    addElementToStack();\r\n\t                    stackSize = size;\r\n\t                } else {\r\n\t                    addElementToStack();\r\n\t                    stacks.push(stack);\r\n\t                    stack = [];\r\n\t                    stackSize = 0;\r\n\t                }\r\n\t            } else {\r\n\t                addElementToStack();\r\n\t                stackSize += size;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    if (stack.length) {\r\n\t        stacks.push(stack);\r\n\t    }\r\n\r\n\t    return stacks;\r\n\t}\r\n\r\n\tfunction wrapElements(elements, rect, axis, otherAxis, sizeField) {\r\n\t    var stacks = getStacks(elements, rect, sizeField);\r\n\t    var origin = rect.origin.clone();\r\n\t    var result = [];\r\n\r\n\t    for (var idx = 0; idx < stacks.length; idx++) {\r\n\t        var stack = stacks[idx];\r\n\t        var startElement = stack[0];\r\n\t        origin[otherAxis] = startElement.bbox.origin[otherAxis];\r\n\t        translateToPoint(origin, startElement.bbox, startElement.element);\r\n\t        startElement.bbox.origin[axis] = origin[axis];\r\n\t        stackElements(stack, axis, otherAxis, sizeField);\r\n\t        result.push([]);\r\n\t        for (var elementIdx = 0; elementIdx < stack.length; elementIdx++) {\r\n\t            result[idx].push(stack[elementIdx].element);\r\n\t        }\r\n\t    }\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction wrap(elements, rect) {\r\n\t    return wrapElements(elements, rect, \"x\", \"y\", \"width\");\r\n\t}\r\n\r\n\tfunction vWrap(elements, rect) {\r\n\t    return wrapElements(elements, rect, \"y\", \"x\", \"height\");\r\n\t}\r\n\r\n\tfunction fit(element, rect) {\r\n\t    var bbox = element.clippedBBox();\r\n\t    if (bbox) {\r\n\t        var elementSize = bbox.size;\r\n\t        var rectSize = rect.size;\r\n\t        if (rectSize.width < elementSize.width || rectSize.height < elementSize.height) {\r\n\t            var scale = Math.min(rectSize.width / elementSize.width, rectSize.height / elementSize.height);\r\n\t            var transform$$1 = element.transform() || transform();\r\n\t            transform$$1.scale(scale, scale);\r\n\t            element.transform(transform$$1);\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tvar StopsArray = ElementsArray.extend({\r\n\t    _change: function() {\r\n\t        this.optionsChange({\r\n\t            field: \"stops\"\r\n\t        });\r\n\t    }\r\n\t});\r\n\r\n\tfunction optionsAccessor(name) {\r\n\t    return function(value) {\r\n\t        if (defined(value)) {\r\n\t            this.options.set(name, value);\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this.options.get(name);\r\n\t    };\r\n\t}\r\n\r\n\tfunction defineOptionsAccessors(fn, names) {\r\n\t    for (var i = 0; i < names.length; i++) {\r\n\t        fn[names[i]] = optionsAccessor(names[i]);\r\n\t    }\r\n\t}\r\n\r\n\tvar GradientStop = Class.extend({\r\n\t    init: function(offset, color, opacity) {\r\n\r\n\t        this.options = new OptionsStore({\r\n\t            offset: offset,\r\n\t            color: color,\r\n\t            opacity: defined(opacity) ? opacity : 1\r\n\t        });\r\n\t        this.options.addObserver(this);\r\n\t    }\r\n\t});\r\n\r\n\tGradientStop.create = function(arg) {\r\n\t    if (defined(arg)) {\r\n\t        var stop;\r\n\t        if (arg instanceof GradientStop) {\r\n\t            stop = arg;\r\n\t        } else if (arg.length > 1) {\r\n\t            stop = new GradientStop(arg[0], arg[1], arg[2]);\r\n\t        } else {\r\n\t            stop = new GradientStop(arg.offset, arg.color, arg.opacity);\r\n\t        }\r\n\r\n\t        return stop;\r\n\t    }\r\n\t};\r\n\r\n\tdefineOptionsAccessors(GradientStop.prototype, [ \"offset\", \"color\", \"opacity\" ]);\r\n\tObserversMixin.extend(GradientStop.prototype);\r\n\r\n\tvar Gradient = Class.extend({\r\n\t    init: function(options) {\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        this.stops = new StopsArray(this._createStops(options.stops));\r\n\t        this.stops.addObserver(this);\r\n\t        this._userSpace = options.userSpace;\r\n\t        this.id = definitionId();\r\n\t    },\r\n\r\n\t    userSpace: function(value) {\r\n\t        if (defined(value)) {\r\n\t            this._userSpace = value;\r\n\t            this.optionsChange();\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this._userSpace;\r\n\t    },\r\n\r\n\t    _createStops: function(stops) {\r\n\t        if (stops === void 0) { stops = []; }\r\n\r\n\t        var result = [];\r\n\t        for (var idx = 0; idx < stops.length; idx++) {\r\n\t            result.push(GradientStop.create(stops[idx]));\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    addStop: function(offset, color, opacity) {\r\n\t        this.stops.push(new GradientStop(offset, color, opacity));\r\n\t    },\r\n\r\n\t    removeStop: function(stop) {\r\n\t        var index = this.stops.indexOf(stop);\r\n\t        if (index >= 0) {\r\n\t            this.stops.splice(index, 1);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tGradient.prototype.nodeType = \"Gradient\";\r\n\r\n\tObserversMixin.extend(Gradient.prototype);\r\n\r\n\t$.extend(Gradient.prototype, {\r\n\t    optionsChange: function(e) {\r\n\t        this.trigger(\"optionsChange\", {\r\n\t            field: \"gradient\" + (e ? \".\" + e.field : \"\"),\r\n\t            value: this\r\n\t        });\r\n\t    },\r\n\r\n\t    geometryChange: function() {\r\n\t        this.optionsChange();\r\n\t    }\r\n\t});\r\n\r\n\tvar LinearGradient = Gradient.extend({\r\n\t    init: function(options) {\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        Gradient.fn.init.call(this, options);\r\n\r\n\t        this.start(options.start || new Point());\r\n\r\n\t        this.end(options.end || new Point(1, 0));\r\n\t    }\r\n\t});\r\n\r\n\tdefinePointAccessors(LinearGradient.prototype, [ \"start\", \"end\" ]);\r\n\r\n\tvar RadialGradient = Gradient.extend({\r\n\t    init: function(options) {\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        Gradient.fn.init.call(this, options);\r\n\r\n\t        this.center(options.center || new Point());\r\n\t        this._radius = defined(options.radius) ? options.radius : 1;\r\n\t        this._fallbackFill = options.fallbackFill;\r\n\t    },\r\n\r\n\t    radius: function(value) {\r\n\t        if (defined(value)) {\r\n\t            this._radius = value;\r\n\t            this.geometryChange();\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this._radius;\r\n\t    },\r\n\r\n\t    fallbackFill: function(value) {\r\n\t        if (defined(value)) {\r\n\t            this._fallbackFill = value;\r\n\t            this.optionsChange();\r\n\t            return this;\r\n\t        }\r\n\r\n\t        return this._fallbackFill;\r\n\t    }\r\n\t});\r\n\r\n\tdefinePointAccessors(RadialGradient.prototype, [ \"center\" ]);\r\n\r\n\tfunction swing(position) {\r\n\t    return 0.5 - Math.cos(position * Math.PI) / 2;\r\n\t}\r\n\r\n\tfunction linear(position) {\r\n\t    return position;\r\n\t}\r\n\r\n\tfunction easeOutElastic(position, time, start, diff) {\r\n\t    var s = 1.70158,\r\n\t        p = 0,\r\n\t        a = diff;\r\n\r\n\t    if (position === 0) {\r\n\t        return start;\r\n\t    }\r\n\r\n\t    if (position === 1) {\r\n\t        return start + diff;\r\n\t    }\r\n\r\n\t    if (!p) {\r\n\t        p = 0.5;\r\n\t    }\r\n\r\n\t    if (a < Math.abs(diff)) {\r\n\t        a = diff;\r\n\t        s = p / 4;\r\n\t    } else {\r\n\t        s = p / (2 * Math.PI) * Math.asin(diff / a);\r\n\t    }\r\n\r\n\t    return a * Math.pow(2, -10 * position) *\r\n\t           Math.sin((Number(position) - s) * (1.1 * Math.PI) / p) + diff + start;\r\n\t}\r\n\r\n\tvar easingFunctions = {\r\n\t\tswing: swing,\r\n\t\tlinear: linear,\r\n\t\teaseOutElastic: easeOutElastic\r\n\t};\r\n\r\n\tvar now = Date.now || function() {\r\n\t    return new Date().getTime();\r\n\t};\r\n\r\n\tvar Animation = Class.extend({\r\n\t    init: function(element, options) {\r\n\r\n\t        this.options = $.extend({}, this.options, options);\r\n\t        this.element = element;\r\n\t    },\r\n\r\n\t    setup: function() {},\r\n\r\n\t    step: function() {},\r\n\r\n\t    play: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var duration = options.duration;\r\n\t        var delay = options.delay; if (delay === void 0) { delay = 0; }\r\n\t        var easing = easingFunctions[options.easing];\r\n\t        var start = now() + delay;\r\n\t        var finish = start + duration;\r\n\r\n\t        if (duration === 0) {\r\n\t            this.step(1);\r\n\t            this.abort();\r\n\t        } else {\r\n\t            setTimeout(function () {\r\n\t                var loop = function () {\r\n\t                    if (this$1._stopped) {\r\n\t                        return;\r\n\t                    }\r\n\r\n\t                    var wallTime = now();\r\n\r\n\t                    var time = limitValue(wallTime - start, 0, duration);\r\n\t                    var position = time / duration;\r\n\t                    var easingPosition = easing(position, time, 0, 1, duration);\r\n\r\n\t                    this$1.step(easingPosition);\r\n\r\n\t                    if (wallTime < finish) {\r\n\t                        kendo.animationFrame(loop);\r\n\t                    } else {\r\n\t                        this$1.abort();\r\n\t                    }\r\n\t                };\r\n\r\n\t                loop();\r\n\t            }, delay);\r\n\t        }\r\n\t    },\r\n\r\n\t    abort: function() {\r\n\t        this._stopped = true;\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        this.abort();\r\n\t    }\r\n\t});\r\n\r\n\tAnimation.prototype.options = {\r\n\t    duration: 500,\r\n\t    easing: \"swing\"\r\n\t};\r\n\r\n\tvar AnimationFactory = Class.extend({\r\n\t    init: function() {\r\n\r\n\t        this._items = [];\r\n\t    },\r\n\r\n\t    register: function(name, type) {\r\n\t        this._items.push({\r\n\t            name: name,\r\n\t            type: type\r\n\t        });\r\n\t    },\r\n\r\n\t    create: function(element, options) {\r\n\t        var items = this._items;\r\n\t        var match;\r\n\r\n\t        if (options && options.type) {\r\n\t            var type = options.type.toLowerCase();\r\n\t            for (var i = 0; i < items.length; i++) {\r\n\t                if (items[i].name.toLowerCase() === type) {\r\n\t                    match = items[i];\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (match) {\r\n\t            return new match.type(element, options);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tAnimationFactory.current = new AnimationFactory();\r\n\r\n\tAnimation.create = function(type, element, options) {\r\n\t    return AnimationFactory.current.create(type, element, options);\r\n\t};\r\n\r\n\tvar ShapeMap = {\r\n\t    l: function(path, options) {\r\n\t        var parameters = options.parameters;\r\n\t        var position = options.position;\r\n\r\n\t        for (var i = 0; i < parameters.length; i += 2) {\r\n\t            var point = new Point(parameters[i], parameters[i + 1]);\r\n\r\n\t            if (options.isRelative) {\r\n\t                point.translateWith(position);\r\n\t            }\r\n\r\n\t            path.lineTo(point.x, point.y);\r\n\r\n\t            position.x = point.x;\r\n\t            position.y = point.y;\r\n\t        }\r\n\t    },\r\n\r\n\t    c: function(path, options) {\r\n\t        var parameters = options.parameters;\r\n\t        var position = options.position;\r\n\r\n\t        for (var i = 0; i < parameters.length; i += 6) {\r\n\t            var controlOut = new Point(parameters[i], parameters[i + 1]);\r\n\t            var controlIn = new Point(parameters[i + 2], parameters[i + 3]);\r\n\t            var point = new Point(parameters[i + 4], parameters[i + 5]);\r\n\t            if (options.isRelative) {\r\n\t                controlIn.translateWith(position);\r\n\t                controlOut.translateWith(position);\r\n\t                point.translateWith(position);\r\n\t            }\r\n\r\n\t            path.curveTo(controlOut, controlIn, point);\r\n\r\n\t            position.x = point.x;\r\n\t            position.y = point.y;\r\n\t        }\r\n\t    },\r\n\r\n\t    v: function(path, options) {\r\n\t        var value = options.isRelative ? 0 : options.position.x;\r\n\r\n\t        toLineParamaters(options.parameters, true, value);\r\n\t        this.l(path, options);\r\n\t    },\r\n\r\n\t    h: function(path, options) {\r\n\t        var value = options.isRelative ? 0 : options.position.y;\r\n\r\n\t        toLineParamaters(options.parameters, false, value);\r\n\t        this.l(path, options);\r\n\t    },\r\n\r\n\t    a: function(path, options) {\r\n\t        var parameters = options.parameters;\r\n\t        var position = options.position;\r\n\r\n\t        for (var i = 0; i < parameters.length; i += 7) {\r\n\t            var radiusX = parameters[i];\r\n\t            var radiusY = parameters[i + 1];\r\n\t            var rotation = parameters[i + 2];\r\n\t            var largeArc = parameters[i + 3];\r\n\t            var swipe = parameters[i + 4];\r\n\t            var endPoint = new Point(parameters[i + 5], parameters[i + 6]);\r\n\r\n\t            if (options.isRelative) {\r\n\t                endPoint.translateWith(position);\r\n\t            }\r\n\t            if (position.x !== endPoint.x || position.y !== endPoint.y) {\r\n\t                path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);\r\n\r\n\t                position.x = endPoint.x;\r\n\t                position.y = endPoint.y;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    s: function(path, options) {\r\n\t        var parameters = options.parameters;\r\n\t        var position = options.position;\r\n\t        var previousCommand = options.previousCommand;\r\n\t        var lastControlIn;\r\n\r\n\t        if (previousCommand === \"s\" || previousCommand === \"c\") {\r\n\t            lastControlIn = last(last(path.paths).segments).controlIn();\r\n\t        }\r\n\r\n\t        for (var i = 0; i < parameters.length; i += 4) {\r\n\t            var controlIn = new Point(parameters[i], parameters[i + 1]);\r\n\t            var endPoint = new Point(parameters[i + 2], parameters[i + 3]);\r\n\t            var controlOut = (void 0);\r\n\r\n\t            if (options.isRelative) {\r\n\t                controlIn.translateWith(position);\r\n\t                endPoint.translateWith(position);\r\n\t            }\r\n\r\n\t            if (lastControlIn) {\r\n\t                controlOut = reflectionPoint(lastControlIn, position);\r\n\t            } else {\r\n\t                controlOut = position.clone();\r\n\t            }\r\n\r\n\t            lastControlIn = controlIn;\r\n\r\n\t            path.curveTo(controlOut, controlIn, endPoint);\r\n\r\n\t            position.x = endPoint.x;\r\n\t            position.y = endPoint.y;\r\n\t        }\r\n\t    },\r\n\r\n\t    q: function(path, options) {\r\n\t        var parameters = options.parameters;\r\n\t        var position = options.position;\r\n\r\n\t        for (var i = 0; i < parameters.length; i += 4) {\r\n\t            var controlPoint = new Point(parameters[i], parameters[i + 1]);\r\n\t            var endPoint = new Point(parameters[i + 2], parameters[i + 3]);\r\n\r\n\t            if (options.isRelative) {\r\n\t                controlPoint.translateWith(position);\r\n\t                endPoint.translateWith(position);\r\n\t            }\r\n\r\n\t            var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\r\n\r\n\t            path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\r\n\r\n\t            position.x = endPoint.x;\r\n\t            position.y = endPoint.y;\r\n\t        }\r\n\t    },\r\n\r\n\t    t: function(path, options) {\r\n\t        var parameters = options.parameters;\r\n\t        var position = options.position;\r\n\t        var previousCommand = options.previousCommand;\r\n\t        var controlPoint;\r\n\r\n\t        if (previousCommand === \"q\" || previousCommand === \"t\") {\r\n\t            var lastSegment = last(last(path.paths).segments);\r\n\t            controlPoint = lastSegment.controlIn().clone()\r\n\t                .translateWith(position.scaleCopy(-1 / 3))\r\n\t                .scale(3 / 2);\r\n\t        }\r\n\r\n\t        for (var i = 0; i < parameters.length; i += 2) {\r\n\t            var endPoint = new Point(parameters[i], parameters[i + 1]);\r\n\t            if (options.isRelative) {\r\n\t                endPoint.translateWith(position);\r\n\t            }\r\n\r\n\t            if (controlPoint) {\r\n\t                controlPoint = reflectionPoint(controlPoint, position);\r\n\t            } else {\r\n\t                controlPoint = position.clone();\r\n\t            }\r\n\r\n\t            var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\r\n\r\n\t            path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\r\n\r\n\t            position.x = endPoint.x;\r\n\t            position.y = endPoint.y;\r\n\t        }\r\n\t    }\r\n\t};\r\n\r\n\tfunction toLineParamaters(parameters, isVertical, value) {\r\n\t    var insertPosition = isVertical ? 0 : 1;\r\n\r\n\t    for (var i = 0; i < parameters.length; i += 2) {\r\n\t        parameters.splice(i + insertPosition, 0, value);\r\n\t    }\r\n\t}\r\n\r\n\tfunction reflectionPoint(point, center) {\r\n\t    if (point && center) {\r\n\t        return center.scaleCopy(2).translate(-point.x, -point.y);\r\n\t    }\r\n\t}\r\n\r\n\tvar third = 1 / 3;\r\n\r\n\tfunction quadraticToCubicControlPoints(position, controlPoint, endPoint) {\r\n\t    var scaledPoint = controlPoint.clone().scale(2 / 3);\r\n\t    return {\r\n\t        controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),\r\n\t        controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))\r\n\t    };\r\n\t}\r\n\r\n\tvar SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;\r\n\tvar SPLIT_REGEX = /[,\\s]?([+\\-]?(?:\\d*\\.\\d+|\\d+)(?:[eE][+\\-]?\\d+)?)/g;\r\n\tvar MOVE = \"m\";\r\n\tvar CLOSE = \"z\";\r\n\r\n\tfunction parseParameters(str) {\r\n\t    var parameters = [];\r\n\t    str.replace(SPLIT_REGEX, function(match, number) {\r\n\t        parameters.push(parseFloat(number));\r\n\t    });\r\n\t    return parameters;\r\n\t}\r\n\r\n\tvar PathParser = Class.extend({\r\n\t    parse: function(str, options) {\r\n\t        var multiPath = new MultiPath(options);\r\n\t        var position = new Point();\r\n\t        var previousCommand;\r\n\r\n\t        str.replace(SEGMENT_REGEX, function (match, element, params, closePath) {\r\n\t            var command = element.toLowerCase();\r\n\t            var isRelative = command === element;\r\n\t            var parameters = parseParameters(params.trim());\r\n\r\n\t            if (command === MOVE) {\r\n\t                if (isRelative) {\r\n\t                    position.x += parameters[0];\r\n\t                    position.y += parameters[1];\r\n\t                } else {\r\n\t                    position.x = parameters[0];\r\n\t                    position.y = parameters[1];\r\n\t                }\r\n\r\n\t                multiPath.moveTo(position.x, position.y);\r\n\r\n\t                if (parameters.length > 2) {\r\n\t                    command = \"l\";\r\n\t                    parameters.splice(0, 2);\r\n\t                }\r\n\t            }\r\n\r\n\t            if (ShapeMap[command]) {\r\n\t                ShapeMap[command](\r\n\t                    multiPath, {\r\n\t                        parameters: parameters,\r\n\t                        position: position,\r\n\t                        isRelative: isRelative,\r\n\t                        previousCommand: previousCommand\r\n\t                    }\r\n\t                );\r\n\r\n\t                if (closePath && closePath.toLowerCase() === CLOSE) {\r\n\t                    multiPath.close();\r\n\t                }\r\n\t            } else if (command !== MOVE) {\r\n\t                throw new Error(\"Error while parsing SVG path. Unsupported command: \" + command);\r\n\t            }\r\n\r\n\t            previousCommand = command;\r\n\t        });\r\n\r\n\t        return multiPath;\r\n\t    }\r\n\t});\r\n\r\n\tPathParser.current = new PathParser();\r\n\r\n\tPath.parse = function(str, options) {\r\n\t    return PathParser.current.parse(str, options);\r\n\t};\r\n\r\n\tvar SurfaceFactory = Class.extend({\r\n\t    init: function() {\r\n\r\n\t        this._items = [];\r\n\t    },\r\n\r\n\t    register: function(name, type, order) {\r\n\t        var items = this._items;\r\n\t        var first = items[0];\r\n\t        var entry = {\r\n\t            name: name,\r\n\t            type: type,\r\n\t            order: order\r\n\t        };\r\n\r\n\t        if (!first || order < first.order) {\r\n\t            items.unshift(entry);\r\n\t        } else {\r\n\t            items.push(entry);\r\n\t        }\r\n\t    },\r\n\r\n\t    create: function(element, options) {\r\n\t        var items = this._items;\r\n\t        var match = items[0];\r\n\r\n\t        if (options && options.type) {\r\n\t            var preferred = options.type.toLowerCase();\r\n\t            for (var i = 0; i < items.length; i++) {\r\n\t                if (items[i].name === preferred) {\r\n\t                    match = items[i];\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (match) {\r\n\t            return new match.type(element, options);\r\n\t        }\r\n\r\n\t        kendo.logToConsole(\r\n\t            \"Warning: Unable to create Kendo UI Drawing Surface. Possible causes:\\n\" +\r\n\t            \"- The browser does not support SVG and Canvas. User agent: \" + (navigator.userAgent));\r\n\t    }\r\n\t});\r\n\r\n\tSurfaceFactory.current = new SurfaceFactory();\r\n\r\n\tvar events = [\r\n\t    \"click\",\r\n\t    \"mouseenter\",\r\n\t    \"mouseleave\",\r\n\t    \"mousemove\",\r\n\t    \"resize\"\r\n\t];\r\n\r\n\tvar Surface = kendo.Observable.extend({\r\n\t    init: function(element, options) {\r\n\t        kendo.Observable.fn.init.call(this);\r\n\r\n\t        this.options = $.extend({}, options);\r\n\t        this.element = element;\r\n\t        this.element._kendoExportVisual = this.exportVisual.bind(this);\r\n\r\n\t        this._click = this._handler(\"click\");\r\n\t        this._mouseenter = this._handler(\"mouseenter\");\r\n\t        this._mouseleave = this._handler(\"mouseleave\");\r\n\t        this._mousemove = this._handler(\"mousemove\");\r\n\r\n\t        this._visual = new Group();\r\n\r\n\t        elementSize(element, this.options);\r\n\r\n\t        this.bind(events, this.options);\r\n\r\n\t        this._enableTracking();\r\n\t    },\r\n\r\n\t    draw: function(element) {\r\n\t        this._visual.children.push(element);\r\n\t    },\r\n\r\n\t    clear: function() {\r\n\t        this._visual.children = [];\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        this._visual = null;\r\n\t        this.element._kendoExportVisual = null;\r\n\t        this.unbind();\r\n\t    },\r\n\r\n\t    eventTarget: function(e) {\r\n\t        var this$1 = this;\r\n\r\n\t        var domNode = eventElement(e);\r\n\t        var node;\r\n\r\n\t        while (!node && domNode) {\r\n\t            node = domNode._kendoNode;\r\n\t            if (domNode === this$1.element) {\r\n\t                break;\r\n\t            }\r\n\r\n\t            domNode = domNode.parentElement;\r\n\t        }\r\n\r\n\t        if (node) {\r\n\t            return node.srcElement;\r\n\t        }\r\n\t    },\r\n\r\n\t    exportVisual: function() {\r\n\t        return this._visual;\r\n\t    },\r\n\r\n\t    getSize: function() {\r\n\t        return elementSize(this.element);\r\n\t    },\r\n\r\n\t    currentSize: function(size) {\r\n\t        if (size) {\r\n\t            this._size = size;\r\n\t        } else {\r\n\t            return this._size;\r\n\t        }\r\n\t    },\r\n\r\n\t    setSize: function(size) {\r\n\t        elementSize(this.element, size);\r\n\r\n\t        this.currentSize(size);\r\n\t        this._resize();\r\n\t    },\r\n\r\n\t    resize: function(force) {\r\n\t        var size = this.getSize();\r\n\t        var currentSize = this.currentSize();\r\n\r\n\t        if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\r\n\t            this.currentSize(size);\r\n\t            this._resize(size, force);\r\n\t            this.trigger(\"resize\", size);\r\n\t        }\r\n\t    },\r\n\r\n\t    size: function(value) {\r\n\t        if (!value) {\r\n\t            return this.getSize();\r\n\t        }\r\n\r\n\t        this.setSize(value);\r\n\t    },\r\n\r\n\t    suspendTracking: function() {\r\n\t        this._suspendedTracking = true;\r\n\t    },\r\n\r\n\t    resumeTracking: function() {\r\n\t        this._suspendedTracking = false;\r\n\t    },\r\n\r\n\t    _enableTracking: function() {},\r\n\r\n\t    _resize: function() {},\r\n\r\n\t    _handler: function(eventName) {\r\n\t        var this$1 = this;\r\n\r\n\t        return function (e) {\r\n\t            var node = this$1.eventTarget(e);\r\n\t            if (node && !this$1._suspendedTracking) {\r\n\t                this$1.trigger(eventName, {\r\n\t                    element: node,\r\n\t                    originalEvent: e,\r\n\t                    type: eventName\r\n\t                });\r\n\t            }\r\n\t        };\r\n\t    },\r\n\r\n\t    _elementOffset: function() {\r\n\t        var element = this.element;\r\n\t        var ref = elementStyles(element, [ \"paddingLeft\", \"paddingTop\" ]);\r\n\t        var paddingLeft = ref.paddingLeft;\r\n\t        var paddingTop = ref.paddingTop;\r\n\t        var ref$1 = elementOffset(element);\r\n\t        var left = ref$1.left;\r\n\t        var top = ref$1.top;\r\n\r\n\t        return {\r\n\t            left: left + parseInt(paddingLeft, 10),\r\n\t            top: top + parseInt(paddingTop, 10)\r\n\t        };\r\n\t    },\r\n\r\n\t    _surfacePoint: function(e) {\r\n\t        var offset = this._elementOffset();\r\n\t        var coord = eventCoordinates(e);\r\n\t        var x = coord.x - offset.left;\r\n\t        var y = coord.y - offset.top;\r\n\r\n\t        return new Point(x, y);\r\n\t    }\r\n\t});\r\n\r\n\tSurface.create = function(element, options) {\r\n\t    return SurfaceFactory.current.create(element, options);\r\n\t};\r\n\r\n\tSurface.support = {};\r\n\r\n\tvar BaseNode = Class.extend({\r\n\t    init: function(srcElement) {\r\n\r\n\t        this.childNodes = [];\r\n\t        this.parent = null;\r\n\r\n\t        if (srcElement) {\r\n\t            this.srcElement = srcElement;\r\n\t            this.observe();\r\n\t        }\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        if (this.srcElement) {\r\n\t            this.srcElement.removeObserver(this);\r\n\t        }\r\n\r\n\t        var children = this.childNodes;\r\n\t        for (var i = 0; i < children.length; i++) {\r\n\t            this$1.childNodes[i].destroy();\r\n\t        }\r\n\r\n\t        this.parent = null;\r\n\t    },\r\n\r\n\t    load: function() {},\r\n\r\n\t    observe: function() {\r\n\t        if (this.srcElement) {\r\n\t            this.srcElement.addObserver(this);\r\n\t        }\r\n\t    },\r\n\r\n\t    append: function(node) {\r\n\t        this.childNodes.push(node);\r\n\t        node.parent = this;\r\n\t    },\r\n\r\n\t    insertAt: function(node, pos) {\r\n\t        this.childNodes.splice(pos, 0, node);\r\n\t        node.parent = this;\r\n\t    },\r\n\r\n\t    remove: function(index, count) {\r\n\t        var this$1 = this;\r\n\r\n\t        var end = index + count;\r\n\t        for (var i = index; i < end; i++) {\r\n\t            this$1.childNodes[i].removeSelf();\r\n\t        }\r\n\t        this.childNodes.splice(index, count);\r\n\t    },\r\n\r\n\t    removeSelf: function() {\r\n\t        this.clear();\r\n\t        this.destroy();\r\n\t    },\r\n\r\n\t    clear: function() {\r\n\t        this.remove(0, this.childNodes.length);\r\n\t    },\r\n\r\n\t    invalidate: function() {\r\n\t        if (this.parent) {\r\n\t            this.parent.invalidate();\r\n\t        }\r\n\t    },\r\n\r\n\t    geometryChange: function() {\r\n\t        this.invalidate();\r\n\t    },\r\n\r\n\t    optionsChange: function() {\r\n\t        this.invalidate();\r\n\t    },\r\n\r\n\t    childrenChange: function(e) {\r\n\t        if (e.action === \"add\") {\r\n\t            this.load(e.items, e.index);\r\n\t        } else if (e.action === \"remove\") {\r\n\t            this.remove(e.index, e.items.length);\r\n\t        }\r\n\r\n\t        this.invalidate();\r\n\t    }\r\n\t});\r\n\r\n\tfunction renderAttr(name, value) {\r\n\t    return (defined(value) && value !== null) ? (\" \" + name + \"='\" + value + \"' \") : \"\";\r\n\t}\r\n\r\n\tfunction renderAllAttr(attrs) {\r\n\t    var output = \"\";\r\n\t    for (var i = 0; i < attrs.length; i++) {\r\n\t        output += renderAttr(attrs[i][0], attrs[i][1]);\r\n\t    }\r\n\r\n\t    return output;\r\n\t}\r\n\r\n\tfunction renderStyle(attrs) {\r\n\t    var output = \"\";\r\n\t    for (var i = 0; i < attrs.length; i++) {\r\n\t        var value = attrs[i][1];\r\n\t        if (defined(value)) {\r\n\t            output += attrs[i][0] + \":\" + value + \";\";\r\n\t        }\r\n\t    }\r\n\r\n\t    if (output !== \"\") {\r\n\t        return output;\r\n\t    }\r\n\t}\r\n\r\n\tvar NODE_MAP = {};\r\n\r\n\tvar SVG_NS = \"http://www.w3.org/2000/svg\";\r\n\tvar NONE = \"none\";\r\n\r\n\tvar renderSVG = function(container, svg) {\r\n\t    container.innerHTML = svg;\r\n\t};\r\n\r\n\tif (typeof document !== \"undefined\") {\r\n\t    var testFragment = \"<svg xmlns='\" + SVG_NS + \"'></svg>\";\r\n\t    var testContainer = document.createElement(\"div\");\r\n\t    var hasParser = typeof DOMParser !== \"undefined\";\r\n\r\n\t    testContainer.innerHTML = testFragment;\r\n\r\n\t    if (hasParser && testContainer.firstChild.namespaceURI !== SVG_NS) {\r\n\t        renderSVG = function(container, svg) {\r\n\t            var parser = new DOMParser();\r\n\t            var chartDoc = parser.parseFromString(svg, \"text/xml\");\r\n\t            var importedDoc = document.adoptNode(chartDoc.documentElement);\r\n\r\n\t            container.innerHTML = \"\";\r\n\t            container.appendChild(importedDoc);\r\n\t        };\r\n\t    }\r\n\t}\r\n\r\n\tvar renderSVG$1 = renderSVG;\r\n\r\n\tvar TRANSFORM = \"transform\";\r\n\tvar DefinitionMap = {\r\n\t    clip: \"clip-path\",\r\n\t    fill: \"fill\"\r\n\t};\r\n\r\n\tfunction isDefinition(type, value) {\r\n\t    return type === \"clip\" || (type === \"fill\" && (!value || value.nodeType === \"Gradient\"));\r\n\t}\r\n\r\n\tfunction baseUrl() {\r\n\t    var base = document.getElementsByTagName(\"base\")[0];\r\n\t    var href = document.location.href;\r\n\t    var hashIndex = href.indexOf(\"#\");\r\n\t    var url = \"\";\r\n\r\n\t    if (base && !supportBrowser.msie) {\r\n\t        if (hashIndex !== -1) {\r\n\t            href = href.substring(0, hashIndex);\r\n\t        }\r\n\r\n\t        url = href;\r\n\t    }\r\n\r\n\t    return url;\r\n\t}\r\n\r\n\tfunction refUrl(id, skipBaseHref) {\r\n\t    var base = skipBaseHref ? '' : baseUrl();\r\n\t    return (\"url(\" + base + \"#\" + id + \")\");\r\n\t}\r\n\r\n\tvar Node = BaseNode.extend({\r\n\t    init: function(srcElement, options) {\r\n\t        BaseNode.fn.init.call(this, srcElement);\r\n\t        this.definitions = {};\r\n\r\n\t        this.options = options;\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        if (this.element) {\r\n\t            this.element._kendoNode = null;\r\n\t            this.element = null;\r\n\t        }\r\n\r\n\t        this.clearDefinitions();\r\n\t        BaseNode.fn.destroy.call(this);\r\n\t    },\r\n\r\n\t    load: function(elements, pos) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var i = 0; i < elements.length; i++) {\r\n\t            var srcElement = elements[i];\r\n\t            var children = srcElement.children;\r\n\r\n\t            var childNode = new NODE_MAP[srcElement.nodeType](srcElement, this$1.options);\r\n\r\n\t            if (defined(pos)) {\r\n\t                this$1.insertAt(childNode, pos);\r\n\t            } else {\r\n\t                this$1.append(childNode);\r\n\t            }\r\n\r\n\t            childNode.createDefinitions();\r\n\r\n\t            if (children && children.length > 0) {\r\n\t                childNode.load(children);\r\n\t            }\r\n\r\n\t            var element = this$1.element;\r\n\t            if (element) {\r\n\t                childNode.attachTo(element, pos);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    root: function() {\r\n\t        var root = this;\r\n\r\n\t        while (root.parent) {\r\n\t            root = root.parent;\r\n\t        }\r\n\r\n\t        return root;\r\n\t    },\r\n\r\n\t    attachTo: function(domElement, pos) {\r\n\t        var container = document.createElement(\"div\");\r\n\t        renderSVG$1(container,\r\n\t            \"<svg xmlns='\" + SVG_NS + \"' version='1.1'>\" +\r\n\t                this.render() +\r\n\t            \"</svg>\"\r\n\t        );\r\n\r\n\t        var element = container.firstChild.firstChild;\r\n\t        if (element) {\r\n\t            if (defined(pos)) {\r\n\t                domElement.insertBefore(element, domElement.childNodes[pos] || null);\r\n\t            } else {\r\n\t                domElement.appendChild(element);\r\n\t            }\r\n\t            this.setElement(element);\r\n\t        }\r\n\t    },\r\n\r\n\t    setElement: function(element) {\r\n\t        if (this.element) {\r\n\t            this.element._kendoNode = null;\r\n\t        }\r\n\r\n\t        this.element = element;\r\n\t        this.element._kendoNode = this;\r\n\r\n\t        var nodes = this.childNodes;\r\n\t        for (var i = 0; i < nodes.length; i++) {\r\n\t            var childElement = element.childNodes[i];\r\n\t            nodes[i].setElement(childElement);\r\n\t        }\r\n\t    },\r\n\r\n\t    clear: function() {\r\n\t        this.clearDefinitions();\r\n\r\n\t        if (this.element) {\r\n\t            this.element.innerHTML = \"\";\r\n\t        }\r\n\r\n\t        var children = this.childNodes;\r\n\t        for (var i = 0; i < children.length; i++) {\r\n\t            children[i].destroy();\r\n\t        }\r\n\r\n\t        this.childNodes = [];\r\n\t    },\r\n\r\n\t    removeSelf: function() {\r\n\t        if (this.element) {\r\n\t            var parentNode = this.element.parentNode;\r\n\t            if (parentNode) {\r\n\t                parentNode.removeChild(this.element);\r\n\t            }\r\n\t            this.element = null;\r\n\t        }\r\n\r\n\t        BaseNode.fn.removeSelf.call(this);\r\n\t    },\r\n\r\n\t    template: function() {\r\n\t        return this.renderChildren();\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        return this.template();\r\n\t    },\r\n\r\n\t    renderChildren: function() {\r\n\t        var nodes = this.childNodes;\r\n\t        var output = \"\";\r\n\r\n\t        for (var i = 0; i < nodes.length; i++) {\r\n\t            output += nodes[i].render();\r\n\t        }\r\n\r\n\t        return output;\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        var field = e.field;\r\n\t        var value = e.value;\r\n\r\n\t        if (field === \"visible\") {\r\n\t            this.css(\"display\", value ? \"\" : NONE);\r\n\t        } else if (DefinitionMap[field] && isDefinition(field, value)) {\r\n\t            this.updateDefinition(field, value);\r\n\t        } else if (field === \"opacity\") {\r\n\t            this.attr(\"opacity\", value);\r\n\t        } else if (field === \"cursor\") {\r\n\t            this.css(\"cursor\", value);\r\n\t        } else if (field === \"id\") {\r\n\t            if (value) {\r\n\t                this.attr(\"id\", value);\r\n\t            } else {\r\n\t                this.removeAttr(\"id\");\r\n\t            }\r\n\t        }\r\n\r\n\t        BaseNode.fn.optionsChange.call(this, e);\r\n\t    },\r\n\r\n\t    attr: function(name, value) {\r\n\t        if (this.element) {\r\n\t            this.element.setAttribute(name, value);\r\n\t        }\r\n\t    },\r\n\r\n\t    allAttr: function(attrs) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var i = 0; i < attrs.length; i++) {\r\n\t            this$1.attr(attrs[i][0], attrs[i][1]);\r\n\t        }\r\n\t    },\r\n\r\n\t    css: function(name, value) {\r\n\t        if (this.element) {\r\n\t            this.element.style[name] = value;\r\n\t        }\r\n\t    },\r\n\r\n\t    allCss: function(styles) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var i = 0; i < styles.length; i++) {\r\n\t            this$1.css(styles[i][0], styles[i][1]);\r\n\t        }\r\n\t    },\r\n\r\n\t    removeAttr: function(name) {\r\n\t        if (this.element) {\r\n\t            this.element.removeAttribute(name);\r\n\t        }\r\n\t    },\r\n\r\n\t    mapTransform: function(transform) {\r\n\t        var attrs = [];\r\n\t        if (transform) {\r\n\t            attrs.push([\r\n\t                TRANSFORM,\r\n\t                \"matrix(\" + transform.matrix().toString(6) + \")\"\r\n\t            ]);\r\n\t        }\r\n\r\n\t        return attrs;\r\n\t    },\r\n\r\n\t    renderTransform: function() {\r\n\t        return renderAllAttr(\r\n\t            this.mapTransform(this.srcElement.transform())\r\n\t        );\r\n\t    },\r\n\r\n\t    transformChange: function(value) {\r\n\t        if (value) {\r\n\t            this.allAttr(this.mapTransform(value));\r\n\t        } else {\r\n\t            this.removeAttr(TRANSFORM);\r\n\t        }\r\n\t    },\r\n\r\n\t    mapStyle: function() {\r\n\t        var options = this.srcElement.options;\r\n\t        var style = [ [ \"cursor\", options.cursor ] ];\r\n\r\n\t        if (options.visible === false) {\r\n\t            style.push([ \"display\", NONE ]);\r\n\t        }\r\n\r\n\t        return style;\r\n\t    },\r\n\r\n\t    renderStyle: function() {\r\n\t        return renderAttr(\"style\", renderStyle(this.mapStyle(true)));\r\n\t    },\r\n\r\n\t    renderOpacity: function() {\r\n\t        return renderAttr(\"opacity\", this.srcElement.options.opacity);\r\n\t    },\r\n\r\n\t    renderId: function() {\r\n\t        return renderAttr(\"id\", this.srcElement.options.id);\r\n\t    },\r\n\r\n\t    createDefinitions: function() {\r\n\t        var srcElement = this.srcElement;\r\n\t        var definitions = this.definitions;\r\n\t        if (srcElement) {\r\n\t            var options = srcElement.options;\r\n\t            var hasDefinitions;\r\n\r\n\t            for (var field in DefinitionMap) {\r\n\t                var definition = options.get(field);\r\n\t                if (definition && isDefinition(field, definition)) {\r\n\t                    definitions[field] = definition;\r\n\t                    hasDefinitions = true;\r\n\t                }\r\n\t            }\r\n\t            if (hasDefinitions) {\r\n\t                this.definitionChange({\r\n\t                    action: \"add\",\r\n\t                    definitions: definitions\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    definitionChange: function(e) {\r\n\t        if (this.parent) {\r\n\t            this.parent.definitionChange(e);\r\n\t        }\r\n\t    },\r\n\r\n\t    updateDefinition: function(type, value) {\r\n\t        var definitions = this.definitions;\r\n\t        var current = definitions[type];\r\n\t        var attr = DefinitionMap[type];\r\n\t        var definition = {};\r\n\t        if (current) {\r\n\t            definition[type] = current;\r\n\t            this.definitionChange({\r\n\t                action: \"remove\",\r\n\t                definitions: definition\r\n\t            });\r\n\t            delete definitions[type];\r\n\t        }\r\n\r\n\t        if (!value) {\r\n\t            if (current) {\r\n\t                this.removeAttr(attr);\r\n\t            }\r\n\t        } else {\r\n\t            definition[type] = value;\r\n\t            this.definitionChange({\r\n\t                action: \"add\",\r\n\t                definitions: definition\r\n\t            });\r\n\t            definitions[type] = value;\r\n\t            this.attr(attr, this.refUrl(value.id));\r\n\t        }\r\n\t    },\r\n\r\n\t    clearDefinitions: function() {\r\n\t        var definitions = this.definitions;\r\n\r\n\t        this.definitionChange({\r\n\t            action: \"remove\",\r\n\t            definitions: definitions\r\n\t        });\r\n\t        this.definitions = {};\r\n\t    },\r\n\r\n\t    renderDefinitions: function() {\r\n\t        return renderAllAttr(this.mapDefinitions());\r\n\t    },\r\n\r\n\t    mapDefinitions: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var definitions = this.definitions;\r\n\t        var attrs = [];\r\n\r\n\t        for (var field in definitions) {\r\n\t            attrs.push([ DefinitionMap[field], this$1.refUrl(definitions[field].id) ]);\r\n\t        }\r\n\r\n\t        return attrs;\r\n\t    },\r\n\r\n\t    refUrl: function(id) {\r\n\t        var skipBaseHref = (this.options || {}).skipBaseHref;\r\n\t        return refUrl(id, skipBaseHref);\r\n\t    }\r\n\t});\r\n\r\n\tvar GradientStopNode = Node.extend({\r\n\t    template: function() {\r\n\t        return (\"<stop \" + (this.renderOffset()) + \" \" + (this.renderStyle()) + \" />\");\r\n\t    },\r\n\r\n\t    renderOffset: function() {\r\n\t        return renderAttr(\"offset\", this.srcElement.offset());\r\n\t    },\r\n\r\n\t    mapStyle: function() {\r\n\t        var srcElement = this.srcElement;\r\n\t        return [\r\n\t            [ \"stop-color\", srcElement.color() ],\r\n\t            [ \"stop-opacity\", srcElement.opacity() ]\r\n\t        ];\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        if (e.field === \"offset\") {\r\n\t            this.attr(e.field, e.value);\r\n\t        } else if (e.field === \"color\" || e.field === \"opacity\") {\r\n\t            this.css(\"stop-\" + e.field, e.value);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar GradientNode = Node.extend({\r\n\t    init: function(srcElement) {\r\n\t        Node.fn.init.call(this, srcElement);\r\n\r\n\t        this.id = srcElement.id;\r\n\r\n\t        this.loadStops();\r\n\t    },\r\n\r\n\t    loadStops: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var stops = this.srcElement.stops;\r\n\t        var element = this.element;\r\n\r\n\t        for (var idx = 0; idx < stops.length; idx++) {\r\n\t            var stopNode = new GradientStopNode(stops[idx]);\r\n\t            this$1.append(stopNode);\r\n\t            if (element) {\r\n\t                stopNode.attachTo(element);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        if (e.field === \"gradient.stops\") {\r\n\t            BaseNode.prototype.clear.call(this);\r\n\t            this.loadStops();\r\n\t        } else if (e.field === \"gradient\") {\r\n\t            this.allAttr(this.mapCoordinates());\r\n\t        }\r\n\t    },\r\n\r\n\t    renderCoordinates: function() {\r\n\t        return renderAllAttr(this.mapCoordinates());\r\n\t    },\r\n\r\n\t    mapSpace: function() {\r\n\t        return [ \"gradientUnits\", this.srcElement.userSpace() ? \"userSpaceOnUse\" : \"objectBoundingBox\" ];\r\n\t    }\r\n\t});\r\n\r\n\tvar LinearGradientNode = GradientNode.extend({\r\n\t    template: function() {\r\n\t        return (\"<linearGradient id='\" + (this.id) + \"' \" + (this.renderCoordinates()) + \">\" + (this.renderChildren()) + \"</linearGradient>\");\r\n\t    },\r\n\r\n\t    mapCoordinates: function() {\r\n\t        var srcElement = this.srcElement;\r\n\t        var start = srcElement.start();\r\n\t        var end = srcElement.end();\r\n\t        var attrs = [\r\n\t            [ \"x1\", start.x ],\r\n\t            [ \"y1\", start.y ],\r\n\t            [ \"x2\", end.x ],\r\n\t            [ \"y2\", end.y ],\r\n\t            this.mapSpace()\r\n\t        ];\r\n\r\n\t        return attrs;\r\n\t    }\r\n\t});\r\n\r\n\tvar RadialGradientNode = GradientNode.extend({\r\n\t    template: function() {\r\n\t        return (\"<radialGradient id='\" + (this.id) + \"' \" + (this.renderCoordinates()) + \">\" + (this.renderChildren()) + \"</radialGradient>\");\r\n\t    },\r\n\r\n\t    mapCoordinates: function() {\r\n\t        var srcElement = this.srcElement;\r\n\t        var center = srcElement.center();\r\n\t        var radius = srcElement.radius();\r\n\t        var attrs = [\r\n\t            [ \"cx\", center.x ],\r\n\t            [ \"cy\", center.y ],\r\n\t            [ \"r\", radius ],\r\n\t            this.mapSpace()\r\n\t        ];\r\n\t        return attrs;\r\n\t    }\r\n\t});\r\n\r\n\tvar ClipNode = Node.extend({\r\n\t    init: function(srcElement) {\r\n\t        Node.fn.init.call(this);\r\n\r\n\t        this.srcElement = srcElement;\r\n\t        this.id = srcElement.id;\r\n\r\n\t        this.load([ srcElement ]);\r\n\t    },\r\n\r\n\t    template: function() {\r\n\t        return (\"<clipPath id='\" + (this.id) + \"'>\" + (this.renderChildren()) + \"</clipPath>\");\r\n\t    }\r\n\t});\r\n\r\n\tvar DefinitionNode = Node.extend({\r\n\t    init: function() {\r\n\t        Node.fn.init.call(this);\r\n\t        this.definitionMap = {};\r\n\t    },\r\n\r\n\t    attachTo: function(domElement) {\r\n\t        this.element = domElement;\r\n\t    },\r\n\r\n\t    template: function() {\r\n\t        return (\"<defs>\" + (this.renderChildren()) + \"</defs>\");\r\n\t    },\r\n\r\n\t    definitionChange: function(e) {\r\n\t        var definitions = e.definitions;\r\n\t        var action = e.action;\r\n\r\n\t        if (action === \"add\") {\r\n\t            this.addDefinitions(definitions);\r\n\t        } else if (action === \"remove\") {\r\n\t            this.removeDefinitions(definitions);\r\n\t        }\r\n\t    },\r\n\r\n\t    createDefinition: function(type, item) {\r\n\t        var nodeType;\r\n\t        if (type === \"clip\") {\r\n\t            nodeType = ClipNode;\r\n\t        } else if (type === \"fill\") {\r\n\t            if (item instanceof LinearGradient) {\r\n\t                nodeType = LinearGradientNode;\r\n\t            } else if (item instanceof RadialGradient) {\r\n\t                nodeType = RadialGradientNode;\r\n\t            }\r\n\t        }\r\n\t        return new nodeType(item);\r\n\t    },\r\n\r\n\t    addDefinitions: function(definitions) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var field in definitions) {\r\n\t            this$1.addDefinition(field, definitions[field]);\r\n\t        }\r\n\t    },\r\n\r\n\t    addDefinition: function(type, srcElement) {\r\n\t        var ref = this;\r\n\t        var element = ref.element;\r\n\t        var definitionMap = ref.definitionMap;\r\n\t        var id = srcElement.id;\r\n\t        var mapItem = definitionMap[id];\r\n\t        if (!mapItem) {\r\n\t            var node = this.createDefinition(type, srcElement);\r\n\t            definitionMap[id] = {\r\n\t                element: node,\r\n\t                count: 1\r\n\t            };\r\n\t            this.append(node);\r\n\t            if (element) {\r\n\t                node.attachTo(this.element);\r\n\t            }\r\n\t        } else {\r\n\t            mapItem.count++;\r\n\t        }\r\n\t    },\r\n\r\n\t    removeDefinitions: function(definitions) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var field in definitions) {\r\n\t            this$1.removeDefinition(definitions[field]);\r\n\t        }\r\n\t    },\r\n\r\n\t    removeDefinition: function(srcElement) {\r\n\t        var definitionMap = this.definitionMap;\r\n\t        var id = srcElement.id;\r\n\t        var mapItem = definitionMap[id];\r\n\r\n\t        if (mapItem) {\r\n\t            mapItem.count--;\r\n\t            if (mapItem.count === 0) {\r\n\t                this.remove(this.childNodes.indexOf(mapItem.element), 1);\r\n\t                delete definitionMap[id];\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar RootNode = Node.extend({\r\n\t    init: function(options) {\r\n\t        Node.fn.init.call(this);\r\n\t        this.options = options;\r\n\t        this.defs = new DefinitionNode();\r\n\t    },\r\n\r\n\t    attachTo: function(domElement) {\r\n\t        this.element = domElement;\r\n\t        this.defs.attachTo(domElement.firstElementChild);\r\n\t    },\r\n\r\n\t    clear: function() {\r\n\t        BaseNode.prototype.clear.call(this);\r\n\t    },\r\n\r\n\t    template: function() {\r\n\t        return this.defs.render() + this.renderChildren();\r\n\t    },\r\n\r\n\t    definitionChange: function(e) {\r\n\t        this.defs.definitionChange(e);\r\n\t    }\r\n\t});\r\n\r\n\tvar RTL = 'rtl';\r\n\r\n\tfunction alignToScreen(element) {\r\n\t    var ctm;\r\n\r\n\t    try {\r\n\t        ctm = element.getScreenCTM ? element.getScreenCTM() : null;\r\n\t    } catch (e) { } // eslint-disable-line no-empty\r\n\r\n\t    if (ctm) {\r\n\t        var left = - ctm.e % 1;\r\n\t        var top = - ctm.f % 1;\r\n\t        var style = element.style;\r\n\r\n\t        if (left !== 0 || top !== 0) {\r\n\t            style.left = left + \"px\";\r\n\t            style.top = top + \"px\";\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tvar Surface$1 = Surface.extend({\r\n\t    init: function(element, options) {\r\n\t        Surface.fn.init.call(this, element, options);\r\n\r\n\t        this._root = new RootNode($.extend({\r\n\t            rtl: elementStyles(element, 'direction').direction === RTL\r\n\t        }, this.options));\r\n\r\n\t        renderSVG$1(this.element, this._template());\r\n\r\n\t        this._rootElement = this.element.firstElementChild;\r\n\r\n\t        alignToScreen(this._rootElement);\r\n\r\n\t        this._root.attachTo(this._rootElement);\r\n\r\n\t        bindEvents(this.element, {\r\n\t            click: this._click,\r\n\t            mouseover: this._mouseenter,\r\n\t            mouseout: this._mouseleave,\r\n\t            mousemove: this._mousemove\r\n\t        });\r\n\r\n\t        this.resize();\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        if (this._root) {\r\n\t            this._root.destroy();\r\n\t            this._root = null;\r\n\t            this._rootElement = null;\r\n\t            unbindEvents(this.element, {\r\n\t                click: this._click,\r\n\t                mouseover: this._mouseenter,\r\n\t                mouseout: this._mouseleave,\r\n\t                mousemove: this._mousemove\r\n\t            });\r\n\t        }\r\n\r\n\t        Surface.fn.destroy.call(this);\r\n\t    },\r\n\r\n\t    translate: function(offset) {\r\n\t        var viewBox = (Math.round(offset.x)) + \" \" + (Math.round(offset.y)) + \" \" + (this._size.width) + \" \" + (this._size.height);\r\n\r\n\t        this._offset = offset;\r\n\t        this._rootElement.setAttribute(\"viewBox\", viewBox);\r\n\t    },\r\n\r\n\t    draw: function(element) {\r\n\t        Surface.fn.draw.call(this, element);\r\n\t        this._root.load([ element ]);\r\n\t    },\r\n\r\n\t    clear: function() {\r\n\t        Surface.fn.clear.call(this);\r\n\t        this._root.clear();\r\n\t    },\r\n\r\n\t    svg: function() {\r\n\t        return \"<?xml version='1.0' ?>\" + this._template();\r\n\t    },\r\n\r\n\t    exportVisual: function() {\r\n\t        var ref = this;\r\n\t        var visual = ref._visual;\r\n\t        var offset = ref._offset;\r\n\r\n\t        if (offset) {\r\n\t            var wrap = new Group();\r\n\t            wrap.children.push(visual);\r\n\r\n\t            wrap.transform(\r\n\t                transform().translate(-offset.x, -offset.y)\r\n\t            );\r\n\r\n\t            visual = wrap;\r\n\t        }\r\n\r\n\t        return visual;\r\n\t    },\r\n\r\n\t    _resize: function() {\r\n\t        if (this._offset) {\r\n\t            this.translate(this._offset);\r\n\t        }\r\n\t    },\r\n\r\n\t    _template: function() {\r\n\t        return (\"<svg style='width: 100%; height: 100%; overflow: hidden;' xmlns='\" + SVG_NS + \"' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>\" + (this._root.render()) + \"</svg>\");\r\n\t    }\r\n\t});\r\n\r\n\tSurface$1.prototype.type = \"svg\";\r\n\r\n\tif (typeof document !== \"undefined\" && document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\")) {\r\n\t    Surface.support.svg = true;\r\n\t    SurfaceFactory.current.register(\"svg\", Surface$1, 10);\r\n\t}\r\n\r\n\tvar GroupNode = Node.extend({\r\n\t    template: function() {\r\n\t        return (\"<g\" + (this.renderId() + this.renderTransform() + this.renderStyle() + this.renderOpacity() + this.renderDefinitions()) + \">\" + (this.renderChildren()) + \"</g>\");\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        if (e.field === \"transform\") {\r\n\t            this.transformChange(e.value);\r\n\t        }\r\n\r\n\t        Node.fn.optionsChange.call(this, e);\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP.Group = GroupNode;\r\n\r\n\tvar DASH_ARRAYS = {\r\n\t    dot: [ 1.5, 3.5 ],\r\n\t    dash: [ 4, 3.5 ],\r\n\t    longdash: [ 8, 3.5 ],\r\n\t    dashdot: [ 3.5, 3.5, 1.5, 3.5 ],\r\n\t    longdashdot: [ 8, 3.5, 1.5, 3.5 ],\r\n\t    longdashdotdot: [ 8, 3.5, 1.5, 3.5, 1.5, 3.5 ]\r\n\t};\r\n\r\n\tvar SOLID = \"solid\";\r\n\tvar BUTT = \"butt\";\r\n\r\n\tvar ATTRIBUTE_MAP = {\r\n\t    \"fill.opacity\": \"fill-opacity\",\r\n\t    \"stroke.color\": \"stroke\",\r\n\t    \"stroke.width\": \"stroke-width\",\r\n\t    \"stroke.opacity\": \"stroke-opacity\"\r\n\t};\r\n\tvar SPACE = \" \";\r\n\r\n\tvar PathNode = Node.extend({\r\n\t    geometryChange: function() {\r\n\t        this.attr(\"d\", this.renderData());\r\n\t        this.invalidate();\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        switch (e.field) {\r\n\t            case \"fill\":\r\n\t                if (e.value) {\r\n\t                    this.allAttr(this.mapFill(e.value));\r\n\t                } else {\r\n\t                    this.removeAttr(\"fill\");\r\n\t                }\r\n\t                break;\r\n\r\n\t            case \"fill.color\":\r\n\t                this.allAttr(this.mapFill({ color: e.value }));\r\n\t                break;\r\n\r\n\t            case \"stroke\":\r\n\t                if (e.value) {\r\n\t                    this.allAttr(this.mapStroke(e.value));\r\n\t                } else {\r\n\t                    this.removeAttr(\"stroke\");\r\n\t                }\r\n\t                break;\r\n\r\n\t            case \"transform\":\r\n\t                this.transformChange(e.value);\r\n\t                break;\r\n\r\n\t            default:\r\n\t                var name = ATTRIBUTE_MAP[e.field];\r\n\t                if (name) {\r\n\t                    this.attr(name, e.value);\r\n\t                }\r\n\t                break;\r\n\t        }\r\n\r\n\t        Node.fn.optionsChange.call(this, e);\r\n\t    },\r\n\r\n\t    content: function() {\r\n\t        if (this.element) {\r\n\t            this.element.textContent = this.srcElement.content();\r\n\t        }\r\n\t    },\r\n\r\n\t    renderData: function() {\r\n\t        return this.printPath(this.srcElement);\r\n\t    },\r\n\r\n\t    printPath: function(path) {\r\n\t        var this$1 = this;\r\n\r\n\t        var segments = path.segments;\r\n\t        var length = segments.length;\r\n\t        if (length > 0) {\r\n\t            var parts = [];\r\n\t            var output, currentType;\r\n\r\n\t            for (var i = 1; i < length; i++) {\r\n\t                var segmentType = this$1.segmentType(segments[i - 1], segments[i]);\r\n\t                if (segmentType !== currentType) {\r\n\t                    currentType = segmentType;\r\n\t                    parts.push(segmentType);\r\n\t                }\r\n\r\n\t                if (segmentType === \"L\") {\r\n\t                    parts.push(this$1.printPoints(segments[i].anchor()));\r\n\t                } else {\r\n\t                    parts.push(this$1.printPoints(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\r\n\t                }\r\n\t            }\r\n\r\n\t            output = \"M\" + this.printPoints(segments[0].anchor()) + SPACE + parts.join(SPACE);\r\n\t            if (path.options.closed) {\r\n\t                output += \"Z\";\r\n\t            }\r\n\r\n\t            return output;\r\n\t        }\r\n\t    },\r\n\r\n\t    printPoints: function() {\r\n\t        var points = arguments;\r\n\t        var length = points.length;\r\n\t        var result = [];\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            result.push(points[i].toString(3));\r\n\t        }\r\n\r\n\t        return result.join(\" \");\r\n\t    },\r\n\r\n\t    segmentType: function(segmentStart, segmentEnd) {\r\n\t        return segmentStart.controlOut() && segmentEnd.controlIn() ? \"C\" : \"L\";\r\n\t    },\r\n\r\n\t    mapStroke: function(stroke) {\r\n\t        var attrs = [];\r\n\r\n\t        if (stroke && !isTransparent(stroke.color)) {\r\n\t            attrs.push([ \"stroke\", stroke.color ]);\r\n\t            attrs.push([ \"stroke-width\", stroke.width ]);\r\n\t            attrs.push([ \"stroke-linecap\", this.renderLinecap(stroke) ]);\r\n\t            attrs.push([ \"stroke-linejoin\", stroke.lineJoin ]);\r\n\r\n\t            if (defined(stroke.opacity)) {\r\n\t                attrs.push([ \"stroke-opacity\", stroke.opacity ]);\r\n\t            }\r\n\r\n\t            if (defined(stroke.dashType)) {\r\n\t                attrs.push([ \"stroke-dasharray\", this.renderDashType(stroke) ]);\r\n\t            }\r\n\t        } else {\r\n\t            attrs.push([ \"stroke\", NONE ]);\r\n\t        }\r\n\r\n\t        return attrs;\r\n\t    },\r\n\r\n\t    renderStroke: function() {\r\n\t        return renderAllAttr(\r\n\t            this.mapStroke(this.srcElement.options.stroke)\r\n\t        );\r\n\t    },\r\n\r\n\t    renderDashType: function(stroke) {\r\n\t        var dashType = stroke.dashType;\r\n\t        var width = stroke.width; if (width === void 0) { width = 1; }\r\n\r\n\t        if (dashType && dashType !== SOLID) {\r\n\t            var dashArray = DASH_ARRAYS[dashType.toLowerCase()];\r\n\t            var result = [];\r\n\r\n\t            for (var i = 0; i < dashArray.length; i++) {\r\n\t                result.push(dashArray[i] * width);\r\n\t            }\r\n\r\n\t            return result.join(\" \");\r\n\t        }\r\n\t    },\r\n\r\n\t    renderLinecap: function(stroke) {\r\n\t        var dashType = stroke.dashType;\r\n\t        var lineCap = stroke.lineCap;\r\n\r\n\t        return (dashType && dashType !== \"solid\") ? BUTT : lineCap;\r\n\t    },\r\n\r\n\t    mapFill: function(fill) {\r\n\t        var attrs = [];\r\n\t        if (!(fill && fill.nodeType === \"Gradient\")) {\r\n\t            if (fill && !isTransparent(fill.color)) {\r\n\t                attrs.push([ \"fill\", fill.color ]);\r\n\r\n\t                if (defined(fill.opacity)) {\r\n\t                    attrs.push([ \"fill-opacity\", fill.opacity ]);\r\n\t                }\r\n\t            } else {\r\n\t                attrs.push([ \"fill\", NONE ]);\r\n\t            }\r\n\t        }\r\n\r\n\t        return attrs;\r\n\t    },\r\n\r\n\t    renderFill: function() {\r\n\t        return renderAllAttr(\r\n\t            this.mapFill(this.srcElement.options.fill)\r\n\t        );\r\n\t    },\r\n\r\n\t    template: function() {\r\n\t        return \"<path \" + (this.renderId()) + \" \" + (this.renderStyle()) + \" \" + (this.renderOpacity()) + \" \" + (renderAttr('d', this.renderData())) +\r\n\t                    \"\" + (this.renderStroke()) + (this.renderFill()) + (this.renderDefinitions()) + (this.renderTransform()) + \"></path>\";\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP.Path = PathNode;\r\n\r\n\tvar ArcNode = PathNode.extend({\r\n\t    renderData: function() {\r\n\t        return this.printPath(this.srcElement.toPath());\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP.Arc = ArcNode;\r\n\r\n\tvar CircleNode = PathNode.extend({\r\n\t    geometryChange: function() {\r\n\t        var center = this.center();\r\n\t        this.attr(\"cx\", center.x);\r\n\t        this.attr(\"cy\", center.y);\r\n\t        this.attr(\"r\", this.radius());\r\n\t        this.invalidate();\r\n\t    },\r\n\r\n\t    center: function() {\r\n\t        return this.srcElement.geometry().center;\r\n\t    },\r\n\r\n\t    radius: function() {\r\n\t        return this.srcElement.geometry().radius;\r\n\t    },\r\n\r\n\t    template: function() {\r\n\t        return \"<circle \" + (this.renderId()) + \" \" + (this.renderStyle()) + \" \" + (this.renderOpacity()) +\r\n\t                    \"cx='\" + (this.center().x) + \"' cy='\" + (this.center().y) + \"' r='\" + (this.radius()) + \"'\" +\r\n\t                    (this.renderStroke()) + \" \" + (this.renderFill()) + \" \" + (this.renderDefinitions()) +\r\n\t                    (this.renderTransform()) + \" ></circle>\";\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP.Circle = CircleNode;\r\n\r\n\tvar RectNode = PathNode.extend({\r\n\t    geometryChange: function() {\r\n\t        var geometry = this.srcElement.geometry();\r\n\t        this.attr(\"x\", geometry.origin.x);\r\n\t        this.attr(\"y\", geometry.origin.y);\r\n\t        this.attr(\"width\", geometry.size.width);\r\n\t        this.attr(\"height\", geometry.size.height);\r\n\t        this.invalidate();\r\n\t    },\r\n\r\n\t    size: function() {\r\n\t        return this.srcElement.geometry().size;\r\n\t    },\r\n\r\n\t    origin: function() {\r\n\t        return this.srcElement.geometry().origin;\r\n\t    },\r\n\r\n\t    template: function() {\r\n\t        return \"<rect \" + (this.renderId()) + \" \" + (this.renderStyle()) + \" \" + (this.renderOpacity()) + \" x='\" + (this.origin().x) + \"' y='\" + (this.origin().y) + \"' \" +\r\n\t                    \"width='\" + (this.size().width) + \"' height='\" + (this.size().height) + \"' \" + (this.renderStroke()) + \" \" +\r\n\t                    (this.renderFill()) + \" \" + (this.renderDefinitions()) + \" \" + (this.renderTransform()) + \" />\";\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP.Rect = RectNode;\r\n\r\n\tvar ImageNode = PathNode.extend({\r\n\t    geometryChange: function() {\r\n\t        this.allAttr(this.mapPosition());\r\n\t        this.invalidate();\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        if (e.field === \"src\") {\r\n\t            this.allAttr(this.mapSource());\r\n\t        }\r\n\r\n\t        PathNode.fn.optionsChange.call(this, e);\r\n\t    },\r\n\r\n\t    mapPosition: function() {\r\n\t        var rect = this.srcElement.rect();\r\n\t        var tl = rect.topLeft();\r\n\r\n\t        return [\r\n\t            [ \"x\", tl.x ],\r\n\t            [ \"y\", tl.y ],\r\n\t            [ \"width\", rect.width() + \"px\" ],\r\n\t            [ \"height\", rect.height() + \"px\" ]\r\n\t        ];\r\n\t    },\r\n\r\n\t    renderPosition: function() {\r\n\t        return renderAllAttr(this.mapPosition());\r\n\t    },\r\n\r\n\t    mapSource: function(encode) {\r\n\t        var src = this.srcElement.src();\r\n\r\n\t        if (encode) {\r\n\t            src = kendo.htmlEncode(src);\r\n\t        }\r\n\r\n\t        return [ [ \"xlink:href\", src ] ];\r\n\t    },\r\n\r\n\t    renderSource: function() {\r\n\t        return renderAllAttr(this.mapSource(true));\r\n\t    },\r\n\r\n\t    template: function() {\r\n\t        return \"<image preserveAspectRatio='none' \" + (this.renderId()) + \" \" + (this.renderStyle()) + \" \" + (this.renderTransform()) + \" \" + (this.renderOpacity()) +\r\n\t               (this.renderPosition()) + \" \" + (this.renderSource()) + \" \" + (this.renderDefinitions()) + \">\" +\r\n\t               \"</image>\";\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP.Image = ImageNode;\r\n\r\n\tvar ENTITY_REGEX = /&(?:[a-zA-Z]+|#\\d+);/g;\r\n\r\n\tfunction decodeEntities(text) {\r\n\t    if (!text || typeof text !== \"string\" || !ENTITY_REGEX.test(text)) {\r\n\t        return text;\r\n\t    }\r\n\r\n\t    var element = decodeEntities._element;\r\n\t    ENTITY_REGEX.lastIndex = 0;\r\n\r\n\t    return text.replace(ENTITY_REGEX, function (match) {\r\n\t        element.innerHTML = match;\r\n\r\n\t        return element.textContent || element.innerText;\r\n\t    });\r\n\t}\r\n\r\n\tif (typeof document !== \"undefined\") {\r\n\t    decodeEntities._element = document.createElement(\"span\");\r\n\t}\r\n\r\n\tvar TextNode = PathNode.extend({\r\n\t    geometryChange: function() {\r\n\t        var pos = this.pos();\r\n\t        this.attr(\"x\", pos.x);\r\n\t        this.attr(\"y\", pos.y);\r\n\t        this.invalidate();\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        if (e.field === \"font\") {\r\n\t            this.attr(\"style\", renderStyle(this.mapStyle()));\r\n\t            this.geometryChange();\r\n\t        } else if (e.field === \"content\") {\r\n\t            PathNode.fn.content.call(this, this.srcElement.content());\r\n\t        }\r\n\r\n\t        PathNode.fn.optionsChange.call(this, e);\r\n\t    },\r\n\r\n\t    mapStyle: function(encode) {\r\n\t        var style = PathNode.fn.mapStyle.call(this, encode);\r\n\t        var font = this.srcElement.options.font;\r\n\r\n\t        if (encode) {\r\n\t            font = kendo.htmlEncode(font);\r\n\t        }\r\n\r\n\t        style.push([ \"font\", font ], [ \"white-space\", \"pre\" ]);\r\n\r\n\t        return style;\r\n\t    },\r\n\r\n\t    pos: function() {\r\n\t        var pos = this.srcElement.position();\r\n\t        var size = this.srcElement.measure();\r\n\t        return pos.clone().setY(pos.y + size.baseline);\r\n\t    },\r\n\r\n\t    renderContent: function() {\r\n\t        var content = this.srcElement.content();\r\n\t        content = decodeEntities(content);\r\n\t        content = kendo.htmlEncode(content);\r\n\r\n\t        return kendoUtil.normalizeText(content);\r\n\t    },\r\n\r\n\t    renderTextAnchor: function() {\r\n\t        var anchor;\r\n\r\n\t        if ((this.options || {}).rtl && !(supportBrowser.msie || supportBrowser.edge)) {\r\n\t            anchor = 'end';\r\n\t        }\r\n\r\n\t        return renderAttr(\"text-anchor\", anchor);\r\n\t    },\r\n\r\n\t    template: function() {\r\n\t        return \"<text \" + (this.renderId()) + \" \" + (this.renderTextAnchor()) + \" \" + (this.renderStyle()) + \" \" + (this.renderOpacity()) +\r\n\t                    \"x='\" + (this.pos().x) + \"' y='\" + (this.pos().y) + \"' \" + (this.renderStroke()) + \" \" + (this.renderTransform()) + \" \" + (this.renderDefinitions()) +\r\n\t                    (this.renderFill()) + \">\" + (this.renderContent()) + \"</text>\";\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP.Text = TextNode;\r\n\r\n\tvar MultiPathNode = PathNode.extend({\r\n\t    renderData: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var paths = this.srcElement.paths;\r\n\r\n\t        if (paths.length > 0) {\r\n\t            var result = [];\r\n\r\n\t            for (var i = 0; i < paths.length; i++) {\r\n\t                result.push(this$1.printPath(paths[i]));\r\n\t            }\r\n\r\n\t            return result.join(\" \");\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP.MultiPath = MultiPathNode;\r\n\r\n\tvar geometry = {\r\n\t\tCircle: Circle$2,\r\n\t\tArc: Arc$2,\r\n\t\tRect: Rect,\r\n\t\tPoint: Point,\r\n\t\tSegment: Segment,\r\n\t\tMatrix: Matrix,\r\n\t\tSize: Size,\r\n\t\ttoMatrix: toMatrix,\r\n\t\tTransformation: Transformation,\r\n\t\ttransform: transform\r\n\t};\r\n\r\n\tfunction exportGroup(group) {\r\n\t    var root = new RootNode({\r\n\t        skipBaseHref: true\r\n\t    });\r\n\t    var bbox = group.clippedBBox();\r\n\t    var rootGroup = group;\r\n\r\n\t    if (bbox) {\r\n\t        var origin = bbox.getOrigin();\r\n\t        var exportRoot = new Group();\r\n\t        exportRoot.transform(transform().translate(-origin.x, -origin.y));\r\n\t        exportRoot.children.push(group);\r\n\t        rootGroup = exportRoot;\r\n\t    }\r\n\r\n\t    root.load([ rootGroup ]);\r\n\r\n\t    var svg = \"<?xml version='1.0' ?><svg xmlns='\" + SVG_NS + \"' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>\" + (root.render()) + \"</svg>\";\r\n\r\n\t    root.destroy();\r\n\r\n\t    return svg;\r\n\t}\r\n\r\n\tvar svg = {\r\n\t\tSurface: Surface$1,\r\n\t\tRootNode: RootNode,\r\n\t\tNode: Node,\r\n\t\tGroupNode: GroupNode,\r\n\t\tArcNode: ArcNode,\r\n\t\tCircleNode: CircleNode,\r\n\t\tRectNode: RectNode,\r\n\t\tImageNode: ImageNode,\r\n\t\tTextNode: TextNode,\r\n\t\tPathNode: PathNode,\r\n\t\tMultiPathNode: MultiPathNode,\r\n\t\tDefinitionNode: DefinitionNode,\r\n\t\tClipNode: ClipNode,\r\n\t\tGradientStopNode: GradientStopNode,\r\n\t\tLinearGradientNode: LinearGradientNode,\r\n\t\tRadialGradientNode: RadialGradientNode,\r\n\t\texportGroup: exportGroup\r\n\t};\r\n\r\n\tvar NODE_MAP$2 = {};\r\n\r\n\tfunction renderPath(ctx, path) {\r\n\t    var segments = path.segments;\r\n\r\n\t    if (segments.length === 0) {\r\n\t        return;\r\n\t    }\r\n\r\n\t    var segment = segments[0];\r\n\t    var anchor = segment.anchor();\r\n\t    ctx.moveTo(anchor.x, anchor.y);\r\n\r\n\t    for (var i = 1; i < segments.length; i++) {\r\n\t        segment = segments[i];\r\n\t        anchor = segment.anchor();\r\n\r\n\t        var prevSeg = segments[i - 1];\r\n\t        var prevOut = prevSeg.controlOut();\r\n\t        var controlIn = segment.controlIn();\r\n\r\n\t        if (prevOut && controlIn) {\r\n\t            ctx.bezierCurveTo(prevOut.x, prevOut.y,\r\n\t                              controlIn.x, controlIn.y,\r\n\t                              anchor.x, anchor.y);\r\n\t        } else {\r\n\t            ctx.lineTo(anchor.x, anchor.y);\r\n\t        }\r\n\t    }\r\n\r\n\t    if (path.options.closed) {\r\n\t        ctx.closePath();\r\n\t    }\r\n\t}\r\n\r\n\tvar Node$2 = BaseNode.extend({\r\n\t    init: function(srcElement) {\r\n\t        BaseNode.fn.init.call(this, srcElement);\r\n\t        if (srcElement) {\r\n\t            this.initClip();\r\n\t        }\r\n\t    },\r\n\r\n\t    initClip: function() {\r\n\t        var clip = this.srcElement.clip();\r\n\t        if (clip) {\r\n\t            this.clip = clip;\r\n\t            clip.addObserver(this);\r\n\t        }\r\n\t    },\r\n\r\n\t    clear: function() {\r\n\t        if (this.srcElement) {\r\n\t            this.srcElement.removeObserver(this);\r\n\t        }\r\n\r\n\t        this.clearClip();\r\n\r\n\t        BaseNode.fn.clear.call(this);\r\n\t    },\r\n\r\n\t    clearClip: function() {\r\n\t        if (this.clip) {\r\n\t            this.clip.removeObserver(this);\r\n\t            delete this.clip;\r\n\t        }\r\n\t    },\r\n\r\n\t    setClip: function(ctx) {\r\n\t        if (this.clip) {\r\n\t            ctx.beginPath();\r\n\t            renderPath(ctx, this.clip);\r\n\t            ctx.clip();\r\n\t        }\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        if (e.field === \"clip\") {\r\n\t            this.clearClip();\r\n\t            this.initClip();\r\n\t        }\r\n\r\n\t        BaseNode.fn.optionsChange.call(this, e);\r\n\t    },\r\n\r\n\t    setTransform: function(ctx) {\r\n\t        if (this.srcElement) {\r\n\t            var transform = this.srcElement.transform();\r\n\t            if (transform) {\r\n\t                ctx.transform.apply(ctx, transform.matrix().toArray(6));\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    loadElements: function(elements, pos, cors) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var i = 0; i < elements.length; i++) {\r\n\t            var srcElement = elements[i];\r\n\t            var children = srcElement.children;\r\n\r\n\t            var childNode = new NODE_MAP$2[srcElement.nodeType](srcElement, cors);\r\n\r\n\t            if (children && children.length > 0) {\r\n\t                childNode.load(children, pos, cors);\r\n\t            }\r\n\r\n\t            if (defined(pos)) {\r\n\t                this$1.insertAt(childNode, pos);\r\n\t            } else {\r\n\t                this$1.append(childNode);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    load: function(elements, pos, cors) {\r\n\t        this.loadElements(elements, pos, cors);\r\n\r\n\t        this.invalidate();\r\n\t    },\r\n\r\n\t    setOpacity: function(ctx) {\r\n\t        if (this.srcElement) {\r\n\t            var opacity = this.srcElement.opacity();\r\n\t            if (defined(opacity)) {\r\n\t                this.globalAlpha(ctx, opacity);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    globalAlpha: function(ctx, value) {\r\n\t        var opactity = value;\r\n\t        if (opactity && ctx.globalAlpha) {\r\n\t            opactity *= ctx.globalAlpha;\r\n\t        }\r\n\t        ctx.globalAlpha = opactity;\r\n\t    },\r\n\r\n\t    visible: function() {\r\n\t        var src = this.srcElement;\r\n\t        return !src || (src && src.options.visible !== false);\r\n\t    }\r\n\t});\r\n\r\n\tvar GroupNode$2 = Node$2.extend({\r\n\t    renderTo: function(ctx) {\r\n\t        if (!this.visible()) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        ctx.save();\r\n\r\n\t        this.setTransform(ctx);\r\n\t        this.setClip(ctx);\r\n\t        this.setOpacity(ctx);\r\n\r\n\t        var childNodes = this.childNodes;\r\n\t        for (var i = 0; i < childNodes.length; i++) {\r\n\t            var child = childNodes[i];\r\n\t            if (child.visible()) {\r\n\t                child.renderTo(ctx);\r\n\t            }\r\n\t        }\r\n\r\n\t        ctx.restore();\r\n\t    }\r\n\t});\r\n\r\n\tTraversable.extend(GroupNode$2.prototype, \"childNodes\");\r\n\r\n\tNODE_MAP$2.Group = GroupNode$2;\r\n\r\n\tvar FRAME_DELAY = 1000 / 60;\r\n\r\n\tvar RootNode$2 = GroupNode$2.extend({\r\n\t    init: function(canvas) {\r\n\t        GroupNode$2.fn.init.call(this);\r\n\r\n\t        this.canvas = canvas;\r\n\t        this.ctx = canvas.getContext(\"2d\");\r\n\r\n\t        var invalidateHandler = this._invalidate.bind(this);\r\n\t        this.invalidate = kendo.throttle(function () {\r\n\t            kendo.animationFrame(invalidateHandler);\r\n\t        }, FRAME_DELAY);\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        GroupNode$2.fn.destroy.call(this);\r\n\t        this.canvas = null;\r\n\t        this.ctx = null;\r\n\t    },\r\n\r\n\t    load: function(elements, pos, cors) {\r\n\t        this.loadElements(elements, pos, cors);\r\n\t        this._invalidate();\r\n\t    },\r\n\r\n\t    _invalidate: function() {\r\n\t        if (!this.ctx) {\r\n\t            return;\r\n\t        }\r\n\t        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\r\n\t        this.renderTo(this.ctx);\r\n\t    }\r\n\t});\r\n\r\n\tTraversable.extend(RootNode$2.prototype, \"childNodes\");\r\n\r\n\tvar QuadRoot = Class.extend({\r\n\t    init: function() {\r\n\r\n\t        this.shapes = [];\r\n\t    },\r\n\r\n\t    _add: function(shape, bbox) {\r\n\t        this.shapes.push({\r\n\t            bbox: bbox,\r\n\t            shape: shape\r\n\t        });\r\n\t        shape._quadNode = this;\r\n\t    },\r\n\r\n\t    pointShapes: function(point) {\r\n\t        var shapes = this.shapes;\r\n\t        var length = shapes.length;\r\n\t        var result = [];\r\n\t        for (var idx = 0; idx < length; idx++) {\r\n\t            if (shapes[idx].bbox.containsPoint(point)) {\r\n\t                result.push(shapes[idx].shape);\r\n\t            }\r\n\t        }\r\n\t        return result;\r\n\t    },\r\n\r\n\t    insert: function(shape, bbox) {\r\n\t        this._add(shape, bbox);\r\n\t    },\r\n\r\n\t    remove: function(shape) {\r\n\t        var shapes = this.shapes;\r\n\t        var length = shapes.length;\r\n\r\n\t        for (var idx = 0; idx < length; idx++) {\r\n\t            if (shapes[idx].shape === shape) {\r\n\t                shapes.splice(idx, 1);\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar QuadNode = QuadRoot.extend({\r\n\t    init: function(rect) {\r\n\t        QuadRoot.fn.init.call(this);\r\n\t        this.children = [];\r\n\t        this.rect = rect;\r\n\t    },\r\n\r\n\t    inBounds: function(rect) {\r\n\t        var nodeRect = this.rect;\r\n\t        var nodeBottomRight = nodeRect.bottomRight();\r\n\t        var bottomRight = rect.bottomRight();\r\n\t        var inBounds = nodeRect.origin.x <= rect.origin.x && nodeRect.origin.y <= rect.origin.y && bottomRight.x <= nodeBottomRight.x &&\r\n\t            bottomRight.y <= nodeBottomRight.y;\r\n\t        return inBounds;\r\n\t    },\r\n\r\n\t    pointShapes: function(point) {\r\n\t        var children = this.children;\r\n\t        var length = children.length;\r\n\t        var result = QuadRoot.fn.pointShapes.call(this, point);\r\n\t        for (var idx = 0; idx < length; idx++) {\r\n\t            append(result, children[idx].pointShapes(point));\r\n\t        }\r\n\t        return result;\r\n\t    },\r\n\r\n\t    insert: function(shape, bbox) {\r\n\t        var children = this.children;\r\n\t        var inserted = false;\r\n\r\n\t        if (this.inBounds(bbox)) {\r\n\t            if (this.shapes.length < 4) {\r\n\t                this._add(shape, bbox);\r\n\t            } else {\r\n\t                if (!children.length) {\r\n\t                    this._initChildren();\r\n\t                }\r\n\r\n\t                for (var idx = 0; idx < children.length; idx++) {\r\n\t                    if (children[idx].insert(shape, bbox)) {\r\n\t                        inserted = true;\r\n\t                        break;\r\n\t                    }\r\n\t                }\r\n\r\n\t                if (!inserted) {\r\n\t                    this._add(shape, bbox);\r\n\t                }\r\n\t            }\r\n\t            inserted = true;\r\n\t        }\r\n\r\n\t        return inserted;\r\n\t    },\r\n\r\n\t    _initChildren: function() {\r\n\t        var ref = this;\r\n\t        var rect = ref.rect;\r\n\t        var children = ref.children;\r\n\t        var center = rect.center();\r\n\t        var halfWidth = rect.width() / 2;\r\n\t        var halfHeight = rect.height() / 2;\r\n\r\n\t        children.push(\r\n\t            new QuadNode(new Rect([ rect.origin.x, rect.origin.y ], [ halfWidth, halfHeight ])),\r\n\t            new QuadNode(new Rect([ center.x, rect.origin.y ], [ halfWidth, halfHeight ])),\r\n\t            new QuadNode(new Rect([ rect.origin.x, center.y ], [ halfWidth, halfHeight ])),\r\n\t            new QuadNode(new Rect([ center.x, center.y ], [ halfWidth, halfHeight ]))\r\n\t        );\r\n\t    }\r\n\t});\r\n\r\n\tvar ROOT_SIZE = 3000;\r\n\tvar LEVEL_STEP = 10000;\r\n\tvar MAX_LEVEL = 75;\r\n\r\n\tvar ShapesQuadTree = Class.extend({\r\n\t    init: function() {\r\n\r\n\t        this.initRoots();\r\n\t    },\r\n\r\n\t    initRoots: function() {\r\n\t        this.rootMap = {};\r\n\t        this.root = new QuadRoot();\r\n\t        this.rootElements = [];\r\n\t    },\r\n\r\n\t    clear: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var rootElements = this.rootElements;\r\n\t        for (var idx = 0; idx < rootElements.length; idx++) {\r\n\t            this$1.remove(rootElements[idx]);\r\n\t        }\r\n\t        this.initRoots();\r\n\t    },\r\n\r\n\t    pointShape: function(point) {\r\n\t        var sectorRoot = ( this.rootMap[ Math.floor( point.x / ROOT_SIZE ) ] || {} )[ Math.floor( point.y / ROOT_SIZE ) ];\r\n\t        var result = this.root.pointShapes(point);\r\n\r\n\t        if (sectorRoot) {\r\n\t            result = result.concat(sectorRoot.pointShapes(point));\r\n\t        }\r\n\r\n\t        this.assignZindex(result);\r\n\r\n\t        result.sort(zIndexComparer);\r\n\t        for (var idx = 0; idx < result.length; idx++) {\r\n\t            if (result[idx].containsPoint(point)) {\r\n\t                return result[idx];\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    assignZindex: function(elements) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var idx = 0; idx < elements.length; idx++) {\r\n\t            var element = elements[idx];\r\n\t            var zIndex = 0;\r\n\t            var levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);\r\n\t            var parents = [];\r\n\r\n\t            while (element) {\r\n\t                parents.push(element);\r\n\t                element = element.parent;\r\n\t            }\r\n\r\n\t            while (parents.length) {\r\n\t                element = parents.pop();\r\n\t                zIndex += ((element.parent ? element.parent.children : this$1.rootElements).indexOf(element) + 1) * levelWeight;\r\n\t                levelWeight /= LEVEL_STEP;\r\n\t            }\r\n\r\n\t            elements[idx]._zIndex = zIndex;\r\n\t        }\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        if (e.field === \"transform\" || e.field === \"stroke.width\") {\r\n\t            this.bboxChange(e.element);\r\n\t        }\r\n\t    },\r\n\r\n\t    geometryChange: function(e) {\r\n\t        this.bboxChange(e.element);\r\n\t    },\r\n\r\n\t    bboxChange: function(element) {\r\n\t        var this$1 = this;\r\n\r\n\t        if (element.nodeType === \"Group\") {\r\n\t            for (var idx = 0; idx < element.children.length; idx++) {\r\n\t                this$1.bboxChange(element.children[idx]);\r\n\t            }\r\n\t        } else {\r\n\t            if (element._quadNode) {\r\n\t                element._quadNode.remove(element);\r\n\t            }\r\n\t            this._insertShape(element);\r\n\t        }\r\n\t    },\r\n\r\n\t    add: function(elements) {\r\n\t        var elementsArray = Array.isArray(elements) ? elements.slice(0) : [ elements ];\r\n\r\n\t        append(this.rootElements, elementsArray);\r\n\t        this._insert(elementsArray);\r\n\t    },\r\n\r\n\t    childrenChange: function(e) {\r\n\t        var this$1 = this;\r\n\r\n\t        if (e.action === \"remove\") {\r\n\t            for (var idx = 0; idx < e.items.length; idx++) {\r\n\t                this$1.remove(e.items[idx]);\r\n\t            }\r\n\t        } else {\r\n\t            this._insert(Array.prototype.slice.call(e.items, 0));\r\n\t        }\r\n\t    },\r\n\r\n\t    _insert: function(elements) {\r\n\t        var this$1 = this;\r\n\r\n\t        var element;\r\n\r\n\t        while (elements.length > 0) {\r\n\t            element = elements.pop();\r\n\t            element.addObserver(this$1);\r\n\t            if (element.nodeType === \"Group\") {\r\n\t                append(elements, element.children);\r\n\t            } else {\r\n\t                this$1._insertShape(element);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _insertShape: function(shape) {\r\n\t        var bbox = shape.bbox();\r\n\t        if (bbox) {\r\n\t            var sectors = this.getSectors(bbox);\r\n\t            var x = sectors[0][0];\r\n\t            var y = sectors[1][0];\r\n\r\n\t            if (this.inRoot(sectors)) {\r\n\t                this.root.insert(shape, bbox);\r\n\t            } else {\r\n\t                var rootMap = this.rootMap;\r\n\t                if (!rootMap[x]) {\r\n\t                    rootMap[x] = {};\r\n\t                }\r\n\r\n\t                if (!rootMap[x][y]) {\r\n\t                    rootMap[x][y] = new QuadNode(\r\n\t                        new Rect([ x * ROOT_SIZE, y * ROOT_SIZE ], [ ROOT_SIZE, ROOT_SIZE ])\r\n\t                    );\r\n\t                }\r\n\r\n\t                rootMap[x][y].insert(shape, bbox);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    remove: function(element) {\r\n\t        var this$1 = this;\r\n\r\n\t        element.removeObserver(this);\r\n\r\n\t        if (element.nodeType === \"Group\") {\r\n\t            var children = element.children;\r\n\t            for (var idx = 0; idx < children.length; idx++) {\r\n\t                this$1.remove(children[idx]);\r\n\t            }\r\n\t        } else if (element._quadNode) {\r\n\t            element._quadNode.remove(element);\r\n\t            delete element._quadNode;\r\n\t        }\r\n\t    },\r\n\r\n\t    inRoot: function(sectors) {\r\n\t        return sectors[0].length > 1 || sectors[1].length > 1;\r\n\t    },\r\n\r\n\t    getSectors: function(rect) {\r\n\t        var bottomRight = rect.bottomRight();\r\n\t        var bottomX = Math.floor(bottomRight.x / ROOT_SIZE);\r\n\t        var bottomY = Math.floor(bottomRight.y / ROOT_SIZE);\r\n\t        var sectors = [ [], [] ];\r\n\t        for (var x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {\r\n\t            sectors[0].push(x);\r\n\t        }\r\n\t        for (var y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {\r\n\t            sectors[1].push(y);\r\n\t        }\r\n\t        return sectors;\r\n\t    }\r\n\t});\r\n\r\n\tfunction zIndexComparer(x1, x2) {\r\n\t    if (x1._zIndex < x2._zIndex) {\r\n\t        return 1;\r\n\t    }\r\n\t    if (x1._zIndex > x2._zIndex) {\r\n\t        return -1;\r\n\t    }\r\n\r\n\t    return 0;\r\n\t}\r\n\r\n\tvar SurfaceCursor = Class.extend({\r\n\t    init: function(surface) {\r\n\t        surface.bind(\"mouseenter\", this._mouseenter.bind(this));\r\n\t        surface.bind(\"mouseleave\", this._mouseleave.bind(this));\r\n\r\n\t        this.element = surface.element;\r\n\t    },\r\n\r\n\t    clear: function() {\r\n\t        this._resetCursor();\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        this._resetCursor();\r\n\t        delete this.element;\r\n\t    },\r\n\r\n\t    _mouseenter: function(e) {\r\n\t        var cursor = this._shapeCursor(e);\r\n\r\n\t        if (!cursor) {\r\n\t            this._resetCursor();\r\n\t        } else {\r\n\t            if (!this._current) {\r\n\t                this._defaultCursor = this._getCursor();\r\n\t            }\r\n\r\n\t            this._setCursor(cursor);\r\n\t        }\r\n\t    },\r\n\r\n\t    _mouseleave: function() {\r\n\t        this._resetCursor();\r\n\t    },\r\n\r\n\t    _shapeCursor: function(e) {\r\n\t        var shape = e.element;\r\n\r\n\t        while (shape && !defined(shape.options.cursor)) {\r\n\t            shape = shape.parent;\r\n\t        }\r\n\r\n\t        if (shape) {\r\n\t            return shape.options.cursor;\r\n\t        }\r\n\t    },\r\n\r\n\t    _getCursor: function() {\r\n\t        if (this.element) {\r\n\t            return this.element.style.cursor;\r\n\t        }\r\n\t    },\r\n\r\n\t    _setCursor: function(cursor) {\r\n\t        if (this.element) {\r\n\t            this.element.style.cursor = cursor;\r\n\t            this._current = cursor;\r\n\t        }\r\n\t    },\r\n\r\n\t    _resetCursor: function() {\r\n\t        if (this._current) {\r\n\t            this._setCursor(this._defaultCursor || \"\");\r\n\t            delete this._current;\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar Surface$3 = Surface.extend({\r\n\t    init: function(element, options) {\r\n\t        Surface.fn.init.call(this, element, options);\r\n\r\n\t        this.element.innerHTML = this._template(this);\r\n\r\n\t        var canvas = this.element.firstElementChild;\r\n\t        var size = elementSize(element);\r\n\r\n\t        canvas.width = size.width;\r\n\t        canvas.height = size.height;\r\n\r\n\t        this._rootElement = canvas;\r\n\r\n\t        this._root = new RootNode$2(canvas);\r\n\r\n\t        this._mouseTrackHandler = this._trackMouse.bind(this);\r\n\r\n\t        bindEvents(this.element, {\r\n\t            click: this._mouseTrackHandler,\r\n\t            mousemove: this._mouseTrackHandler\r\n\t        });\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        Surface.fn.destroy.call(this);\r\n\r\n\t        if (this._root) {\r\n\t            this._root.destroy();\r\n\t            this._root = null;\r\n\t        }\r\n\r\n\t        if (this._searchTree) {\r\n\t            this._searchTree.clear();\r\n\t            delete this._searchTree;\r\n\t        }\r\n\r\n\t        if (this._cursor) {\r\n\t            this._cursor.destroy();\r\n\t            delete this._cursor;\r\n\t        }\r\n\r\n\t        unbindEvents(this.element, {\r\n\t            click: this._mouseTrackHandler,\r\n\t            mousemove: this._mouseTrackHandler\r\n\t        });\r\n\t    },\r\n\r\n\t    draw: function(element) {\r\n\t        Surface.fn.draw.call(this, element);\r\n\t        this._root.load([ element ], undefined, this.options.cors);\r\n\r\n\t        if (this._searchTree) {\r\n\t            this._searchTree.add([ element ]);\r\n\t        }\r\n\t    },\r\n\r\n\t    clear: function() {\r\n\t        Surface.fn.clear.call(this);\r\n\t        this._root.clear();\r\n\r\n\t        if (this._searchTree) {\r\n\t            this._searchTree.clear();\r\n\t        }\r\n\r\n\t        if (this._cursor) {\r\n\t            this._cursor.clear();\r\n\t        }\r\n\t    },\r\n\r\n\t    eventTarget: function(e) {\r\n\t        if (this._searchTree) {\r\n\t            var point = this._surfacePoint(e);\r\n\t            var shape = this._searchTree.pointShape(point);\r\n\t            return shape;\r\n\t        }\r\n\t    },\r\n\r\n\t    image: function() {\r\n\t        var ref = this;\r\n\t        var root = ref._root;\r\n\t        var rootElement = ref._rootElement;\r\n\t        var loadingStates = [];\r\n\r\n\t        root.traverse(function (childNode) {\r\n\t            if (childNode.loading) {\r\n\t                loadingStates.push(childNode.loading);\r\n\t            }\r\n\t        });\r\n\r\n\t        var promise = createPromise();\r\n\t        var resolveDataURL = function () {\r\n\t            root._invalidate();\r\n\r\n\t            try {\r\n\t                var data = rootElement.toDataURL();\r\n\t                promise.resolve(data);\r\n\t            } catch (e) {\r\n\t                promise.reject(e);\r\n\t            }\r\n\t        };\r\n\r\n\t        promiseAll(loadingStates).then(resolveDataURL, resolveDataURL);\r\n\r\n\t        return promise;\r\n\t    },\r\n\r\n\t    suspendTracking: function() {\r\n\t        Surface.fn.suspendTracking.call(this);\r\n\t        if (this._searchTree) {\r\n\t            this._searchTree.clear();\r\n\t            delete this._searchTree;\r\n\t        }\r\n\t    },\r\n\r\n\t    resumeTracking: function() {\r\n\t        Surface.fn.resumeTracking.call(this);\r\n\t        if (!this._searchTree) {\r\n\t            this._searchTree = new ShapesQuadTree();\r\n\r\n\t            var childNodes = this._root.childNodes;\r\n\t            var rootElements = [];\r\n\t            for (var idx = 0; idx < childNodes.length; idx++) {\r\n\t                rootElements.push(childNodes[idx].srcElement);\r\n\t            }\r\n\t            this._searchTree.add(rootElements);\r\n\t        }\r\n\t    },\r\n\r\n\t    _resize: function() {\r\n\t        this._rootElement.width = this._size.width;\r\n\t        this._rootElement.height = this._size.height;\r\n\r\n\t        this._root.invalidate();\r\n\t    },\r\n\r\n\t    _template: function() {\r\n\t        return \"<canvas style='width: 100%; height: 100%;'></canvas>\";\r\n\t    },\r\n\r\n\t    _enableTracking: function() {\r\n\t        this._searchTree = new ShapesQuadTree();\r\n\t        this._cursor = new SurfaceCursor(this);\r\n\r\n\t        Surface.fn._enableTracking.call(this);\r\n\t    },\r\n\r\n\t    _trackMouse: function(e) {\r\n\t        if (this._suspendedTracking) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var shape = this.eventTarget(e);\r\n\r\n\t        if (e.type !== \"click\") {\r\n\t            var currentShape = this._currentShape;\r\n\t            if (currentShape && currentShape !== shape) {\r\n\t                this.trigger(\"mouseleave\", {\r\n\t                    element: currentShape,\r\n\t                    originalEvent: e,\r\n\t                    type: \"mouseleave\"\r\n\t                });\r\n\t            }\r\n\r\n\t            if (shape && currentShape !== shape) {\r\n\t                this.trigger(\"mouseenter\", {\r\n\t                    element: shape,\r\n\t                    originalEvent: e,\r\n\t                    type: \"mouseenter\"\r\n\t                });\r\n\t            }\r\n\r\n\t            this.trigger(\"mousemove\", {\r\n\t                element: shape,\r\n\t                originalEvent: e,\r\n\t                type: \"mousemove\"\r\n\t            });\r\n\r\n\t            this._currentShape = shape;\r\n\t        } else if (shape) {\r\n\t            this.trigger(\"click\", {\r\n\t                element: shape,\r\n\t                originalEvent: e,\r\n\t                type: \"click\"\r\n\t            });\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tSurface$3.prototype.type = \"canvas\";\r\n\r\n\tif (typeof document !== \"undefined\" && document.createElement(\"canvas\").getContext) {\r\n\t    Surface.support.canvas = true;\r\n\t    SurfaceFactory.current.register(\"canvas\", Surface$3, 20);\r\n\t}\r\n\r\n\tfunction addGradientStops(gradient, stops) {\r\n\t    for (var idx = 0; idx < stops.length; idx++) {\r\n\t        var stop = stops[idx];\r\n\t        var color = kendo.parseColor(stop.color());\r\n\r\n\t        color.a *= stop.opacity();\r\n\r\n\t        gradient.addColorStop(stop.offset(), color.toCssRgba());\r\n\t    }\r\n\t}\r\n\r\n\tvar PathNode$2 = Node$2.extend({\r\n\t    renderTo: function(ctx) {\r\n\t        ctx.save();\r\n\r\n\t        this.setTransform(ctx);\r\n\t        this.setClip(ctx);\r\n\t        this.setOpacity(ctx);\r\n\r\n\t        ctx.beginPath();\r\n\r\n\t        this.renderPoints(ctx, this.srcElement);\r\n\r\n\t        this.setLineDash(ctx);\r\n\t        this.setLineCap(ctx);\r\n\t        this.setLineJoin(ctx);\r\n\r\n\t        this.setFill(ctx);\r\n\t        this.setStroke(ctx);\r\n\r\n\t        ctx.restore();\r\n\t    },\r\n\r\n\t    setFill: function(ctx) {\r\n\t        var fill = this.srcElement.options.fill;\r\n\t        var hasFill = false;\r\n\r\n\t        if (fill) {\r\n\t            if (fill.nodeType === \"Gradient\") {\r\n\t                this.setGradientFill(ctx, fill);\r\n\t                hasFill = true;\r\n\t            } else if (!isTransparent(fill.color)) {\r\n\t                ctx.fillStyle = fill.color;\r\n\r\n\t                ctx.save();\r\n\t                this.globalAlpha(ctx, fill.opacity);\r\n\t                ctx.fill();\r\n\t                ctx.restore();\r\n\r\n\t                hasFill = true;\r\n\t            }\r\n\t        }\r\n\r\n\t        return hasFill;\r\n\t    },\r\n\r\n\t    setGradientFill: function(ctx, fill) {\r\n\t        var bbox = this.srcElement.rawBBox();\r\n\t        var gradient;\r\n\r\n\t        if (fill instanceof LinearGradient) {\r\n\t            var start = fill.start();\r\n\t            var end = fill.end();\r\n\t            gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\r\n\t        } else if (fill instanceof RadialGradient) {\r\n\t            var center = fill.center();\r\n\t            gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());\r\n\t        }\r\n\r\n\t        addGradientStops(gradient, fill.stops);\r\n\r\n\t        ctx.save();\r\n\r\n\t        if (!fill.userSpace()) {\r\n\t            ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);\r\n\t        }\r\n\t        ctx.fillStyle = gradient;\r\n\t        ctx.fill();\r\n\r\n\t        ctx.restore();\r\n\t    },\r\n\r\n\t    setStroke: function(ctx) {\r\n\t        var stroke = this.srcElement.options.stroke;\r\n\t        if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {\r\n\t            ctx.strokeStyle = stroke.color;\r\n\t            ctx.lineWidth = valueOrDefault(stroke.width, 1);\r\n\r\n\t            ctx.save();\r\n\t            this.globalAlpha(ctx, stroke.opacity);\r\n\t            ctx.stroke();\r\n\t            ctx.restore();\r\n\r\n\t            return true;\r\n\t        }\r\n\t    },\r\n\r\n\t    dashType: function() {\r\n\t        var stroke = this.srcElement.options.stroke;\r\n\t        if (stroke && stroke.dashType) {\r\n\t            return stroke.dashType.toLowerCase();\r\n\t        }\r\n\t    },\r\n\r\n\t    setLineDash: function(ctx) {\r\n\t        var dashType = this.dashType();\r\n\t        if (dashType && dashType !== SOLID) {\r\n\t            var dashArray = DASH_ARRAYS[dashType];\r\n\t            if (ctx.setLineDash) {\r\n\t                ctx.setLineDash(dashArray);\r\n\t            } else {\r\n\t                ctx.mozDash = dashArray;\r\n\t                ctx.webkitLineDash = dashArray;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    setLineCap: function(ctx) {\r\n\t        var dashType = this.dashType();\r\n\t        var stroke = this.srcElement.options.stroke;\r\n\t        if (dashType && dashType !== SOLID) {\r\n\t            ctx.lineCap = BUTT;\r\n\t        } else if (stroke && stroke.lineCap) {\r\n\t            ctx.lineCap = stroke.lineCap;\r\n\t        }\r\n\t    },\r\n\r\n\t    setLineJoin: function(ctx) {\r\n\t        var stroke = this.srcElement.options.stroke;\r\n\t        if (stroke && stroke.lineJoin) {\r\n\t            ctx.lineJoin = stroke.lineJoin;\r\n\t        }\r\n\t    },\r\n\r\n\t    renderPoints: function(ctx, path) {\r\n\t        renderPath(ctx, path);\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP$2.Path = PathNode$2;\r\n\r\n\tvar ArcNode$2 = PathNode$2.extend({\r\n\t    renderPoints: function(ctx) {\r\n\t        var path = this.srcElement.toPath();\r\n\t        renderPath(ctx, path);\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP$2.Arc = ArcNode$2;\r\n\r\n\tvar CircleNode$2 = PathNode$2.extend({\r\n\t    renderPoints: function(ctx) {\r\n\t        var ref = this.srcElement.geometry();\r\n\t        var center = ref.center;\r\n\t        var radius = ref.radius;\r\n\r\n\t        ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP$2.Circle = CircleNode$2;\r\n\r\n\tvar RectNode$2 = PathNode$2.extend({\r\n\t    renderPoints: function(ctx) {\r\n\t        var ref = this.srcElement.geometry();\r\n\t        var origin = ref.origin;\r\n\t        var size = ref.size;\r\n\r\n\t        ctx.rect(origin.x, origin.y, size.width, size.height);\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP$2.Rect = RectNode$2;\r\n\r\n\tvar ImageNode$2 = PathNode$2.extend({\r\n\t    init: function(srcElement, cors) {\r\n\t        PathNode$2.fn.init.call(this, srcElement);\r\n\r\n\t        this.onLoad = this.onLoad.bind(this);\r\n\t        this.onError = this.onError.bind(this);\r\n\r\n\t        this.loading = createPromise();\r\n\r\n\t        var img = this.img = new Image();\r\n\r\n\t        if (cors && !(/^data:/i.test(srcElement.src()))) {\r\n\t            img.crossOrigin = cors;\r\n\t        }\r\n\r\n\t        img.src = srcElement.src();\r\n\r\n\t        if (img.complete) {\r\n\t            this.onLoad();\r\n\t        } else {\r\n\t            img.onload = this.onLoad;\r\n\t            img.onerror = this.onError;\r\n\t        }\r\n\t    },\r\n\r\n\t    renderTo: function(ctx) {\r\n\t        if (this.loading.state() === \"resolved\") {\r\n\t            ctx.save();\r\n\r\n\t            this.setTransform(ctx);\r\n\t            this.setClip(ctx);\r\n\r\n\t            this.drawImage(ctx);\r\n\r\n\t            ctx.restore();\r\n\t        }\r\n\t    },\r\n\r\n\t    optionsChange: function(e) {\r\n\t        if (e.field === \"src\") {\r\n\t            this.loading = createPromise();\r\n\t            this.img.src = this.srcElement.src();\r\n\t        } else {\r\n\t            PathNode$2.fn.optionsChange.call(this, e);\r\n\t        }\r\n\t    },\r\n\r\n\t    onLoad: function() {\r\n\t        this.loading.resolve();\r\n\t        this.invalidate();\r\n\t    },\r\n\r\n\t    onError: function() {\r\n\t        this.loading.reject(new Error(\r\n\t            \"Unable to load image '\" + this.img.src +\r\n\t            \"'. Check for connectivity and verify CORS headers.\"\r\n\t        ));\r\n\t    },\r\n\r\n\t    drawImage: function(ctx) {\r\n\t        var rect = this.srcElement.rect();\r\n\t        var topLeft = rect.topLeft();\r\n\r\n\t        ctx.drawImage(\r\n\t            this.img, topLeft.x, topLeft.y, rect.width(), rect.height()\r\n\t        );\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP$2.Image = ImageNode$2;\r\n\r\n\tvar TextNode$2 = PathNode$2.extend({\r\n\t    renderTo: function(ctx) {\r\n\t        var text = this.srcElement;\r\n\t        var pos = text.position();\r\n\t        var size = text.measure();\r\n\r\n\t        ctx.save();\r\n\r\n\t        this.setTransform(ctx);\r\n\t        this.setClip(ctx);\r\n\t        this.setOpacity(ctx);\r\n\r\n\t        ctx.beginPath();\r\n\r\n\t        ctx.font = text.options.font;\r\n\t        ctx.textAlign = 'left';\r\n\r\n\t        if (this.setFill(ctx)) {\r\n\t            ctx.fillText(text.content(), pos.x, pos.y + size.baseline);\r\n\t        }\r\n\r\n\t        if (this.setStroke(ctx)) {\r\n\t            this.setLineDash(ctx);\r\n\t            ctx.strokeText(text.content(), pos.x, pos.y + size.baseline);\r\n\t        }\r\n\r\n\t        ctx.restore();\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP$2.Text = TextNode$2;\r\n\r\n\tvar MultiPathNode$2 = PathNode$2.extend({\r\n\t    renderPoints: function(ctx) {\r\n\t        var paths = this.srcElement.paths;\r\n\t        for (var i = 0; i < paths.length; i++) {\r\n\t            renderPath(ctx, paths[i]);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tNODE_MAP$2.MultiPath = MultiPathNode$2;\r\n\r\n\tvar canvas = {\r\n\t\tSurface: Surface$3,\r\n\t\tRootNode: RootNode$2,\r\n\t\tNode: Node$2,\r\n\t\tGroupNode: GroupNode$2,\r\n\t\tArcNode: ArcNode$2,\r\n\t\tCircleNode: CircleNode$2,\r\n\t\tRectNode: RectNode$2,\r\n\t\tImageNode: ImageNode$2,\r\n\t\tTextNode: TextNode$2,\r\n\t\tPathNode: PathNode$2,\r\n\t\tMultiPathNode: MultiPathNode$2\r\n\t};\r\n\r\n\tfunction exportImage(group, options) {\r\n\t    var defaults = {\r\n\t        width: \"800px\", height: \"600px\",\r\n\t        cors: \"Anonymous\"\r\n\t    };\r\n\r\n\t    var exportRoot = group;\r\n\t    var bbox = group.clippedBBox();\r\n\r\n\t    if (bbox) {\r\n\t        var origin = bbox.getOrigin();\r\n\t        exportRoot = new Group();\r\n\t        exportRoot.transform(transform().translate(-origin.x, -origin.y));\r\n\t        exportRoot.children.push(group);\r\n\r\n\t        var size = bbox.getSize();\r\n\t        defaults.width = size.width + \"px\";\r\n\t        defaults.height = size.height + \"px\";\r\n\t    }\r\n\r\n\t    var surfaceOptions = $.extend(defaults, options);\r\n\r\n\t    var container = document.createElement(\"div\");\r\n\t    var style = container.style;\r\n\r\n\t    style.display = \"none\";\r\n\t    style.width = surfaceOptions.width;\r\n\t    style.height = surfaceOptions.height;\r\n\t    document.body.appendChild(container);\r\n\r\n\t    var surface = new Surface$3(container, surfaceOptions);\r\n\t    surface.suspendTracking();\r\n\t    surface.draw(exportRoot);\r\n\r\n\t    var promise = surface.image();\r\n\t    var destroy = function () {\r\n\t        surface.destroy();\r\n\t        document.body.removeChild(container);\r\n\t    };\r\n\t    promise.then(destroy, destroy);\r\n\r\n\t    return promise;\r\n\t}\r\n\r\n\tfunction exportSVG(group, options) {\r\n\t    var svg = exportGroup(group);\r\n\r\n\t    if (!options || !options.raw) {\r\n\t        svg = \"data:image/svg+xml;base64,\" + encodeBase64(svg);\r\n\t    }\r\n\r\n\t    return createPromise().resolve(svg);\r\n\t}\r\n\r\n\t/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\r\n\t/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\r\n\t/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty, yoda */\r\n\t/* eslint-disable no-param-reassign, no-var, block-scoped-var */\r\n\r\n\tvar browser = supportBrowser;\r\n\t/*\r\n\r\n\t  XXX: to test:\r\n\r\n\t  - cloneNodes function:\r\n\t    - drawing document containing canvas with page breaking\r\n\t    - drawing document with named radio <input>-s (should not clear selection)\r\n\t    - IE9/IE10 don't support el.dataset; do they copy user data?\r\n\r\n\t  - repeating table headers/footers on page breaking\r\n\r\n\t  - forceBreak, keepTogether\r\n\r\n\t  - avoidLinks\r\n\r\n\t */\r\n\r\n\t/* -----[ local vars ]----- */\r\n\r\n\tfunction slice$1(thing) {\r\n\t    return Array.prototype.slice.call(thing);\r\n\t}\r\n\r\n\tvar KENDO_PSEUDO_ELEMENT = \"KENDO-PSEUDO-ELEMENT\";\r\n\r\n\tvar IMAGE_CACHE = {};\r\n\r\n\tvar nodeInfo = {};\r\n\tnodeInfo._root = nodeInfo;\r\n\r\n\t/* -----[ Custom Text node to speed up rendering in kendo.pdf ]----- */\r\n\r\n\tvar TextRect = Text.extend({\r\n\t    init: function(str, rect, options) {\r\n\t        Text.fn.init.call(this, str, rect.getOrigin(), options);\r\n\t        this._pdfRect = rect;\r\n\t    },\r\n\r\n\t    rect: function() {\r\n\t        // this is the crux of it: we can avoid a call to\r\n\t        // measure(), which is what the base class does, since we\r\n\t        // already know the rect.  measure() is s-l-o-w.\r\n\t        return this._pdfRect;\r\n\t    },\r\n\r\n\t    rawBBox: function() {\r\n\t        // also let's avoid creating a new rectangle.\r\n\t        return this._pdfRect;\r\n\t    }\r\n\t});\r\n\r\n\tfunction addClass(el, cls) {\r\n\t    if (el.classList) {\r\n\t        el.classList.add(cls);\r\n\t    } else {\r\n\t        el.className += \" \" + cls;\r\n\t    }\r\n\t}\r\n\r\n\tfunction removeClass(el, cls) {\r\n\t    if (el.classList) {\r\n\t        el.classList.remove(cls);\r\n\t    } else {\r\n\t        el.className = el.className.split(/\\s+/).reduce(function(a, word){\r\n\t            if (word != cls) {\r\n\t                a.push(word);\r\n\t            }\r\n\t            return a;\r\n\t        }, []).join(\" \");\r\n\t    }\r\n\t}\r\n\r\n\tfunction setCSS(el, styles) {\r\n\t    Object.keys(styles).forEach(function(key){\r\n\t        el.style[key] = styles[key];\r\n\t    });\r\n\t}\r\n\r\n\tvar matches = typeof Element !== \"undefined\" && Element.prototype && (function(p){\r\n\t    if (p.matches) {\r\n\t        return function(el, selector) { return el.matches(selector); };\r\n\t    }\r\n\t    if (p.webkitMatchesSelector) {\r\n\t        return function(el, selector) { return el.webkitMatchesSelector(selector); };\r\n\t    }\r\n\t    if (p.mozMatchesSelector) {\r\n\t        return function(el, selector) { return el.mozMatchesSelector(selector); };\r\n\t    }\r\n\t    if (p.msMatchesSelector) {\r\n\t        return function(el, selector) { return el.msMatchesSelector(selector); };\r\n\t    }\r\n\t    return function(s) {\r\n\t\treturn [].indexOf.call(document.querySelectorAll(s), this) !== -1;\r\n\t    };\r\n\t})(Element.prototype);\r\n\r\n\tfunction closest(el, selector) {\r\n\t    if (el.closest) {\r\n\t        return el.closest(selector);\r\n\t    }\r\n\t    // IE: stringifying rather than simply comparing with `document`,\r\n\t    // which is not iframe-proof and fails in editor export \r\n\t    // https://github.com/telerik/kendo/issues/6721\r\n\t    while (el && !/^\\[object (?:HTML)?Document\\]$/.test(String(el))) {\r\n\t        if (matches(el, selector)) {\r\n\t            return el;\r\n\t        }\r\n\t        el = el.parentNode;\r\n\t    }\r\n\t}\r\n\r\n\t// clone nodes ourselves, so that we redraw <canvas> (DOM or\r\n\t// jQuery clone will not)\r\n\tvar cloneNodes = (function($){\r\n\t    if ($) {\r\n\t        // if we have Kendo and jQuery, use this version as it will\r\n\t        // maintain proper links between cloned element and Kendo\r\n\t        // widgets (i.e. it clones jQuery data(), which isn't the same\r\n\t        // as element's data attributes).\r\n\t        // https://github.com/telerik/kendo-ui-core/issues/2750\r\n\t        return function cloneNodes(el) {\r\n\t            var clone = el.cloneNode(false);\r\n\t            if (el.nodeType == 1 /* Element */) {\r\n\t                var $el = $(el), $clone = $(clone), i;\r\n\t                var data = $el.data();\r\n\t                for (i in data) {\r\n\t                    $clone.data(i, data[i]);\r\n\t                }\r\n\t                if (/^canvas$/i.test(el.tagName)) {\r\n\t                    clone.getContext(\"2d\").drawImage(el, 0, 0);\r\n\t                } else if (/^(?:input|select|textarea|option)$/i.test(el.tagName)) {\r\n\t                    // drop the name attributes so that we don't affect the selection of the\r\n\t                    // original nodes (i.e. checked status of radio buttons) when we insert our copy\r\n\t                    // into the DOM.  https://github.com/telerik/kendo/issues/5409\r\n\t                    clone.removeAttribute(\"id\");\r\n\t                    clone.removeAttribute(\"name\");\r\n\t                    clone.value = el.value;\r\n\t                    clone.checked = el.checked;\r\n\t                    clone.selected = el.selected;\r\n\t                }\r\n\t                for (i = el.firstChild; i; i = i.nextSibling) {\r\n\t                    clone.appendChild(cloneNodes(i));\r\n\t                }\r\n\t            }\r\n\t            return clone;\r\n\t        };\r\n\t    } else {\r\n\t        // the no-jQuery version\r\n\t        return function cloneNodes(el) {\r\n\t            var clone = (function dive(node){\r\n\t                var clone = node.cloneNode(false);\r\n\t                if (node._kendoExportVisual) {\r\n\t                    clone._kendoExportVisual = node._kendoExportVisual;\r\n\t                }\r\n\t                for (var i = node.firstChild; i; i = i.nextSibling) {\r\n\t                    clone.appendChild(dive(i));\r\n\t                }\r\n\t                return clone;\r\n\t            })(el);\r\n\r\n\t            // re-draw canvases - https://github.com/telerik/kendo/issues/4872\r\n\t            var canvases = el.querySelectorAll(\"canvas\");\r\n\t            if (canvases.length) {\r\n\t                slice$1(clone.querySelectorAll(\"canvas\")).forEach(function (canvas$$1, i) {\r\n\t                    canvas$$1.getContext(\"2d\").drawImage(canvases[i], 0, 0);\r\n\t                });\r\n\t            }\r\n\r\n\t            // remove \"name\" attributes from <input> elements -\r\n\t            // https://github.com/telerik/kendo/issues/5409\r\n\t            var orig = el.querySelectorAll(\"input, select, textarea, option\");\r\n\t            slice$1(clone.querySelectorAll(\"input, select, textarea, option\")).forEach(function (el, i) {\r\n\t                el.removeAttribute(\"id\");\r\n\t                el.removeAttribute(\"name\");\r\n\t                el.value = orig[i].value;\r\n\t                el.checked = orig[i].checked;\r\n\t                el.selected = orig[i].selected;\r\n\t            });\r\n\r\n\t            return clone;\r\n\t        };\r\n\t    }\r\n\t})(typeof window !== \"undefined\" && window.kendo && window.kendo.jQuery);\r\n\r\n\tfunction getXY(thing) {\r\n\t    if (typeof thing == \"number\") {\r\n\t        return { x: thing, y: thing };\r\n\t    }\r\n\t    if (Array.isArray(thing)) {\r\n\t        return { x: thing[0], y: thing[1] };\r\n\t    }\r\n\t    return { x: thing.x, y: thing.y };\r\n\t}\r\n\r\n\tfunction drawDOM(element, options) {\r\n\t    if (!options) {\r\n\t        options = {};\r\n\t    }\r\n\t    var promise = createPromise();\r\n\r\n\t    if (!element) {\r\n\t        return promise.reject(\"No element to export\");\r\n\t    }\r\n\r\n\t    if (typeof window.getComputedStyle != \"function\") {\r\n\t        throw new Error(\"window.getComputedStyle is missing.  You are using an unsupported browser, or running in IE8 compatibility mode.  Drawing HTML is supported in Chrome, Firefox, Safari and IE9+.\");\r\n\t    }\r\n\r\n\t    kendo.pdf.defineFont(getFontFaces(element.ownerDocument));\r\n\r\n\t    var scale = getXY(options.scale || 1);\r\n\r\n\t    function doOne(element) {\r\n\t        var group = new Group();\r\n\r\n\t        // translate to start of page\r\n\t        var pos = element.getBoundingClientRect();\r\n\t        setTransform(group, [\r\n\t            scale.x,\r\n\t            0,\r\n\t            0,\r\n\t            scale.y,\r\n\t            (-pos.left * scale.x),\r\n\t            (-pos.top * scale.y)\r\n\t        ]);\r\n\r\n\t        nodeInfo._clipbox = false;\r\n\t        nodeInfo._matrix = Matrix.unit();\r\n\t        nodeInfo._stackingContext = {\r\n\t            element: element,\r\n\t            group: group\r\n\t        };\r\n\r\n\t        if (options.avoidLinks === true) {\r\n\t            nodeInfo._avoidLinks = \"a\";\r\n\t        } else {\r\n\t            nodeInfo._avoidLinks = options.avoidLinks;\r\n\t        }\r\n\r\n\t        addClass(element, \"k-pdf-export\");\r\n\t        renderElement(element, group);\r\n\t        removeClass(element, \"k-pdf-export\");\r\n\r\n\t        return group;\r\n\t    }\r\n\r\n\t    cacheImages(element, function(){\r\n\t        var forceBreak = options && options.forcePageBreak;\r\n\t        var hasPaperSize = options && options.paperSize && options.paperSize != \"auto\";\r\n\t        var paperOptions = kendo.pdf.getPaperOptions(function(key, def){\r\n\t            if (key == \"paperSize\") {\r\n\t                // PDF.getPaperOptions croaks on \"auto\", just pass dummy A4 as we might\r\n\t                // still be interested in margins.\r\n\t                return hasPaperSize ? options[key] : \"A4\";\r\n\t            }\r\n\t            return key in options ? options[key] : def;\r\n\t        });\r\n\t        var pageWidth = hasPaperSize && paperOptions.paperSize[0];\r\n\t        var pageHeight = hasPaperSize && paperOptions.paperSize[1];\r\n\t        var margin = options.margin && paperOptions.margin;\r\n\t        var hasMargin = Boolean(margin);\r\n\t        if (forceBreak || pageHeight) {\r\n\t            if (!margin) {\r\n\t                margin = { left: 0, top: 0, right: 0, bottom: 0 };\r\n\t            }\r\n\r\n\t            // we want paper size and margin to be unaffected by\r\n\t            // scaling in the output, so we have to reverse-scale\r\n\t            // before our calculations begin.\r\n\t            if (pageWidth)  { pageWidth  /= scale.x; }\r\n\t            if (pageHeight) { pageHeight /= scale.y; }\r\n\t            margin.left   /= scale.x;\r\n\t            margin.right  /= scale.x;\r\n\t            margin.top    /= scale.y;\r\n\t            margin.bottom /= scale.y;\r\n\r\n\t            var group = new Group({\r\n\t                pdf: {\r\n\t                    multiPage     : true,\r\n\t                    paperSize     : hasPaperSize ? paperOptions.paperSize : \"auto\",\r\n\t                    _ignoreMargin : hasMargin // HACK!  see exportPDF in pdf/drawing.js\r\n\t                }\r\n\t            });\r\n\t            handlePageBreaks(\r\n\t                function(x) {\r\n\t                    if (options.progress) {\r\n\t                        var canceled = false, pageNum = 0;\r\n\t                        (function next(){\r\n\t                            if (pageNum < x.pages.length) {\r\n\t                                var page = doOne(x.pages[pageNum]);\r\n\t                                group.append(page);\r\n\t                                options.progress({\r\n\t                                    page: page,\r\n\t                                    pageNum: ++pageNum,\r\n\t                                    totalPages: x.pages.length,\r\n\t                                    cancel: function() {\r\n\t                                        canceled = true;\r\n\t                                    }\r\n\t                                });\r\n\t                                if (!canceled) {\r\n\t                                    setTimeout(next);\r\n\t                                } else {\r\n\t                                    // XXX: should we also fail() the deferred object?\r\n\t                                    x.container.parentNode.removeChild(x.container);\r\n\t                                }\r\n\t                            } else {\r\n\t                                x.container.parentNode.removeChild(x.container);\r\n\t                                promise.resolve(group);\r\n\t                            }\r\n\t                        })();\r\n\t                    } else {\r\n\t                        x.pages.forEach(function(page){\r\n\t                            group.append(doOne(page));\r\n\t                        });\r\n\t                        x.container.parentNode.removeChild(x.container);\r\n\t                        promise.resolve(group);\r\n\t                    }\r\n\t                },\r\n\t                element,\r\n\t                forceBreak,\r\n\t                pageWidth ? pageWidth - margin.left - margin.right : null,\r\n\t                pageHeight ? pageHeight - margin.top - margin.bottom : null,\r\n\t                margin,\r\n\t                options\r\n\t            );\r\n\t        } else {\r\n\t            promise.resolve(doOne(element));\r\n\t        }\r\n\t    });\r\n\r\n\t    function makeTemplate(template$$1) {\r\n\t        if (template$$1 != null) {\r\n\t            if (typeof template$$1 == \"string\") {\r\n\t                template$$1 = kendo.template(template$$1.replace(/^\\s+|\\s+$/g, \"\"));\r\n\t            }\r\n\t            if (typeof template$$1 == \"function\") {\r\n\t                return function(data) {\r\n\t                    var el = template$$1(data);\r\n\t                    if (el && typeof el == \"string\") {\r\n\t                        var div = document.createElement(\"div\");\r\n\t                        div.innerHTML = el;\r\n\t                        el = div.firstElementChild;\r\n\t                    }\r\n\t                    return el;\r\n\t                };\r\n\t            }\r\n\t            // assumed DOM element\r\n\t            return function() {\r\n\t                return template$$1.cloneNode(true);\r\n\t            };\r\n\t        }\r\n\t    }\r\n\r\n\t    function handlePageBreaks(callback, element, forceBreak, pageWidth, pageHeight, margin, options) {\r\n\t        var template$$1 = makeTemplate(options.template);\r\n\t        var doc = element.ownerDocument;\r\n\t        var pages = [];\r\n\t        var copy = options._destructive ? element : cloneNodes(element);\r\n\t        var container = doc.createElement(\"KENDO-PDF-DOCUMENT\");\r\n\t        var adjust = 0;\r\n\r\n\t        // make sure <tfoot> elements are at the end (Grid widget\r\n\t        // places TFOOT before TBODY, tricking our algorithm to\r\n\t        // insert a page break right after the header).\r\n\t        // https://github.com/telerik/kendo/issues/4699\r\n\t        slice$1(copy.querySelectorAll(\"tfoot\")).forEach(function(tfoot){\r\n\t            tfoot.parentNode.appendChild(tfoot);\r\n\t        });\r\n\r\n\t        // remember the index of each LI from an ordered list.\r\n\t        // we'll use it to reconstruct the proper numbering.\r\n\t        slice$1(copy.querySelectorAll(\"ol\")).forEach(function(ol){\r\n\t            slice$1(ol.children).forEach(function(li, index){\r\n\t                li.setAttribute(\"kendo-split-index\", index);\r\n\t            });\r\n\t        });\r\n\r\n\t        setCSS(container, {\r\n\t            display   : \"block\",\r\n\t            position  : \"absolute\",\r\n\t            boxSizing : \"content-box\",\r\n\t            left      : \"-10000px\",\r\n\t            top       : \"-10000px\"\r\n\t        });\r\n\r\n\t        if (pageWidth) {\r\n\t            // subtle: if we don't set the width *and* margins here, the layout in this\r\n\t            // container will be different from the one in our final page elements, and we'll\r\n\t            // split at the wrong places.\r\n\t            setCSS(container, {\r\n\t                width        : pageWidth + \"px\",\r\n\t                paddingLeft  : margin.left + \"px\",\r\n\t                paddingRight : margin.right + \"px\"\r\n\t            });\r\n\r\n\t            // when the first element has a margin-top (i.e. a <h1>) the page will be\r\n\t            // inadvertently enlarged by that number (the browser will report the container's\r\n\t            // bounding box top to start at the element's top, rather than including its\r\n\t            // margin).  Adding overflow: hidden seems to fix it.\r\n\t            //\r\n\t            // to understand the difference, try the following snippets in your browser:\r\n\t            //\r\n\t            // 1. <div style=\"background: yellow\">\r\n\t            //      <h1 style=\"margin: 3em\">Foo</h1>\r\n\t            //    </div>\r\n\t            //\r\n\t            // 2. <div style=\"background: yellow; overflow: hidden\">\r\n\t            //      <h1 style=\"margin: 3em\">Foo</h1>\r\n\t            //    </div>\r\n\t            //\r\n\t            // this detail is not important when automatic page breaking is not requested, hence\r\n\t            // doing it only if pageWidth is defined.\r\n\t            setCSS(copy, { overflow: \"hidden\" });\r\n\t        }\r\n\r\n\t        element.parentNode.insertBefore(container, element);\r\n\t        container.appendChild(copy);\r\n\r\n\t        // we need the timeouts here, so that images dimensions are\r\n\t        // properly computed in DOM when we start our thing.\r\n\t        if (options.beforePageBreak) {\r\n\t            setTimeout(function(){\r\n\t                options.beforePageBreak(container, doPageBreak);\r\n\t            }, 15);\r\n\t        } else {\r\n\t            setTimeout(doPageBreak, 15);\r\n\t        }\r\n\r\n\t        function doPageBreak() {\r\n\t            if (forceBreak != \"-\" || pageHeight) {\r\n\t                splitElement(copy);\r\n\t            }\r\n\r\n\t            {\r\n\t                var page = makePage();\r\n\t                copy.parentNode.insertBefore(page, copy);\r\n\t                page.appendChild(copy);\r\n\t            }\r\n\r\n\t            if (template$$1) {\r\n\t                pages.forEach(function(page, i){\r\n\t                    var el = template$$1({\r\n\t                        element    : page,\r\n\t                        pageNum    : i + 1,\r\n\t                        totalPages : pages.length\r\n\t                    });\r\n\t                    if (el) {\r\n\t                        page.appendChild(el);\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\r\n\t            cacheImages(pages, function() {\r\n\t                // Even though we already cached images, they simply won't be available\r\n\t                // immediately in the newly created DOM.  Previously we'd allow a 10ms timeout,\r\n\t                // but that's arbitrary and clearly not working in all cases\r\n\t                // (https://github.com/telerik/kendo/issues/5399), so this function will wait\r\n\t                // for their .complete attribute.\r\n\t                whenImagesAreActuallyLoaded(pages, function(){\r\n\t                    callback({ pages: pages, container: container });\r\n\t                });\r\n\t            });\r\n\t        }\r\n\r\n\t        function keepTogether(el) {\r\n\t            if (options.keepTogether && matches(el, options.keepTogether) && el.offsetHeight <= pageHeight - adjust) {\r\n\t                return true;\r\n\t            }\r\n\r\n\t            var tag = el.tagName;\r\n\t            if (/^h[1-6]$/i.test(tag) && el.offsetHeight >= pageHeight - adjust) {\r\n\t                return false;\r\n\t            }\r\n\r\n\t            return (el.getAttribute(\"data-kendo-chart\") ||\r\n\t                    /^(?:img|tr|thead|th|tfoot|iframe|svg|object|canvas|input|textarea|select|video|h[1-6])/i.test(el.tagName));\r\n\t        }\r\n\r\n\t        function splitElement(element) {\r\n\t            if (element.tagName == \"TABLE\") {\r\n\t                setCSS(element, { tableLayout: \"fixed\" });\r\n\t            }\r\n\t            var style = getComputedStyle(element);\r\n\t            var bottomPadding = parseFloat(getPropertyValue(style, \"padding-bottom\"));\r\n\t            var bottomBorder = parseFloat(getPropertyValue(style, \"border-bottom-width\"));\r\n\t            var saveAdjust = adjust;\r\n\t            adjust += bottomPadding + bottomBorder;\r\n\t            var isFirst = true;\r\n\t            for (var el = element.firstChild; el; el = el.nextSibling) {\r\n\t                if (el.nodeType == 1 /* Element */) {\r\n\t                    isFirst = false;\r\n\t                    if (matches(el, forceBreak)) {\r\n\t                        breakAtElement(el);\r\n\t                        continue;\r\n\t                    }\r\n\t                    if (!pageHeight) {\r\n\t                        // we're in \"manual breaks mode\"\r\n\t                        splitElement(el);\r\n\t                        continue;\r\n\t                    }\r\n\t                    if (!/^(?:static|relative)$/.test(getPropertyValue(getComputedStyle(el), \"position\"))) {\r\n\t                        continue;\r\n\t                    }\r\n\t                    var fall = fallsOnMargin(el);\r\n\t                    if (fall == 1) {\r\n\t                        // element starts on next page, break before anyway.\r\n\t                        breakAtElement(el);\r\n\t                    }\r\n\t                    else if (fall) {\r\n\t                        // elements ends up on next page, or possibly doesn't fit on a page at\r\n\t                        // all.  break before it anyway if it's an <img> or <tr>, otherwise\r\n\t                        // attempt to split.\r\n\t                        if (keepTogether(el)) {\r\n\t                            breakAtElement(el);\r\n\t                        } else {\r\n\t                            splitElement(el);\r\n\t                        }\r\n\t                    }\r\n\t                    else {\r\n\t                        splitElement(el);\r\n\t                    }\r\n\t                }\r\n\t                else if (el.nodeType == 3 /* Text */ && pageHeight) {\r\n\t                    splitText(el, isFirst);\r\n\t                    isFirst = false;\r\n\t                }\r\n\t            }\r\n\t            adjust = saveAdjust;\r\n\t        }\r\n\r\n\t        function firstInParent(el) {\r\n\t            var p = el.parentNode, first = p.firstChild;\r\n\t            if (el === first) {\r\n\t                return true;\r\n\t            }\r\n\t            if (el === p.children[0]) {\r\n\t                if (first.nodeType == 7 /* comment */ ||\r\n\t                    first.nodeType == 8 /* processing instruction */) {\r\n\t                    return true;\r\n\t                }\r\n\t                if (first.nodeType == 3 /* text */) {\r\n\t                    // if whitespace only we can probably consider it's first\r\n\t                    return !/\\S/.test(first.data);\r\n\t                }\r\n\t            }\r\n\t            return false;\r\n\t        }\r\n\r\n\t        function breakAtElement(el) {\r\n\t            if (el.nodeType == 1 && el !== copy && firstInParent(el)) {\r\n\t                return breakAtElement(el.parentNode);\r\n\t            }\r\n\t            var table, colgroup, thead, grid, gridHead;\r\n\t            table = closest(el, \"table\");\r\n\t            colgroup = table && table.querySelector(\"colgroup\");\r\n\t            if (options.repeatHeaders) {\r\n\t                thead = table && table.querySelector(\"thead\");\r\n\r\n\t                // If we break page in a Kendo Grid, repeat its header.  This ugly hack is\r\n\t                // necessary because a scrollable grid will keep the header in a separate\r\n\t                // <table> element from its content.\r\n\t                //\r\n\t                // XXX: This is likely to break as soon as the widget HTML is modified.\r\n\t                grid = closest(el, \".k-grid.k-widget\");\r\n\t                if (grid && grid.querySelector(\".k-auto-scrollable\")) {\r\n\t                    gridHead = grid.querySelector(\".k-grid-header\");\r\n\t                }\r\n\t            }\r\n\t            var page = makePage();\r\n\t            var range = doc.createRange();\r\n\t            range.setStartBefore(copy);\r\n\t            range.setEndBefore(el);\r\n\t            page.appendChild(range.extractContents());\r\n\t            copy.parentNode.insertBefore(page, copy);\r\n\t            preventBulletOnListItem(el.parentNode);\r\n\t            if (table) {\r\n\t                table = closest(el, \"table\"); // that's the <table> on next page!\r\n\t                if (options.repeatHeaders && thead) {\r\n\t                    table.insertBefore(thead.cloneNode(true), table.firstChild);\r\n\t                }\r\n\t                if (colgroup) {\r\n\t                    table.insertBefore(colgroup.cloneNode(true), table.firstChild);\r\n\t                }\r\n\t            }\r\n\t            if (options.repeatHeaders && gridHead) {\r\n\t                grid = closest(el, \".k-grid.k-widget\");\r\n\t                grid.insertBefore(gridHead.cloneNode(true), grid.firstChild);\r\n\t            }\r\n\t        }\r\n\r\n\t        function makePage() {\r\n\t            var page = doc.createElement(\"KENDO-PDF-PAGE\");\r\n\t            setCSS(page, {\r\n\t                display  : \"block\",\r\n\t                boxSizing: \"content-box\",\r\n\t                width    : pageWidth ? (pageWidth + \"px\") : \"auto\",\r\n\t                padding  : (margin.top + \"px \" +\r\n\t                            margin.right + \"px \" +\r\n\t                            margin.bottom + \"px \" +\r\n\t                            margin.left + \"px\"),\r\n\r\n\t                // allow absolutely positioned elements to be relative to current page\r\n\t                position : \"relative\",\r\n\r\n\t                // without the following we might affect layout of subsequent pages\r\n\t                height   : pageHeight ? (pageHeight + \"px\") : \"auto\",\r\n\t                overflow : pageHeight || pageWidth ? \"hidden\" : \"visible\",\r\n\t                clear    : \"both\"\r\n\t            });\r\n\r\n\t            // debug\r\n\t            // $(\"<div>\").css({\r\n\t            //     position  : \"absolute\",\r\n\t            //     left      : margin.left,\r\n\t            //     top       : margin.top,\r\n\t            //     width     : pageWidth,\r\n\t            //     height    : pageHeight,\r\n\t            //     boxSizing : \"border-box\",\r\n\t            //     background: \"rgba(255, 255, 0, 0.5)\"\r\n\t            //     //border    : \"1px solid red\"\r\n\t            // }).appendTo(page);\r\n\r\n\t            if (options && options.pageClassName) {\r\n\t                page.className = options.pageClassName;\r\n\t            }\r\n\t            pages.push(page);\r\n\t            return page;\r\n\t        }\r\n\r\n\t        function fallsOnMargin(thing) {\r\n\t            var box = thing.getBoundingClientRect();\r\n\t            if (box.width === 0 || box.height === 0) {\r\n\t                // I'd say an element with dimensions zero fits on current page.\r\n\t                return 0;\r\n\t            }\r\n\t            var top = copy.getBoundingClientRect().top;\r\n\t            var available = pageHeight - adjust;\r\n\t            return (box.height > available) ? 3\r\n\t                : (box.top - top > available) ? 1\r\n\t                : (box.bottom - top > available) ? 2\r\n\t                : 0;\r\n\t        }\r\n\r\n\t        function splitText(node, isFirst) {\r\n\t            if (!/\\S/.test(node.data)) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            var len = node.data.length;\r\n\t            var range = doc.createRange();\r\n\t            range.selectNodeContents(node);\r\n\t            var fall = fallsOnMargin(range);\r\n\t            if (!fall) {\r\n\t                return;     // the whole text fits on current page\r\n\t            }\r\n\r\n\t            var nextnode = node;\r\n\t            if (fall == 1) {\r\n\t                // starts on next page, break before anyway.\r\n\t                if (isFirst) {\r\n\t                    // avoid leaving an empty <p>, <li>, etc. on previous page.\r\n\t                    breakAtElement(node.parentNode);\r\n\t                } else {\r\n\t                    breakAtElement(node);\r\n\t                }\r\n\t            }\r\n\t            else {\r\n\t                (function findEOP(min, pos, max) {\r\n\t                    range.setEnd(node, pos);\r\n\t                    if (min == pos || pos == max) {\r\n\t                        return pos;\r\n\t                    }\r\n\t                    if (fallsOnMargin(range)) {\r\n\t                        return findEOP(min, (min + pos) >> 1, pos);\r\n\t                    } else {\r\n\t                        return findEOP(pos, (pos + max) >> 1, max);\r\n\t                    }\r\n\t                })(0, len >> 1, len);\r\n\r\n\t                if (!/\\S/.test(range.toString()) && isFirst) {\r\n\t                    // avoid leaving an empty <p>, <li>, etc. on previous page.\r\n\t                    breakAtElement(node.parentNode);\r\n\t                } else {\r\n\t                    // This is only needed for IE, but it feels cleaner to do it anyway.  Without\r\n\t                    // it, IE will truncate a very long text (playground/pdf-long-text-2.html).\r\n\t                    nextnode = node.splitText(range.endOffset);\r\n\r\n\t                    var page = makePage();\r\n\t                    range.setStartBefore(copy);\r\n\t                    page.appendChild(range.extractContents());\r\n\t                    copy.parentNode.insertBefore(page, copy);\r\n\t                    preventBulletOnListItem(nextnode.parentNode);\r\n\t                }\r\n\t            }\r\n\r\n\t            splitText(nextnode);\r\n\t        }\r\n\r\n\t        function preventBulletOnListItem(el) {\r\n\t            // set a hint on continued LI elements, to tell the\r\n\t            // renderer not to draw the bullet again.\r\n\t            // https://github.com/telerik/kendo-ui-core/issues/2732\r\n\t            var li = closest(el, \"li\");\r\n\t            if (li) {\r\n\t                li.setAttribute(\"kendo-no-bullet\", \"1\");\r\n\t                preventBulletOnListItem(li.parentNode);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    return promise;\r\n\t}\r\n\r\n\tdrawDOM.getFontFaces = getFontFaces;\r\n\r\n\t// This is needed for the Spreadsheet print functionality.  Since\r\n\t// there we only need to draw text, this cuts through the ceremony\r\n\t// of drawDOM/renderElement and renders the text node directly.\r\n\tdrawDOM.drawText = function(element) {\r\n\t    var group = new Group();\r\n\t    nodeInfo._clipbox = false;\r\n\t    nodeInfo._matrix = Matrix.unit();\r\n\t    nodeInfo._stackingContext = {\r\n\t        element: element,\r\n\t        group: group\r\n\t    };\r\n\t    pushNodeInfo(element, getComputedStyle(element), group);\r\n\t    if (element.firstChild.nodeType == 3 /* Text */) {\r\n\t        // avoid the penalty of renderElement\r\n\t        renderText(element, element.firstChild, group);\r\n\t    } else {\r\n\t        _renderElement(element, group);\r\n\t    }\r\n\t    popNodeInfo();\r\n\t    return group;\r\n\t};\r\n\r\n\tvar parseBackgroundImage = (function(){\r\n\t    var tok_linear_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?linear-gradient\\s*)\\(/;\r\n\t    //var tok_radial_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?radial-gradient\\s*)\\(/;\r\n\t    var tok_percent          = /^([-0-9.]+%)/;\r\n\t    var tok_length           = /^([-0-9.]+px)/;\r\n\t    var tok_keyword          = /^(left|right|top|bottom|to|center)\\W/;\r\n\t    var tok_angle            = /^([-0-9.]+(deg|grad|rad|turn))/;\r\n\t    var tok_whitespace       = /^(\\s+)/;\r\n\t    var tok_popen            = /^(\\()/;\r\n\t    var tok_pclose           = /^(\\))/;\r\n\t    var tok_comma            = /^(,)/;\r\n\t    var tok_url              = /^(url)\\(/;\r\n\t    var tok_content          = /^(.*?)\\)/;\r\n\r\n\t    var cache1 = {}, cache2 = {};\r\n\r\n\t    function parse(input) {\r\n\t        var orig = input;\r\n\t        if (hasOwnProperty(cache1, orig)) {\r\n\t            return cache1[orig];\r\n\t        }\r\n\t        function skip_ws() {\r\n\t            var m = tok_whitespace.exec(input);\r\n\t            if (m) {\r\n\t                input = input.substr(m[1].length);\r\n\t            }\r\n\t        }\r\n\t        function read(token) {\r\n\t            skip_ws();\r\n\t            var m = token.exec(input);\r\n\t            if (m) {\r\n\t                input = input.substr(m[1].length);\r\n\t                return m[1];\r\n\t            }\r\n\t        }\r\n\r\n\t        function read_stop() {\r\n\t            var color = kendo.parseColor(input, true);\r\n\t            var length, percent;\r\n\t            if (color) {\r\n\t                var match =\r\n\t                    /^#[0-9a-f]+/i.exec(input) ||\r\n\t                    /^rgba?\\(.*?\\)/i.exec(input) ||\r\n\t                    /^..*?\\b/.exec(input); // maybe named color\r\n\t                input = input.substr(match[0].length);\r\n\t                color = color.toRGB();\r\n\t                if (!(length = read(tok_length))) {\r\n\t                    percent = read(tok_percent);\r\n\t                }\r\n\t                return { color: color, length: length, percent: percent };\r\n\t            }\r\n\t        }\r\n\r\n\t        function read_linear_gradient(propName) {\r\n\t            var angle;\r\n\t            var to1, to2;\r\n\t            var stops = [];\r\n\t            var reverse = false;\r\n\r\n\t            if (read(tok_popen)) {\r\n\t                // 1. [ <angle> || to <side-or-corner>, ]?\r\n\t                angle = read(tok_angle);\r\n\t                if (angle) {\r\n\t                    angle = parseAngle(angle);\r\n\t                    read(tok_comma);\r\n\t                }\r\n\t                else {\r\n\t                    to1 = read(tok_keyword);\r\n\t                    if (to1 == \"to\") {\r\n\t                        to1 = read(tok_keyword);\r\n\t                    } else if (to1 && /^-/.test(propName)) {\r\n\t                        reverse = true;\r\n\t                    }\r\n\t                    to2 = read(tok_keyword);\r\n\t                    read(tok_comma);\r\n\t                }\r\n\r\n\t                if (/-moz-/.test(propName) && angle == null && to1 == null) {\r\n\t                    var x = read(tok_percent), y = read(tok_percent);\r\n\t                    reverse = true;\r\n\t                    if (x == \"0%\") {\r\n\t                        to1 = \"left\";\r\n\t                    } else if (x == \"100%\") {\r\n\t                        to1 = \"right\";\r\n\t                    }\r\n\t                    if (y == \"0%\") {\r\n\t                        to2 = \"top\";\r\n\t                    } else if (y == \"100%\") {\r\n\t                        to2 = \"bottom\";\r\n\t                    }\r\n\t                    read(tok_comma);\r\n\t                }\r\n\r\n\t                // 2. color stops\r\n\t                while (input && !read(tok_pclose)) {\r\n\t                    var stop = read_stop();\r\n\t                    if (!stop) {\r\n\t                        break;\r\n\t                    }\r\n\t                    stops.push(stop);\r\n\t                    read(tok_comma);\r\n\t                }\r\n\r\n\t                return {\r\n\t                    type    : \"linear\",\r\n\t                    angle   : angle,\r\n\t                    to      : to1 && to2 ? to1 + \" \" + to2 : to1 ? to1 : to2 ? to2 : null,\r\n\t                    stops   : stops,\r\n\t                    reverse : reverse\r\n\t                };\r\n\t            }\r\n\t        }\r\n\r\n\t        function read_url() {\r\n\t            if (read(tok_popen)) {\r\n\t                var url = read(tok_content);\r\n\t                url = url.replace(/^['\"]+|[\"']+$/g, \"\");\r\n\t                read(tok_pclose);\r\n\t                return { type: \"url\", url: url };\r\n\t            }\r\n\t        }\r\n\r\n\t        var tok;\r\n\r\n\t        if ((tok = read(tok_linear_gradient))) {\r\n\t            tok = read_linear_gradient(tok);\r\n\t        }\r\n\t        else if ((tok = read(tok_url))) {\r\n\t            tok = read_url();\r\n\t        }\r\n\r\n\t        return (cache1[orig] = tok || { type: \"none\" });\r\n\t    }\r\n\r\n\t    return function(input) {\r\n\t        if (hasOwnProperty(cache2, input)) {\r\n\t            return cache2[input];\r\n\t        }\r\n\t        return (cache2[input] = splitProperty(input).map(parse));\r\n\t    };\r\n\t})();\r\n\r\n\tvar splitProperty = (function(){\r\n\t    var cache = {};\r\n\t    return function(input, separator) {\r\n\t        if (!separator) {\r\n\t            separator = /^\\s*,\\s*/;\r\n\t        }\r\n\r\n\t        var cacheKey = input + separator;\r\n\r\n\t        if (hasOwnProperty(cache, cacheKey)) {\r\n\t            return cache[cacheKey];\r\n\t        }\r\n\r\n\t        var ret = [];\r\n\t        var last$$1 = 0, pos = 0;\r\n\t        var in_paren = 0;\r\n\t        var in_string = false;\r\n\t        var m;\r\n\r\n\t        function looking_at(rx) {\r\n\t            return (m = rx.exec(input.substr(pos)));\r\n\t        }\r\n\r\n\t        function trim(str) {\r\n\t            return str.replace(/^\\s+|\\s+$/g, \"\");\r\n\t        }\r\n\r\n\t        while (pos < input.length) {\r\n\t            if (!in_string && looking_at(/^[\\(\\[\\{]/)) {\r\n\t                in_paren++;\r\n\t                pos++;\r\n\t            }\r\n\t            else if (!in_string && looking_at(/^[\\)\\]\\}]/)) {\r\n\t                in_paren--;\r\n\t                pos++;\r\n\t            }\r\n\t            else if (!in_string && looking_at(/^[\\\"\\']/)) {\r\n\t                in_string = m[0];\r\n\t                pos++;\r\n\t            }\r\n\t            else if (in_string == \"'\" && looking_at(/^\\\\\\'/)) {\r\n\t                pos += 2;\r\n\t            }\r\n\t            else if (in_string == '\"' && looking_at(/^\\\\\\\"/)) {\r\n\t                pos += 2;\r\n\t            }\r\n\t            else if (in_string == \"'\" && looking_at(/^\\'/)) {\r\n\t                in_string = false;\r\n\t                pos++;\r\n\t            }\r\n\t            else if (in_string == '\"' && looking_at(/^\\\"/)) {\r\n\t                in_string = false;\r\n\t                pos++;\r\n\t            }\r\n\t            else if (looking_at(separator)) {\r\n\t                if (!in_string && !in_paren && pos > last$$1) {\r\n\t                    ret.push(trim(input.substring(last$$1, pos)));\r\n\t                    last$$1 = pos + m[0].length;\r\n\t                }\r\n\t                pos += m[0].length;\r\n\t            }\r\n\t            else {\r\n\t                pos++;\r\n\t            }\r\n\t        }\r\n\t        if (last$$1 < pos) {\r\n\t            ret.push(trim(input.substring(last$$1, pos)));\r\n\t        }\r\n\t        return (cache[cacheKey] = ret);\r\n\t    };\r\n\t})();\r\n\r\n\tvar getFontURL = (function(cache){\r\n\t    return function(el){\r\n\t        // XXX: for IE we get here the whole cssText of the rule,\r\n\t        // because the computedStyle.src is empty.  Next time we need\r\n\t        // to fix these regexps we better write a CSS parser. :-\\\r\n\t        var url = cache[el];\r\n\t        if (!url) {\r\n\t            var m;\r\n\t            if ((m = /url\\((['\"]?)([^'\")]*?)\\1\\)\\s+format\\((['\"]?)truetype\\3\\)/.exec(el))) {\r\n\t                url = cache[el] = m[2];\r\n\t            } else if ((m = /url\\((['\"]?)([^'\")]*?\\.ttf)\\1\\)/.exec(el))) {\r\n\t                url = cache[el] = m[2];\r\n\t            }\r\n\t        }\r\n\t        return url;\r\n\t    };\r\n\t})(Object.create ? Object.create(null) : {});\r\n\r\n\tvar getFontHeight = (function(cache){\r\n\t    return function(font) {\r\n\t        var height = cache[font];\r\n\t        if (height == null) {\r\n\t            height = cache[font] = kendoUtil.measureText(\"Mapq\", { font: font }).height;\r\n\t        }\r\n\t        return height;\r\n\t    };\r\n\t})(Object.create ? Object.create(null) : {});\r\n\r\n\tfunction getFontFaces(doc) {\r\n\t    if (doc == null) {\r\n\t        doc = document;\r\n\t    }\r\n\t    var result = {};\r\n\t    for (var i = 0; i < doc.styleSheets.length; ++i) {\r\n\t        doStylesheet(doc.styleSheets[i]);\r\n\t    }\r\n\t    return result;\r\n\t    function doStylesheet(ss) {\r\n\t        if (ss) {\r\n\t            var rules = null;\r\n\t            try {\r\n\t                rules = ss.cssRules;\r\n\t            } catch (ex) {}\r\n\t            if (rules) {\r\n\t                addRules(ss, rules);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    function findFonts(rule) {\r\n\t        var src = getPropertyValue(rule.style, \"src\");\r\n\t        if (src) {\r\n\t            return splitProperty(src).reduce(function(a, el){\r\n\t                var font = getFontURL(el);\r\n\t                if (font) {\r\n\t                    a.push(font);\r\n\t                }\r\n\t                return a;\r\n\t            }, []);\r\n\t        } else {\r\n\t            // Internet Explorer\r\n\t            // XXX: this is gross.  should work though for valid CSS.\r\n\t            var font = getFontURL(rule.cssText);\r\n\t            return font ? [ font ] : [];\r\n\t        }\r\n\t    }\r\n\t    function addRules(styleSheet, rules) {\r\n\t        for (var i = 0; i < rules.length; ++i) {\r\n\t            var r = rules[i];\r\n\t            switch (r.type) {\r\n\t              case 3:       // CSSImportRule\r\n\t                doStylesheet(r.styleSheet);\r\n\t                break;\r\n\t              case 5:       // CSSFontFaceRule\r\n\t                var style  = r.style;\r\n\t                var family = splitProperty(getPropertyValue(style, \"font-family\"));\r\n\t                var bold   = /^([56789]00|bold)$/i.test(getPropertyValue(style, \"font-weight\"));\r\n\t                var italic = \"italic\" == getPropertyValue(style, \"font-style\");\r\n\t                var src    = findFonts(r);\r\n\t                if (src.length > 0) {\r\n\t                    addRule(styleSheet, family, bold, italic, src[0]);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t    function addRule(styleSheet, names, bold, italic, url) {\r\n\t        // We get full resolved absolute URLs in Chrome, but sadly\r\n\t        // not in Firefox.\r\n\t        if (!(/^data:/i.test(url))) {\r\n\t            if (!(/^[^\\/:]+:\\/\\//.test(url) || /^\\//.test(url))) {\r\n\t                url = String(styleSheet.href).replace(/[^\\/]*$/, \"\") + url;\r\n\t            }\r\n\t        }\r\n\t        names.forEach(function(name){\r\n\t            name = name.replace(/^(['\"]?)(.*?)\\1$/, \"$2\"); // it's quoted\r\n\t            if (bold) {\r\n\t                name += \"|bold\";\r\n\t            }\r\n\t            if (italic) {\r\n\t                name += \"|italic\";\r\n\t            }\r\n\t            result[name] = url;\r\n\t        });\r\n\t    }\r\n\t}\r\n\r\n\tfunction hasOwnProperty(obj, key) {\r\n\t    return Object.prototype.hasOwnProperty.call(obj, key);\r\n\t}\r\n\r\n\tfunction getCounter(name) {\r\n\t    name = \"_counter_\" + name;\r\n\t    return nodeInfo[name];\r\n\t}\r\n\r\n\tfunction getAllCounters(name) {\r\n\t    var values = [], p = nodeInfo;\r\n\t    name = \"_counter_\" + name;\r\n\t    while (p) {\r\n\t        if (hasOwnProperty(p, name)) {\r\n\t            values.push(p[name]);\r\n\t        }\r\n\t        p = Object.getPrototypeOf(p);\r\n\t    }\r\n\t    return values.reverse();\r\n\t}\r\n\r\n\tfunction incCounter(name, inc) {\r\n\t    var p = nodeInfo;\r\n\t    name = \"_counter_\" + name;\r\n\t    while (p && !hasOwnProperty(p, name)) {\r\n\t        p = Object.getPrototypeOf(p);\r\n\t    }\r\n\t    if (!p) {\r\n\t        p = nodeInfo._root;\r\n\t    }\r\n\t    p[name] = (p[name] || 0) + (inc == null ? 1 : inc);\r\n\t}\r\n\r\n\tfunction resetCounter(name, val) {\r\n\t    name = \"_counter_\" + name;\r\n\t    nodeInfo[name] = val == null ? 0 : val;\r\n\t}\r\n\r\n\tfunction doCounters(a, f, def) {\r\n\t    for (var i = 0; i < a.length;) {\r\n\t        var name = a[i++];\r\n\t        var val = parseFloat(a[i]);\r\n\t        if (isNaN(val)) {\r\n\t            f(name, def);\r\n\t        } else {\r\n\t            f(name, val);\r\n\t            ++i;\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction updateCounters(style) {\r\n\t    var counterReset = getPropertyValue(style, \"counter-reset\");\r\n\t    if (counterReset) {\r\n\t        doCounters(splitProperty(counterReset, /^\\s+/), resetCounter, 0);\r\n\t    }\r\n\t    var counterIncrement = getPropertyValue(style, \"counter-increment\");\r\n\t    if (counterIncrement) {\r\n\t        doCounters(splitProperty(counterIncrement, /^\\s+/), incCounter, 1);\r\n\t    }\r\n\t}\r\n\r\n\tfunction parseColor$1(str, css) {\r\n\t    var color = kendo.parseColor(str, true);\r\n\t    if (color) {\r\n\t        color = color.toRGB();\r\n\t        if (css) {\r\n\t            color = color.toCssRgba();\r\n\t        } else if (color.a === 0) {\r\n\t            color = null;\r\n\t        }\r\n\t    }\r\n\t    return color;\r\n\t}\r\n\r\n\tfunction whenImagesAreActuallyLoaded(elements, callback) {\r\n\t    var pending = 0;\r\n\t    elements.forEach(function(el){\r\n\t        var images = el.querySelectorAll(\"img\");\r\n\t        for (var i = 0; i < images.length; ++i) {\r\n\t            var img = images[i];\r\n\t            if (!img.complete) {\r\n\t                pending++;\r\n\t                img.onload = img.onerror = next;\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t    if (!pending) {\r\n\t        next();\r\n\t    }\r\n\t    function next() {\r\n\t        if (--pending <= 0) {\r\n\t            callback();\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction cacheImages(element, callback) {\r\n\t    var urls = [];\r\n\t    function add(url) {\r\n\t        if (!IMAGE_CACHE[url]) {\r\n\t            IMAGE_CACHE[url] = true;\r\n\t            urls.push(url);\r\n\t        }\r\n\t    }\r\n\t    function dive(element){\r\n\t        if (/^img$/i.test(element.tagName)) {\r\n\t            add(element.src);\r\n\t        }\r\n\t        parseBackgroundImage(\r\n\t            getPropertyValue(\r\n\t                getComputedStyle(element), \"background-image\"\r\n\t            )\r\n\t        ).forEach(function(bg){\r\n\t            if (bg.type == \"url\") {\r\n\t                add(bg.url);\r\n\t            }\r\n\t        });\r\n\r\n\t        if (element.children) {\r\n\t            slice$1(element.children).forEach(dive);\r\n\t        }\r\n\t    }\r\n\r\n\t    if (Array.isArray(element)) {\r\n\t        element.forEach(dive);\r\n\t    } else {\r\n\t        dive(element);\r\n\t    }\r\n\r\n\t    var count = urls.length;\r\n\t    function next() {\r\n\t        if (--count <= 0) {\r\n\t            callback();\r\n\t        }\r\n\t    }\r\n\t    if (count === 0) {\r\n\t        next();\r\n\t    }\r\n\t    urls.forEach(function(url){\r\n\t        var img = IMAGE_CACHE[url] = new window.Image();\r\n\t        if (!(/^data:/i.test(url))) {\r\n\t            img.crossOrigin = \"Anonymous\";\r\n\t        }\r\n\t        img.src = url;\r\n\t        if (img.complete) {\r\n\t            next();\r\n\t        } else {\r\n\t            img.onload = next;\r\n\t            img.onerror = function() {\r\n\t                IMAGE_CACHE[url] = null;\r\n\t                next();\r\n\t            };\r\n\t        }\r\n\t    });\r\n\t}\r\n\r\n\tfunction alphaNumeral(n) {\r\n\t    var result = \"\";\r\n\t    do {\r\n\t        var r = n % 26;\r\n\t        result = String.fromCharCode(97 + r) + result;\r\n\t        n = Math.floor(n / 26);\r\n\t    } while (n > 0);\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction pushNodeInfo(element, style, group) {\r\n\t    nodeInfo = Object.create(nodeInfo);\r\n\t    nodeInfo[element.tagName.toLowerCase()] = {\r\n\t        element: element,\r\n\t        style: style\r\n\t    };\r\n\t    var decoration = getPropertyValue(style, \"text-decoration\");\r\n\t    if (decoration && decoration != \"none\") {\r\n\t        var color = getPropertyValue(style, \"color\");\r\n\t        decoration.split(/\\s+/g).forEach(function(name){\r\n\t            if (!nodeInfo[name]) {\r\n\t                nodeInfo[name] = color;\r\n\t            }\r\n\t        });\r\n\t    }\r\n\r\n\t    if (createsStackingContext(style)) {\r\n\t        nodeInfo._stackingContext = {\r\n\t            element: element,\r\n\t            group: group\r\n\t        };\r\n\t    }\r\n\t}\r\n\r\n\tfunction popNodeInfo() {\r\n\t    nodeInfo = Object.getPrototypeOf(nodeInfo);\r\n\t}\r\n\r\n\tfunction updateClipbox(path) {\r\n\t    if (nodeInfo._clipbox != null) {\r\n\t        var box = path.bbox(nodeInfo._matrix);\r\n\t        if (nodeInfo._clipbox) {\r\n\t            nodeInfo._clipbox = Rect.intersect(nodeInfo._clipbox, box);\r\n\t        } else {\r\n\t            nodeInfo._clipbox = box;\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction emptyClipbox() {\r\n\t    var cb = nodeInfo._clipbox;\r\n\t    if (cb == null) {\r\n\t        return true;\r\n\t    }\r\n\t    if (cb) {\r\n\t        return cb.width() === 0 || cb.height() === 0;\r\n\t    }\r\n\t}\r\n\r\n\tfunction createsStackingContext(style) {\r\n\t    function prop(name) { return getPropertyValue(style, name); }\r\n\t    if (prop(\"transform\") != \"none\" ||\r\n\t        prop(\"position\") != \"static\" ||\r\n\t        prop(\"z-index\") != \"auto\" ||\r\n\t        prop(\"opacity\") < 1) {\r\n\t        return true;\r\n\t    }\r\n\t}\r\n\r\n\tfunction getComputedStyle(element, pseudoElt) {\r\n\t    return window.getComputedStyle(element, pseudoElt || null);\r\n\t}\r\n\r\n\tfunction getPropertyValue(style, prop, defa) {\r\n\t    var val = style.getPropertyValue(prop);\r\n\t    if (val == null || val === \"\") {\r\n\t        if (browser.webkit) {\r\n\t            val = style.getPropertyValue(\"-webkit-\" + prop );\r\n\t        } else if (browser.mozilla) {\r\n\t            val = style.getPropertyValue(\"-moz-\" + prop );\r\n\t        } else if (browser.opera) {\r\n\t            val = style.getPropertyValue(\"-o-\" + prop);\r\n\t        } else if (browser.msie || browser.edge) {\r\n\t            val = style.getPropertyValue(\"-ms-\" + prop);\r\n\t        }\r\n\t    }\r\n\t    if (arguments.length > 2 && (val == null || val === \"\")) {\r\n\t        return defa;\r\n\t    } else {\r\n\t        return val;\r\n\t    }\r\n\t}\r\n\r\n\tfunction pleaseSetPropertyValue(style, prop, value, important) {\r\n\t    style.setProperty(prop, value, important);\r\n\t    if (browser.webkit) {\r\n\t        style.setProperty(\"-webkit-\" + prop, value, important);\r\n\t    } else if (browser.mozilla) {\r\n\t        style.setProperty(\"-moz-\" + prop, value, important);\r\n\t    } else if (browser.opera) {\r\n\t        style.setProperty(\"-o-\" + prop, value, important);\r\n\t    } else if (browser.msie || browser.edge) {\r\n\t        style.setProperty(\"-ms-\" + prop, value, important);\r\n\t        prop = \"ms\" + prop.replace(/(^|-)([a-z])/g, function(s, p1, p2){\r\n\t            return p1 + p2.toUpperCase();\r\n\t        });\r\n\t        style[prop] = value;\r\n\t    }\r\n\t}\r\n\r\n\tfunction getBorder(style, side) {\r\n\t    side = \"border-\" + side;\r\n\t    return {\r\n\t        width: parseFloat(getPropertyValue(style, side + \"-width\")),\r\n\t        style: getPropertyValue(style, side + \"-style\"),\r\n\t        color: parseColor$1(getPropertyValue(style, side + \"-color\"), true)\r\n\t    };\r\n\t}\r\n\r\n\tfunction saveStyle(element, func) {\r\n\t    var prev = element.style.cssText;\r\n\t    var result = func();\r\n\t    element.style.cssText = prev;\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction getBorderRadius(style, side) {\r\n\t    var r = getPropertyValue(style, \"border-\" + side + \"-radius\").split(/\\s+/g).map(parseFloat);\r\n\t    if (r.length == 1) {\r\n\t        r.push(r[0]);\r\n\t    }\r\n\t    return sanitizeRadius({ x: r[0], y: r[1] });\r\n\t}\r\n\r\n\tfunction getContentBox(element) {\r\n\t    var box = element.getBoundingClientRect();\r\n\t    box = innerBox(box, \"border-*-width\", element);\r\n\t    box = innerBox(box, \"padding-*\", element);\r\n\t    return box;\r\n\t}\r\n\r\n\tfunction innerBox(box, prop, element) {\r\n\t    var style, wt, wr, wb, wl;\r\n\t    if (typeof prop == \"string\") {\r\n\t        style = getComputedStyle(element);\r\n\t        wt = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"top\")));\r\n\t        wr = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"right\")));\r\n\t        wb = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"bottom\")));\r\n\t        wl = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"left\")));\r\n\t    }\r\n\t    else if (typeof prop == \"number\") {\r\n\t        wt = wr = wb = wl = prop;\r\n\t    }\r\n\t    return {\r\n\t        top    : box.top + wt,\r\n\t        right  : box.right - wr,\r\n\t        bottom : box.bottom - wb,\r\n\t        left   : box.left + wl,\r\n\t        width  : box.right - box.left - wr - wl,\r\n\t        height : box.bottom - box.top - wb - wt\r\n\t    };\r\n\t}\r\n\r\n\tfunction getTransform(style) {\r\n\t    var transform$$1 = getPropertyValue(style, \"transform\");\r\n\t    if (transform$$1 == \"none\") {\r\n\t        return null;\r\n\t    }\r\n\t    var matrix = /^\\s*matrix\\(\\s*(.*?)\\s*\\)\\s*$/.exec(transform$$1);\r\n\t    if (matrix) {\r\n\t        var origin = getPropertyValue(style, \"transform-origin\");\r\n\t        matrix = matrix[1].split(/\\s*,\\s*/g).map(parseFloat);\r\n\t        origin = origin.split(/\\s+/g).map(parseFloat);\r\n\t        return {\r\n\t            matrix: matrix,\r\n\t            origin: origin\r\n\t        };\r\n\t    }\r\n\t}\r\n\r\n\tfunction radiansToDegrees(radians) {\r\n\t    return ((180 * radians) / Math.PI) % 360;\r\n\t}\r\n\r\n\tfunction parseAngle(angle) {\r\n\t    var num = parseFloat(angle);\r\n\t    if (/grad$/.test(angle)) {\r\n\t        return Math.PI * num / 200;\r\n\t    }\r\n\t    else if (/rad$/.test(angle)) {\r\n\t        return num;\r\n\t    }\r\n\t    else if (/turn$/.test(angle)) {\r\n\t        return Math.PI * num * 2;\r\n\t    }\r\n\t    else if (/deg$/.test(angle)) {\r\n\t        return Math.PI * num / 180;\r\n\t    }\r\n\t}\r\n\r\n\tfunction setTransform(shape, m) {\r\n\t    m = new Matrix(m[0], m[1], m[2], m[3], m[4], m[5]);\r\n\t    shape.transform(m);\r\n\t    return m;\r\n\t}\r\n\r\n\tfunction setClipping(shape, clipPath) {\r\n\t    shape.clip(clipPath);\r\n\t}\r\n\r\n\tfunction addArcToPath(path, x, y, options) {\r\n\t    var points = new Arc$2([ x, y ], options).curvePoints(), i = 1;\r\n\t    while (i < points.length) {\r\n\t        path.curveTo(points[i++], points[i++], points[i++]);\r\n\t    }\r\n\t}\r\n\r\n\tfunction sanitizeRadius(r) {\r\n\t    if (r.x <= 0 || r.y <= 0) {\r\n\t        r.x = r.y = 0;\r\n\t    }\r\n\t    return r;\r\n\t}\r\n\r\n\tfunction adjustBorderRadiusForBox(box, rTL, rTR, rBR, rBL) {\r\n\t    // adjust border radiuses such that the sum of adjacent\r\n\t    // radiuses is not bigger than the length of the side.\r\n\t    // seems the correct algorithm is variant (3) from here:\r\n\t    // http://www.w3.org/Style/CSS/Tracker/issues/29?changelog\r\n\t    var tl_x = Math.max(0, rTL.x), tl_y = Math.max(0, rTL.y);\r\n\t    var tr_x = Math.max(0, rTR.x), tr_y = Math.max(0, rTR.y);\r\n\t    var br_x = Math.max(0, rBR.x), br_y = Math.max(0, rBR.y);\r\n\t    var bl_x = Math.max(0, rBL.x), bl_y = Math.max(0, rBL.y);\r\n\r\n\t    var f = Math.min(\r\n\t        box.width / (tl_x + tr_x),\r\n\t        box.height / (tr_y + br_y),\r\n\t        box.width / (br_x + bl_x),\r\n\t        box.height / (bl_y + tl_y)\r\n\t    );\r\n\r\n\t    if (f < 1) {\r\n\t        tl_x *= f; tl_y *= f;\r\n\t        tr_x *= f; tr_y *= f;\r\n\t        br_x *= f; br_y *= f;\r\n\t        bl_x *= f; bl_y *= f;\r\n\t    }\r\n\r\n\t    return {\r\n\t        tl: { x: tl_x, y: tl_y },\r\n\t        tr: { x: tr_x, y: tr_y },\r\n\t        br: { x: br_x, y: br_y },\r\n\t        bl: { x: bl_x, y: bl_y }\r\n\t    };\r\n\t}\r\n\r\n\tfunction elementRoundBox(element, box, type) {\r\n\t    var style = getComputedStyle(element);\r\n\r\n\t    var rTL = getBorderRadius(style, \"top-left\");\r\n\t    var rTR = getBorderRadius(style, \"top-right\");\r\n\t    var rBL = getBorderRadius(style, \"bottom-left\");\r\n\t    var rBR = getBorderRadius(style, \"bottom-right\");\r\n\r\n\t    if (type == \"padding\" || type == \"content\") {\r\n\t        var bt = getBorder(style, \"top\");\r\n\t        var br = getBorder(style, \"right\");\r\n\t        var bb = getBorder(style, \"bottom\");\r\n\t        var bl = getBorder(style, \"left\");\r\n\t        rTL.x -= bl.width; rTL.y -= bt.width;\r\n\t        rTR.x -= br.width; rTR.y -= bt.width;\r\n\t        rBR.x -= br.width; rBR.y -= bb.width;\r\n\t        rBL.x -= bl.width; rBL.y -= bb.width;\r\n\t        if (type == \"content\") {\r\n\t            var pt = parseFloat(getPropertyValue(style, \"padding-top\"));\r\n\t            var pr = parseFloat(getPropertyValue(style, \"padding-right\"));\r\n\t            var pb = parseFloat(getPropertyValue(style, \"padding-bottom\"));\r\n\t            var pl = parseFloat(getPropertyValue(style, \"padding-left\"));\r\n\t            rTL.x -= pl; rTL.y -= pt;\r\n\t            rTR.x -= pr; rTR.y -= pt;\r\n\t            rBR.x -= pr; rBR.y -= pb;\r\n\t            rBL.x -= pl; rBL.y -= pb;\r\n\t        }\r\n\t    }\r\n\r\n\t    if (typeof type == \"number\") {\r\n\t        rTL.x -= type; rTL.y -= type;\r\n\t        rTR.x -= type; rTR.y -= type;\r\n\t        rBR.x -= type; rBR.y -= type;\r\n\t        rBL.x -= type; rBL.y -= type;\r\n\t    }\r\n\r\n\t    return roundBox(box, rTL, rTR, rBR, rBL);\r\n\t}\r\n\r\n\t// Create a drawing.Path for a rounded rectangle.  Receives the\r\n\t// bounding box and the border-radiuses in CSS order (top-left,\r\n\t// top-right, bottom-right, bottom-left).  The radiuses must be\r\n\t// objects containing x (horiz. radius) and y (vertical radius).\r\n\tfunction roundBox(box, rTL0, rTR0, rBR0, rBL0) {\r\n\t    var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\r\n\t    var rTL = tmp.tl;\r\n\t    var rTR = tmp.tr;\r\n\t    var rBR = tmp.br;\r\n\t    var rBL = tmp.bl;\r\n\t    var path = new Path({ fill: null, stroke: null });\r\n\t    path.moveTo(box.left, box.top + rTL.y);\r\n\t    if (rTL.x) {\r\n\t        addArcToPath(path, box.left + rTL.x, box.top + rTL.y, {\r\n\t            startAngle: -180,\r\n\t            endAngle: -90,\r\n\t            radiusX: rTL.x,\r\n\t            radiusY: rTL.y\r\n\t        });\r\n\t    }\r\n\t    path.lineTo(box.right - rTR.x, box.top);\r\n\t    if (rTR.x) {\r\n\t        addArcToPath(path, box.right - rTR.x, box.top + rTR.y, {\r\n\t            startAngle: -90,\r\n\t            endAngle: 0,\r\n\t            radiusX: rTR.x,\r\n\t            radiusY: rTR.y\r\n\t        });\r\n\t    }\r\n\t    path.lineTo(box.right, box.bottom - rBR.y);\r\n\t    if (rBR.x) {\r\n\t        addArcToPath(path, box.right - rBR.x, box.bottom - rBR.y, {\r\n\t            startAngle: 0,\r\n\t            endAngle: 90,\r\n\t            radiusX: rBR.x,\r\n\t            radiusY: rBR.y\r\n\t        });\r\n\t    }\r\n\t    path.lineTo(box.left + rBL.x, box.bottom);\r\n\t    if (rBL.x) {\r\n\t        addArcToPath(path, box.left + rBL.x, box.bottom - rBL.y, {\r\n\t            startAngle: 90,\r\n\t            endAngle: 180,\r\n\t            radiusX: rBL.x,\r\n\t            radiusY: rBL.y\r\n\t        });\r\n\t    }\r\n\t    return path.close();\r\n\t}\r\n\r\n\tfunction formatCounter(val, style) {\r\n\t    var str = String(parseFloat(val));\r\n\t    switch (style) {\r\n\t      case \"decimal-leading-zero\":\r\n\t        if (str.length < 2) {\r\n\t            str = \"0\" + str;\r\n\t        }\r\n\t        return str;\r\n\t      case \"lower-roman\":\r\n\t        return arabicToRoman(val).toLowerCase();\r\n\t      case \"upper-roman\":\r\n\t        return arabicToRoman(val).toUpperCase();\r\n\t      case \"lower-latin\":\r\n\t      case \"lower-alpha\":\r\n\t        return alphaNumeral(val - 1);\r\n\t      case \"upper-latin\":\r\n\t      case \"upper-alpha\":\r\n\t        return alphaNumeral(val - 1).toUpperCase();\r\n\t      default:\r\n\t        return str;\r\n\t    }\r\n\t}\r\n\r\n\tfunction evalPseudoElementContent(element, content) {\r\n\t    function displayCounter(name, style, separator) {\r\n\t        if (!separator) {\r\n\t            return formatCounter(getCounter(name) || 0, style);\r\n\t        }\r\n\t        separator = separator.replace(/^\\s*([\"'])(.*)\\1\\s*$/, \"$2\");\r\n\t        return getAllCounters(name).map(function(val){\r\n\t            return formatCounter(val, style);\r\n\t        }).join(separator);\r\n\t    }\r\n\t    var a = splitProperty(content, /^\\s+/);\r\n\t    var result = [], m;\r\n\t    a.forEach(function(el){\r\n\t        var tmp;\r\n\t        if ((m = /^\\s*([\"'])(.*)\\1\\s*$/.exec(el))) {\r\n\t            result.push(m[2].replace(/\\\\([0-9a-f]{4})/gi, function(s, p){\r\n\t                return String.fromCharCode(parseInt(p, 16));\r\n\t            }));\r\n\t        }\r\n\t        else if ((m = /^\\s*counter\\((.*?)\\)\\s*$/.exec(el))) {\r\n\t            tmp = splitProperty(m[1]);\r\n\t            result.push(displayCounter(tmp[0], tmp[1]));\r\n\t        }\r\n\t        else if ((m = /^\\s*counters\\((.*?)\\)\\s*$/.exec(el))) {\r\n\t            tmp = splitProperty(m[1]);\r\n\t            result.push(displayCounter(tmp[0], tmp[2], tmp[1]));\r\n\t        }\r\n\t        else if ((m = /^\\s*attr\\((.*?)\\)\\s*$/.exec(el))) {\r\n\t            result.push(element.getAttribute(m[1]) || \"\");\r\n\t        }\r\n\t        else {\r\n\t            result.push(el);\r\n\t        }\r\n\t    });\r\n\t    return result.join(\"\");\r\n\t}\r\n\r\n\tfunction getCssText(style) {\r\n\t    if (style.cssText) {\r\n\t        return style.cssText;\r\n\t    }\r\n\t    // Status: NEW.  Report year: 2002.  Current year: 2014.\r\n\t    // Nice played, Mozillians.\r\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=137687\r\n\t    var result = [];\r\n\t    for (var i = 0; i < style.length; ++i) {\r\n\t        result.push(style[i] + \": \" + getPropertyValue(style, style[i]));\r\n\t    }\r\n\t    return result.join(\";\\n\");\r\n\t}\r\n\r\n\tfunction _renderWithPseudoElements(element, group) {\r\n\t    if (element.tagName == KENDO_PSEUDO_ELEMENT) {\r\n\t        _renderElement(element, group);\r\n\t        return;\r\n\t    }\r\n\t    var fake = [];\r\n\t    function pseudo(kind, place) {\r\n\t        var style = getComputedStyle(element, kind);\r\n\t        updateCounters(style);\r\n\t        if (style.content && style.content != \"normal\" && style.content != \"none\" && style.width != \"0px\") {\r\n\t            var psel = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\r\n\t            psel.style.cssText = getCssText(style);\r\n\t            psel.textContent = evalPseudoElementContent(element, style.content);\r\n\t            element.insertBefore(psel, place);\r\n\t            fake.push(psel);\r\n\t        }\r\n\t    }\r\n\t    pseudo(\":before\", element.firstChild);\r\n\t    pseudo(\":after\", null);\r\n\t    var saveClass = element.className;\r\n\t    element.className += \" kendo-pdf-hide-pseudo-elements\";\r\n\t    _renderElement(element, group);\r\n\t    element.className = saveClass;\r\n\t    fake.forEach(function(el){ element.removeChild(el); });\r\n\t}\r\n\r\n\tfunction _renderElement(element, group) {\r\n\t    var style = getComputedStyle(element);\r\n\r\n\t    var top = getBorder(style, \"top\");\r\n\t    var right = getBorder(style, \"right\");\r\n\t    var bottom = getBorder(style, \"bottom\");\r\n\t    var left = getBorder(style, \"left\");\r\n\r\n\t    var rTL0 = getBorderRadius(style, \"top-left\");\r\n\t    var rTR0 = getBorderRadius(style, \"top-right\");\r\n\t    var rBL0 = getBorderRadius(style, \"bottom-left\");\r\n\t    var rBR0 = getBorderRadius(style, \"bottom-right\");\r\n\r\n\t    var dir = getPropertyValue(style, \"direction\");\r\n\r\n\t    var backgroundColor = getPropertyValue(style, \"background-color\");\r\n\t    backgroundColor = parseColor$1(backgroundColor);\r\n\r\n\t    var backgroundImage = parseBackgroundImage( getPropertyValue(style, \"background-image\") );\r\n\t    var backgroundRepeat = splitProperty( getPropertyValue(style, \"background-repeat\") );\r\n\t    var backgroundPosition = splitProperty( getPropertyValue(style, \"background-position\") );\r\n\t    var backgroundOrigin = splitProperty( getPropertyValue(style, \"background-origin\") );\r\n\t    var backgroundSize = splitProperty( getPropertyValue(style, \"background-size\") );\r\n\r\n\t    if (browser.msie && browser.version < 10) {\r\n\t        // IE9 hacks.  getPropertyValue won't return the correct\r\n\t        // value.  Sucks that we have to do it here, I'd prefer to\r\n\t        // move it in getPropertyValue, but we don't have the\r\n\t        // element.\r\n\t        backgroundPosition = splitProperty(element.currentStyle.backgroundPosition);\r\n\t    }\r\n\r\n\t    var innerbox = innerBox(element.getBoundingClientRect(), \"border-*-width\", element);\r\n\r\n\t    // CSS \"clip\" property - if present, replace the group with a\r\n\t    // new one which is clipped.  This must happen before drawing\r\n\t    // the borders and background.\r\n\t    (function(){\r\n\t        var clip = getPropertyValue(style, \"clip\");\r\n\t        var m = /^\\s*rect\\((.*)\\)\\s*$/.exec(clip);\r\n\t        if (m) {\r\n\t            var a = m[1].split(/[ ,]+/g);\r\n\t            var top = a[0] == \"auto\" ? innerbox.top : parseFloat(a[0]) + innerbox.top;\r\n\t            var right = a[1] == \"auto\" ? innerbox.right : parseFloat(a[1]) + innerbox.left;\r\n\t            var bottom = a[2] == \"auto\" ? innerbox.bottom : parseFloat(a[2]) + innerbox.top;\r\n\t            var left = a[3] == \"auto\" ? innerbox.left : parseFloat(a[3]) + innerbox.left;\r\n\t            var tmp = new Group();\r\n\t            var clipPath = new Path()\r\n\t                .moveTo(left, top)\r\n\t                .lineTo(right, top)\r\n\t                .lineTo(right, bottom)\r\n\t                .lineTo(left, bottom)\r\n\t                .close();\r\n\t            setClipping(tmp, clipPath);\r\n\t            group.append(tmp);\r\n\t            group = tmp;\r\n\t            updateClipbox(clipPath);\r\n\t        }\r\n\t    })();\r\n\r\n\t    var boxes, i, cells;\r\n\t    var display = getPropertyValue(style, \"display\");\r\n\r\n\t    if (display == \"table-row\") {\r\n\t        // because of rowspan/colspan, we shouldn't draw background of table row elements on the\r\n\t        // box given by its getBoundingClientRect, because if we do we risk overwritting a\r\n\t        // previously rendered cell.  https://github.com/telerik/kendo/issues/4881\r\n\t        boxes = [];\r\n\t        for (i = 0, cells = element.children; i < cells.length; ++i) {\r\n\t            boxes.push(cells[i].getBoundingClientRect());\r\n\t        }\r\n\t    } else {\r\n\t        boxes = element.getClientRects();\r\n\t        if (boxes.length == 1) {\r\n\t            // Workaround the missing borders in Chrome!  getClientRects() boxes contains values\r\n\t            // rounded to integer.  getBoundingClientRect() appears to work fine.  We still need\r\n\t            // getClientRects() to support cases where there are more boxes (continued inline\r\n\t            // elements that might have border/background).\r\n\t            boxes = [ element.getBoundingClientRect() ];\r\n\t        }\r\n\t    }\r\n\r\n\t    // This function workarounds another Chrome bug, where boxes returned for a table with\r\n\t    // border-collapse: collapse will overlap the table border.  Our rendering is not perfect in\r\n\t    // such case anyway, but with this is better than without it.\r\n\t    boxes = adjustBoxes(boxes);\r\n\r\n\t    for (i = 0; i < boxes.length; ++i) {\r\n\t        drawOneBox(boxes[i], i === 0, i == boxes.length - 1);\r\n\t    }\r\n\r\n\t    // Render links as separate groups.  We can't use boxes returned by element's getClientRects\r\n\t    // because if display type is \"inline\" (default for <a>), boxes will not include the height of\r\n\t    // images inside.  https://github.com/telerik/kendo-ui-core/issues/3359\r\n\t    if (element.tagName == \"A\" && element.href && !/^#?$/.test(element.getAttribute(\"href\"))) {\r\n\t        if (!nodeInfo._avoidLinks || !matches(element, nodeInfo._avoidLinks)) {\r\n\t            var r = document.createRange();\r\n\t            r.selectNodeContents(element);\r\n\t            slice$1(r.getClientRects()).forEach(function(box){\r\n\t                var g = new Group();\r\n\t                g._pdfLink = {\r\n\t                    url    : element.href,\r\n\t                    top    : box.top,\r\n\t                    right  : box.right,\r\n\t                    bottom : box.bottom,\r\n\t                    left   : box.left\r\n\t                };\r\n\t                group.append(g);\r\n\t            });\r\n\t        }\r\n\t    }\r\n\r\n\t    if (boxes.length > 0 && display == \"list-item\" && !element.getAttribute(\"kendo-no-bullet\")) {\r\n\t        drawBullet(boxes[0]);\r\n\t    }\r\n\r\n\t    // overflow: hidden/auto - if present, replace the group with\r\n\t    // a new one clipped by the inner box.\r\n\t    (function(){\r\n\t        function clipit() {\r\n\t            var clipPath = elementRoundBox(element, innerbox, \"padding\");\r\n\t            var tmp = new Group();\r\n\t            setClipping(tmp, clipPath);\r\n\t            group.append(tmp);\r\n\t            group = tmp;\r\n\t            updateClipbox(clipPath);\r\n\t        }\r\n\t        if (isFormField(element)) {\r\n\t            clipit();\r\n\t        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow\"))) {\r\n\t            clipit();\r\n\t        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-x\"))) {\r\n\t            clipit();\r\n\t        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-y\"))) {\r\n\t            clipit();\r\n\t        }\r\n\t    })();\r\n\r\n\t    if (!maybeRenderWidget(element, group)) {\r\n\t        renderContents(element, group);\r\n\t    }\r\n\r\n\t    return group; // only utility functions after this line.\r\n\r\n\t    function adjustBoxes(boxes) {\r\n\t        if (/^td$/i.test(element.tagName)) {\r\n\t            var table = nodeInfo.table;\r\n\t            if (table && getPropertyValue(table.style, \"border-collapse\") == \"collapse\") {\r\n\t                var tableBorderLeft = getBorder(table.style, \"left\").width;\r\n\t                var tableBorderTop = getBorder(table.style, \"top\").width;\r\n\t                // check if we need to adjust\r\n\t                if (tableBorderLeft === 0 && tableBorderTop === 0) {\r\n\t                    return boxes; // nope\r\n\t                }\r\n\t                var tableBox = table.element.getBoundingClientRect();\r\n\t                var firstCell = table.element.rows[0].cells[0];\r\n\t                var firstCellBox = firstCell.getBoundingClientRect();\r\n\t                if (firstCellBox.top == tableBox.top || firstCellBox.left == tableBox.left) {\r\n\t                    return slice$1(boxes).map(function(box){\r\n\t                        return {\r\n\t                            left   : box.left + tableBorderLeft,\r\n\t                            top    : box.top + tableBorderTop,\r\n\t                            right  : box.right + tableBorderLeft,\r\n\t                            bottom : box.bottom + tableBorderTop,\r\n\t                            height : box.height,\r\n\t                            width  : box.width\r\n\t                        };\r\n\t                    });\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return boxes;\r\n\t    }\r\n\r\n\t    // this function will be called to draw each border.  it\r\n\t    // draws starting at origin and the resulted path must be\r\n\t    // translated/rotated to be placed in the proper position.\r\n\t    //\r\n\t    // arguments are named as if it draws the top border:\r\n\t    //\r\n\t    //    - `len` the length of the edge\r\n\t    //    - `Wtop` the width of the edge (i.e. border-top-width)\r\n\t    //    - `Wleft` the width of the left edge (border-left-width)\r\n\t    //    - `Wright` the width of the right edge\r\n\t    //    - `rl` and `rl` -- the border radius on the left and right\r\n\t    //      (objects containing x and y, for horiz/vertical radius)\r\n\t    //    - `transform` -- transformation to apply\r\n\t    //\r\n\t    function drawEdge(color, len, Wtop, Wleft, Wright, rl, rr, transform$$1) {\r\n\t        if (Wtop <= 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var path, edge = new Group();\r\n\t        setTransform(edge, transform$$1);\r\n\t        group.append(edge);\r\n\r\n\t        sanitizeRadius(rl);\r\n\t        sanitizeRadius(rr);\r\n\r\n\t        // draw main border.  this is the area without the rounded corners\r\n\t        path = new Path({\r\n\t            fill: { color: color },\r\n\t            stroke: null\r\n\t        });\r\n\t        edge.append(path);\r\n\t        path.moveTo(rl.x ? Math.max(rl.x, Wleft) : 0, 0)\r\n\t            .lineTo(len - (rr.x ? Math.max(rr.x, Wright) : 0), 0)\r\n\t            .lineTo(len - Math.max(rr.x, Wright), Wtop)\r\n\t            .lineTo(Math.max(rl.x, Wleft), Wtop)\r\n\t            .close();\r\n\r\n\t        if (rl.x) {\r\n\t            drawRoundCorner(Wleft, rl, [ -1, 0, 0, 1, rl.x, 0 ]);\r\n\t        }\r\n\r\n\t        if (rr.x) {\r\n\t            drawRoundCorner(Wright, rr, [ 1, 0, 0, 1, len - rr.x, 0 ]);\r\n\t        }\r\n\r\n\t        // draws one round corner, starting at origin (needs to be\r\n\t        // translated/rotated to be placed properly).\r\n\t        function drawRoundCorner(Wright, r, transform$$1) {\r\n\t            var angle = Math.PI/2 * Wright / (Wright + Wtop);\r\n\r\n\t            // not sanitizing this one, because negative values\r\n\t            // are useful to fill the box correctly.\r\n\t            var ri = {\r\n\t                x: r.x - Wright,\r\n\t                y: r.y - Wtop\r\n\t            };\r\n\r\n\t            var path = new Path({\r\n\t                fill: { color: color },\r\n\t                stroke: null\r\n\t            }).moveTo(0, 0);\r\n\r\n\t            setTransform(path, transform$$1);\r\n\r\n\t            addArcToPath(path, 0, r.y, {\r\n\t                startAngle: -90,\r\n\t                endAngle: -radiansToDegrees(angle),\r\n\t                radiusX: r.x,\r\n\t                radiusY: r.y\r\n\t            });\r\n\r\n\t            if (ri.x > 0 && ri.y > 0) {\r\n\t                path.lineTo(ri.x * Math.cos(angle), r.y - ri.y * Math.sin(angle));\r\n\t                addArcToPath(path, 0, r.y, {\r\n\t                    startAngle: -radiansToDegrees(angle),\r\n\t                    endAngle: -90,\r\n\t                    radiusX: ri.x,\r\n\t                    radiusY: ri.y,\r\n\t                    anticlockwise: true\r\n\t                });\r\n\t            }\r\n\t            else if (ri.x > 0) {\r\n\t                path.lineTo(ri.x, Wtop)\r\n\t                    .lineTo(0, Wtop);\r\n\t            }\r\n\t            else {\r\n\t                path.lineTo(ri.x, Wtop)\r\n\t                    .lineTo(ri.x, 0);\r\n\t            }\r\n\r\n\t            edge.append(path.close());\r\n\t        }\r\n\t    }\r\n\r\n\t    function drawBackground(box) {\r\n\t        var background = new Group();\r\n\t        setClipping(background, roundBox(box, rTL0, rTR0, rBR0, rBL0));\r\n\t        group.append(background);\r\n\r\n\t        if (backgroundColor) {\r\n\t            var path = new Path({\r\n\t                fill: { color: backgroundColor.toCssRgba() },\r\n\t                stroke: null\r\n\t            });\r\n\t            path.moveTo(box.left, box.top)\r\n\t                .lineTo(box.right, box.top)\r\n\t                .lineTo(box.right, box.bottom)\r\n\t                .lineTo(box.left, box.bottom)\r\n\t                .close();\r\n\t            background.append(path);\r\n\t        }\r\n\r\n\t        for (var i = backgroundImage.length; --i >= 0;) {\r\n\t            drawOneBackground(\r\n\t                background, box,\r\n\t                backgroundImage[i],\r\n\t                backgroundRepeat[i % backgroundRepeat.length],\r\n\t                backgroundPosition[i % backgroundPosition.length],\r\n\t                backgroundOrigin[i % backgroundOrigin.length],\r\n\t                backgroundSize[i % backgroundSize.length]\r\n\t            );\r\n\t        }\r\n\t    }\r\n\r\n\t    function drawOneBackground(group, box, background, backgroundRepeat, backgroundPosition, backgroundOrigin, backgroundSize) {\r\n\t        if (!background || (background == \"none\")) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        if (background.type == \"url\") {\r\n\t            // SVG taints the canvas, can't draw it.\r\n\t            if (/^url\\(\\\"data:image\\/svg/i.test(background.url)) {\r\n\t                return;\r\n\t            }\r\n\t            var img = IMAGE_CACHE[background.url];\r\n\t            if (img && img.width > 0 && img.height > 0) {\r\n\t                drawBackgroundImage(group, box, img.width, img.height, function(group, rect){\r\n\t                    group.append(new Image$1(background.url, rect));\r\n\t                });\r\n\t            }\r\n\t        } else if (background.type == \"linear\") {\r\n\t            drawBackgroundImage(group, box, box.width, box.height, gradientRenderer(background));\r\n\t        } else {\r\n\t            return;\r\n\t        }\r\n\r\n\t        function drawBackgroundImage(group, box, img_width, img_height, renderBG) {\r\n\t            var aspect_ratio = img_width / img_height, f;\r\n\r\n\t            // for background-origin: border-box the box is already appropriate\r\n\t            var orgBox = box;\r\n\t            if (backgroundOrigin == \"content-box\") {\r\n\t                orgBox = innerBox(orgBox, \"border-*-width\", element);\r\n\t                orgBox = innerBox(orgBox, \"padding-*\", element);\r\n\t            } else if (backgroundOrigin == \"padding-box\") {\r\n\t                orgBox = innerBox(orgBox, \"border-*-width\", element);\r\n\t            }\r\n\r\n\t            if (!/^\\s*auto(\\s+auto)?\\s*$/.test(backgroundSize)) {\r\n\t                if (backgroundSize == \"contain\") {\r\n\t                    f = Math.min(orgBox.width / img_width,\r\n\t                                 orgBox.height / img_height);\r\n\t                    img_width *= f;\r\n\t                    img_height *= f;\r\n\t                }\r\n\t                else if (backgroundSize == \"cover\") {\r\n\t                    f = Math.max(orgBox.width / img_width,\r\n\t                                 orgBox.height / img_height);\r\n\t                    img_width *= f;\r\n\t                    img_height *= f;\r\n\t                }\r\n\t                else {\r\n\t                    var size = backgroundSize.split(/\\s+/g);\r\n\t                    // compute width\r\n\t                    if (/%$/.test(size[0])) {\r\n\t                        img_width = orgBox.width * parseFloat(size[0]) / 100;\r\n\t                    } else {\r\n\t                        img_width = parseFloat(size[0]);\r\n\t                    }\r\n\t                    // compute height\r\n\t                    if (size.length == 1 || size[1] == \"auto\") {\r\n\t                        img_height = img_width / aspect_ratio;\r\n\t                    } else if (/%$/.test(size[1])) {\r\n\t                        img_height = orgBox.height * parseFloat(size[1]) / 100;\r\n\t                    } else {\r\n\t                        img_height = parseFloat(size[1]);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            var pos = String(backgroundPosition);\r\n\r\n\t            // IE sometimes reports single-word positions\r\n\t            // https://github.com/telerik/kendo-ui-core/issues/2786\r\n\t            //\r\n\t            // it seems to switch to percentages when the horizontal\r\n\t            // position is not \"center\", therefore we don't handle\r\n\t            // multi-word cases here.  All other browsers return\r\n\t            // percentages or pixels instead of keywords.  At least\r\n\t            // for now...\r\n\t            switch (pos) {\r\n\t              case \"bottom\" : pos = \"50% 100%\"; break;\r\n\t              case \"top\"    : pos = \"50% 0\"; break;\r\n\t              case \"left\"   : pos = \"0 50%\"; break;\r\n\t              case \"right\"  : pos = \"100% 50%\"; break;\r\n\t              case \"center\" : pos = \"50% 50%\"; break;\r\n\t            }\r\n\r\n\t            pos = pos.split(/\\s+/);\r\n\t            if (pos.length == 1) {\r\n\t                pos[1] = \"50%\";\r\n\t            }\r\n\r\n\t            if (/%$/.test(pos[0])) {\r\n\t                pos[0] = parseFloat(pos[0]) / 100 * (orgBox.width - img_width);\r\n\t            } else {\r\n\t                pos[0] = parseFloat(pos[0]);\r\n\t            }\r\n\t            if (/%$/.test(pos[1])) {\r\n\t                pos[1] = parseFloat(pos[1]) / 100 * (orgBox.height - img_height);\r\n\t            } else {\r\n\t                pos[1] = parseFloat(pos[1]);\r\n\t            }\r\n\r\n\t            var rect = new Rect([ orgBox.left + pos[0], orgBox.top + pos[1] ], [ img_width, img_height ]);\r\n\r\n\t            // XXX: background-repeat could be implemented more\r\n\t            //      efficiently as a fill pattern (at least for PDF\r\n\t            //      output, probably SVG too).\r\n\r\n\t            function rewX() {\r\n\t                while (rect.origin.x > box.left) {\r\n\t                    rect.origin.x -= img_width;\r\n\t                }\r\n\t            }\r\n\r\n\t            function rewY() {\r\n\t                while (rect.origin.y > box.top) {\r\n\t                    rect.origin.y -= img_height;\r\n\t                }\r\n\t            }\r\n\r\n\t            function repeatX() {\r\n\t                while (rect.origin.x < box.right) {\r\n\t                    renderBG(group, rect.clone());\r\n\t                    rect.origin.x += img_width;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (backgroundRepeat == \"no-repeat\") {\r\n\t                renderBG(group, rect);\r\n\t            }\r\n\t            else if (backgroundRepeat == \"repeat-x\") {\r\n\t                rewX();\r\n\t                repeatX();\r\n\t            }\r\n\t            else if (backgroundRepeat == \"repeat-y\") {\r\n\t                rewY();\r\n\t                while (rect.origin.y < box.bottom) {\r\n\t                    renderBG(group, rect.clone());\r\n\t                    rect.origin.y += img_height;\r\n\t                }\r\n\t            }\r\n\t            else if (backgroundRepeat == \"repeat\") {\r\n\t                rewX();\r\n\t                rewY();\r\n\t                var origin = rect.origin.clone();\r\n\t                while (rect.origin.y < box.bottom) {\r\n\t                    rect.origin.x = origin.x;\r\n\t                    repeatX();\r\n\t                    rect.origin.y += img_height;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function drawBullet() {\r\n\t        var listStyleType = getPropertyValue(style, \"list-style-type\");\r\n\t        if (listStyleType == \"none\") {\r\n\t            return;\r\n\t        }\r\n\t        var listStylePosition = getPropertyValue(style, \"list-style-position\");\r\n\r\n\t        function _drawBullet(f) {\r\n\t            saveStyle(element, function(){\r\n\t                element.style.position = \"relative\";\r\n\t                var bullet = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\r\n\t                bullet.style.position = \"absolute\";\r\n\t                bullet.style.boxSizing = \"border-box\";\r\n\t                if (listStylePosition == \"outside\") {\r\n\t                    bullet.style.width = \"6em\";\r\n\t                    bullet.style.left = \"-6.8em\";\r\n\t                    bullet.style.textAlign = \"right\";\r\n\t                } else {\r\n\t                    bullet.style.left = \"0px\";\r\n\t                }\r\n\t                f(bullet);\r\n\t                element.insertBefore(bullet, element.firstChild);\r\n\t                renderElement(bullet, group);\r\n\t                element.removeChild(bullet);\r\n\t            });\r\n\t        }\r\n\r\n\t        function elementIndex(f) {\r\n\t            var a = element.parentNode.children;\r\n\t            var k = element.getAttribute(\"kendo-split-index\");\r\n\t            if (k != null) {\r\n\t                return f(k|0, a.length);\r\n\t            }\r\n\t            for (var i = 0; i < a.length; ++i) {\r\n\t                if (a[i] === element) {\r\n\t                    return f(i, a.length);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        switch (listStyleType) {\r\n\t          case \"circle\":\r\n\t          case \"disc\":\r\n\t          case \"square\":\r\n\t            _drawBullet(function(bullet){\r\n\t                // XXX: the science behind these values is called \"trial and error\".\r\n\t                bullet.style.fontSize = \"60%\";\r\n\t                bullet.style.lineHeight = \"200%\";\r\n\t                bullet.style.paddingRight = \"0.5em\";\r\n\t                bullet.style.fontFamily = \"DejaVu Serif\";\r\n\t                bullet.innerHTML = {\r\n\t                    \"disc\"   : \"\\u25cf\",\r\n\t                    \"circle\" : \"\\u25ef\",\r\n\t                    \"square\" : \"\\u25a0\"\r\n\t                }[listStyleType];\r\n\t            });\r\n\t            break;\r\n\r\n\t          case \"decimal\":\r\n\t          case \"decimal-leading-zero\":\r\n\t            _drawBullet(function(bullet){\r\n\t                elementIndex(function(idx){\r\n\t                    ++idx;\r\n\t                    if (listStyleType == \"decimal-leading-zero\" && idx < 10) {\r\n\t                        idx = \"0\" + idx;\r\n\t                    }\r\n\t                    bullet.innerHTML = idx + \".\";\r\n\t                });\r\n\t            });\r\n\t            break;\r\n\r\n\t          case \"lower-roman\":\r\n\t          case \"upper-roman\":\r\n\t            _drawBullet(function(bullet){\r\n\t                elementIndex(function(idx){\r\n\t                    idx = arabicToRoman(idx + 1);\r\n\t                    if (listStyleType == \"upper-roman\") {\r\n\t                        idx = idx.toUpperCase();\r\n\t                    }\r\n\t                    bullet.innerHTML = idx + \".\";\r\n\t                });\r\n\t            });\r\n\t            break;\r\n\r\n\t          case \"lower-latin\":\r\n\t          case \"lower-alpha\":\r\n\t          case \"upper-latin\":\r\n\t          case \"upper-alpha\":\r\n\t            _drawBullet(function(bullet){\r\n\t                elementIndex(function(idx){\r\n\t                    idx = alphaNumeral(idx);\r\n\t                    if (/^upper/i.test(listStyleType)) {\r\n\t                        idx = idx.toUpperCase();\r\n\t                    }\r\n\t                    bullet.innerHTML = idx + \".\";\r\n\t                });\r\n\t            });\r\n\t            break;\r\n\t        }\r\n\t    }\r\n\r\n\t    // draws a single border box\r\n\t    function drawOneBox(box, isFirst, isLast) {\r\n\t        if (box.width === 0 || box.height === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        drawBackground(box);\r\n\r\n\t        var shouldDrawLeft = (left.width > 0 && ((isFirst && dir == \"ltr\") || (isLast && dir == \"rtl\")));\r\n\t        var shouldDrawRight = (right.width > 0 && ((isLast && dir == \"ltr\") || (isFirst && dir == \"rtl\")));\r\n\r\n\t        // The most general case is that the 4 borders have different widths and border\r\n\t        // radiuses.  The way that is handled is by drawing 3 Paths for each border: the\r\n\t        // straight line, and two round corners which represent half of the entire rounded\r\n\t        // corner.  To simplify code those shapes are drawed at origin (by the drawEdge\r\n\t        // function), then translated/rotated into the right position.\r\n\t        //\r\n\t        // However, this leads to poor results due to rounding in the simpler cases where\r\n\t        // borders are straight lines.  Therefore we handle a few such cases separately with\r\n\t        // straight lines. C^wC^wC^w -- nope, scratch that.  poor rendering was because of a bug\r\n\t        // in Chrome (getClientRects() returns rounded integer values rather than exact floats.\r\n\t        // web dev is still a ghetto.)\r\n\r\n\t        // first, just in case there is no border...\r\n\t        if (top.width === 0 && left.width === 0 && right.width === 0 && bottom.width === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        // START paint borders\r\n\t        // if all borders have equal colors...\r\n\t        if (top.color == right.color && top.color == bottom.color && top.color == left.color) {\r\n\r\n\t            // if same widths too, we can draw the whole border by stroking a single path.\r\n\t            if (top.width == right.width && top.width == bottom.width && top.width == left.width)\r\n\t            {\r\n\t                if (shouldDrawLeft && shouldDrawRight) {\r\n\t                    // reduce box by half the border width, so we can draw it by stroking.\r\n\t                    box = innerBox(box, top.width/2);\r\n\r\n\t                    // adjust the border radiuses, again by top.width/2, and make the path element.\r\n\t                    var path = elementRoundBox(element, box, top.width/2);\r\n\t                    path.options.stroke = {\r\n\t                        color: top.color,\r\n\t                        width: top.width\r\n\t                    };\r\n\t                    group.append(path);\r\n\t                    return;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        // if border radiuses are zero and widths are at most one pixel, we can again use simple\r\n\t        // paths.\r\n\t        if (rTL0.x === 0 && rTR0.x === 0 && rBR0.x === 0 && rBL0.x === 0) {\r\n\t            // alright, 1.9px will do as well.  the difference in color blending should not be\r\n\t            // noticeable.\r\n\t            if (top.width < 2 && left.width < 2 && right.width < 2 && bottom.width < 2) {\r\n\t                // top border\r\n\t                if (top.width > 0) {\r\n\t                    group.append(\r\n\t                        new Path({\r\n\t                            stroke: { width: top.width, color: top.color }\r\n\t                        })\r\n\t                            .moveTo(box.left, box.top + top.width/2)\r\n\t                            .lineTo(box.right, box.top + top.width/2)\r\n\t                    );\r\n\t                }\r\n\r\n\t                // bottom border\r\n\t                if (bottom.width > 0) {\r\n\t                    group.append(\r\n\t                        new Path({\r\n\t                            stroke: { width: bottom.width, color: bottom.color }\r\n\t                        })\r\n\t                            .moveTo(box.left, box.bottom - bottom.width/2)\r\n\t                            .lineTo(box.right, box.bottom - bottom.width/2)\r\n\t                    );\r\n\t                }\r\n\r\n\t                // left border\r\n\t                if (shouldDrawLeft) {\r\n\t                    group.append(\r\n\t                        new Path({\r\n\t                            stroke: { width: left.width, color: left.color }\r\n\t                        })\r\n\t                            .moveTo(box.left + left.width/2, box.top)\r\n\t                            .lineTo(box.left + left.width/2, box.bottom)\r\n\t                    );\r\n\t                }\r\n\r\n\t                // right border\r\n\t                if (shouldDrawRight) {\r\n\t                    group.append(\r\n\t                        new Path({\r\n\t                            stroke: { width: right.width, color: right.color }\r\n\t                        })\r\n\t                            .moveTo(box.right - right.width/2, box.top)\r\n\t                            .lineTo(box.right - right.width/2, box.bottom)\r\n\t                    );\r\n\t                }\r\n\r\n\t                return;\r\n\t            }\r\n\t        }\r\n\t        // END paint borders\r\n\r\n\t        var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\r\n\t        var rTL = tmp.tl;\r\n\t        var rTR = tmp.tr;\r\n\t        var rBR = tmp.br;\r\n\t        var rBL = tmp.bl;\r\n\r\n\t        // top border\r\n\t        drawEdge(top.color,\r\n\t                 box.width, top.width, left.width, right.width,\r\n\t                 rTL, rTR,\r\n\t                 [ 1, 0, 0, 1, box.left, box.top ]);\r\n\r\n\t        // bottom border\r\n\t        drawEdge(bottom.color,\r\n\t                 box.width, bottom.width, right.width, left.width,\r\n\t                 rBR, rBL,\r\n\t                 [ -1, 0, 0, -1, box.right, box.bottom ]);\r\n\r\n\t        // for left/right borders we need to invert the border-radiuses\r\n\t        function inv(p) {\r\n\t            return { x: p.y, y: p.x };\r\n\t        }\r\n\r\n\t        // left border\r\n\t        drawEdge(left.color,\r\n\t                 box.height, left.width, bottom.width, top.width,\r\n\t                 inv(rBL), inv(rTL),\r\n\t                 [ 0, -1, 1, 0, box.left, box.bottom ]);\r\n\r\n\t        // right border\r\n\t        drawEdge(right.color,\r\n\t                 box.height, right.width, top.width, bottom.width,\r\n\t                 inv(rTR), inv(rBR),\r\n\t                 [ 0, 1, -1, 0, box.right, box.top ]);\r\n\t    }\r\n\t}\r\n\r\n\tfunction gradientRenderer(gradient) {\r\n\t    return function(group, rect) {\r\n\t        var width = rect.width(), height = rect.height();\r\n\r\n\t        switch (gradient.type) {\r\n\t          case \"linear\":\r\n\r\n\t            // figure out the angle.\r\n\t            var angle = gradient.angle != null ? gradient.angle : Math.PI;\r\n\t            switch (gradient.to) {\r\n\t              case \"top\":\r\n\t                angle = 0;\r\n\t                break;\r\n\t              case \"left\":\r\n\t                angle = -Math.PI / 2;\r\n\t                break;\r\n\t              case \"bottom\":\r\n\t                angle = Math.PI;\r\n\t                break;\r\n\t              case \"right\":\r\n\t                angle = Math.PI / 2;\r\n\t                break;\r\n\t              case \"top left\": case \"left top\":\r\n\t                angle = -Math.atan2(height, width);\r\n\t                break;\r\n\t              case \"top right\": case \"right top\":\r\n\t                angle = Math.atan2(height, width);\r\n\t                break;\r\n\t              case \"bottom left\": case \"left bottom\":\r\n\t                angle = Math.PI + Math.atan2(height, width);\r\n\t                break;\r\n\t              case \"bottom right\": case \"right bottom\":\r\n\t                angle = Math.PI - Math.atan2(height, width);\r\n\t                break;\r\n\t            }\r\n\r\n\t            if (gradient.reverse) {\r\n\t                angle -= Math.PI;\r\n\t            }\r\n\r\n\t            // limit the angle between 0..2PI\r\n\t            angle %= 2 * Math.PI;\r\n\t            if (angle < 0) {\r\n\t                angle += 2 * Math.PI;\r\n\t            }\r\n\r\n\t            // compute gradient's start/end points.  here len is the length of the gradient line\r\n\t            // and x,y is the end point relative to the center of the rectangle in conventional\r\n\t            // (math) axis direction.\r\n\r\n\t            // this is the original (unscaled) length of the gradient line.  needed to deal with\r\n\t            // absolutely positioned color stops.  formula from the CSS spec:\r\n\t            // http://dev.w3.org/csswg/css-images-3/#linear-gradient-syntax\r\n\t            var pxlen = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle));\r\n\r\n\t            // The math below is pretty simple, but it took a while to figure out.  We compute x\r\n\t            // and y, the *end* of the gradient line.  However, we want to transform them into\r\n\t            // element-based coordinates (SVG's gradientUnits=\"objectBoundingBox\").  That means,\r\n\t            // x=0 is the left edge, x=1 is the right edge, y=0 is the top edge and y=1 is the\r\n\t            // bottom edge.\r\n\t            //\r\n\t            // A naive approach would use the original angle for these calculations.  Say we'd\r\n\t            // like to draw a gradient angled at 45deg in a 100x400 box.  When we use\r\n\t            // objectBoundingBox, the renderer will draw it in a 1x1 *square* box, and then\r\n\t            // scale that to the desired dimensions.  The 45deg angle will look more like 70deg\r\n\t            // after scaling.  SVG (http://www.w3.org/TR/SVG/pservers.html#LinearGradients) says\r\n\t            // the following:\r\n\t            //\r\n\t            //     When gradientUnits=\"objectBoundingBox\" and 'gradientTransform' is the\r\n\t            //     identity matrix, the normal of the linear gradient is perpendicular to the\r\n\t            //     gradient vector in object bounding box space (i.e., the abstract coordinate\r\n\t            //     system where (0,0) is at the top/left of the object bounding box and (1,1) is\r\n\t            //     at the bottom/right of the object bounding box). When the object's bounding\r\n\t            //     box is not square, the gradient normal which is initially perpendicular to\r\n\t            //     the gradient vector within object bounding box space may render\r\n\t            //     non-perpendicular relative to the gradient vector in user space. If the\r\n\t            //     gradient vector is parallel to one of the axes of the bounding box, the\r\n\t            //     gradient normal will remain perpendicular. This transformation is due to\r\n\t            //     application of the non-uniform scaling transformation from bounding box space\r\n\t            //     to user space.\r\n\t            //\r\n\t            // which is an extremely long and confusing way to tell what I just said above.\r\n\t            //\r\n\t            // For this reason we need to apply the reverse scaling to the original angle, so\r\n\t            // that when it'll finally be rendered it'll actually be at the desired slope.  Now\r\n\t            // I'll let you figure out the math yourself.\r\n\r\n\t            var scaledAngle = Math.atan(width * Math.tan(angle) / height);\r\n\t            var sin = Math.sin(scaledAngle), cos = Math.cos(scaledAngle);\r\n\t            var len = Math.abs(sin) + Math.abs(cos);\r\n\t            var x = len/2 * sin;\r\n\t            var y = len/2 * cos;\r\n\r\n\t            // Because of the arctangent, our scaledAngle ends up between -PI/2..PI/2, possibly\r\n\t            // losing the intended direction of the gradient.  The following fixes it.\r\n\t            if (angle > Math.PI/2 && angle <= 3*Math.PI/2) {\r\n\t                x = -x;\r\n\t                y = -y;\r\n\t            }\r\n\r\n\t            // compute the color stops.\r\n\t            var implicit = [], right = 0;\r\n\t            var stops = gradient.stops.map(function(s, i){\r\n\t                var offset = s.percent;\r\n\t                if (offset) {\r\n\t                    offset = parseFloat(offset) / 100;\r\n\t                } else if (s.length) {\r\n\t                    offset = parseFloat(s.length) / pxlen;\r\n\t                } else if (i === 0) {\r\n\t                    offset = 0;\r\n\t                } else if (i == gradient.stops.length - 1) {\r\n\t                    offset = 1;\r\n\t                }\r\n\t                var stop = {\r\n\t                    color: s.color.toCssRgba(),\r\n\t                    offset: offset\r\n\t                };\r\n\t                if (offset != null) {\r\n\t                    right = offset;\r\n\t                    // fix implicit offsets\r\n\t                    implicit.forEach(function(s, i){\r\n\t                        var stop = s.stop;\r\n\t                        stop.offset = s.left + (right - s.left) * (i + 1) / (implicit.length + 1);\r\n\t                    });\r\n\t                    implicit = [];\r\n\t                } else {\r\n\t                    implicit.push({ left: right, stop: stop });\r\n\t                }\r\n\t                return stop;\r\n\t            });\r\n\r\n\t            var start = [ 0.5 - x, 0.5 + y ];\r\n\t            var end = [ 0.5 + x, 0.5 - y ];\r\n\r\n\t            // finally, draw it.\r\n\t            group.append(\r\n\t                Path.fromRect(rect)\r\n\t                    .stroke(null)\r\n\t                    .fill(new LinearGradient({\r\n\t                        start     : start,\r\n\t                        end       : end,\r\n\t                        stops     : stops,\r\n\t                        userSpace : false\r\n\t                    }))\r\n\t            );\r\n\t            break;\r\n\t          case \"radial\":\r\n\t            // XXX:\r\n\t            if (window.console && window.console.log) {\r\n\t                window.console.log(\"Radial gradients are not yet supported in HTML renderer\");\r\n\t            }\r\n\t            break;\r\n\t        }\r\n\t    };\r\n\t}\r\n\r\n\tfunction maybeRenderWidget(element, group) {\r\n\t    var visual;\r\n\r\n\t    if (element._kendoExportVisual) {\r\n\t        visual = element._kendoExportVisual();\r\n\t    } else if (window.kendo && window.kendo.jQuery && element.getAttribute(window.kendo.attr(\"role\"))) {\r\n\t        var widget = window.kendo.widgetInstance(window.kendo.jQuery(element));\r\n\t        if (widget && (widget.exportDOMVisual || widget.exportVisual)) {\r\n\t            if (widget.exportDOMVisual) {\r\n\t                visual = widget.exportDOMVisual();\r\n\t            } else {\r\n\t                visual = widget.exportVisual();\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    if (!visual) {\r\n\t        return false;\r\n\t    }\r\n\r\n\t    var wrap$$1 = new Group();\r\n\t    wrap$$1.children.push(visual);\r\n\r\n\t    var bbox = element.getBoundingClientRect();\r\n\t    wrap$$1.transform(transform().translate(bbox.left, bbox.top));\r\n\r\n\t    group.append(wrap$$1);\r\n\r\n\t    return true;\r\n\t}\r\n\r\n\tfunction renderImage(element, url, group) {\r\n\t    var box = getContentBox(element);\r\n\t    var rect = new Rect([ box.left, box.top ], [ box.width, box.height ]);\r\n\t    var image = new Image$1(url, rect);\r\n\t    setClipping(image, elementRoundBox(element, box, \"content\"));\r\n\t    group.append(image);\r\n\t}\r\n\r\n\tfunction zIndexSort(a, b) {\r\n\t    var sa = getComputedStyle(a);\r\n\t    var sb = getComputedStyle(b);\r\n\t    var za = parseFloat(getPropertyValue(sa, \"z-index\"));\r\n\t    var zb = parseFloat(getPropertyValue(sb, \"z-index\"));\r\n\t    var pa = getPropertyValue(sa, \"position\");\r\n\t    var pb = getPropertyValue(sb, \"position\");\r\n\t    if (isNaN(za) && isNaN(zb)) {\r\n\t        if ((/static|absolute/.test(pa)) && (/static|absolute/.test(pb))) {\r\n\t            return 0;\r\n\t        }\r\n\t        if (pa == \"static\") {\r\n\t            return -1;\r\n\t        }\r\n\t        if (pb == \"static\") {\r\n\t            return 1;\r\n\t        }\r\n\t        return 0;\r\n\t    }\r\n\t    if (isNaN(za)) {\r\n\t        return zb === 0 ? 0 : zb > 0 ? -1 : 1;\r\n\t    }\r\n\t    if (isNaN(zb)) {\r\n\t        return za === 0 ? 0 : za > 0 ? 1 : -1;\r\n\t    }\r\n\t    return parseFloat(za) - parseFloat(zb);\r\n\t}\r\n\r\n\tfunction isFormField(element) {\r\n\t    return /^(?:textarea|select|input)$/i.test(element.tagName);\r\n\t}\r\n\r\n\tfunction getSelectedOption(element) {\r\n\t    if (element.selectedOptions && element.selectedOptions.length > 0) {\r\n\t        return element.selectedOptions[0];\r\n\t    }\r\n\t    return element.options[element.selectedIndex];\r\n\t}\r\n\r\n\tfunction renderCheckbox(element, group) {\r\n\t    var style = getComputedStyle(element);\r\n\t    var color = getPropertyValue(style, \"color\");\r\n\t    var box = element.getBoundingClientRect();\r\n\t    if (element.type == \"checkbox\") {\r\n\t        group.append(\r\n\t            Path.fromRect(\r\n\t                new Rect([ box.left+1, box.top+1 ],\r\n\t                             [ box.width-2, box.height-2 ])\r\n\t            ).stroke(color, 1)\r\n\t        );\r\n\t        if (element.checked) {\r\n\t            // fill a rectangle inside?  looks kinda ugly.\r\n\t            // group.append(\r\n\t            //     Path.fromRect(\r\n\t            //         new geo.Rect([ box.left+4, box.top+4 ],\r\n\t            //                      [ box.width-8, box.height-8])\r\n\t            //     ).fill(color).stroke(null)\r\n\t            // );\r\n\r\n\t            // let's draw a checkmark instead.  artistic, eh?\r\n\t            group.append(\r\n\t                new Path()\r\n\t                    .stroke(color, 1.2)\r\n\t                    .moveTo(box.left + 0.22 * box.width,\r\n\t                            box.top + 0.55 * box.height)\r\n\t                    .lineTo(box.left + 0.45 * box.width,\r\n\t                            box.top + 0.75 * box.height)\r\n\t                    .lineTo(box.left + 0.78 * box.width,\r\n\t                            box.top + 0.22 * box.width)\r\n\t            );\r\n\t        }\r\n\t    } else {\r\n\t        group.append(\r\n\t            new Circle(\r\n\t                new Circle$2([\r\n\t                    (box.left + box.right) / 2,\r\n\t                    (box.top + box.bottom) / 2\r\n\t                ], Math.min(box.width-2, box.height-2) / 2)\r\n\t            ).stroke(color, 1)\r\n\t        );\r\n\t        if (element.checked) {\r\n\t            group.append(\r\n\t                new Circle(\r\n\t                    new Circle$2([\r\n\t                        (box.left + box.right) / 2,\r\n\t                        (box.top + box.bottom) / 2\r\n\t                    ], Math.min(box.width-8, box.height-8) / 2)\r\n\t                ).fill(color).stroke(null)\r\n\t            );\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction renderFormField(element, group) {\r\n\t    var tag = element.tagName.toLowerCase();\r\n\t    if (tag == \"input\" && (element.type == \"checkbox\" || element.type == \"radio\")) {\r\n\t        return renderCheckbox(element, group);\r\n\t    }\r\n\t    var p = element.parentNode;\r\n\t    var doc = element.ownerDocument;\r\n\t    var el = doc.createElement(KENDO_PSEUDO_ELEMENT);\r\n\t    var option;\r\n\t    el.style.cssText = getCssText(getComputedStyle(element));\r\n\t    if (tag == \"input\") {\r\n\t        el.style.whiteSpace = \"pre\";\r\n\t    }\r\n\t    if (tag == \"select\" || tag == \"textarea\") {\r\n\t        el.style.overflow = \"auto\";\r\n\t    }\r\n\t    if (tag == \"select\") {\r\n\t        if (element.multiple) {\r\n\t            for (var i = 0; i < element.options.length; ++i) {\r\n\t                option = doc.createElement(KENDO_PSEUDO_ELEMENT);\r\n\t                option.style.cssText = getCssText(getComputedStyle(element.options[i]));\r\n\t                option.style.display = \"block\"; // IE9 messes up without this\r\n\t                option.textContent = element.options[i].textContent;\r\n\t                el.appendChild(option);\r\n\t            }\r\n\t        } else {\r\n\t            option = getSelectedOption(element);\r\n\t            if (option) {\r\n\t                el.textContent = option.textContent;\r\n\t            }\r\n\t        }\r\n\t    } else {\r\n\t        el.textContent = element.value;\r\n\t    }\r\n\t    p.insertBefore(el, element);\r\n\t    el.scrollLeft = element.scrollLeft;\r\n\t    el.scrollTop = element.scrollTop;\r\n\r\n\t    // must temporarily hide the original element, otherwise it\r\n\t    // may affect layout of the fake element we want to render.\r\n\t    element.style.display = \"none\";\r\n\r\n\t    renderContents(el, group);\r\n\t    element.style.display = \"\";\r\n\t    p.removeChild(el);\r\n\t}\r\n\r\n\tfunction renderContents(element, group) {\r\n\t    if (nodeInfo._stackingContext.element === element) {\r\n\t        // the group that was set in pushNodeInfo might have\r\n\t        // changed due to clipping/transforms, update it here.\r\n\t        nodeInfo._stackingContext.group = group;\r\n\t    }\r\n\t    switch (element.tagName.toLowerCase()) {\r\n\t      case \"img\":\r\n\t        renderImage(element, element.src, group);\r\n\t        break;\r\n\r\n\t      case \"canvas\":\r\n\t        try {\r\n\t            renderImage(element, element.toDataURL(\"image/png\"), group);\r\n\t        } catch (ex) {\r\n\t            // tainted; can't draw it, ignore.\r\n\t        }\r\n\t        break;\r\n\r\n\t      case \"textarea\":\r\n\t      case \"input\":\r\n\t      case \"select\":\r\n\t        renderFormField(element, group);\r\n\t        break;\r\n\r\n\t      default:\r\n\t        var children = [], floats = [], positioned = [];\r\n\t        for (var i = element.firstChild; i; i = i.nextSibling) {\r\n\t            switch (i.nodeType) {\r\n\t              case 3:         // Text\r\n\t                if (/\\S/.test(i.data)) {\r\n\t                    renderText(element, i, group);\r\n\t                }\r\n\t                break;\r\n\t              case 1:         // Element\r\n\t                var style = getComputedStyle(i);\r\n\t                var floating = getPropertyValue(style, \"float\");\r\n\t                var position = getPropertyValue(style, \"position\");\r\n\t                if (position != \"static\") {\r\n\t                    positioned.push(i);\r\n\t                }\r\n\t                else if (floating != \"none\") {\r\n\t                    floats.push(i);\r\n\t                } else {\r\n\t                    children.push(i);\r\n\t                }\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        mergeSort(children, zIndexSort).forEach(function(el){ renderElement(el, group); });\r\n\t        mergeSort(floats, zIndexSort).forEach(function(el){ renderElement(el, group); });\r\n\t        mergeSort(positioned, zIndexSort).forEach(function(el){ renderElement(el, group); });\r\n\t    }\r\n\t}\r\n\r\n\tfunction renderText(element, node, group) {\r\n\t    if (emptyClipbox()) {\r\n\t        return;\r\n\t    }\r\n\t    var style = getComputedStyle(element);\r\n\r\n\t    if (parseFloat(getPropertyValue(style, \"text-indent\")) < -500) {\r\n\t        // assume it should not be displayed.  the slider's\r\n\t        // draggable handle displays a Drag text for some reason,\r\n\t        // having text-indent: -3333px.\r\n\t        return;\r\n\t    }\r\n\r\n\t    var text = node.data;\r\n\t    var start = 0;\r\n\t    var end = text.search(/\\S\\s*$/) + 1;\r\n\r\n\t    if (!end) {\r\n\t        return; // whitespace-only node\r\n\t    }\r\n\r\n\t    var fontSize = getPropertyValue(style, \"font-size\");\r\n\t    var lineHeight = getPropertyValue(style, \"line-height\");\r\n\r\n\t    // simply getPropertyValue(\"font\") doesn't work in Firefox :-\\\r\n\t    var font = [\r\n\t        getPropertyValue(style, \"font-style\"),\r\n\t        getPropertyValue(style, \"font-variant\"),\r\n\t        getPropertyValue(style, \"font-weight\"),\r\n\t        fontSize, // no need for line height here; it breaks layout in FF\r\n\t        getPropertyValue(style, \"font-family\")\r\n\t    ].join(\" \");\r\n\r\n\t    fontSize = parseFloat(fontSize);\r\n\t    lineHeight = parseFloat(lineHeight);\r\n\r\n\t    if (fontSize === 0) {\r\n\t        return;\r\n\t    }\r\n\r\n\t    var color = getPropertyValue(style, \"color\");\r\n\t    var range = element.ownerDocument.createRange();\r\n\t    var align$$1 = getPropertyValue(style, \"text-align\");\r\n\t    var isJustified = align$$1 == \"justify\";\r\n\t    var columnCount = getPropertyValue(style, \"column-count\", 1);\r\n\t    var whiteSpace = getPropertyValue(style, \"white-space\");\r\n\t    var textTransform = getPropertyValue(style, \"text-transform\");\r\n\r\n\t    // IE shrinks the text with text-overflow: ellipsis,\r\n\t    // apparently because the returned bounding box for the range\r\n\t    // is limited to the visible area minus space for the dots,\r\n\t    // instead of being the full width of the text.\r\n\t    //\r\n\t    // https://github.com/telerik/kendo/issues/5232\r\n\t    var textOverflow, saveTextOverflow;\r\n\t    if (browser.msie || browser.edge) {\r\n\t        textOverflow = style.textOverflow;             // computed style\r\n\t        if (textOverflow == \"ellipsis\") {\r\n\t            saveTextOverflow = element.style.textOverflow; // own style.\r\n\t            element.style.textOverflow = \"clip\";\r\n\t        }\r\n\t    }\r\n\r\n\t    // A line of 500px, with a font of 12px, contains an average of 80 characters, but since we\r\n\t    // err, we'd like to guess a bigger number rather than a smaller one.  Multiplying by 5\r\n\t    // seems to be a good option.\r\n\t    var estimateLineLength = element.getBoundingClientRect().width / fontSize * 5;\r\n\t    if (estimateLineLength === 0) {\r\n\t        estimateLineLength = 500;\r\n\t    }\r\n\r\n\t    // we'll maintain this so we can workaround bugs in Chrome's Range.getClientRects\r\n\t    // https://github.com/telerik/kendo/issues/5740\r\n\t    var prevLineBottom = null;\r\n\r\n\t    var underline = nodeInfo[\"underline\"];\r\n\t    var lineThrough = nodeInfo[\"line-through\"];\r\n\t    var overline = nodeInfo[\"overline\"];\r\n\t    var hasDecoration = underline || lineThrough || overline;\r\n\r\n\t    // doChunk returns true when all text has been rendered\r\n\t    while (!doChunk()) {}\r\n\r\n\t    if ((browser.msie || browser.edge) && textOverflow == \"ellipsis\") {\r\n\t        element.style.textOverflow = saveTextOverflow;\r\n\t    }\r\n\r\n\t    if (hasDecoration) {\r\n\t        range.selectNode(node);\r\n\t        slice$1(range.getClientRects()).forEach(decorate);\r\n\t    }\r\n\r\n\t    return;                 // only function declarations after this line\r\n\r\n\t    function actuallyGetRangeBoundingRect(range) {\r\n\t        // XXX: to be revised when this Chrome bug is fixed:\r\n\t        // https://bugs.chromium.org/p/chromium/issues/detail?id=612459\r\n\t        if (browser.msie || browser.edge || browser.chrome) {\r\n\t            // Workaround browser bugs: IE and Chrome would sometimes\r\n\t            // return 0 or 1-width rectangles before or after the main\r\n\t            // one.  https://github.com/telerik/kendo/issues/4674\r\n\r\n\t            // Actually Chrome 50 got worse, since the rectangles can now have the width of a\r\n\t            // full character, making it hard to tell whether it's a bogus rectangle or valid\r\n\t            // selection location.  The workaround is to ignore rectangles that fall on the\r\n\t            // previous line.  https://github.com/telerik/kendo/issues/5740\r\n\t            var rectangles = range.getClientRects(), box = {\r\n\t                top    :  Infinity,\r\n\t                right  : -Infinity,\r\n\t                bottom : -Infinity,\r\n\t                left   :  Infinity\r\n\t            };\r\n\t            for (var i = 0; i < rectangles.length; ++i) {\r\n\t                var b = rectangles[i];\r\n\t                if (b.width <= 1 || b.bottom === prevLineBottom) {\r\n\t                    continue;   // bogus rectangle\r\n\t                }\r\n\t                box.left   = Math.min(b.left   , box.left);\r\n\t                box.top    = Math.min(b.top    , box.top);\r\n\t                box.right  = Math.max(b.right  , box.right);\r\n\t                box.bottom = Math.max(b.bottom , box.bottom);\r\n\t            }\r\n\t            box.width = box.right - box.left;\r\n\t            box.height = box.bottom - box.top;\r\n\t            return box;\r\n\t        }\r\n\t        return range.getBoundingClientRect();\r\n\t    }\r\n\r\n\t    // Render a chunk of text, typically one line (but for justified text we render each word as\r\n\t    // a separate Text object, because spacing is variable).  Returns true when it finished the\r\n\t    // current node.  After each chunk it updates `start` to just after the last rendered\r\n\t    // character.\r\n\t    function doChunk() {\r\n\t        var origStart = start;\r\n\t        var box, pos = text.substr(start).search(/\\S/);\r\n\t        start += pos;\r\n\t        if (pos < 0 || start >= end) {\r\n\t            return true;\r\n\t        }\r\n\r\n\t        // Select a single character to determine the height of a line of text.  The box.bottom\r\n\t        // will be essential for us to figure out where the next line begins.\r\n\t        range.setStart(node, start);\r\n\t        range.setEnd(node, start + 1);\r\n\t        box = actuallyGetRangeBoundingRect(range);\r\n\r\n\t        // for justified text we must split at each space, because space has variable width.\r\n\t        var found = false;\r\n\t        if (isJustified || columnCount > 1) {\r\n\t            pos = text.substr(start).search(/\\s/);\r\n\t            if (pos >= 0) {\r\n\t                // we can only split there if it's on the same line, otherwise we'll fall back\r\n\t                // to the default mechanism (see findEOL below).\r\n\t                range.setEnd(node, start + pos);\r\n\t                var r = actuallyGetRangeBoundingRect(range);\r\n\t                if (r.bottom == box.bottom) {\r\n\t                    box = r;\r\n\t                    found = true;\r\n\t                    start += pos;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (!found) {\r\n\t            // This code does three things: (1) it selects one line of text in `range`, (2) it\r\n\t            // leaves the bounding rect of that line in `box` and (3) it returns the position\r\n\t            // just after the EOL.  We know where the line starts (`start`) but we don't know\r\n\t            // where it ends.  To figure this out, we select a piece of text and look at the\r\n\t            // bottom of the bounding box.  If it changes, we have more than one line selected\r\n\t            // and should retry with a smaller selection.\r\n\t            //\r\n\t            // To speed things up, we first try to select all text in the node (`start` ->\r\n\t            // `end`).  If there's more than one line there, then select only half of it.  And\r\n\t            // so on.  When we find a value for `end` that fits in one line, we try increasing\r\n\t            // it (also in halves) until we get to the next line.  The algorithm stops when the\r\n\t            // right side of the bounding box does not change.\r\n\t            //\r\n\t            // One more thing to note is that everything happens in a single Text DOM node.\r\n\t            // There's no other tags inside it, therefore the left/top coordinates of the\r\n\t            // bounding box will not change.\r\n\t            pos = (function findEOL(min, eol, max){\r\n\t                range.setEnd(node, eol);\r\n\t                var r = actuallyGetRangeBoundingRect(range);\r\n\t                if (r.bottom != box.bottom && min < eol) {\r\n\t                    return findEOL(min, (min + eol) >> 1, eol);\r\n\t                } else if (r.right != box.right) {\r\n\t                    box = r;\r\n\t                    if (eol < max) {\r\n\t                        return findEOL(eol, (eol + max) >> 1, max);\r\n\t                    } else {\r\n\t                        return eol;\r\n\t                    }\r\n\t                } else {\r\n\t                    return eol;\r\n\t                }\r\n\t            })(start, Math.min(end, start + estimateLineLength), end);\r\n\r\n\t            if (pos == start) {\r\n\t                // if EOL is at the start, then no more text fits on this line.  Skip the\r\n\t                // remainder of this node entirely to avoid a stack overflow.\r\n\t                return true;\r\n\t            }\r\n\t            start = pos;\r\n\r\n\t            pos = range.toString().search(/\\s+$/);\r\n\t            if (pos === 0) {\r\n\t                return false; // whitespace only; we should not get here.\r\n\t            }\r\n\t            if (pos > 0) {\r\n\t                // eliminate trailing whitespace\r\n\t                range.setEnd(node, range.startOffset + pos);\r\n\t                box = actuallyGetRangeBoundingRect(range);\r\n\t            }\r\n\t        }\r\n\r\n\t        // another workaround for IE: if we rely on getBoundingClientRect() we'll overlap with the bullet for LI\r\n\t        // elements.  Calling getClientRects() and using the *first* rect appears to give us the correct location.\r\n\t        // Note: not to be used in Chrome as it randomly returns a zero-width rectangle from the previous line.\r\n\t        if (browser.msie || browser.edge) {\r\n\t            box = range.getClientRects()[0];\r\n\t        }\r\n\r\n\t        var str = range.toString();\r\n\t        if (!/^(?:pre|pre-wrap)$/i.test(whiteSpace)) {\r\n\t            // node with non-significant space -- collapse whitespace.\r\n\t            str = str.replace(/\\s+/g, \" \");\r\n\t        }\r\n\t        else if (/\\t/.test(str)) {\r\n\t            // with significant whitespace we need to do something about literal TAB characters.\r\n\t            // There's no TAB glyph in a font so they would be rendered in PDF as an empty box,\r\n\t            // and the whole text will stretch to fill the original width.  The core PDF lib\r\n\t            // does not have sufficient context to deal with it.\r\n\r\n\t            // calculate the starting column here, since we initially discarded any whitespace.\r\n\t            var cc = 0;\r\n\t            for (pos = origStart; pos < range.startOffset; ++pos) {\r\n\t                var code = text.charCodeAt(pos);\r\n\t                if (code == 9) {\r\n\t                    // when we meet a TAB we must round up to the next tab stop.\r\n\t                    // in all browsers TABs seem to be 8 characters.\r\n\t                    cc += 8 - cc % 8;\r\n\t                } else if (code == 10 || code == 13) {\r\n\t                    // just in case we meet a newline we must restart.\r\n\t                    cc = 0;\r\n\t                } else {\r\n\t                    // ordinary character --> advance one column\r\n\t                    cc++;\r\n\t                }\r\n\t            }\r\n\r\n\t            // based on starting column, replace any TAB characters in the string we actually\r\n\t            // have to display with spaces so that they align to columns multiple of 8.\r\n\t            while ((pos = str.search(\"\\t\")) >= 0) {\r\n\t                var indent = \"        \".substr(0, 8 - (cc + pos) % 8);\r\n\t                str = str.substr(0, pos) + indent + str.substr(pos + 1);\r\n\t            }\r\n\t        }\r\n\r\n\t        if (!found) {\r\n\t            prevLineBottom = box.bottom;\r\n\t        }\r\n\t        drawText(str, box);\r\n\t    }\r\n\r\n\t    function drawText(str, box) {\r\n\t        // In IE the box height will be approximately lineHeight, while in\r\n\t        // other browsers it'll (correctly) be the height of the bounding\r\n\t        // box for the current text/font.  Which is to say, IE sucks again.\r\n\t        // The only good solution I can think of is to measure the text\r\n\t        // ourselves and center the bounding box.\r\n\t        if ((browser.msie || browser.edge) && !isNaN(lineHeight)) {\r\n\t            var height = getFontHeight(font);\r\n\t            var top = (box.top + box.bottom - height) / 2;\r\n\t            box = {\r\n\t                top    : top,\r\n\t                right  : box.right,\r\n\t                bottom : top + height,\r\n\t                left   : box.left,\r\n\t                height : height,\r\n\t                width  : box.right - box.left\r\n\t            };\r\n\t        }\r\n\r\n\t        // var path = new Path({ stroke: { color: \"red\" }});\r\n\t        // path.moveTo(box.left, box.top)\r\n\t        //     .lineTo(box.right, box.top)\r\n\t        //     .lineTo(box.right, box.bottom)\r\n\t        //     .lineTo(box.left, box.bottom)\r\n\t        //     .close();\r\n\t        // group.append(path);\r\n\r\n\t        switch (textTransform) {\r\n\t          case \"uppercase\":\r\n\t            str = str.toUpperCase();\r\n\t            break;\r\n\t          case \"lowercase\":\r\n\t            str = str.toLowerCase();\r\n\t            break;\r\n\t          case \"capitalize\":\r\n\t            str = str.replace(/(?:^|\\s)\\S/g, function (l) { return l.toUpperCase(); });\r\n\t            break;\r\n\t        }\r\n\r\n\t        var text = new TextRect(\r\n\t            str, new Rect([ box.left, box.top ],\r\n\t                              [ box.width, box.height ]),\r\n\t            {\r\n\t                font: font,\r\n\t                fill: { color: color }\r\n\t            }\r\n\t        );\r\n\t        group.append(text);\r\n\t    }\r\n\r\n\t    function decorate(box) {\r\n\t        line(underline, box.bottom);\r\n\t        line(lineThrough, box.bottom - box.height / 2.7);\r\n\t        line(overline, box.top);\r\n\t        function line(color, ypos) {\r\n\t            if (color) {\r\n\t                var width = fontSize / 12;\r\n\t                var path = new Path({ stroke: {\r\n\t                    width: width,\r\n\t                    color: color\r\n\t                }});\r\n\r\n\t                ypos -= width;\r\n\t                path.moveTo(box.left, ypos)\r\n\t                    .lineTo(box.right, ypos);\r\n\t                group.append(path);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction groupInStackingContext(element, group, zIndex) {\r\n\t    var main;\r\n\t    if (zIndex != \"auto\") {\r\n\t        // use the current stacking context\r\n\t        main = nodeInfo._stackingContext.group;\r\n\t        zIndex = parseFloat(zIndex);\r\n\t    } else {\r\n\t        // normal flow  use given container.  we still have to\r\n\t        // figure out where should we insert this element with the\r\n\t        // assumption that its z-index is zero, as the group might\r\n\t        // already contain elements with higher z-index.\r\n\t        main = group;\r\n\t        zIndex = 0;\r\n\t    }\r\n\t    var a = main.children;\r\n\t    for (var i = 0; i < a.length; ++i) {\r\n\t        if (a[i]._dom_zIndex != null && a[i]._dom_zIndex > zIndex) {\r\n\t            break;\r\n\t        }\r\n\t    }\r\n\r\n\t    var tmp = new Group();\r\n\t    main.insert(i, tmp);\r\n\t    tmp._dom_zIndex = zIndex;\r\n\r\n\t    if (main !== group) {\r\n\t        // console.log(\"Placing\", element, \"in\", nodeInfo._stackingContext.element, \"at position\", i, \" / \", a.length);\r\n\t        // console.log(a.slice(i+1));\r\n\r\n\t        // if (nodeInfo._matrix) {\r\n\t        //     tmp.transform(nodeInfo._matrix);\r\n\t        // }\r\n\t        if (nodeInfo._clipbox) {\r\n\t            var m = nodeInfo._matrix.invert();\r\n\t            var r = nodeInfo._clipbox.transformCopy(m);\r\n\t            setClipping(tmp, Path.fromRect(r));\r\n\t            // console.log(r);\r\n\t            // tmp.append(Path.fromRect(r));\r\n\t            // tmp.append(new Text(element.className || element.id, r.topLeft()));\r\n\t        }\r\n\t    }\r\n\r\n\t    return tmp;\r\n\t}\r\n\r\n\tfunction renderElement(element, container) {\r\n\t    var style = getComputedStyle(element);\r\n\r\n\t    updateCounters(style);\r\n\r\n\t    if (/^(style|script|link|meta|iframe|svg|col|colgroup)$/i.test(element.tagName)) {\r\n\t        return;\r\n\t    }\r\n\r\n\t    if (nodeInfo._clipbox == null) {\r\n\t        return;\r\n\t    }\r\n\r\n\t    var opacity = parseFloat(getPropertyValue(style, \"opacity\"));\r\n\t    var visibility = getPropertyValue(style, \"visibility\");\r\n\t    var display = getPropertyValue(style, \"display\");\r\n\r\n\t    if (opacity === 0 || visibility == \"hidden\" || display == \"none\") {\r\n\t        return;\r\n\t    }\r\n\r\n\t    var tr = getTransform(style);\r\n\t    var group;\r\n\r\n\t    var zIndex = getPropertyValue(style, \"z-index\");\r\n\t    if ((tr || opacity < 1) && zIndex == \"auto\") {\r\n\t        zIndex = 0;\r\n\t    }\r\n\t    group = groupInStackingContext(element, container, zIndex);\r\n\r\n\t    // XXX: remove at some point\r\n\t    // group._pdfElement = element;\r\n\t    // group.options._pdfDebug = \"\";\r\n\t    // if (element.id) {\r\n\t    //     group.options._pdfDebug = \"#\" + element.id;\r\n\t    // }\r\n\t    // if (element.className) {\r\n\t    //     group.options._pdfDebug += \".\" + element.className.split(\" \").join(\".\");\r\n\t    // }\r\n\r\n\t    if (opacity < 1) {\r\n\t        group.opacity(opacity * group.opacity());\r\n\t    }\r\n\r\n\t    pushNodeInfo(element, style, group);\r\n\r\n\t    if (!tr) {\r\n\t        _renderWithPseudoElements(element, group);\r\n\t    }\r\n\t    else {\r\n\t        saveStyle(element, function(){\r\n\t            // must clear transform, so getBoundingClientRect returns correct values.\r\n\t            pleaseSetPropertyValue(element.style, \"transform\", \"none\", \"important\");\r\n\r\n\t            // must also clear transitions, so correct values are returned *immediately*\r\n\t            pleaseSetPropertyValue(element.style, \"transition\", \"none\", \"important\");\r\n\r\n\t            // the presence of any transform makes it behave like it had position: relative,\r\n\t            // because why not.\r\n\t            // http://meyerweb.com/eric/thoughts/2011/09/12/un-fixing-fixed-elements-with-css-transforms/\r\n\t            if (getPropertyValue(style, \"position\") == \"static\") {\r\n\t                // but only if it's not already positioned. :-/\r\n\t                pleaseSetPropertyValue(element.style, \"position\", \"relative\", \"important\");\r\n\t            }\r\n\r\n\t            // must translate to origin before applying the CSS\r\n\t            // transformation, then translate back.\r\n\t            var bbox = element.getBoundingClientRect();\r\n\t            var x = bbox.left + tr.origin[0];\r\n\t            var y = bbox.top + tr.origin[1];\r\n\t            var m = [ 1, 0, 0, 1, -x, -y ];\r\n\t            m = mmul(m, tr.matrix);\r\n\t            m = mmul(m, [ 1, 0, 0, 1, x, y ]);\r\n\t            m = setTransform(group, m);\r\n\r\n\t            nodeInfo._matrix = nodeInfo._matrix.multiplyCopy(m);\r\n\r\n\t            _renderWithPseudoElements(element, group);\r\n\t        });\r\n\t    }\r\n\r\n\t    popNodeInfo();\r\n\r\n\t    //drawDebugBox(element.getBoundingClientRect(), container);\r\n\t}\r\n\r\n\t// function drawDebugBox(box, group, color) {\r\n\t//     var path = Path.fromRect(new geo.Rect([ box.left, box.top ], [ box.width, box.height ]));\r\n\t//     if (color) {\r\n\t//         path.stroke(color);\r\n\t//     }\r\n\t//     group.append(path);\r\n\t// }\r\n\r\n\t// function dumpTextNode(node) {\r\n\t//     var txt = node.data.replace(/^\\s+/, \"\");\r\n\t//     if (txt.length < 100) {\r\n\t//         console.log(node.data.length + \": |\" + txt);\r\n\t//     } else {\r\n\t//         console.log(node.data.length + \": |\" + txt.substr(0, 50) + \"|...|\" + txt.substr(-50));\r\n\t//     }\r\n\t// }\r\n\r\n\tfunction mmul(a, b) {\r\n\t    var a1 = a[0], b1 = a[1], c1 = a[2], d1 = a[3], e1 = a[4], f1 = a[5];\r\n\t    var a2 = b[0], b2 = b[1], c2 = b[2], d2 = b[3], e2 = b[4], f2 = b[5];\r\n\t    return [\r\n\t        a1*a2 + b1*c2,          a1*b2 + b1*d2,\r\n\t        c1*a2 + d1*c2,          c1*b2 + d1*d2,\r\n\t        e1*a2 + f1*c2 + e2,     e1*b2 + f1*d2 + f2\r\n\t    ];\r\n\t}\r\n\r\n\tvar drawing = {\r\n\t\tsvg: svg,\r\n\t\tcanvas: canvas,\r\n\t\tutil: util,\r\n\t\tPathParser: PathParser,\r\n\t\tSurface: Surface,\r\n\t\tBaseNode: BaseNode,\r\n\t\tSurfaceFactory: SurfaceFactory,\r\n\t\tOptionsStore: OptionsStore,\r\n\t\texportImage: exportImage,\r\n\t\texportSVG: exportSVG,\r\n\t\tQuadNode: QuadNode,\r\n\t\tShapesQuadTree: ShapesQuadTree,\r\n\t\tObserversMixin: ObserversMixin,\r\n\t\tElement: Element$1,\r\n\t\tCircle: Circle,\r\n\t\tArc: Arc,\r\n\t\tPath: Path,\r\n\t\tMultiPath: MultiPath,\r\n\t\tText: Text,\r\n\t\tImage: Image$1,\r\n\t\tGroup: Group,\r\n\t\tLayout: Layout,\r\n\t\tRect: Rect$2,\r\n\t\talign: align,\r\n\t\tvAlign: vAlign,\r\n\t\tstack: stack,\r\n\t\tvStack: vStack,\r\n\t\twrap: wrap,\r\n\t\tvWrap: vWrap,\r\n\t\tfit: fit,\r\n\t\tLinearGradient: LinearGradient,\r\n\t\tRadialGradient: RadialGradient,\r\n\t\tGradientStop: GradientStop,\r\n\t\tGradient: Gradient,\r\n\t\tAnimation: Animation,\r\n\t\tAnimationFactory: AnimationFactory,\r\n\t\tdrawDOM: drawDOM\r\n\t};\r\n\r\n\tkendo.deepExtend(kendo, {\r\n\t    drawing: drawing,\r\n\t    geometry: geometry\r\n\t});\r\n\r\n\tkendo.drawing.Segment = kendo.geometry.Segment;\r\n\tkendo.dataviz.drawing = kendo.drawing;\r\n\tkendo.dataviz.geometry = kendo.geometry;\r\n\tkendo.drawing.util.measureText = kendo.util.measureText;\r\n\tkendo.drawing.util.objectKey = kendo.util.objectKey;\r\n\tkendo.drawing.Color = kendo.Color;\r\n\tkendo.util.encodeBase64 = kendo.drawing.util.encodeBase64;\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 912:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./util\");\n\n/***/ }),\n\n/***/ 913:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../kendo.color\");\n\n/***/ }),\n\n/***/ 914:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../util/text-metrics\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/drawing/kendo-drawing.js\n// module id = 169\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1014);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 993:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo.core\");\n\n/***/ }),\n\n/***/ 1014:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(993) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t    var __meta__ = { // jshint ignore:line\r\n\t        id: \"color\",\r\n\t        name: \"Color utils\",\r\n\t        category: \"framework\",\r\n\t        advanced: true,\r\n\t        description: \"Color utilities used across components\",\r\n\t        depends: [ \"core\" ]\r\n\t    };\r\n\r\n\t/*jshint eqnull:true  */\r\n\r\n\twindow.kendo = window.kendo || {};\r\n\r\n\tvar Class = kendo.Class;\r\n\tvar support = kendo.support;\r\n\r\n\tvar namedColors = {\r\n\t    aliceblue: \"f0f8ff\", antiquewhite: \"faebd7\", aqua: \"00ffff\",\r\n\t    aquamarine: \"7fffd4\", azure: \"f0ffff\", beige: \"f5f5dc\",\r\n\t    bisque: \"ffe4c4\", black: \"000000\", blanchedalmond: \"ffebcd\",\r\n\t    blue: \"0000ff\", blueviolet: \"8a2be2\", brown: \"a52a2a\",\r\n\t    burlywood: \"deb887\", cadetblue: \"5f9ea0\", chartreuse: \"7fff00\",\r\n\t    chocolate: \"d2691e\", coral: \"ff7f50\", cornflowerblue: \"6495ed\",\r\n\t    cornsilk: \"fff8dc\", crimson: \"dc143c\", cyan: \"00ffff\",\r\n\t    darkblue: \"00008b\", darkcyan: \"008b8b\", darkgoldenrod: \"b8860b\",\r\n\t    darkgray: \"a9a9a9\", darkgrey: \"a9a9a9\", darkgreen: \"006400\",\r\n\t    darkkhaki: \"bdb76b\", darkmagenta: \"8b008b\", darkolivegreen: \"556b2f\",\r\n\t    darkorange: \"ff8c00\", darkorchid: \"9932cc\", darkred: \"8b0000\",\r\n\t    darksalmon: \"e9967a\", darkseagreen: \"8fbc8f\", darkslateblue: \"483d8b\",\r\n\t    darkslategray: \"2f4f4f\", darkslategrey: \"2f4f4f\", darkturquoise: \"00ced1\",\r\n\t    darkviolet: \"9400d3\", deeppink: \"ff1493\", deepskyblue: \"00bfff\",\r\n\t    dimgray: \"696969\", dimgrey: \"696969\", dodgerblue: \"1e90ff\",\r\n\t    firebrick: \"b22222\", floralwhite: \"fffaf0\", forestgreen: \"228b22\",\r\n\t    fuchsia: \"ff00ff\", gainsboro: \"dcdcdc\", ghostwhite: \"f8f8ff\",\r\n\t    gold: \"ffd700\", goldenrod: \"daa520\", gray: \"808080\",\r\n\t    grey: \"808080\", green: \"008000\", greenyellow: \"adff2f\",\r\n\t    honeydew: \"f0fff0\", hotpink: \"ff69b4\", indianred: \"cd5c5c\",\r\n\t    indigo: \"4b0082\", ivory: \"fffff0\", khaki: \"f0e68c\",\r\n\t    lavender: \"e6e6fa\", lavenderblush: \"fff0f5\", lawngreen: \"7cfc00\",\r\n\t    lemonchiffon: \"fffacd\", lightblue: \"add8e6\", lightcoral: \"f08080\",\r\n\t    lightcyan: \"e0ffff\", lightgoldenrodyellow: \"fafad2\", lightgray: \"d3d3d3\",\r\n\t    lightgrey: \"d3d3d3\", lightgreen: \"90ee90\", lightpink: \"ffb6c1\",\r\n\t    lightsalmon: \"ffa07a\", lightseagreen: \"20b2aa\", lightskyblue: \"87cefa\",\r\n\t    lightslategray: \"778899\", lightslategrey: \"778899\", lightsteelblue: \"b0c4de\",\r\n\t    lightyellow: \"ffffe0\", lime: \"00ff00\", limegreen: \"32cd32\",\r\n\t    linen: \"faf0e6\", magenta: \"ff00ff\", maroon: \"800000\",\r\n\t    mediumaquamarine: \"66cdaa\", mediumblue: \"0000cd\", mediumorchid: \"ba55d3\",\r\n\t    mediumpurple: \"9370d8\", mediumseagreen: \"3cb371\", mediumslateblue: \"7b68ee\",\r\n\t    mediumspringgreen: \"00fa9a\", mediumturquoise: \"48d1cc\", mediumvioletred: \"c71585\",\r\n\t    midnightblue: \"191970\", mintcream: \"f5fffa\", mistyrose: \"ffe4e1\",\r\n\t    moccasin: \"ffe4b5\", navajowhite: \"ffdead\", navy: \"000080\",\r\n\t    oldlace: \"fdf5e6\", olive: \"808000\", olivedrab: \"6b8e23\",\r\n\t    orange: \"ffa500\", orangered: \"ff4500\", orchid: \"da70d6\",\r\n\t    palegoldenrod: \"eee8aa\", palegreen: \"98fb98\", paleturquoise: \"afeeee\",\r\n\t    palevioletred: \"d87093\", papayawhip: \"ffefd5\", peachpuff: \"ffdab9\",\r\n\t    peru: \"cd853f\", pink: \"ffc0cb\", plum: \"dda0dd\",\r\n\t    powderblue: \"b0e0e6\", purple: \"800080\", red: \"ff0000\",\r\n\t    rosybrown: \"bc8f8f\", royalblue: \"4169e1\", saddlebrown: \"8b4513\",\r\n\t    salmon: \"fa8072\", sandybrown: \"f4a460\", seagreen: \"2e8b57\",\r\n\t    seashell: \"fff5ee\", sienna: \"a0522d\", silver: \"c0c0c0\",\r\n\t    skyblue: \"87ceeb\", slateblue: \"6a5acd\", slategray: \"708090\",\r\n\t    slategrey: \"708090\", snow: \"fffafa\", springgreen: \"00ff7f\",\r\n\t    steelblue: \"4682b4\", tan: \"d2b48c\", teal: \"008080\",\r\n\t    thistle: \"d8bfd8\", tomato: \"ff6347\", turquoise: \"40e0d0\",\r\n\t    violet: \"ee82ee\", wheat: \"f5deb3\", white: \"ffffff\",\r\n\t    whitesmoke: \"f5f5f5\", yellow: \"ffff00\", yellowgreen: \"9acd32\"\r\n\t};\r\n\r\n\tvar browser = support.browser;\r\n\r\n\tvar matchNamedColor = function (color) {\r\n\t    var colorNames = Object.keys(namedColors);\r\n\t    colorNames.push(\"transparent\");\r\n\r\n\t    var regexp = new RegExp(\"^(\" + colorNames.join(\"|\") + \")(\\\\W|$)\", \"i\");\r\n\t    matchNamedColor = function (color) { return regexp.exec(color); };\r\n\r\n\t    return regexp.exec(color);\r\n\t};\r\n\r\n\tvar BaseColor = Class.extend({\r\n\t    init: function() {  },\r\n\r\n\t    toHSV: function() { return this; },\r\n\r\n\t    toRGB: function() { return this; },\r\n\r\n\t    toHex: function() { return this.toBytes().toHex(); },\r\n\r\n\t    toBytes: function() { return this; },\r\n\r\n\t    toCss: function() { return \"#\" + this.toHex(); },\r\n\r\n\t    toCssRgba: function() {\r\n\t        var rgb = this.toBytes();\r\n\t        return (\"rgba(\" + (rgb.r) + \", \" + (rgb.g) + \", \" + (rgb.b) + \", \" + (parseFloat((Number(this.a)).toFixed(3))) + \")\");\r\n\t    },\r\n\r\n\t    toDisplay: function() {\r\n\t        if (browser.msie && browser.version < 9) {\r\n\t            return this.toCss(); // no RGBA support; does it support any opacity in colors?\r\n\t        }\r\n\t        return this.toCssRgba();\r\n\t    },\r\n\r\n\t    equals: function(c) {\r\n\t        return c === this || c !== null && this.toCssRgba() === parseColor(c).toCssRgba();\r\n\t    },\r\n\r\n\t    diff: function(other) {\r\n\t        if (other === null) {\r\n\t            return NaN;\r\n\t        }\r\n\r\n\t        var c1 = this.toBytes();\r\n\t        var c2 = other.toBytes();\r\n\r\n\t        return Math.sqrt(Math.pow((c1.r - c2.r) * 0.30, 2) +\r\n\t                         Math.pow((c1.g - c2.g) * 0.59, 2) +\r\n\t                         Math.pow((c1.b - c2.b) * 0.11, 2));\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        var c = this.toBytes();\r\n\t        if (c === this) {\r\n\t            c = new Bytes(c.r, c.g, c.b, c.a);\r\n\t        }\r\n\r\n\t        return c;\r\n\t    }\r\n\t});\r\n\r\n\tvar RGB = BaseColor.extend({\r\n\t    init: function(r, g, b, a) {\r\n\t        BaseColor.fn.init.call(this);\r\n\r\n\t        this.r = r;\r\n\t        this.g = g;\r\n\t        this.b = b;\r\n\t        this.a = a;\r\n\t    },\r\n\r\n\t    toHSV: function() {\r\n\t        var ref = this;\r\n\t        var r = ref.r;\r\n\t        var g = ref.g;\r\n\t        var b = ref.b;\r\n\t        var min = Math.min(r, g, b);\r\n\t        var max = Math.max(r, g, b);\r\n\t        var delta = max - min;\r\n\t        var v = max;\r\n\t        var h, s;\r\n\r\n\t        if (delta === 0) {\r\n\t            return new HSV(0, 0, v, this.a);\r\n\t        }\r\n\r\n\t        if (max !== 0) {\r\n\t            s = delta / max;\r\n\t            if (r === max) {\r\n\t                h = (g - b) / delta;\r\n\t            } else if (g === max) {\r\n\t                h = 2 + (b - r) / delta;\r\n\t            } else {\r\n\t                h = 4 + (r - g) / delta;\r\n\t            }\r\n\r\n\t            h *= 60;\r\n\t            if (h < 0) {\r\n\t                h += 360;\r\n\t            }\r\n\t        } else {\r\n\t            s = 0;\r\n\t            h = -1;\r\n\t        }\r\n\r\n\t        return new HSV(h, s, v, this.a);\r\n\t    },\r\n\r\n\t    toHSL: function() {\r\n\t        var ref = this;\r\n\t        var r = ref.r;\r\n\t        var g = ref.g;\r\n\t        var b = ref.b;\r\n\t        var max = Math.max(r, g, b);\r\n\t        var min = Math.min(r, g, b);\r\n\t        var h, s, l = (max + min) / 2;\r\n\r\n\t        if (max === min) {\r\n\t            h = s = 0;\r\n\t        } else {\r\n\t            var d = max - min;\r\n\t            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\r\n\t            switch (max) {\r\n\t                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\r\n\t                case g: h = (b - r) / d + 2; break;\r\n\t                case b: h = (r - g) / d + 4; break;\r\n\t                default: break;\r\n\t            }\r\n\r\n\t            h *= 60;\r\n\t            s *= 100;\r\n\t            l *= 100;\r\n\t        }\r\n\r\n\t        return new HSL(h, s, l, this.a);\r\n\t    },\r\n\r\n\t    toBytes: function() {\r\n\t        return new Bytes(this.r * 255, this.g * 255, this.b * 255, this.a);\r\n\t    }\r\n\t});\r\n\r\n\tvar Bytes = RGB.extend({\r\n\t    init: function(r, g, b, a) {\r\n\t        RGB.fn.init.call(this, Math.round(r), Math.round(g), Math.round(b), a);\r\n\t    },\r\n\r\n\t    toRGB: function() {\r\n\t        return new RGB(this.r / 255, this.g / 255, this.b / 255, this.a);\r\n\t    },\r\n\r\n\t    toHSV: function() {\r\n\t        return this.toRGB().toHSV();\r\n\t    },\r\n\r\n\t    toHSL: function() {\r\n\t        return this.toRGB().toHSL();\r\n\t    },\r\n\r\n\t    toHex: function() {\r\n\t        return hex(this.r, 2) + hex(this.g, 2) + hex(this.b, 2);\r\n\t    },\r\n\r\n\t    toBytes: function() {\r\n\t        return this;\r\n\t    }\r\n\t});\r\n\r\n\tfunction hex(n, width, pad) {\r\n\t    if (pad === void 0) { pad = \"0\"; }\r\n\r\n\t    var result = n.toString(16);\r\n\t    while (width > result.length) {\r\n\t        result = pad + result;\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tvar HSV = BaseColor.extend({\r\n\t    init: function(h, s, v, a) {\r\n\t        BaseColor.fn.init.call(this);\r\n\r\n\t        this.h = h;\r\n\t        this.s = s;\r\n\t        this.v = v;\r\n\t        this.a = a;\r\n\t    },\r\n\r\n\t    toRGB: function() {\r\n\t        var ref = this;\r\n\t        var h = ref.h;\r\n\t        var s = ref.s;\r\n\t        var v = ref.v;\r\n\t        var r, g, b;\r\n\r\n\t        if (s === 0) {\r\n\t            r = g = b = v;\r\n\t        } else {\r\n\t            h /= 60;\r\n\r\n\t            var i = Math.floor(h);\r\n\t            var f = h - i;\r\n\t            var p = v * (1 - s);\r\n\t            var q = v * (1 - s * f);\r\n\t            var t = v * (1 - s * (1 - f));\r\n\r\n\t            switch (i) {\r\n\t                case 0: r = v; g = t; b = p; break;\r\n\t                case 1: r = q; g = v; b = p; break;\r\n\t                case 2: r = p; g = v; b = t; break;\r\n\t                case 3: r = p; g = q; b = v; break;\r\n\t                case 4: r = t; g = p; b = v; break;\r\n\t                default: r = v; g = p; b = q; break;\r\n\t            }\r\n\t        }\r\n\r\n\t        return new RGB(r, g, b, this.a);\r\n\t    },\r\n\r\n\t    toHSL: function() {\r\n\t        return this.toRGB().toHSL();\r\n\t    },\r\n\r\n\t    toBytes: function() {\r\n\t        return this.toRGB().toBytes();\r\n\t    }\r\n\t});\r\n\r\n\tvar HSL = BaseColor.extend({\r\n\t    init: function(h, s, l, a) {\r\n\t        BaseColor.fn.init.call(this);\r\n\r\n\t        this.h = h;\r\n\t        this.s = s;\r\n\t        this.l = l;\r\n\t        this.a = a;\r\n\t    },\r\n\r\n\t    toRGB: function() {\r\n\t        var ref = this;\r\n\t        var h = ref.h;\r\n\t        var s = ref.s;\r\n\t        var l = ref.l;\r\n\t        var r, g, b;\r\n\r\n\t        if (s === 0) {\r\n\t            r = g = b = l; // achromatic\r\n\t        } else {\r\n\t            h /= 360;\r\n\t            s /= 100;\r\n\t            l /= 100;\r\n\r\n\t            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n\t            var p = 2 * l - q;\r\n\t            r = hue2rgb(p, q, h + 1 / 3);\r\n\t            g = hue2rgb(p, q, h);\r\n\t            b = hue2rgb(p, q, h - 1 / 3);\r\n\t        }\r\n\r\n\t        return new RGB(r, g, b, this.a);\r\n\t    },\r\n\r\n\t    toHSV: function() {\r\n\t        return this.toRGB().toHSV();\r\n\t    },\r\n\r\n\t    toBytes: function() {\r\n\t        return this.toRGB().toBytes();\r\n\t    }\r\n\t});\r\n\r\n\tfunction hue2rgb(p, q, s) {\r\n\t    var t = s;\r\n\r\n\t    if (t < 0) {\r\n\t        t += 1;\r\n\t    }\r\n\r\n\t    if (t > 1) {\r\n\t        t -= 1;\r\n\t    }\r\n\r\n\t    if (t < 1 / 6) {\r\n\t        return p + (q - p) * 6 * t;\r\n\t    }\r\n\r\n\t    if (t < 1 / 2) {\r\n\t        return q;\r\n\t    }\r\n\r\n\t    if (t < 2 / 3) {\r\n\t        return p + (q - p) * (2 / 3 - t) * 6;\r\n\t    }\r\n\r\n\t    return p;\r\n\t}\r\n\r\n\tfunction parseColor(value, safe) {\r\n\t    var m, ret;\r\n\r\n\t    if (value == null || value === \"none\") {\r\n\t        return null;\r\n\t    }\r\n\r\n\t    if (value instanceof BaseColor) {\r\n\t        return value;\r\n\t    }\r\n\r\n\t    var color = value.toLowerCase();\r\n\t    if ((m = matchNamedColor(color))) {\r\n\t        if (m[1] === \"transparent\") {\r\n\t            color = new RGB(1, 1, 1, 0);\r\n\t        } else {\r\n\t            color = parseColor(namedColors[m[1]], safe);\r\n\t        }\r\n\t        color.match = [ m[1] ];\r\n\t        return color;\r\n\t    }\r\n\t    if ((m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\\b/i.exec(color))) {\r\n\t        ret = new Bytes(parseInt(m[1], 16),\r\n\t                        parseInt(m[2], 16),\r\n\t                        parseInt(m[3], 16), 1);\r\n\t    } else if ((m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])\\b/i.exec(color))) {\r\n\t        ret = new Bytes(parseInt(m[1] + m[1], 16),\r\n\t                        parseInt(m[2] + m[2], 16),\r\n\t                        parseInt(m[3] + m[3], 16), 1);\r\n\t    } else if ((m = /^rgb\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/.exec(color))) {\r\n\t        ret = new Bytes(parseInt(m[1], 10),\r\n\t                        parseInt(m[2], 10),\r\n\t                        parseInt(m[3], 10), 1);\r\n\t    } else if ((m = /^rgba\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9.]+)\\s*\\)/.exec(color))) {\r\n\t        ret = new Bytes(parseInt(m[1], 10),\r\n\t                        parseInt(m[2], 10),\r\n\t                        parseInt(m[3], 10), parseFloat(m[4]));\r\n\t    } else if ((m = /^rgb\\(\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*\\)/.exec(color))) {\r\n\t        ret = new RGB(parseFloat(m[1]) / 100,\r\n\t                      parseFloat(m[2]) / 100,\r\n\t                      parseFloat(m[3]) / 100, 1);\r\n\t    } else if ((m = /^rgba\\(\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9]*\\.?[0-9]+)%\\s*,\\s*([0-9.]+)\\s*\\)/.exec(color))) {\r\n\t        ret = new RGB(parseFloat(m[1]) / 100,\r\n\t                      parseFloat(m[2]) / 100,\r\n\t                      parseFloat(m[3]) / 100, parseFloat(m[4]));\r\n\t    }\r\n\r\n\t    if (ret) {\r\n\t        ret.match = m;\r\n\t    } else if (!safe) {\r\n\t        throw new Error(\"Cannot parse color: \" + color);\r\n\t    }\r\n\r\n\t    return ret;\r\n\t}\r\n\r\n\tvar Color = Class.extend({\r\n\t    init: function(value) {\r\n\t        var this$1 = this;\r\n\r\n\t        if (arguments.length === 1) {\r\n\t            var formats = Color.formats;\r\n\t            var resolvedColor = this.resolveColor(value);\r\n\r\n\t            for (var idx = 0; idx < formats.length; idx++) {\r\n\t                var formatRegex = formats[idx].re;\r\n\t                var processor = formats[idx].process;\r\n\t                var parts = formatRegex.exec(resolvedColor);\r\n\r\n\t                if (parts) {\r\n\t                    var channels = processor(parts);\r\n\t                    this$1.r = channels[0];\r\n\t                    this$1.g = channels[1];\r\n\t                    this$1.b = channels[2];\r\n\t                }\r\n\t            }\r\n\t        } else {\r\n\t            this.r = arguments[0];\r\n\t            this.g = arguments[1];\r\n\t            this.b = arguments[2];\r\n\t        }\r\n\r\n\t        this.r = this.normalizeByte(this.r);\r\n\t        this.g = this.normalizeByte(this.g);\r\n\t        this.b = this.normalizeByte(this.b);\r\n\t    },\r\n\r\n\t    toHex: function() {\r\n\t        var pad = this.padDigit;\r\n\t        var r = this.r.toString(16);\r\n\t        var g = this.g.toString(16);\r\n\t        var b = this.b.toString(16);\r\n\r\n\t        return \"#\" + pad(r) + pad(g) + pad(b);\r\n\t    },\r\n\r\n\t    resolveColor: function(value) {\r\n\t        var color = value || \"black\";\r\n\r\n\t        if (color.charAt(0) === \"#\") {\r\n\t            color = color.substr(1, 6);\r\n\t        }\r\n\r\n\t        color = color.replace(/ /g, \"\");\r\n\t        color = color.toLowerCase();\r\n\t        color = Color.namedColors[color] || color;\r\n\r\n\t        return color;\r\n\t    },\r\n\r\n\t    normalizeByte: function(value) {\r\n\t        if (value < 0 || isNaN(value)) {\r\n\t            return 0;\r\n\t        }\r\n\r\n\t        return value > 255 ? 255 : value;\r\n\t    },\r\n\r\n\t    padDigit: function(value) {\r\n\t        return (value.length === 1) ? \"0\" + value : value;\r\n\t    },\r\n\r\n\t    brightness: function(value) {\r\n\t        var round = Math.round;\r\n\r\n\t        this.r = round(this.normalizeByte(this.r * value));\r\n\t        this.g = round(this.normalizeByte(this.g * value));\r\n\t        this.b = round(this.normalizeByte(this.b * value));\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    percBrightness: function() {\r\n\t        return Math.sqrt(0.241 * this.r * this.r + 0.691 * this.g * this.g + 0.068 * this.b * this.b);\r\n\t    }\r\n\t});\r\n\r\n\tColor.fromBytes = function(r, g, b, a) {\r\n\t    return new Bytes(r, g, b, a != null ? a : 1);\r\n\t};\r\n\r\n\tColor.fromRGB = function(r, g, b, a) {\r\n\t    return new RGB(r, g, b, a != null ? a : 1);\r\n\t};\r\n\r\n\tColor.fromHSV = function(h, s, v, a) {\r\n\t    return new HSV(h, s, v, a != null ? a : 1);\r\n\t};\r\n\r\n\tColor.fromHSL = function(h, s, l, a) {\r\n\t    return new HSL(h, s, l, a != null ? a : 1);\r\n\t};\r\n\r\n\tColor.formats = [ {\r\n\t    re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\r\n\t    process: function(parts) {\r\n\t        return [\r\n\t            parseInt(parts[1], 10), parseInt(parts[2], 10), parseInt(parts[3], 10)\r\n\t        ];\r\n\t    }\r\n\t}, {\r\n\t    re: /^(\\w{2})(\\w{2})(\\w{2})$/,\r\n\t    process: function(parts) {\r\n\t        return [\r\n\t            parseInt(parts[1], 16), parseInt(parts[2], 16), parseInt(parts[3], 16)\r\n\t        ];\r\n\t    }\r\n\t}, {\r\n\t    re: /^(\\w{1})(\\w{1})(\\w{1})$/,\r\n\t    process: function(parts) {\r\n\t        return [\r\n\t            parseInt(parts[1] + parts[1], 16),\r\n\t            parseInt(parts[2] + parts[2], 16),\r\n\t            parseInt(parts[3] + parts[3], 16)\r\n\t        ];\r\n\t    }\r\n\t} ];\r\n\r\n\tColor.namedColors = namedColors;\r\n\r\n\tkendo.deepExtend(kendo, {\r\n\t    parseColor: parseColor,\r\n\t    Color: Color\r\n\t});\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.color.js\n// module id = 170\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1026);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 992:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"jquery\");\n\n/***/ }),\n\n/***/ 1026:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(jQuery) {(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(992)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"core\",\r\n\t    name: \"Core\",\r\n\t    category: \"framework\",\r\n\t    description: \"The core of the Kendo framework.\"\r\n\t};\r\n\r\n\t/*jshint eqnull: true, loopfunc: true, evil: true, boss: true, freeze: false*/\r\n\t(function($, window, undefined) {\r\n\t    var kendo = window.kendo = window.kendo || { cultures: {} },\r\n\t        extend = $.extend,\r\n\t        each = $.each,\r\n\t        isArray = $.isArray,\r\n\t        proxy = $.proxy,\r\n\t        noop = $.noop,\r\n\t        math = Math,\r\n\t        Template,\r\n\t        JSON = window.JSON || {},\r\n\t        support = {},\r\n\t        percentRegExp = /%/,\r\n\t        formatRegExp = /\\{(\\d+)(:[^\\}]+)?\\}/g,\r\n\t        boxShadowRegExp = /(\\d+(?:\\.?)\\d*)px\\s*(\\d+(?:\\.?)\\d*)px\\s*(\\d+(?:\\.?)\\d*)px\\s*(\\d+)?/i,\r\n\t        numberRegExp = /^(\\+|-?)\\d+(\\.?)\\d*$/,\r\n\t        FUNCTION = \"function\",\r\n\t        STRING = \"string\",\r\n\t        NUMBER = \"number\",\r\n\t        OBJECT = \"object\",\r\n\t        NULL = \"null\",\r\n\t        BOOLEAN = \"boolean\",\r\n\t        UNDEFINED = \"undefined\",\r\n\t        getterCache = {},\r\n\t        setterCache = {},\r\n\t        slice = [].slice;\r\n\r\n\t    kendo.version = \"2017.3.1116\".replace(/^\\s+|\\s+$/g, '');\r\n\r\n\t    function Class() {}\r\n\r\n\t    Class.extend = function(proto) {\r\n\t        var base = function() {},\r\n\t            member,\r\n\t            that = this,\r\n\t            subclass = proto && proto.init ? proto.init : function () {\r\n\t                that.apply(this, arguments);\r\n\t            },\r\n\t            fn;\r\n\r\n\t        base.prototype = that.prototype;\r\n\t        fn = subclass.fn = subclass.prototype = new base();\r\n\r\n\t        for (member in proto) {\r\n\t            if (proto[member] != null && proto[member].constructor === Object) {\r\n\t                // Merge object members\r\n\t                fn[member] = extend(true, {}, base.prototype[member], proto[member]);\r\n\t            } else {\r\n\t                fn[member] = proto[member];\r\n\t            }\r\n\t        }\r\n\r\n\t        fn.constructor = subclass;\r\n\t        subclass.extend = that.extend;\r\n\r\n\t        return subclass;\r\n\t    };\r\n\r\n\t    Class.prototype._initOptions = function(options) {\r\n\t        this.options = deepExtend({}, this.options, options);\r\n\t    };\r\n\r\n\t    var isFunction = kendo.isFunction = function(fn) {\r\n\t        return typeof fn === \"function\";\r\n\t    };\r\n\r\n\t    var preventDefault = function() {\r\n\t        this._defaultPrevented = true;\r\n\t    };\r\n\r\n\t    var isDefaultPrevented = function() {\r\n\t        return this._defaultPrevented === true;\r\n\t    };\r\n\r\n\t    var Observable = Class.extend({\r\n\t        init: function() {\r\n\t            this._events = {};\r\n\t        },\r\n\r\n\t        bind: function(eventName, handlers, one) {\r\n\t            var that = this,\r\n\t                idx,\r\n\t                eventNames = typeof eventName === STRING ? [eventName] : eventName,\r\n\t                length,\r\n\t                original,\r\n\t                handler,\r\n\t                handlersIsFunction = typeof handlers === FUNCTION,\r\n\t                events;\r\n\r\n\t            if (handlers === undefined) {\r\n\t                for (idx in eventName) {\r\n\t                    that.bind(idx, eventName[idx]);\r\n\t                }\r\n\t                return that;\r\n\t            }\r\n\r\n\t            for (idx = 0, length = eventNames.length; idx < length; idx++) {\r\n\t                eventName = eventNames[idx];\r\n\r\n\t                handler = handlersIsFunction ? handlers : handlers[eventName];\r\n\r\n\t                if (handler) {\r\n\t                    if (one) {\r\n\t                        original = handler;\r\n\t                        handler = function() {\r\n\t                            that.unbind(eventName, handler);\r\n\t                            original.apply(that, arguments);\r\n\t                        };\r\n\t                        handler.original = original;\r\n\t                    }\r\n\t                    events = that._events[eventName] = that._events[eventName] || [];\r\n\t                    events.push(handler);\r\n\t                }\r\n\t            }\r\n\r\n\t            return that;\r\n\t        },\r\n\r\n\t        one: function(eventNames, handlers) {\r\n\t            return this.bind(eventNames, handlers, true);\r\n\t        },\r\n\r\n\t        first: function(eventName, handlers) {\r\n\t            var that = this,\r\n\t                idx,\r\n\t                eventNames = typeof eventName === STRING ? [eventName] : eventName,\r\n\t                length,\r\n\t                handler,\r\n\t                handlersIsFunction = typeof handlers === FUNCTION,\r\n\t                events;\r\n\r\n\t            for (idx = 0, length = eventNames.length; idx < length; idx++) {\r\n\t                eventName = eventNames[idx];\r\n\r\n\t                handler = handlersIsFunction ? handlers : handlers[eventName];\r\n\r\n\t                if (handler) {\r\n\t                    events = that._events[eventName] = that._events[eventName] || [];\r\n\t                    events.unshift(handler);\r\n\t                }\r\n\t            }\r\n\r\n\t            return that;\r\n\t        },\r\n\r\n\t        trigger: function(eventName, e) {\r\n\t            var that = this,\r\n\t                events = that._events[eventName],\r\n\t                idx,\r\n\t                length;\r\n\r\n\t            if (events) {\r\n\t                e = e || {};\r\n\r\n\t                e.sender = that;\r\n\r\n\t                e._defaultPrevented = false;\r\n\r\n\t                e.preventDefault = preventDefault;\r\n\r\n\t                e.isDefaultPrevented = isDefaultPrevented;\r\n\r\n\t                events = events.slice();\r\n\r\n\t                for (idx = 0, length = events.length; idx < length; idx++) {\r\n\t                    events[idx].call(that, e);\r\n\t                }\r\n\r\n\t                return e._defaultPrevented === true;\r\n\t            }\r\n\r\n\t            return false;\r\n\t        },\r\n\r\n\t        unbind: function(eventName, handler) {\r\n\t            var that = this,\r\n\t                events = that._events[eventName],\r\n\t                idx;\r\n\r\n\t            if (eventName === undefined) {\r\n\t                that._events = {};\r\n\t            } else if (events) {\r\n\t                if (handler) {\r\n\t                    for (idx = events.length - 1; idx >= 0; idx--) {\r\n\t                        if (events[idx] === handler || events[idx].original === handler) {\r\n\t                            events.splice(idx, 1);\r\n\t                        }\r\n\t                    }\r\n\t                } else {\r\n\t                    that._events[eventName] = [];\r\n\t                }\r\n\t            }\r\n\r\n\t            return that;\r\n\t        }\r\n\t    });\r\n\r\n\r\n\t     function compilePart(part, stringPart) {\r\n\t         if (stringPart) {\r\n\t             return \"'\" +\r\n\t                 part.split(\"'\").join(\"\\\\'\")\r\n\t                     .split('\\\\\"').join('\\\\\\\\\\\\\"')\r\n\t                     .replace(/\\n/g, \"\\\\n\")\r\n\t                     .replace(/\\r/g, \"\\\\r\")\r\n\t                     .replace(/\\t/g, \"\\\\t\") + \"'\";\r\n\t         } else {\r\n\t             var first = part.charAt(0),\r\n\t                 rest = part.substring(1);\r\n\r\n\t             if (first === \"=\") {\r\n\t                 return \"+(\" + rest + \")+\";\r\n\t             } else if (first === \":\") {\r\n\t                 return \"+$kendoHtmlEncode(\" + rest + \")+\";\r\n\t             } else {\r\n\t                 return \";\" + part + \";$kendoOutput+=\";\r\n\t             }\r\n\t         }\r\n\t     }\r\n\r\n\t    var argumentNameRegExp = /^\\w+/,\r\n\t        encodeRegExp = /\\$\\{([^}]*)\\}/g,\r\n\t        escapedCurlyRegExp = /\\\\\\}/g,\r\n\t        curlyRegExp = /__CURLY__/g,\r\n\t        escapedSharpRegExp = /\\\\#/g,\r\n\t        sharpRegExp = /__SHARP__/g,\r\n\t        zeros = [\"\", \"0\", \"00\", \"000\", \"0000\"];\r\n\r\n\t    Template = {\r\n\t        paramName: \"data\", // name of the parameter of the generated template\r\n\t        useWithBlock: true, // whether to wrap the template in a with() block\r\n\t        render: function(template, data) {\r\n\t            var idx,\r\n\t                length,\r\n\t                html = \"\";\r\n\r\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                html += template(data[idx]);\r\n\t            }\r\n\r\n\t            return html;\r\n\t        },\r\n\t        compile: function(template, options) {\r\n\t            var settings = extend({}, this, options),\r\n\t                paramName = settings.paramName,\r\n\t                argumentName = paramName.match(argumentNameRegExp)[0],\r\n\t                useWithBlock = settings.useWithBlock,\r\n\t                functionBody = \"var $kendoOutput, $kendoHtmlEncode = kendo.htmlEncode;\",\r\n\t                fn,\r\n\t                parts,\r\n\t                idx;\r\n\r\n\t            if (isFunction(template)) {\r\n\t                return template;\r\n\t            }\r\n\r\n\t            functionBody += useWithBlock ? \"with(\" + paramName + \"){\" : \"\";\r\n\r\n\t            functionBody += \"$kendoOutput=\";\r\n\r\n\t            parts = template\r\n\t                .replace(escapedCurlyRegExp, \"__CURLY__\")\r\n\t                .replace(encodeRegExp, \"#=$kendoHtmlEncode($1)#\")\r\n\t                .replace(curlyRegExp, \"}\")\r\n\t                .replace(escapedSharpRegExp, \"__SHARP__\")\r\n\t                .split(\"#\");\r\n\r\n\t            for (idx = 0; idx < parts.length; idx ++) {\r\n\t                functionBody += compilePart(parts[idx], idx % 2 === 0);\r\n\t            }\r\n\r\n\t            functionBody += useWithBlock ? \";}\" : \";\";\r\n\r\n\t            functionBody += \"return $kendoOutput;\";\r\n\r\n\t            functionBody = functionBody.replace(sharpRegExp, \"#\");\r\n\r\n\t            try {\r\n\t                fn = new Function(argumentName, functionBody);\r\n\t                fn._slotCount = Math.floor(parts.length / 2);\r\n\t                return fn;\r\n\t            } catch(e) {\r\n\t                throw new Error(kendo.format(\"Invalid template:'{0}' Generated code:'{1}'\", template, functionBody));\r\n\t            }\r\n\t        }\r\n\t    };\r\n\r\n\tfunction pad(number, digits, end) {\r\n\t    number = number + \"\";\r\n\t    digits = digits || 2;\r\n\t    end = digits - number.length;\r\n\r\n\t    if (end) {\r\n\t        return zeros[digits].substring(0, end) + number;\r\n\t    }\r\n\r\n\t    return number;\r\n\t}\r\n\r\n\t    //JSON stringify\r\n\t(function() {\r\n\t    var escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\r\n\t        gap,\r\n\t        indent,\r\n\t        meta = {\r\n\t            \"\\b\": \"\\\\b\",\r\n\t            \"\\t\": \"\\\\t\",\r\n\t            \"\\n\": \"\\\\n\",\r\n\t            \"\\f\": \"\\\\f\",\r\n\t            \"\\r\": \"\\\\r\",\r\n\t            \"\\\"\" : '\\\\\"',\r\n\t            \"\\\\\": \"\\\\\\\\\"\r\n\t        },\r\n\t        rep,\r\n\t        toString = {}.toString;\r\n\r\n\r\n\t    if (typeof Date.prototype.toJSON !== FUNCTION) {\r\n\r\n\t        Date.prototype.toJSON = function () {\r\n\t            var that = this;\r\n\r\n\t            return isFinite(that.valueOf()) ?\r\n\t                pad(that.getUTCFullYear(), 4) + \"-\" +\r\n\t                pad(that.getUTCMonth() + 1)   + \"-\" +\r\n\t                pad(that.getUTCDate())        + \"T\" +\r\n\t                pad(that.getUTCHours())       + \":\" +\r\n\t                pad(that.getUTCMinutes())     + \":\" +\r\n\t                pad(that.getUTCSeconds())     + \"Z\" : null;\r\n\t        };\r\n\r\n\t        String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function () {\r\n\t            return this.valueOf();\r\n\t        };\r\n\t    }\r\n\r\n\t    function quote(string) {\r\n\t        escapable.lastIndex = 0;\r\n\t        return escapable.test(string) ? \"\\\"\" + string.replace(escapable, function (a) {\r\n\t            var c = meta[a];\r\n\t            return typeof c === STRING ? c :\r\n\t                \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).slice(-4);\r\n\t        }) + \"\\\"\" : \"\\\"\" + string + \"\\\"\";\r\n\t    }\r\n\r\n\t    function str(key, holder) {\r\n\t        var i,\r\n\t            k,\r\n\t            v,\r\n\t            length,\r\n\t            mind = gap,\r\n\t            partial,\r\n\t            value = holder[key],\r\n\t            type;\r\n\r\n\t        if (value && typeof value === OBJECT && typeof value.toJSON === FUNCTION) {\r\n\t            value = value.toJSON(key);\r\n\t        }\r\n\r\n\t        if (typeof rep === FUNCTION) {\r\n\t            value = rep.call(holder, key, value);\r\n\t        }\r\n\r\n\t        type = typeof value;\r\n\t        if (type === STRING) {\r\n\t            return quote(value);\r\n\t        } else if (type === NUMBER) {\r\n\t            return isFinite(value) ? String(value) : NULL;\r\n\t        } else if (type === BOOLEAN || type === NULL) {\r\n\t            return String(value);\r\n\t        } else if (type === OBJECT) {\r\n\t            if (!value) {\r\n\t                return NULL;\r\n\t            }\r\n\t            gap += indent;\r\n\t            partial = [];\r\n\t            if (toString.apply(value) === \"[object Array]\") {\r\n\t                length = value.length;\r\n\t                for (i = 0; i < length; i++) {\r\n\t                    partial[i] = str(i, value) || NULL;\r\n\t                }\r\n\t                v = partial.length === 0 ? \"[]\" : gap ?\r\n\t                    \"[\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"]\" :\r\n\t                    \"[\" + partial.join(\",\") + \"]\";\r\n\t                gap = mind;\r\n\t                return v;\r\n\t            }\r\n\t            if (rep && typeof rep === OBJECT) {\r\n\t                length = rep.length;\r\n\t                for (i = 0; i < length; i++) {\r\n\t                    if (typeof rep[i] === STRING) {\r\n\t                        k = rep[i];\r\n\t                        v = str(k, value);\r\n\t                        if (v) {\r\n\t                            partial.push(quote(k) + (gap ? \": \" : \":\") + v);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            } else {\r\n\t                for (k in value) {\r\n\t                    if (Object.hasOwnProperty.call(value, k)) {\r\n\t                        v = str(k, value);\r\n\t                        if (v) {\r\n\t                            partial.push(quote(k) + (gap ? \": \" : \":\") + v);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            v = partial.length === 0 ? \"{}\" : gap ?\r\n\t                \"{\\n\" + gap + partial.join(\",\\n\" + gap) + \"\\n\" + mind + \"}\" :\r\n\t                \"{\" + partial.join(\",\") + \"}\";\r\n\t            gap = mind;\r\n\t            return v;\r\n\t        }\r\n\t    }\r\n\r\n\t    if (typeof JSON.stringify !== FUNCTION) {\r\n\t        JSON.stringify = function (value, replacer, space) {\r\n\t            var i;\r\n\t            gap = \"\";\r\n\t            indent = \"\";\r\n\r\n\t            if (typeof space === NUMBER) {\r\n\t                for (i = 0; i < space; i += 1) {\r\n\t                    indent += \" \";\r\n\t                }\r\n\r\n\t            } else if (typeof space === STRING) {\r\n\t                indent = space;\r\n\t            }\r\n\r\n\t            rep = replacer;\r\n\t            if (replacer && typeof replacer !== FUNCTION && (typeof replacer !== OBJECT || typeof replacer.length !== NUMBER)) {\r\n\t                throw new Error(\"JSON.stringify\");\r\n\t            }\r\n\r\n\t            return str(\"\", {\"\": value});\r\n\t        };\r\n\t    }\r\n\t})();\r\n\r\n\t// Date and Number formatting\r\n\t(function() {\r\n\t    var dateFormatRegExp = /dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|HH|H|hh|h|mm|m|fff|ff|f|tt|ss|s|zzz|zz|z|\"[^\"]*\"|'[^']*'/g,\r\n\t        standardFormatRegExp =  /^(n|c|p|e)(\\d*)$/i,\r\n\t        literalRegExp = /(\\\\.)|(['][^']*[']?)|([\"][^\"]*[\"]?)/g,\r\n\t        commaRegExp = /\\,/g,\r\n\t        EMPTY = \"\",\r\n\t        POINT = \".\",\r\n\t        COMMA = \",\",\r\n\t        SHARP = \"#\",\r\n\t        ZERO = \"0\",\r\n\t        PLACEHOLDER = \"??\",\r\n\t        EN = \"en-US\",\r\n\t        objectToString = {}.toString;\r\n\r\n\t    //cultures\r\n\t    kendo.cultures[\"en-US\"] = {\r\n\t        name: EN,\r\n\t        numberFormat: {\r\n\t            pattern: [\"-n\"],\r\n\t            decimals: 2,\r\n\t            \",\": \",\",\r\n\t            \".\": \".\",\r\n\t            groupSize: [3],\r\n\t            percent: {\r\n\t                pattern: [\"-n %\", \"n %\"],\r\n\t                decimals: 2,\r\n\t                \",\": \",\",\r\n\t                \".\": \".\",\r\n\t                groupSize: [3],\r\n\t                symbol: \"%\"\r\n\t            },\r\n\t            currency: {\r\n\t                name: \"US Dollar\",\r\n\t                abbr: \"USD\",\r\n\t                pattern: [\"($n)\", \"$n\"],\r\n\t                decimals: 2,\r\n\t                \",\": \",\",\r\n\t                \".\": \".\",\r\n\t                groupSize: [3],\r\n\t                symbol: \"$\"\r\n\t            }\r\n\t        },\r\n\t        calendars: {\r\n\t            standard: {\r\n\t                days: {\r\n\t                    names: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\r\n\t                    namesAbbr: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\r\n\t                    namesShort: [ \"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\" ]\r\n\t                },\r\n\t                months: {\r\n\t                    names: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\r\n\t                    namesAbbr: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\r\n\t                },\r\n\t                AM: [ \"AM\", \"am\", \"AM\" ],\r\n\t                PM: [ \"PM\", \"pm\", \"PM\" ],\r\n\t                patterns: {\r\n\t                    d: \"M/d/yyyy\",\r\n\t                    D: \"dddd, MMMM dd, yyyy\",\r\n\t                    F: \"dddd, MMMM dd, yyyy h:mm:ss tt\",\r\n\t                    g: \"M/d/yyyy h:mm tt\",\r\n\t                    G: \"M/d/yyyy h:mm:ss tt\",\r\n\t                    m: \"MMMM dd\",\r\n\t                    M: \"MMMM dd\",\r\n\t                    s: \"yyyy'-'MM'-'ddTHH':'mm':'ss\",\r\n\t                    t: \"h:mm tt\",\r\n\t                    T: \"h:mm:ss tt\",\r\n\t                    u: \"yyyy'-'MM'-'dd HH':'mm':'ss'Z'\",\r\n\t                    y: \"MMMM, yyyy\",\r\n\t                    Y: \"MMMM, yyyy\"\r\n\t                },\r\n\t                \"/\": \"/\",\r\n\t                \":\": \":\",\r\n\t                firstDay: 0,\r\n\t                twoDigitYearMax: 2029\r\n\t            }\r\n\t        }\r\n\t    };\r\n\r\n\r\n\t     function findCulture(culture) {\r\n\t        if (culture) {\r\n\t            if (culture.numberFormat) {\r\n\t                return culture;\r\n\t            }\r\n\r\n\t            if (typeof culture === STRING) {\r\n\t                var cultures = kendo.cultures;\r\n\t                return cultures[culture] || cultures[culture.split(\"-\")[0]] || null;\r\n\t            }\r\n\r\n\t            return null;\r\n\t        }\r\n\r\n\t        return null;\r\n\t    }\r\n\r\n\t    function getCulture(culture) {\r\n\t        if (culture) {\r\n\t            culture = findCulture(culture);\r\n\t        }\r\n\r\n\t        return culture || kendo.cultures.current;\r\n\t    }\r\n\r\n\t    kendo.culture = function(cultureName) {\r\n\t        var cultures = kendo.cultures, culture;\r\n\r\n\t        if (cultureName !== undefined) {\r\n\t            culture = findCulture(cultureName) || cultures[EN];\r\n\t            culture.calendar = culture.calendars.standard;\r\n\t            cultures.current = culture;\r\n\t        } else {\r\n\t            return cultures.current;\r\n\t        }\r\n\t    };\r\n\r\n\t    kendo.findCulture = findCulture;\r\n\t    kendo.getCulture = getCulture;\r\n\r\n\t    //set current culture to en-US.\r\n\t    kendo.culture(EN);\r\n\r\n\t    function formatDate(date, format, culture) {\r\n\t        culture = getCulture(culture);\r\n\r\n\t        var calendar = culture.calendars.standard,\r\n\t            days = calendar.days,\r\n\t            months = calendar.months;\r\n\r\n\t        format = calendar.patterns[format] || format;\r\n\r\n\t        return format.replace(dateFormatRegExp, function (match) {\r\n\t            var minutes;\r\n\t            var result;\r\n\t            var sign;\r\n\r\n\t            if (match === \"d\") {\r\n\t                result = date.getDate();\r\n\t            } else if (match === \"dd\") {\r\n\t                result = pad(date.getDate());\r\n\t            } else if (match === \"ddd\") {\r\n\t                result = days.namesAbbr[date.getDay()];\r\n\t            } else if (match === \"dddd\") {\r\n\t                result = days.names[date.getDay()];\r\n\t            } else if (match === \"M\") {\r\n\t                result = date.getMonth() + 1;\r\n\t            } else if (match === \"MM\") {\r\n\t                result = pad(date.getMonth() + 1);\r\n\t            } else if (match === \"MMM\") {\r\n\t                result = months.namesAbbr[date.getMonth()];\r\n\t            } else if (match === \"MMMM\") {\r\n\t                result = months.names[date.getMonth()];\r\n\t            } else if (match === \"yy\") {\r\n\t                result = pad(date.getFullYear() % 100);\r\n\t            } else if (match === \"yyyy\") {\r\n\t                result = pad(date.getFullYear(), 4);\r\n\t            } else if (match === \"h\" ) {\r\n\t                result = date.getHours() % 12 || 12;\r\n\t            } else if (match === \"hh\") {\r\n\t                result = pad(date.getHours() % 12 || 12);\r\n\t            } else if (match === \"H\") {\r\n\t                result = date.getHours();\r\n\t            } else if (match === \"HH\") {\r\n\t                result = pad(date.getHours());\r\n\t            } else if (match === \"m\") {\r\n\t                result = date.getMinutes();\r\n\t            } else if (match === \"mm\") {\r\n\t                result = pad(date.getMinutes());\r\n\t            } else if (match === \"s\") {\r\n\t                result = date.getSeconds();\r\n\t            } else if (match === \"ss\") {\r\n\t                result = pad(date.getSeconds());\r\n\t            } else if (match === \"f\") {\r\n\t                result = math.floor(date.getMilliseconds() / 100);\r\n\t            } else if (match === \"ff\") {\r\n\t                result = date.getMilliseconds();\r\n\t                if (result > 99) {\r\n\t                    result = math.floor(result / 10);\r\n\t                }\r\n\t                result = pad(result);\r\n\t            } else if (match === \"fff\") {\r\n\t                result = pad(date.getMilliseconds(), 3);\r\n\t            } else if (match === \"tt\") {\r\n\t                result = date.getHours() < 12 ? calendar.AM[0] : calendar.PM[0];\r\n\t            } else if (match === \"zzz\") {\r\n\t                minutes = date.getTimezoneOffset();\r\n\t                sign = minutes < 0;\r\n\r\n\t                result = math.abs(minutes / 60).toString().split(\".\")[0];\r\n\t                minutes = math.abs(minutes) - (result * 60);\r\n\r\n\t                result = (sign ? \"+\" : \"-\") + pad(result);\r\n\t                result += \":\" + pad(minutes);\r\n\t            } else if (match === \"zz\" || match === \"z\") {\r\n\t                result = date.getTimezoneOffset() / 60;\r\n\t                sign = result < 0;\r\n\r\n\t                result = math.abs(result).toString().split(\".\")[0];\r\n\t                result = (sign ? \"+\" : \"-\") + (match === \"zz\" ? pad(result) : result);\r\n\t            }\r\n\r\n\t            return result !== undefined ? result : match.slice(1, match.length - 1);\r\n\t        });\r\n\t    }\r\n\r\n\t    //number formatting\r\n\t    function formatNumber(number, format, culture) {\r\n\t        culture = getCulture(culture);\r\n\r\n\t        var numberFormat = culture.numberFormat,\r\n\t            decimal = numberFormat[POINT],\r\n\t            precision = numberFormat.decimals,\r\n\t            pattern = numberFormat.pattern[0],\r\n\t            literals = [],\r\n\t            symbol,\r\n\t            isCurrency, isPercent,\r\n\t            customPrecision,\r\n\t            formatAndPrecision,\r\n\t            negative = number < 0,\r\n\t            integer,\r\n\t            fraction,\r\n\t            integerLength,\r\n\t            fractionLength,\r\n\t            replacement = EMPTY,\r\n\t            value = EMPTY,\r\n\t            idx,\r\n\t            length,\r\n\t            ch,\r\n\t            hasGroup,\r\n\t            hasNegativeFormat,\r\n\t            decimalIndex,\r\n\t            sharpIndex,\r\n\t            zeroIndex,\r\n\t            hasZero, hasSharp,\r\n\t            percentIndex,\r\n\t            currencyIndex,\r\n\t            startZeroIndex,\r\n\t            start = -1,\r\n\t            end;\r\n\r\n\t        //return empty string if no number\r\n\t        if (number === undefined) {\r\n\t            return EMPTY;\r\n\t        }\r\n\r\n\t        if (!isFinite(number)) {\r\n\t            return number;\r\n\t        }\r\n\r\n\t        //if no format then return number.toString() or number.toLocaleString() if culture.name is not defined\r\n\t        if (!format) {\r\n\t            return culture.name.length ? number.toLocaleString() : number.toString();\r\n\t        }\r\n\r\n\t        formatAndPrecision = standardFormatRegExp.exec(format);\r\n\r\n\t        // standard formatting\r\n\t        if (formatAndPrecision) {\r\n\t            format = formatAndPrecision[1].toLowerCase();\r\n\r\n\t            isCurrency = format === \"c\";\r\n\t            isPercent = format === \"p\";\r\n\r\n\t            if (isCurrency || isPercent) {\r\n\t                //get specific number format information if format is currency or percent\r\n\t                numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;\r\n\t                decimal = numberFormat[POINT];\r\n\t                precision = numberFormat.decimals;\r\n\t                symbol = numberFormat.symbol;\r\n\t                pattern = numberFormat.pattern[negative ? 0 : 1];\r\n\t            }\r\n\r\n\t            customPrecision = formatAndPrecision[2];\r\n\r\n\t            if (customPrecision) {\r\n\t                precision = +customPrecision;\r\n\t            }\r\n\r\n\t            //return number in exponential format\r\n\t            if (format === \"e\") {\r\n\t                return customPrecision ? number.toExponential(precision) : number.toExponential(); // toExponential() and toExponential(undefined) differ in FF #653438.\r\n\t            }\r\n\r\n\t            // multiply if format is percent\r\n\t            if (isPercent) {\r\n\t                number *= 100;\r\n\t            }\r\n\r\n\t            number = round(number, precision);\r\n\t            negative = number < 0;\r\n\t            number = number.split(POINT);\r\n\r\n\t            integer = number[0];\r\n\t            fraction = number[1];\r\n\r\n\t            //exclude \"-\" if number is negative.\r\n\t            if (negative) {\r\n\t                integer = integer.substring(1);\r\n\t            }\r\n\r\n\t            value = groupInteger(integer, 0, integer.length, numberFormat);\r\n\r\n\t            if (fraction) {\r\n\t                value += decimal + fraction;\r\n\t            }\r\n\r\n\t            if (format === \"n\" && !negative) {\r\n\t                return value;\r\n\t            }\r\n\r\n\t            number = EMPTY;\r\n\r\n\t            for (idx = 0, length = pattern.length; idx < length; idx++) {\r\n\t                ch = pattern.charAt(idx);\r\n\r\n\t                if (ch === \"n\") {\r\n\t                    number += value;\r\n\t                } else if (ch === \"$\" || ch === \"%\") {\r\n\t                    number += symbol;\r\n\t                } else {\r\n\t                    number += ch;\r\n\t                }\r\n\t            }\r\n\r\n\t            return number;\r\n\t        }\r\n\r\n\t        //custom formatting\r\n\t        //\r\n\t        //separate format by sections.\r\n\r\n\t        //make number positive\r\n\t        if (negative) {\r\n\t            number = -number;\r\n\t        }\r\n\r\n\t        if (format.indexOf(\"'\") > -1 || format.indexOf(\"\\\"\") > -1 || format.indexOf(\"\\\\\") > -1) {\r\n\t            format = format.replace(literalRegExp, function (match) {\r\n\t                var quoteChar = match.charAt(0).replace(\"\\\\\", \"\"),\r\n\t                    literal = match.slice(1).replace(quoteChar, \"\");\r\n\r\n\t                literals.push(literal);\r\n\r\n\t                return PLACEHOLDER;\r\n\t            });\r\n\t        }\r\n\r\n\t        format = format.split(\";\");\r\n\t        if (negative && format[1]) {\r\n\t            //get negative format\r\n\t            format = format[1];\r\n\t            hasNegativeFormat = true;\r\n\t        } else if (number === 0) {\r\n\t            //format for zeros\r\n\t            format = format[2] || format[0];\r\n\t            if (format.indexOf(SHARP) == -1 && format.indexOf(ZERO) == -1) {\r\n\t                //return format if it is string constant.\r\n\t                return format;\r\n\t            }\r\n\t        } else {\r\n\t            format = format[0];\r\n\t        }\r\n\r\n\t        percentIndex = format.indexOf(\"%\");\r\n\t        currencyIndex = format.indexOf(\"$\");\r\n\r\n\t        isPercent = percentIndex != -1;\r\n\t        isCurrency = currencyIndex != -1;\r\n\r\n\t        //multiply number if the format has percent\r\n\t        if (isPercent) {\r\n\t            number *= 100;\r\n\t        }\r\n\r\n\t        if (isCurrency && format[currencyIndex - 1] === \"\\\\\") {\r\n\t            format = format.split(\"\\\\\").join(\"\");\r\n\t            isCurrency = false;\r\n\t        }\r\n\r\n\t        if (isCurrency || isPercent) {\r\n\t            //get specific number format information if format is currency or percent\r\n\t            numberFormat = isCurrency ? numberFormat.currency : numberFormat.percent;\r\n\t            decimal = numberFormat[POINT];\r\n\t            precision = numberFormat.decimals;\r\n\t            symbol = numberFormat.symbol;\r\n\t        }\r\n\r\n\t        hasGroup = format.indexOf(COMMA) > -1;\r\n\t        if (hasGroup) {\r\n\t            format = format.replace(commaRegExp, EMPTY);\r\n\t        }\r\n\r\n\t        decimalIndex = format.indexOf(POINT);\r\n\t        length = format.length;\r\n\r\n\t        if (decimalIndex != -1) {\r\n\t            fraction = number.toString().split(\"e\");\r\n\t            if (fraction[1]) {\r\n\t                fraction = round(number, Math.abs(fraction[1]));\r\n\t            } else {\r\n\t                fraction = fraction[0];\r\n\t            }\r\n\t            fraction = fraction.split(POINT)[1] || EMPTY;\r\n\t            zeroIndex = format.lastIndexOf(ZERO) - decimalIndex;\r\n\t            sharpIndex = format.lastIndexOf(SHARP) - decimalIndex;\r\n\t            hasZero = zeroIndex > -1;\r\n\t            hasSharp = sharpIndex > -1;\r\n\t            idx = fraction.length;\r\n\r\n\t            if (!hasZero && !hasSharp) {\r\n\t                format = format.substring(0, decimalIndex) + format.substring(decimalIndex + 1);\r\n\t                length = format.length;\r\n\t                decimalIndex = -1;\r\n\t                idx = 0;\r\n\t            } if (hasZero && zeroIndex > sharpIndex) {\r\n\t                idx = zeroIndex;\r\n\t            } else if (sharpIndex > zeroIndex) {\r\n\t                if (hasSharp && idx > sharpIndex) {\r\n\t                    idx = sharpIndex;\r\n\t                } else if (hasZero && idx < zeroIndex) {\r\n\t                    idx = zeroIndex;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (idx > -1) {\r\n\t                number = round(number, idx);\r\n\t            }\r\n\t        } else {\r\n\t            number = round(number);\r\n\t        }\r\n\r\n\t        sharpIndex = format.indexOf(SHARP);\r\n\t        startZeroIndex = zeroIndex = format.indexOf(ZERO);\r\n\r\n\t        //define the index of the first digit placeholder\r\n\t        if (sharpIndex == -1 && zeroIndex != -1) {\r\n\t            start = zeroIndex;\r\n\t        } else if (sharpIndex != -1 && zeroIndex == -1) {\r\n\t            start = sharpIndex;\r\n\t        } else {\r\n\t            start = sharpIndex > zeroIndex ? zeroIndex : sharpIndex;\r\n\t        }\r\n\r\n\t        sharpIndex = format.lastIndexOf(SHARP);\r\n\t        zeroIndex = format.lastIndexOf(ZERO);\r\n\r\n\t        //define the index of the last digit placeholder\r\n\t        if (sharpIndex == -1 && zeroIndex != -1) {\r\n\t            end = zeroIndex;\r\n\t        } else if (sharpIndex != -1 && zeroIndex == -1) {\r\n\t            end = sharpIndex;\r\n\t        } else {\r\n\t            end = sharpIndex > zeroIndex ? sharpIndex : zeroIndex;\r\n\t        }\r\n\r\n\t        if (start == length) {\r\n\t            end = start;\r\n\t        }\r\n\r\n\t        if (start != -1) {\r\n\t            value = number.toString().split(POINT);\r\n\t            integer = value[0];\r\n\t            fraction = value[1] || EMPTY;\r\n\r\n\t            integerLength = integer.length;\r\n\t            fractionLength = fraction.length;\r\n\r\n\t            if (negative && (number * -1) >= 0) {\r\n\t                negative = false;\r\n\t            }\r\n\r\n\t            number = format.substring(0, start);\r\n\r\n\t            if (negative && !hasNegativeFormat) {\r\n\t                number += \"-\";\r\n\t            }\r\n\r\n\t            for (idx = start; idx < length; idx++) {\r\n\t                ch = format.charAt(idx);\r\n\r\n\t                if (decimalIndex == -1) {\r\n\t                    if (end - idx < integerLength) {\r\n\t                        number += integer;\r\n\t                        break;\r\n\t                    }\r\n\t                } else {\r\n\t                    if (zeroIndex != -1 && zeroIndex < idx) {\r\n\t                        replacement = EMPTY;\r\n\t                    }\r\n\r\n\t                    if ((decimalIndex - idx) <= integerLength && decimalIndex - idx > -1) {\r\n\t                        number += integer;\r\n\t                        idx = decimalIndex;\r\n\t                    }\r\n\r\n\t                    if (decimalIndex === idx) {\r\n\t                        number += (fraction ? decimal : EMPTY) + fraction;\r\n\t                        idx += end - decimalIndex + 1;\r\n\t                        continue;\r\n\t                    }\r\n\t                }\r\n\r\n\t                if (ch === ZERO) {\r\n\t                    number += ch;\r\n\t                    replacement = ch;\r\n\t                } else if (ch === SHARP) {\r\n\t                    number += replacement;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (hasGroup) {\r\n\t                number = groupInteger(number, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, (integerLength + start)), numberFormat);\r\n\t            }\r\n\r\n\t            if (end >= start) {\r\n\t                number += format.substring(end + 1);\r\n\t            }\r\n\r\n\t            //replace symbol placeholders\r\n\t            if (isCurrency || isPercent) {\r\n\t                value = EMPTY;\r\n\t                for (idx = 0, length = number.length; idx < length; idx++) {\r\n\t                    ch = number.charAt(idx);\r\n\t                    value += (ch === \"$\" || ch === \"%\") ? symbol : ch;\r\n\t                }\r\n\t                number = value;\r\n\t            }\r\n\r\n\t            length = literals.length;\r\n\r\n\t            if (length) {\r\n\t                for (idx = 0; idx < length; idx++) {\r\n\t                    number = number.replace(PLACEHOLDER, literals[idx]);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return number;\r\n\t    }\r\n\r\n\t    var groupInteger = function(number, start, end, numberFormat) {\r\n\t        var decimalIndex = number.indexOf(numberFormat[POINT]);\r\n\t        var groupSizes = numberFormat.groupSize.slice();\r\n\t        var groupSize = groupSizes.shift();\r\n\t        var integer, integerLength;\r\n\t        var idx, parts, value;\r\n\t        var newGroupSize;\r\n\r\n\t        end = decimalIndex !== -1 ? decimalIndex : end + 1;\r\n\r\n\t        integer = number.substring(start, end);\r\n\t        integerLength = integer.length;\r\n\r\n\t        if (integerLength >= groupSize) {\r\n\t            idx = integerLength;\r\n\t            parts = [];\r\n\r\n\t            while (idx > -1) {\r\n\t                value = integer.substring(idx - groupSize, idx);\r\n\t                if (value) {\r\n\t                    parts.push(value);\r\n\t                }\r\n\t                idx -= groupSize;\r\n\t                newGroupSize = groupSizes.shift();\r\n\t                groupSize = newGroupSize !== undefined ? newGroupSize : groupSize;\r\n\r\n\t                if (groupSize === 0) {\r\n\t                    if (idx > 0) {\r\n\t                        parts.push(integer.substring(0, idx));\r\n\t                    }\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\r\n\t            integer = parts.reverse().join(numberFormat[COMMA]);\r\n\t            number = number.substring(0, start) + integer + number.substring(end);\r\n\t        }\r\n\r\n\t        return number;\r\n\t    };\r\n\r\n\t    var round = function(value, precision) {\r\n\t        precision = precision || 0;\r\n\r\n\t        value = value.toString().split('e');\r\n\t        value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] + precision) : precision)));\r\n\r\n\t        value = value.toString().split('e');\r\n\t        value = +(value[0] + 'e' + (value[1] ? (+value[1] - precision) : -precision));\r\n\r\n\t        return value.toFixed(Math.min(precision, 20));\r\n\t    };\r\n\r\n\t    var toString = function(value, fmt, culture) {\r\n\t        if (fmt) {\r\n\t            if (objectToString.call(value) === \"[object Date]\") {\r\n\t                return formatDate(value, fmt, culture);\r\n\t            } else if (typeof value === NUMBER) {\r\n\t                return formatNumber(value, fmt, culture);\r\n\t            }\r\n\t        }\r\n\r\n\t        return value !== undefined ? value : \"\";\r\n\t    };\r\n\r\n\t    kendo.format = function(fmt) {\r\n\t        var values = arguments;\r\n\r\n\t        return fmt.replace(formatRegExp, function(match, index, placeholderFormat) {\r\n\t            var value = values[parseInt(index, 10) + 1];\r\n\r\n\t            return toString(value, placeholderFormat ? placeholderFormat.substring(1) : \"\");\r\n\t        });\r\n\t    };\r\n\r\n\t    kendo._extractFormat = function (format) {\r\n\t        if (format.slice(0,3) === \"{0:\") {\r\n\t            format = format.slice(3, format.length - 1);\r\n\t        }\r\n\r\n\t        return format;\r\n\t    };\r\n\r\n\t    kendo._activeElement = function() {\r\n\t        try {\r\n\t            return document.activeElement;\r\n\t        } catch(e) {\r\n\t            return document.documentElement.activeElement;\r\n\t        }\r\n\t    };\r\n\r\n\t    kendo._round = round;\r\n\t    kendo._outerWidth = function (element, includeMargin) { return $(element).outerWidth(includeMargin || false) || 0; };\r\n\t    kendo._outerHeight = function (element, includeMargin) { return $(element).outerHeight(includeMargin || false) || 0; };\r\n\t    kendo.toString = toString;\r\n\t})();\r\n\r\n\r\n\t(function() {\r\n\t    var nonBreakingSpaceRegExp = /\\u00A0/g,\r\n\t        exponentRegExp = /[eE][\\-+]?[0-9]+/,\r\n\t        shortTimeZoneRegExp = /[+|\\-]\\d{1,2}/,\r\n\t        longTimeZoneRegExp = /[+|\\-]\\d{1,2}:?\\d{2}/,\r\n\t        dateRegExp = /^\\/Date\\((.*?)\\)\\/$/,\r\n\t        offsetRegExp = /[+-]\\d*/,\r\n\t        FORMATS_SEQUENCE = [ [], [ \"G\", \"g\", \"F\" ], [ \"D\", \"d\", \"y\", \"m\", \"T\", \"t\" ] ],\r\n\t        STANDARD_FORMATS = [\r\n\t            [\r\n\t            \"yyyy-MM-ddTHH:mm:ss.fffffffzzz\",\r\n\t            \"yyyy-MM-ddTHH:mm:ss.fffffff\",\r\n\t            \"yyyy-MM-ddTHH:mm:ss.fffzzz\",\r\n\t            \"yyyy-MM-ddTHH:mm:ss.fff\",\r\n\t            \"ddd MMM dd yyyy HH:mm:ss\",\r\n\t            \"yyyy-MM-ddTHH:mm:sszzz\",\r\n\t            \"yyyy-MM-ddTHH:mmzzz\",\r\n\t            \"yyyy-MM-ddTHH:mmzz\",\r\n\t            \"yyyy-MM-ddTHH:mm:ss\",\r\n\t            \"yyyy-MM-dd HH:mm:ss\",\r\n\t            \"yyyy/MM/dd HH:mm:ss\"\r\n\t            ], [\r\n\t            \"yyyy-MM-ddTHH:mm\",\r\n\t            \"yyyy-MM-dd HH:mm\",\r\n\t            \"yyyy/MM/dd HH:mm\"\r\n\t            ], [\r\n\t            \"yyyy/MM/dd\",\r\n\t            \"yyyy-MM-dd\",\r\n\t            \"HH:mm:ss\",\r\n\t            \"HH:mm\"\r\n\t            ]\r\n\t        ],\r\n\t        numberRegExp = {\r\n\t            2: /^\\d{1,2}/,\r\n\t            3: /^\\d{1,3}/,\r\n\t            4: /^\\d{4}/\r\n\t        },\r\n\t        objectToString = {}.toString;\r\n\r\n\t    function outOfRange(value, start, end) {\r\n\t        return !(value >= start && value <= end);\r\n\t    }\r\n\r\n\t    function designatorPredicate(designator) {\r\n\t        return designator.charAt(0);\r\n\t    }\r\n\r\n\t    function mapDesignators(designators) {\r\n\t        return $.map(designators, designatorPredicate);\r\n\t    }\r\n\r\n\t    //if date's day is different than the typed one - adjust\r\n\t    function adjustDST(date, hours) {\r\n\t        if (!hours && date.getHours() === 23) {\r\n\t            date.setHours(date.getHours() + 2);\r\n\t        }\r\n\t    }\r\n\r\n\t    function lowerArray(data) {\r\n\t        var idx = 0,\r\n\t            length = data.length,\r\n\t            array = [];\r\n\r\n\t        for (; idx < length; idx++) {\r\n\t            array[idx] = (data[idx] + \"\").toLowerCase();\r\n\t        }\r\n\r\n\t        return array;\r\n\t    }\r\n\r\n\t    function lowerLocalInfo(localInfo) {\r\n\t        var newLocalInfo = {}, property;\r\n\r\n\t        for (property in localInfo) {\r\n\t            newLocalInfo[property] = lowerArray(localInfo[property]);\r\n\t        }\r\n\r\n\t        return newLocalInfo;\r\n\t    }\r\n\r\n\t    function parseExact(value, format, culture, strict) {\r\n\t        if (!value) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        var lookAhead = function (match) {\r\n\t                var i = 0;\r\n\t                while (format[idx] === match) {\r\n\t                    i++;\r\n\t                    idx++;\r\n\t                }\r\n\t                if (i > 0) {\r\n\t                    idx -= 1;\r\n\t                }\r\n\t                return i;\r\n\t            },\r\n\t            getNumber = function(size) {\r\n\t                var rg = numberRegExp[size] || new RegExp('^\\\\d{1,' + size + '}'),\r\n\t                    match = value.substr(valueIdx, size).match(rg);\r\n\r\n\t                if (match) {\r\n\t                    match = match[0];\r\n\t                    valueIdx += match.length;\r\n\t                    return parseInt(match, 10);\r\n\t                }\r\n\t                return null;\r\n\t            },\r\n\t            getIndexByName = function (names, lower) {\r\n\t                var i = 0,\r\n\t                    length = names.length,\r\n\t                    name, nameLength,\r\n\t                    matchLength = 0,\r\n\t                    matchIdx = 0,\r\n\t                    subValue;\r\n\r\n\t                for (; i < length; i++) {\r\n\t                    name = names[i];\r\n\t                    nameLength = name.length;\r\n\t                    subValue = value.substr(valueIdx, nameLength);\r\n\r\n\t                    if (lower) {\r\n\t                        subValue = subValue.toLowerCase();\r\n\t                    }\r\n\r\n\t                    if (subValue == name && nameLength > matchLength) {\r\n\t                        matchLength = nameLength;\r\n\t                        matchIdx = i;\r\n\t                    }\r\n\t                }\r\n\r\n\t                if (matchLength) {\r\n\t                    valueIdx += matchLength;\r\n\t                    return matchIdx + 1;\r\n\t                }\r\n\r\n\t                return null;\r\n\t            },\r\n\t            checkLiteral = function() {\r\n\t                var result = false;\r\n\t                if (value.charAt(valueIdx) === format[idx]) {\r\n\t                    valueIdx++;\r\n\t                    result = true;\r\n\t                }\r\n\t                return result;\r\n\t            },\r\n\t            calendar = culture.calendars.standard,\r\n\t            year = null,\r\n\t            month = null,\r\n\t            day = null,\r\n\t            hours = null,\r\n\t            minutes = null,\r\n\t            seconds = null,\r\n\t            milliseconds = null,\r\n\t            idx = 0,\r\n\t            valueIdx = 0,\r\n\t            literal = false,\r\n\t            date = new Date(),\r\n\t            twoDigitYearMax = calendar.twoDigitYearMax || 2029,\r\n\t            defaultYear = date.getFullYear(),\r\n\t            ch, count, length, pattern,\r\n\t            pmHour, UTC, matches,\r\n\t            amDesignators, pmDesignators,\r\n\t            hoursOffset, minutesOffset,\r\n\t            hasTime, match;\r\n\r\n\t        if (!format) {\r\n\t            format = \"d\"; //shord date format\r\n\t        }\r\n\r\n\t        //if format is part of the patterns get real format\r\n\t        pattern = calendar.patterns[format];\r\n\t        if (pattern) {\r\n\t            format = pattern;\r\n\t        }\r\n\r\n\t        format = format.split(\"\");\r\n\t        length = format.length;\r\n\r\n\t        for (; idx < length; idx++) {\r\n\t            ch = format[idx];\r\n\r\n\t            if (literal) {\r\n\t                if (ch === \"'\") {\r\n\t                    literal = false;\r\n\t                } else {\r\n\t                    checkLiteral();\r\n\t                }\r\n\t            } else {\r\n\t                if (ch === \"d\") {\r\n\t                    count = lookAhead(\"d\");\r\n\t                    if (!calendar._lowerDays) {\r\n\t                        calendar._lowerDays = lowerLocalInfo(calendar.days);\r\n\t                    }\r\n\r\n\t                    if (day !== null && count > 2) {\r\n\t                        continue;\r\n\t                    }\r\n\r\n\t                    day = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerDays[count == 3 ? \"namesAbbr\" : \"names\"], true);\r\n\r\n\t                    if (day === null || outOfRange(day, 1, 31)) {\r\n\t                        return null;\r\n\t                    }\r\n\t                } else if (ch === \"M\") {\r\n\t                    count = lookAhead(\"M\");\r\n\t                    if (!calendar._lowerMonths) {\r\n\t                        calendar._lowerMonths = lowerLocalInfo(calendar.months);\r\n\t                    }\r\n\t                    month = count < 3 ? getNumber(2) : getIndexByName(calendar._lowerMonths[count == 3 ? 'namesAbbr' : 'names'], true);\r\n\r\n\t                    if (month === null || outOfRange(month, 1, 12)) {\r\n\t                        return null;\r\n\t                    }\r\n\t                    month -= 1; //because month is zero based\r\n\t                } else if (ch === \"y\") {\r\n\t                    count = lookAhead(\"y\");\r\n\t                    year = getNumber(count);\r\n\r\n\t                    if (year === null) {\r\n\t                        return null;\r\n\t                    }\r\n\r\n\t                    if (count == 2) {\r\n\t                        if (typeof twoDigitYearMax === \"string\") {\r\n\t                            twoDigitYearMax = defaultYear + parseInt(twoDigitYearMax, 10);\r\n\t                        }\r\n\r\n\t                        year = (defaultYear - defaultYear % 100) + year;\r\n\t                        if (year > twoDigitYearMax) {\r\n\t                            year -= 100;\r\n\t                        }\r\n\t                    }\r\n\t                } else if (ch === \"h\" ) {\r\n\t                    lookAhead(\"h\");\r\n\t                    hours = getNumber(2);\r\n\t                    if (hours == 12) {\r\n\t                        hours = 0;\r\n\t                    }\r\n\t                    if (hours === null || outOfRange(hours, 0, 11)) {\r\n\t                        return null;\r\n\t                    }\r\n\t                } else if (ch === \"H\") {\r\n\t                    lookAhead(\"H\");\r\n\t                    hours = getNumber(2);\r\n\t                    if (hours === null || outOfRange(hours, 0, 23)) {\r\n\t                        return null;\r\n\t                    }\r\n\t                } else if (ch === \"m\") {\r\n\t                    lookAhead(\"m\");\r\n\t                    minutes = getNumber(2);\r\n\t                    if (minutes === null || outOfRange(minutes, 0, 59)) {\r\n\t                        return null;\r\n\t                    }\r\n\t                } else if (ch === \"s\") {\r\n\t                    lookAhead(\"s\");\r\n\t                    seconds = getNumber(2);\r\n\t                    if (seconds === null || outOfRange(seconds, 0, 59)) {\r\n\t                        return null;\r\n\t                    }\r\n\t                } else if (ch === \"f\") {\r\n\t                    count = lookAhead(\"f\");\r\n\r\n\t                    match = value.substr(valueIdx, count).match(numberRegExp[3]);\r\n\t                    milliseconds = getNumber(count); //move value index position\r\n\r\n\t                    if (milliseconds !== null) {\r\n\t                        milliseconds = parseFloat(\"0.\" + match[0], 10);\r\n\t                        milliseconds = kendo._round(milliseconds, 3);\r\n\t                        milliseconds *= 1000;\r\n\t                    }\r\n\r\n\t                    if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {\r\n\t                        return null;\r\n\t                    }\r\n\r\n\t                } else if (ch === \"t\") {\r\n\t                    count = lookAhead(\"t\");\r\n\t                    amDesignators = calendar.AM;\r\n\t                    pmDesignators = calendar.PM;\r\n\r\n\t                    if (count === 1) {\r\n\t                        amDesignators = mapDesignators(amDesignators);\r\n\t                        pmDesignators = mapDesignators(pmDesignators);\r\n\t                    }\r\n\r\n\t                    pmHour = getIndexByName(pmDesignators);\r\n\t                    if (!pmHour && !getIndexByName(amDesignators)) {\r\n\t                        return null;\r\n\t                    }\r\n\t                }\r\n\t                else if (ch === \"z\") {\r\n\t                    UTC = true;\r\n\t                    count = lookAhead(\"z\");\r\n\r\n\t                    if (value.substr(valueIdx, 1) === \"Z\") {\r\n\t                        checkLiteral();\r\n\t                        continue;\r\n\t                    }\r\n\r\n\t                    matches = value.substr(valueIdx, 6)\r\n\t                                   .match(count > 2 ? longTimeZoneRegExp : shortTimeZoneRegExp);\r\n\r\n\t                    if (!matches) {\r\n\t                        return null;\r\n\t                    }\r\n\r\n\t                    matches = matches[0].split(\":\");\r\n\r\n\t                    hoursOffset = matches[0];\r\n\t                    minutesOffset = matches[1];\r\n\r\n\t                    if (!minutesOffset && hoursOffset.length > 3) { //(+|-)[hh][mm] format is used\r\n\t                        valueIdx = hoursOffset.length - 2;\r\n\t                        minutesOffset = hoursOffset.substring(valueIdx);\r\n\t                        hoursOffset = hoursOffset.substring(0, valueIdx);\r\n\t                    }\r\n\r\n\t                    hoursOffset = parseInt(hoursOffset, 10);\r\n\t                    if (outOfRange(hoursOffset, -12, 13)) {\r\n\t                        return null;\r\n\t                    }\r\n\r\n\t                    if (count > 2) {\r\n\t                        minutesOffset = parseInt(minutesOffset, 10);\r\n\t                        if (isNaN(minutesOffset) || outOfRange(minutesOffset, 0, 59)) {\r\n\t                            return null;\r\n\t                        }\r\n\t                    }\r\n\t                } else if (ch === \"'\") {\r\n\t                    literal = true;\r\n\t                    checkLiteral();\r\n\t                } else if (!checkLiteral()) {\r\n\t                    return null;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        // if more characters follow, assume wrong format\r\n\t        // https://github.com/telerik/kendo-ui-core/issues/3476\r\n\t        if (strict && !/^\\s*$/.test(value.substr(valueIdx))) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        hasTime = hours !== null || minutes !== null || seconds || null;\r\n\r\n\t        if (year === null && month === null && day === null && hasTime) {\r\n\t            year = defaultYear;\r\n\t            month = date.getMonth();\r\n\t            day = date.getDate();\r\n\t        } else {\r\n\t            if (year === null) {\r\n\t                year = defaultYear;\r\n\t            }\r\n\r\n\t            if (day === null) {\r\n\t                day = 1;\r\n\t            }\r\n\t        }\r\n\r\n\t        if (pmHour && hours < 12) {\r\n\t            hours += 12;\r\n\t        }\r\n\r\n\t        if (UTC) {\r\n\t            if (hoursOffset) {\r\n\t                hours += -hoursOffset;\r\n\t            }\r\n\r\n\t            if (minutesOffset) {\r\n\t                minutes += -minutesOffset;\r\n\t            }\r\n\r\n\t            value = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));\r\n\t        } else {\r\n\t            value = new Date(year, month, day, hours, minutes, seconds, milliseconds);\r\n\t            adjustDST(value, hours);\r\n\t        }\r\n\r\n\t        if (year < 100) {\r\n\t            value.setFullYear(year);\r\n\t        }\r\n\r\n\t        if (value.getDate() !== day && UTC === undefined) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        return value;\r\n\t    }\r\n\r\n\t    function parseMicrosoftFormatOffset(offset) {\r\n\t        var sign = offset.substr(0, 1) === \"-\" ? -1 : 1;\r\n\r\n\t        offset = offset.substring(1);\r\n\t        offset = (parseInt(offset.substr(0, 2), 10) * 60) + parseInt(offset.substring(2), 10);\r\n\r\n\t        return sign * offset;\r\n\t    }\r\n\r\n\t    function getDefaultFormats(culture) {\r\n\t        var length = math.max(FORMATS_SEQUENCE.length, STANDARD_FORMATS.length);\r\n\t        var patterns = culture.calendar.patterns;\r\n\t        var cultureFormats, formatIdx, idx;\r\n\t        var formats = [];\r\n\r\n\t        for (idx = 0; idx < length; idx++) {\r\n\t            cultureFormats = FORMATS_SEQUENCE[idx];\r\n\t            for (formatIdx = 0; formatIdx < cultureFormats.length; formatIdx++) {\r\n\t                formats.push(patterns[cultureFormats[formatIdx]]);\r\n\t            }\r\n\t            formats = formats.concat(STANDARD_FORMATS[idx]);\r\n\t        }\r\n\r\n\t        return formats;\r\n\t    }\r\n\r\n\t    function internalParseDate(value, formats, culture, strict) {\r\n\t        if (objectToString.call(value) === \"[object Date]\") {\r\n\t            return value;\r\n\t        }\r\n\r\n\t        var idx = 0;\r\n\t        var date = null;\r\n\t        var length;\r\n\t        var tzoffset;\r\n\r\n\t        if (value && value.indexOf(\"/D\") === 0) {\r\n\t            date = dateRegExp.exec(value);\r\n\t            if (date) {\r\n\t                date = date[1];\r\n\t                tzoffset = offsetRegExp.exec(date.substring(1));\r\n\r\n\t                date = new Date(parseInt(date, 10));\r\n\r\n\t                if (tzoffset) {\r\n\t                    tzoffset = parseMicrosoftFormatOffset(tzoffset[0]);\r\n\t                    date = kendo.timezone.apply(date, 0);\r\n\t                    date = kendo.timezone.convert(date, 0, -1 * tzoffset);\r\n\t                }\r\n\r\n\t                return date;\r\n\t            }\r\n\t        }\r\n\r\n\t        culture = kendo.getCulture(culture);\r\n\r\n\t        if (!formats) {\r\n\t            formats = getDefaultFormats(culture);\r\n\t        }\r\n\r\n\t        formats = isArray(formats) ? formats: [formats];\r\n\t        length = formats.length;\r\n\r\n\t        for (; idx < length; idx++) {\r\n\t            date = parseExact(value, formats[idx], culture, strict);\r\n\t            if (date) {\r\n\t                return date;\r\n\t            }\r\n\t        }\r\n\r\n\t        return date;\r\n\t    }\r\n\r\n\t    kendo.parseDate = function(value, formats, culture) {\r\n\t        return internalParseDate(value, formats, culture, false);\r\n\t    };\r\n\r\n\t    kendo.parseExactDate = function(value, formats, culture) {\r\n\t        return internalParseDate(value, formats, culture, true);\r\n\t    };\r\n\r\n\t    kendo.parseInt = function(value, culture) {\r\n\t        var result = kendo.parseFloat(value, culture);\r\n\t        if (result) {\r\n\t            result = result | 0;\r\n\t        }\r\n\t        return result;\r\n\t    };\r\n\r\n\t    kendo.parseFloat = function(value, culture, format) {\r\n\t        if (!value && value !== 0) {\r\n\t           return null;\r\n\t        }\r\n\r\n\t        if (typeof value === NUMBER) {\r\n\t           return value;\r\n\t        }\r\n\r\n\t        value = value.toString();\r\n\t        culture = kendo.getCulture(culture);\r\n\r\n\t        var number = culture.numberFormat,\r\n\t            percent = number.percent,\r\n\t            currency = number.currency,\r\n\t            symbol = currency.symbol,\r\n\t            percentSymbol = percent.symbol,\r\n\t            negative = value.indexOf(\"-\"),\r\n\t            parts, isPercent;\r\n\r\n\t        //handle exponential number\r\n\t        if (exponentRegExp.test(value)) {\r\n\t            value = parseFloat(value.replace(number[\".\"], \".\"));\r\n\t            if (isNaN(value)) {\r\n\t                value = null;\r\n\t            }\r\n\t            return value;\r\n\t        }\r\n\r\n\t        if (negative > 0) {\r\n\t            return null;\r\n\t        } else {\r\n\t            negative = negative > -1;\r\n\t        }\r\n\r\n\t        if (value.indexOf(symbol) > -1 || (format && format.toLowerCase().indexOf(\"c\") > -1)) {\r\n\t            number = currency;\r\n\t            parts = number.pattern[0].replace(\"$\", symbol).split(\"n\");\r\n\t            if (value.indexOf(parts[0]) > -1 && value.indexOf(parts[1]) > -1) {\r\n\t                value = value.replace(parts[0], \"\").replace(parts[1], \"\");\r\n\t                negative = true;\r\n\t            }\r\n\t        } else if (value.indexOf(percentSymbol) > -1) {\r\n\t            isPercent = true;\r\n\t            number = percent;\r\n\t            symbol = percentSymbol;\r\n\t        }\r\n\r\n\t        value = value.replace(\"-\", \"\")\r\n\t                     .replace(symbol, \"\")\r\n\t                     .replace(nonBreakingSpaceRegExp, \" \")\r\n\t                     .split(number[\",\"].replace(nonBreakingSpaceRegExp, \" \")).join(\"\")\r\n\t                     .replace(number[\".\"], \".\");\r\n\r\n\t        value = parseFloat(value);\r\n\r\n\t        if (isNaN(value)) {\r\n\t            value = null;\r\n\t        } else if (negative) {\r\n\t            value *= -1;\r\n\t        }\r\n\r\n\t        if (value && isPercent) {\r\n\t            value /= 100;\r\n\t        }\r\n\r\n\t        return value;\r\n\t    };\r\n\t})();\r\n\r\n\t    function getShadows(element) {\r\n\t        var shadow = element.css(kendo.support.transitions.css + \"box-shadow\") || element.css(\"box-shadow\"),\r\n\t            radius = shadow ? shadow.match(boxShadowRegExp) || [ 0, 0, 0, 0, 0 ] : [ 0, 0, 0, 0, 0 ],\r\n\t            blur = math.max((+radius[3]), +(radius[4] || 0));\r\n\r\n\t        return {\r\n\t            left: (-radius[1]) + blur,\r\n\t            right: (+radius[1]) + blur,\r\n\t            bottom: (+radius[2]) + blur\r\n\t        };\r\n\t    }\r\n\r\n\t    function wrap(element, autosize) {\r\n\t        var browser = support.browser,\r\n\t            percentage,\r\n\t            outerWidth = kendo._outerWidth,\r\n\t            outerHeight = kendo._outerHeight;\r\n\r\n\t        if (!element.parent().hasClass(\"k-animation-container\")) {\r\n\t            var width = element[0].style.width,\r\n\t                height = element[0].style.height,\r\n\t                percentWidth = percentRegExp.test(width),\r\n\t                percentHeight = percentRegExp.test(height);\r\n\r\n\t            percentage = percentWidth || percentHeight;\r\n\r\n\t            if (!percentWidth && (!autosize || (autosize && width))) { width = autosize ? outerWidth(element) + 1 : outerWidth(element); }\r\n\t            if (!percentHeight && (!autosize || (autosize && height))) { height = outerHeight(element); }\r\n\r\n\t            element.wrap(\r\n\t                         $(\"<div/>\")\r\n\t                         .addClass(\"k-animation-container\")\r\n\t                         .css({\r\n\t                             width: width,\r\n\t                             height: height\r\n\t                         }));\r\n\r\n\t            if (percentage) {\r\n\t                element.css({\r\n\t                    width: \"100%\",\r\n\t                    height: \"100%\",\r\n\t                    boxSizing: \"border-box\",\r\n\t                    mozBoxSizing: \"border-box\",\r\n\t                    webkitBoxSizing: \"border-box\"\r\n\t                });\r\n\t            }\r\n\t        } else {\r\n\t            var wrapper = element.parent(\".k-animation-container\"),\r\n\t                wrapperStyle = wrapper[0].style;\r\n\r\n\t            if (wrapper.is(\":hidden\")) {\r\n\t                wrapper.css({\r\n\t                    display: \"\",\r\n\t                    position: \"\"\r\n\t                });\r\n\t            }\r\n\r\n\t            percentage = percentRegExp.test(wrapperStyle.width) || percentRegExp.test(wrapperStyle.height);\r\n\r\n\t            if (!percentage) {\r\n\t                wrapper.css({\r\n\t                    width: autosize ? outerWidth(element) + 1 : outerWidth(element),\r\n\t                    height: outerHeight(element),\r\n\t                    boxSizing: \"content-box\",\r\n\t                    mozBoxSizing: \"content-box\",\r\n\t                    webkitBoxSizing: \"content-box\"\r\n\t                });\r\n\t            }\r\n\t        }\r\n\r\n\t        if (browser.msie && math.floor(browser.version) <= 7) {\r\n\t            element.css({ zoom: 1 });\r\n\t            element.children(\".k-menu\").width(element.width());\r\n\t        }\r\n\r\n\t        return element.parent();\r\n\t    }\r\n\r\n\t    function deepExtend(destination) {\r\n\t        var i = 1,\r\n\t            length = arguments.length;\r\n\r\n\t        for (i = 1; i < length; i++) {\r\n\t            deepExtendOne(destination, arguments[i]);\r\n\t        }\r\n\r\n\t        return destination;\r\n\t    }\r\n\r\n\t    function deepExtendOne(destination, source) {\r\n\t        var ObservableArray = kendo.data.ObservableArray,\r\n\t            LazyObservableArray = kendo.data.LazyObservableArray,\r\n\t            DataSource = kendo.data.DataSource,\r\n\t            HierarchicalDataSource = kendo.data.HierarchicalDataSource,\r\n\t            property,\r\n\t            propValue,\r\n\t            propType,\r\n\t            propInit,\r\n\t            destProp;\r\n\r\n\t        for (property in source) {\r\n\t            propValue = source[property];\r\n\t            propType = typeof propValue;\r\n\r\n\t            if (propType === OBJECT && propValue !== null) {\r\n\t                propInit = propValue.constructor;\r\n\t            } else {\r\n\t                propInit = null;\r\n\t            }\r\n\r\n\t            if (propInit &&\r\n\t                propInit !== Array && propInit !== ObservableArray && propInit !== LazyObservableArray &&\r\n\t                propInit !== DataSource && propInit !== HierarchicalDataSource && propInit !== RegExp) {\r\n\r\n\t                if (propValue instanceof Date) {\r\n\t                    destination[property] = new Date(propValue.getTime());\r\n\t                } else if (isFunction(propValue.clone)) {\r\n\t                    destination[property] = propValue.clone();\r\n\t                } else {\r\n\t                    destProp = destination[property];\r\n\t                    if (typeof (destProp) === OBJECT) {\r\n\t                        destination[property] = destProp || {};\r\n\t                    } else {\r\n\t                        destination[property] = {};\r\n\t                    }\r\n\t                    deepExtendOne(destination[property], propValue);\r\n\t                }\r\n\t            } else if (propType !== UNDEFINED) {\r\n\t                destination[property] = propValue;\r\n\t            }\r\n\t        }\r\n\r\n\t        return destination;\r\n\t    }\r\n\r\n\t    function testRx(agent, rxs, dflt) {\r\n\t        for (var rx in rxs) {\r\n\t            if (rxs.hasOwnProperty(rx) && rxs[rx].test(agent)) {\r\n\t                return rx;\r\n\t            }\r\n\t        }\r\n\t        return dflt !== undefined ? dflt : agent;\r\n\t    }\r\n\r\n\t    function toHyphens(str) {\r\n\t        return str.replace(/([a-z][A-Z])/g, function (g) {\r\n\t            return g.charAt(0) + '-' + g.charAt(1).toLowerCase();\r\n\t        });\r\n\t    }\r\n\r\n\t    function toCamelCase(str) {\r\n\t        return str.replace(/\\-(\\w)/g, function (strMatch, g1) {\r\n\t            return g1.toUpperCase();\r\n\t        });\r\n\t    }\r\n\r\n\t    function getComputedStyles(element, properties) {\r\n\t        var styles = {}, computedStyle;\r\n\r\n\t        if (document.defaultView && document.defaultView.getComputedStyle) {\r\n\t            computedStyle = document.defaultView.getComputedStyle(element, \"\");\r\n\r\n\t            if (properties) {\r\n\t                $.each(properties, function(idx, value) {\r\n\t                    styles[value] = computedStyle.getPropertyValue(value);\r\n\t                });\r\n\t            }\r\n\t        } else {\r\n\t            computedStyle = element.currentStyle;\r\n\r\n\t            if (properties) {\r\n\t                $.each(properties, function(idx, value) {\r\n\t                    styles[value] = computedStyle[toCamelCase(value)];\r\n\t                });\r\n\t            }\r\n\t        }\r\n\r\n\t        if (!kendo.size(styles)) {\r\n\t            styles = computedStyle;\r\n\t        }\r\n\r\n\t        return styles;\r\n\t    }\r\n\r\n\t    function isScrollable(element) {\r\n\t        if (element && element.className && typeof(element.className) === \"string\" && element.className.indexOf(\"k-auto-scrollable\") > -1) {\r\n\t            return true;\r\n\t        }\r\n\r\n\t        var overflow = getComputedStyles(element, [\"overflow\"]).overflow;\r\n\t        return overflow == \"auto\" || overflow == \"scroll\";\r\n\t    }\r\n\r\n\t    function scrollLeft(element, value) {\r\n\t        var webkit = support.browser.webkit;\r\n\t        var mozila = support.browser.mozilla;\r\n\t        var el = element instanceof $ ? element[0] : element;\r\n\t        var isRtl;\r\n\r\n\t        if (!element) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        isRtl = support.isRtl(element);\r\n\r\n\t        if (value !== undefined) {\r\n\t            if (isRtl && webkit) {\r\n\t                el.scrollLeft = el.scrollWidth - el.clientWidth - value;\r\n\t            } else if (isRtl && mozila) {\r\n\t                el.scrollLeft = -value;\r\n\t            } else {\r\n\t                el.scrollLeft = value;\r\n\t            }\r\n\t        } else {\r\n\t            if (isRtl && webkit) {\r\n\t                return el.scrollWidth - el.clientWidth - el.scrollLeft;\r\n\t            } else {\r\n\t                return Math.abs(el.scrollLeft);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    (function () {\r\n\t        support._scrollbar = undefined;\r\n\r\n\t        support.scrollbar = function (refresh) {\r\n\t            if (!isNaN(support._scrollbar) && !refresh) {\r\n\t                return support._scrollbar;\r\n\t            } else {\r\n\t                var div = document.createElement(\"div\"),\r\n\t                    result;\r\n\r\n\t                div.style.cssText = \"overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block\";\r\n\t                div.innerHTML = \"&nbsp;\";\r\n\t                document.body.appendChild(div);\r\n\r\n\t                support._scrollbar = result = div.offsetWidth - div.scrollWidth;\r\n\r\n\t                document.body.removeChild(div);\r\n\r\n\t                return result;\r\n\t            }\r\n\t        };\r\n\r\n\t        support.isRtl = function(element) {\r\n\t            return $(element).closest(\".k-rtl\").length > 0;\r\n\t        };\r\n\r\n\t        var table = document.createElement(\"table\");\r\n\r\n\t        // Internet Explorer does not support setting the innerHTML of TBODY and TABLE elements\r\n\t        try {\r\n\t            table.innerHTML = \"<tr><td></td></tr>\";\r\n\r\n\t            support.tbodyInnerHtml = true;\r\n\t        } catch (e) {\r\n\t            support.tbodyInnerHtml = false;\r\n\t        }\r\n\r\n\t        support.touch = \"ontouchstart\" in window;\r\n\r\n\t        var docStyle = document.documentElement.style;\r\n\t        var transitions = support.transitions = false,\r\n\t            transforms = support.transforms = false,\r\n\t            elementProto = \"HTMLElement\" in window ? HTMLElement.prototype : [];\r\n\r\n\t        support.hasHW3D = (\"WebKitCSSMatrix\" in window && \"m11\" in new window.WebKitCSSMatrix()) || \"MozPerspective\" in docStyle || \"msPerspective\" in docStyle;\r\n\t        support.cssFlexbox = (\"flexWrap\" in docStyle) || (\"WebkitFlexWrap\" in docStyle) || (\"msFlexWrap\" in docStyle);\r\n\r\n\t        each([ \"Moz\", \"webkit\", \"O\", \"ms\" ], function () {\r\n\t            var prefix = this.toString(),\r\n\t                hasTransitions = typeof table.style[prefix + \"Transition\"] === STRING;\r\n\r\n\t            if (hasTransitions || typeof table.style[prefix + \"Transform\"] === STRING) {\r\n\t                var lowPrefix = prefix.toLowerCase();\r\n\r\n\t                transforms = {\r\n\t                    css: (lowPrefix != \"ms\") ? \"-\" + lowPrefix + \"-\" : \"\",\r\n\t                    prefix: prefix,\r\n\t                    event: (lowPrefix === \"o\" || lowPrefix === \"webkit\") ? lowPrefix : \"\"\r\n\t                };\r\n\r\n\t                if (hasTransitions) {\r\n\t                    transitions = transforms;\r\n\t                    transitions.event = transitions.event ? transitions.event + \"TransitionEnd\" : \"transitionend\";\r\n\t                }\r\n\r\n\t                return false;\r\n\t            }\r\n\t        });\r\n\r\n\t        table = null;\r\n\r\n\t        support.transforms = transforms;\r\n\t        support.transitions = transitions;\r\n\r\n\t        support.devicePixelRatio = window.devicePixelRatio === undefined ? 1 : window.devicePixelRatio;\r\n\r\n\t        try {\r\n\t            support.screenWidth = window.outerWidth || window.screen ? window.screen.availWidth : window.innerWidth;\r\n\t            support.screenHeight = window.outerHeight || window.screen ? window.screen.availHeight : window.innerHeight;\r\n\t        } catch(e) {\r\n\t            //window.outerWidth throws error when in IE showModalDialog.\r\n\t            support.screenWidth = window.screen.availWidth;\r\n\t            support.screenHeight = window.screen.availHeight;\r\n\t        }\r\n\r\n\t        support.detectOS = function (ua) {\r\n\t            var os = false, minorVersion, match = [],\r\n\t                notAndroidPhone = !/mobile safari/i.test(ua),\r\n\t                agentRxs = {\r\n\t                    wp: /(Windows Phone(?: OS)?)\\s(\\d+)\\.(\\d+(\\.\\d+)?)/,\r\n\t                    fire: /(Silk)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\r\n\t                    android: /(Android|Android.*(?:Opera|Firefox).*?\\/)\\s*(\\d+)\\.(\\d+(\\.\\d+)?)/,\r\n\t                    iphone: /(iPhone|iPod).*OS\\s+(\\d+)[\\._]([\\d\\._]+)/,\r\n\t                    ipad: /(iPad).*OS\\s+(\\d+)[\\._]([\\d_]+)/,\r\n\t                    meego: /(MeeGo).+NokiaBrowser\\/(\\d+)\\.([\\d\\._]+)/,\r\n\t                    webos: /(webOS)\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\r\n\t                    blackberry: /(BlackBerry|BB10).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/,\r\n\t                    playbook: /(PlayBook).*?Tablet\\s*OS\\s*(\\d+)\\.(\\d+(\\.\\d+)?)/,\r\n\t                    windows: /(MSIE)\\s+(\\d+)\\.(\\d+(\\.\\d+)?)/,\r\n\t                    tizen: /(tizen).*?Version\\/(\\d+)\\.(\\d+(\\.\\d+)?)/i,\r\n\t                    sailfish: /(sailfish).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*firefox/i,\r\n\t                    ffos: /(Mobile).*rv:(\\d+)\\.(\\d+(\\.\\d+)?).*Firefox/\r\n\t                },\r\n\t                osRxs = {\r\n\t                    ios: /^i(phone|pad|pod)$/i,\r\n\t                    android: /^android|fire$/i,\r\n\t                    blackberry: /^blackberry|playbook/i,\r\n\t                    windows: /windows/,\r\n\t                    wp: /wp/,\r\n\t                    flat: /sailfish|ffos|tizen/i,\r\n\t                    meego: /meego/\r\n\t                },\r\n\t                formFactorRxs = {\r\n\t                    tablet: /playbook|ipad|fire/i\r\n\t                },\r\n\t                browserRxs = {\r\n\t                    omini: /Opera\\sMini/i,\r\n\t                    omobile: /Opera\\sMobi/i,\r\n\t                    firefox: /Firefox|Fennec/i,\r\n\t                    mobilesafari: /version\\/.*safari/i,\r\n\t                    ie: /MSIE|Windows\\sPhone/i,\r\n\t                    chrome: /chrome|crios/i,\r\n\t                    webkit: /webkit/i\r\n\t                };\r\n\r\n\t            for (var agent in agentRxs) {\r\n\t                if (agentRxs.hasOwnProperty(agent)) {\r\n\t                    match = ua.match(agentRxs[agent]);\r\n\t                    if (match) {\r\n\t                        if (agent == \"windows\" && \"plugins\" in navigator) { return false; } // Break if not Metro/Mobile Windows\r\n\r\n\t                        os = {};\r\n\t                        os.device = agent;\r\n\t                        os.tablet = testRx(agent, formFactorRxs, false);\r\n\t                        os.browser = testRx(ua, browserRxs, \"default\");\r\n\t                        os.name = testRx(agent, osRxs);\r\n\t                        os[os.name] = true;\r\n\t                        os.majorVersion = match[2];\r\n\t                        os.minorVersion = match[3].replace(\"_\", \".\");\r\n\t                        minorVersion = os.minorVersion.replace(\".\", \"\").substr(0, 2);\r\n\t                        os.flatVersion = os.majorVersion + minorVersion + (new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join(\"0\"));\r\n\t                        os.cordova = typeof window.PhoneGap !== UNDEFINED || typeof window.cordova !== UNDEFINED; // Use file protocol to detect appModes.\r\n\t                        os.appMode = window.navigator.standalone || (/file|local|wmapp/).test(window.location.protocol) || os.cordova; // Use file protocol to detect appModes.\r\n\r\n\t                        if (os.android && (support.devicePixelRatio < 1.5 && os.flatVersion < 400 || notAndroidPhone) && (support.screenWidth > 800 || support.screenHeight > 800)) {\r\n\t                            os.tablet = agent;\r\n\t                        }\r\n\r\n\t                        break;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            return os;\r\n\t        };\r\n\r\n\t        var mobileOS = support.mobileOS = support.detectOS(navigator.userAgent);\r\n\r\n\t        support.wpDevicePixelRatio = mobileOS.wp ? screen.width / 320 : 0;\r\n\r\n\t        support.hasNativeScrolling = false;\r\n\r\n\t        if (mobileOS.ios || (mobileOS.android && mobileOS.majorVersion > 2) || mobileOS.wp) {\r\n\t            support.hasNativeScrolling = mobileOS;\r\n\t        }\r\n\r\n\t        support.delayedClick = function() {\r\n\r\n\t            // only the mobile devices with touch events do this.\r\n\t            if (support.touch) {\r\n\t                // All iOS devices so far (by the time I am writing this, iOS 9.0.2 is the latest),\r\n\t                // delay their click events.\r\n\t                if (mobileOS.ios) {\r\n\t                    return true;\r\n\t                }\r\n\r\n\t                if (mobileOS.android) {\r\n\r\n\t                    if (!support.browser.chrome) { // older webkits and webviews delay the click\r\n\t                        return true;\r\n\t                    }\r\n\r\n\t                    // from here on, we deal with Chrome on Android.\r\n\t                    if (support.browser.version < 32) {\r\n\t                        return false;\r\n\t                    }\r\n\r\n\t                    // Chrome 32+ does conditional fast clicks if the view port is not user scalable.\r\n\t                    return !($(\"meta[name=viewport]\").attr(\"content\") || \"\").match(/user-scalable=no/i);\r\n\t                }\r\n\t            }\r\n\r\n\t            return false;\r\n\t        };\r\n\r\n\t        support.mouseAndTouchPresent = support.touch && !(support.mobileOS.ios || support.mobileOS.android);\r\n\r\n\t        support.detectBrowser = function(ua) {\r\n\t            var browser = false, match = [],\r\n\t                browserRxs = {\r\n\t                    edge: /(edge)[ \\/]([\\w.]+)/i,\r\n\t                    webkit: /(chrome)[ \\/]([\\w.]+)/i,\r\n\t                    safari: /(webkit)[ \\/]([\\w.]+)/i,\r\n\t                    opera: /(opera)(?:.*version|)[ \\/]([\\w.]+)/i,\r\n\t                    msie: /(msie\\s|trident.*? rv:)([\\w.]+)/i,\r\n\t                    mozilla: /(mozilla)(?:.*? rv:([\\w.]+)|)/i\r\n\t                };\r\n\r\n\t            for (var agent in browserRxs) {\r\n\t                if (browserRxs.hasOwnProperty(agent)) {\r\n\t                    match = ua.match(browserRxs[agent]);\r\n\t                    if (match) {\r\n\t                        browser = {};\r\n\t                        browser[agent] = true;\r\n\t                        browser[match[1].toLowerCase().split(\" \")[0].split(\"/\")[0]] = true;\r\n\t                        browser.version = parseInt(document.documentMode || match[2], 10);\r\n\r\n\t                        break;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            return browser;\r\n\t        };\r\n\r\n\t        support.browser = support.detectBrowser(navigator.userAgent);\r\n\r\n\t        support.detectClipboardAccess = function() {\r\n\t            var commands = {\r\n\t                copy: document.queryCommandSupported ? document.queryCommandSupported(\"copy\") : false,\r\n\t                cut: document.queryCommandSupported ? document.queryCommandSupported(\"cut\") : false,\r\n\t                paste : document.queryCommandSupported ? document.queryCommandSupported(\"paste\") : false\r\n\t            };\r\n\r\n\t            if (support.browser.chrome) {\r\n\t                //not using queryCommandSupported due to chromium issues 476508 and 542948\r\n\t                commands.paste = false;\r\n\t                if(support.browser.version >= 43) {\r\n\t                    commands.copy = true;\r\n\t                    commands.cut = true;\r\n\t                }\r\n\t            }\r\n\r\n\t            return commands;\r\n\t        };\r\n\r\n\t        support.clipboard = support.detectClipboardAccess();\r\n\r\n\t        support.zoomLevel = function() {\r\n\t            try {\r\n\t                var browser = support.browser;\r\n\t                var ie11WidthCorrection = 0;\r\n\t                var docEl = document.documentElement;\r\n\r\n\t                if (browser.msie && browser.version == 11 && docEl.scrollHeight > docEl.clientHeight && !support.touch) {\r\n\t                    ie11WidthCorrection = support.scrollbar();\r\n\t                }\r\n\r\n\t                return support.touch ? (docEl.clientWidth / window.innerWidth) :\r\n\t                       browser.msie && browser.version >= 10 ? (((top || window).document.documentElement.offsetWidth + ie11WidthCorrection) / (top || window).innerWidth) : 1;\r\n\t            } catch(e) {\r\n\t                return 1;\r\n\t            }\r\n\t        };\r\n\r\n\t        support.cssBorderSpacing = typeof docStyle.borderSpacing != \"undefined\" && !(support.browser.msie && support.browser.version < 8);\r\n\r\n\t        (function(browser) {\r\n\t            // add browser-specific CSS class\r\n\t            var cssClass = \"\",\r\n\t                docElement = $(document.documentElement),\r\n\t                majorVersion = parseInt(browser.version, 10);\r\n\r\n\t            if (browser.msie) {\r\n\t                cssClass = \"ie\";\r\n\t            } else if (browser.mozilla) {\r\n\t                cssClass = \"ff\";\r\n\t            } else if (browser.safari) {\r\n\t                cssClass = \"safari\";\r\n\t            } else if (browser.webkit) {\r\n\t                cssClass = \"webkit\";\r\n\t            } else if (browser.opera) {\r\n\t                cssClass = \"opera\";\r\n\t            } else if (browser.edge) {\r\n\t                cssClass = \"edge\";\r\n\t            }\r\n\r\n\t            if (cssClass) {\r\n\t                cssClass = \"k-\" + cssClass + \" k-\" + cssClass + majorVersion;\r\n\t            }\r\n\t            if (support.mobileOS) {\r\n\t                cssClass += \" k-mobile\";\r\n\t            }\r\n\r\n\t            if (!support.cssFlexbox) {\r\n\t                cssClass += \" k-no-flexbox\";\r\n\t            }\r\n\r\n\t            docElement.addClass(cssClass);\r\n\t        })(support.browser);\r\n\r\n\t        support.eventCapture = document.documentElement.addEventListener;\r\n\r\n\t        var input = document.createElement(\"input\");\r\n\r\n\t        support.placeholder = \"placeholder\" in input;\r\n\t        support.propertyChangeEvent = \"onpropertychange\" in input;\r\n\r\n\t        support.input = (function() {\r\n\t            var types = [\"number\", \"date\", \"time\", \"month\", \"week\", \"datetime\", \"datetime-local\"];\r\n\t            var length = types.length;\r\n\t            var value = \"test\";\r\n\t            var result = {};\r\n\t            var idx = 0;\r\n\t            var type;\r\n\r\n\t            for (;idx < length; idx++) {\r\n\t                type = types[idx];\r\n\t                input.setAttribute(\"type\", type);\r\n\t                input.value = value;\r\n\r\n\t                result[type.replace(\"-\", \"\")] = input.type !== \"text\" && input.value !== value;\r\n\t            }\r\n\r\n\t            return result;\r\n\t        })();\r\n\r\n\t        input.style.cssText = \"float:left;\";\r\n\r\n\t        support.cssFloat = !!input.style.cssFloat;\r\n\r\n\t        input = null;\r\n\r\n\t        support.stableSort = (function() {\r\n\t            // Chrome sort is not stable for more than *10* items\r\n\t            // IE9+ sort is not stable for than *512* items\r\n\t            var threshold = 513;\r\n\r\n\t            var sorted = [{\r\n\t                index: 0,\r\n\t                field: \"b\"\r\n\t            }];\r\n\r\n\t            for (var i = 1; i < threshold; i++) {\r\n\t                sorted.push({\r\n\t                    index: i,\r\n\t                    field: \"a\"\r\n\t                });\r\n\t            }\r\n\r\n\t            sorted.sort(function(a, b) {\r\n\t                return a.field > b.field ? 1 : (a.field < b.field ? -1 : 0);\r\n\t            });\r\n\r\n\t            return sorted[0].index === 1;\r\n\t        })();\r\n\r\n\t        support.matchesSelector = elementProto.webkitMatchesSelector || elementProto.mozMatchesSelector ||\r\n\t                                  elementProto.msMatchesSelector || elementProto.oMatchesSelector ||\r\n\t                                  elementProto.matchesSelector || elementProto.matches ||\r\n\t          function( selector ) {\r\n\t              var nodeList = document.querySelectorAll ? ( this.parentNode || document ).querySelectorAll( selector ) || [] : $(selector),\r\n\t                  i = nodeList.length;\r\n\r\n\t              while (i--) {\r\n\t                  if (nodeList[i] == this) {\r\n\t                      return true;\r\n\t                  }\r\n\t              }\r\n\r\n\t              return false;\r\n\t          };\r\n\r\n\t        support.pushState = window.history && window.history.pushState;\r\n\r\n\t        var documentMode = document.documentMode;\r\n\r\n\t        support.hashChange = (\"onhashchange\" in window) && !(support.browser.msie && (!documentMode || documentMode <= 8)); // old IE detection\r\n\r\n\t        support.customElements = (\"registerElement\" in window.document);\r\n\r\n\t        var chrome = support.browser.chrome;\r\n\t        support.msPointers = !chrome && window.MSPointerEvent;\r\n\t        support.pointers = !chrome && window.PointerEvent;\r\n\t        support.kineticScrollNeeded = mobileOS && (support.touch || support.msPointers || support.pointers);\r\n\t    })();\r\n\r\n\r\n\t    function size(obj) {\r\n\t        var result = 0, key;\r\n\t        for (key in obj) {\r\n\t            if (obj.hasOwnProperty(key) && key != \"toJSON\") { // Ignore fake IE7 toJSON.\r\n\t                result++;\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    }\r\n\r\n\t    function getOffset(element, type, positioned) {\r\n\t        if (!type) {\r\n\t            type = \"offset\";\r\n\t        }\r\n\r\n\t        var offset = element[type]();\r\n\t        // clone ClientRect object to JS object (jQuery3)\r\n\t        var result = {\r\n\t            top: offset.top,\r\n\t            right: offset.right,\r\n\t            bottom: offset.bottom,\r\n\t            left: offset.left\r\n\t        };\r\n\r\n\t        // IE10 touch zoom is living in a separate viewport\r\n\t        if (support.browser.msie && (support.pointers || support.msPointers) && !positioned) {\r\n\t            var sign = support.isRtl(element) ? 1 : -1;\r\n\r\n\t            result.top -= (window.pageYOffset - (document.documentElement.scrollTop));\r\n\t            result.left -= (window.pageXOffset + (sign * document.documentElement.scrollLeft));\r\n\t        }\r\n\r\n\t        return result;\r\n\t    }\r\n\r\n\t    var directions = {\r\n\t        left: { reverse: \"right\" },\r\n\t        right: { reverse: \"left\" },\r\n\t        down: { reverse: \"up\" },\r\n\t        up: { reverse: \"down\" },\r\n\t        top: { reverse: \"bottom\" },\r\n\t        bottom: { reverse: \"top\" },\r\n\t        \"in\": { reverse: \"out\" },\r\n\t        out: { reverse: \"in\" }\r\n\t    };\r\n\r\n\t    function parseEffects(input) {\r\n\t        var effects = {};\r\n\r\n\t        each((typeof input === \"string\" ? input.split(\" \") : input), function(idx) {\r\n\t            effects[idx] = this;\r\n\t        });\r\n\r\n\t        return effects;\r\n\t    }\r\n\r\n\t    function fx(element) {\r\n\t        return new kendo.effects.Element(element);\r\n\t    }\r\n\r\n\t    var effects = {};\r\n\r\n\t    $.extend(effects, {\r\n\t        enabled: true,\r\n\t        Element: function(element) {\r\n\t            this.element = $(element);\r\n\t        },\r\n\r\n\t        promise: function(element, options) {\r\n\t            if (!element.is(\":visible\")) {\r\n\t                element.css({ display: element.data(\"olddisplay\") || \"block\" }).css(\"display\");\r\n\t            }\r\n\r\n\t            if (options.hide) {\r\n\t                element.data(\"olddisplay\", element.css(\"display\")).hide();\r\n\t            }\r\n\r\n\t            if (options.init) {\r\n\t                options.init();\r\n\t            }\r\n\r\n\t            if (options.completeCallback) {\r\n\t                options.completeCallback(element); // call the external complete callback with the element\r\n\t            }\r\n\r\n\t            element.dequeue();\r\n\t        },\r\n\r\n\t        disable: function() {\r\n\t            this.enabled = false;\r\n\t            this.promise = this.promiseShim;\r\n\t        },\r\n\r\n\t        enable: function() {\r\n\t            this.enabled = true;\r\n\t            this.promise = this.animatedPromise;\r\n\t        }\r\n\t    });\r\n\r\n\t    effects.promiseShim = effects.promise;\r\n\r\n\t    function prepareAnimationOptions(options, duration, reverse, complete) {\r\n\t        if (typeof options === STRING) {\r\n\t            // options is the list of effect names separated by space e.g. animate(element, \"fadeIn slideDown\")\r\n\r\n\t            // only callback is provided e.g. animate(element, options, function() {});\r\n\t            if (isFunction(duration)) {\r\n\t                complete = duration;\r\n\t                duration = 400;\r\n\t                reverse = false;\r\n\t            }\r\n\r\n\t            if (isFunction(reverse)) {\r\n\t                complete = reverse;\r\n\t                reverse = false;\r\n\t            }\r\n\r\n\t            if (typeof duration === BOOLEAN){\r\n\t                reverse = duration;\r\n\t                duration = 400;\r\n\t            }\r\n\r\n\t            options = {\r\n\t                effects: options,\r\n\t                duration: duration,\r\n\t                reverse: reverse,\r\n\t                complete: complete\r\n\t            };\r\n\t        }\r\n\r\n\t        return extend({\r\n\t            //default options\r\n\t            effects: {},\r\n\t            duration: 400, //jQuery default duration\r\n\t            reverse: false,\r\n\t            init: noop,\r\n\t            teardown: noop,\r\n\t            hide: false\r\n\t        }, options, { completeCallback: options.complete, complete: noop }); // Move external complete callback, so deferred.resolve can be always executed.\r\n\r\n\t    }\r\n\r\n\t    function animate(element, options, duration, reverse, complete) {\r\n\t        var idx = 0,\r\n\t            length = element.length,\r\n\t            instance;\r\n\r\n\t        for (; idx < length; idx ++) {\r\n\t            instance = $(element[idx]);\r\n\t            instance.queue(function() {\r\n\t                effects.promise(instance, prepareAnimationOptions(options, duration, reverse, complete));\r\n\t            });\r\n\t        }\r\n\r\n\t        return element;\r\n\t    }\r\n\r\n\t    function toggleClass(element, classes, options, add) {\r\n\t        if (classes) {\r\n\t            classes = classes.split(\" \");\r\n\r\n\t            each(classes, function(idx, value) {\r\n\t                element.toggleClass(value, add);\r\n\t            });\r\n\t        }\r\n\r\n\t        return element;\r\n\t    }\r\n\r\n\t    if (!(\"kendoAnimate\" in $.fn)) {\r\n\t        extend($.fn, {\r\n\t            kendoStop: function(clearQueue, gotoEnd) {\r\n\t                return this.stop(clearQueue, gotoEnd);\r\n\t            },\r\n\r\n\t            kendoAnimate: function(options, duration, reverse, complete) {\r\n\t                return animate(this, options, duration, reverse, complete);\r\n\t            },\r\n\r\n\t            kendoAddClass: function(classes, options){\r\n\t                return kendo.toggleClass(this, classes, options, true);\r\n\t            },\r\n\r\n\t            kendoRemoveClass: function(classes, options){\r\n\t                return kendo.toggleClass(this, classes, options, false);\r\n\t            },\r\n\t            kendoToggleClass: function(classes, options, toggle){\r\n\t                return kendo.toggleClass(this, classes, options, toggle);\r\n\t            }\r\n\t        });\r\n\t    }\r\n\r\n\t    var ampRegExp = /&/g,\r\n\t        ltRegExp = /</g,\r\n\t        quoteRegExp = /\"/g,\r\n\t        aposRegExp = /'/g,\r\n\t        gtRegExp = />/g;\r\n\t    function htmlEncode(value) {\r\n\t        return (\"\" + value).replace(ampRegExp, \"&amp;\").replace(ltRegExp, \"&lt;\").replace(gtRegExp, \"&gt;\").replace(quoteRegExp, \"&quot;\").replace(aposRegExp, \"&#39;\");\r\n\t    }\r\n\r\n\t    var eventTarget = function (e) {\r\n\t        return e.target;\r\n\t    };\r\n\r\n\t    if (support.touch) {\r\n\r\n\t        eventTarget = function(e) {\r\n\t            var touches = \"originalEvent\" in e ? e.originalEvent.changedTouches : \"changedTouches\" in e ? e.changedTouches : null;\r\n\r\n\t            return touches ? document.elementFromPoint(touches[0].clientX, touches[0].clientY) : e.target;\r\n\t        };\r\n\r\n\t        each([\"swipe\", \"swipeLeft\", \"swipeRight\", \"swipeUp\", \"swipeDown\", \"doubleTap\", \"tap\"], function(m, value) {\r\n\t            $.fn[value] = function(callback) {\r\n\t                return this.bind(value, callback);\r\n\t            };\r\n\t        });\r\n\t    }\r\n\r\n\t    if (support.touch) {\r\n\t        if (!support.mobileOS) {\r\n\t            support.mousedown = \"mousedown touchstart\";\r\n\t            support.mouseup = \"mouseup touchend\";\r\n\t            support.mousemove = \"mousemove touchmove\";\r\n\t            support.mousecancel = \"mouseleave touchcancel\";\r\n\t            support.click = \"click\";\r\n\t            support.resize = \"resize\";\r\n\t        } else {\r\n\t            support.mousedown = \"touchstart\";\r\n\t            support.mouseup = \"touchend\";\r\n\t            support.mousemove = \"touchmove\";\r\n\t            support.mousecancel = \"touchcancel\";\r\n\t            support.click = \"touchend\";\r\n\t            support.resize = \"orientationchange\";\r\n\t        }\r\n\t    } else if (support.pointers) {\r\n\t        support.mousemove = \"pointermove\";\r\n\t        support.mousedown = \"pointerdown\";\r\n\t        support.mouseup = \"pointerup\";\r\n\t        support.mousecancel = \"pointercancel\";\r\n\t        support.click = \"pointerup\";\r\n\t        support.resize = \"orientationchange resize\";\r\n\t    } else if (support.msPointers) {\r\n\t        support.mousemove = \"MSPointerMove\";\r\n\t        support.mousedown = \"MSPointerDown\";\r\n\t        support.mouseup = \"MSPointerUp\";\r\n\t        support.mousecancel = \"MSPointerCancel\";\r\n\t        support.click = \"MSPointerUp\";\r\n\t        support.resize = \"orientationchange resize\";\r\n\t    } else {\r\n\t        support.mousemove = \"mousemove\";\r\n\t        support.mousedown = \"mousedown\";\r\n\t        support.mouseup = \"mouseup\";\r\n\t        support.mousecancel = \"mouseleave\";\r\n\t        support.click = \"click\";\r\n\t        support.resize = \"resize\";\r\n\t    }\r\n\r\n\t    var wrapExpression = function(members, paramName) {\r\n\t        var result = paramName || \"d\",\r\n\t            index,\r\n\t            idx,\r\n\t            length,\r\n\t            member,\r\n\t            count = 1;\r\n\r\n\t        for (idx = 0, length = members.length; idx < length; idx++) {\r\n\t            member = members[idx];\r\n\t            if (member !== \"\") {\r\n\t                index = member.indexOf(\"[\");\r\n\r\n\t                if (index !== 0) {\r\n\t                    if (index == -1) {\r\n\t                        member = \".\" + member;\r\n\t                    } else {\r\n\t                        count++;\r\n\t                        member = \".\" + member.substring(0, index) + \" || {})\" + member.substring(index);\r\n\t                    }\r\n\t                }\r\n\r\n\t                count++;\r\n\t                result += member + ((idx < length - 1) ? \" || {})\" : \")\");\r\n\t            }\r\n\t        }\r\n\t        return new Array(count).join(\"(\") + result;\r\n\t    },\r\n\t    localUrlRe = /^([a-z]+:)?\\/\\//i;\r\n\r\n\t    extend(kendo, {\r\n\t        widgets: [],\r\n\t        _widgetRegisteredCallbacks: [],\r\n\t        ui: kendo.ui || {},\r\n\t        fx: kendo.fx || fx,\r\n\t        effects: kendo.effects || effects,\r\n\t        mobile: kendo.mobile || { },\r\n\t        data: kendo.data || {},\r\n\t        dataviz: kendo.dataviz || {},\r\n\t        drawing: kendo.drawing || {},\r\n\t        spreadsheet: { messages: {} },\r\n\t        keys: {\r\n\t            INSERT: 45,\r\n\t            DELETE: 46,\r\n\t            BACKSPACE: 8,\r\n\t            TAB: 9,\r\n\t            ENTER: 13,\r\n\t            ESC: 27,\r\n\t            LEFT: 37,\r\n\t            UP: 38,\r\n\t            RIGHT: 39,\r\n\t            DOWN: 40,\r\n\t            END: 35,\r\n\t            HOME: 36,\r\n\t            SPACEBAR: 32,\r\n\t            PAGEUP: 33,\r\n\t            PAGEDOWN: 34,\r\n\t            F2: 113,\r\n\t            F10: 121,\r\n\t            F12: 123,\r\n\t            NUMPAD_PLUS: 107,\r\n\t            NUMPAD_MINUS: 109,\r\n\t            NUMPAD_DOT: 110\r\n\t        },\r\n\t        support: kendo.support || support,\r\n\t        animate: kendo.animate || animate,\r\n\t        ns: \"\",\r\n\t        attr: function(value) {\r\n\t            return \"data-\" + kendo.ns + value;\r\n\t        },\r\n\t        getShadows: getShadows,\r\n\t        wrap: wrap,\r\n\t        deepExtend: deepExtend,\r\n\t        getComputedStyles: getComputedStyles,\r\n\t        webComponents: kendo.webComponents || [],\r\n\t        isScrollable: isScrollable,\r\n\t        scrollLeft: scrollLeft,\r\n\t        size: size,\r\n\t        toCamelCase: toCamelCase,\r\n\t        toHyphens: toHyphens,\r\n\t        getOffset: kendo.getOffset || getOffset,\r\n\t        parseEffects: kendo.parseEffects || parseEffects,\r\n\t        toggleClass: kendo.toggleClass || toggleClass,\r\n\t        directions: kendo.directions || directions,\r\n\t        Observable: Observable,\r\n\t        Class: Class,\r\n\t        Template: Template,\r\n\t        template: proxy(Template.compile, Template),\r\n\t        render: proxy(Template.render, Template),\r\n\t        stringify: proxy(JSON.stringify, JSON),\r\n\t        eventTarget: eventTarget,\r\n\t        htmlEncode: htmlEncode,\r\n\t        isLocalUrl: function(url) {\r\n\t            return url && !localUrlRe.test(url);\r\n\t        },\r\n\r\n\t        expr: function(expression, safe, paramName) {\r\n\t            expression = expression || \"\";\r\n\r\n\t            if (typeof safe == STRING) {\r\n\t                paramName = safe;\r\n\t                safe = false;\r\n\t            }\r\n\r\n\t            paramName = paramName || \"d\";\r\n\r\n\t            if (expression && expression.charAt(0) !== \"[\") {\r\n\t                expression = \".\" + expression;\r\n\t            }\r\n\r\n\t            if (safe) {\r\n\t                expression = expression.replace(/\"([^.]*)\\.([^\"]*)\"/g,'\"$1_$DOT$_$2\"');\r\n\t                expression = expression.replace(/'([^.]*)\\.([^']*)'/g,\"'$1_$DOT$_$2'\");\r\n\t                expression = wrapExpression(expression.split(\".\"), paramName);\r\n\t                expression = expression.replace(/_\\$DOT\\$_/g, \".\");\r\n\t            } else {\r\n\t                expression = paramName + expression;\r\n\t            }\r\n\r\n\t            return expression;\r\n\t        },\r\n\r\n\t        getter: function(expression, safe) {\r\n\t            var key = expression + safe;\r\n\t            return getterCache[key] = getterCache[key] || new Function(\"d\", \"return \" + kendo.expr(expression, safe));\r\n\t        },\r\n\r\n\t        setter: function(expression) {\r\n\t            return setterCache[expression] = setterCache[expression] || new Function(\"d,value\", kendo.expr(expression) + \"=value\");\r\n\t        },\r\n\r\n\t        accessor: function(expression) {\r\n\t            return {\r\n\t                get: kendo.getter(expression),\r\n\t                set: kendo.setter(expression)\r\n\t            };\r\n\t        },\r\n\r\n\t        guid: function() {\r\n\t            var id = \"\", i, random;\r\n\r\n\t            for (i = 0; i < 32; i++) {\r\n\t                random = math.random() * 16 | 0;\r\n\r\n\t                if (i == 8 || i == 12 || i == 16 || i == 20) {\r\n\t                    id += \"-\";\r\n\t                }\r\n\t                id += (i == 12 ? 4 : (i == 16 ? (random & 3 | 8) : random)).toString(16);\r\n\t            }\r\n\r\n\t            return id;\r\n\t        },\r\n\r\n\t        roleSelector: function(role) {\r\n\t            return role.replace(/(\\S+)/g, \"[\" + kendo.attr(\"role\") + \"=$1],\").slice(0, -1);\r\n\t        },\r\n\r\n\t        directiveSelector: function(directives) {\r\n\t            var selectors = directives.split(\" \");\r\n\r\n\t            if (selectors) {\r\n\t                for (var i = 0; i < selectors.length; i++) {\r\n\t                    if (selectors[i] != \"view\") {\r\n\t                        selectors[i] = selectors[i].replace(/(\\w*)(view|bar|strip|over)$/, \"$1-$2\");\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            return selectors.join(\" \").replace(/(\\S+)/g, \"kendo-mobile-$1,\").slice(0, -1);\r\n\t        },\r\n\r\n\t        triggeredByInput: function(e) {\r\n\t            return (/^(label|input|textarea|select)$/i).test(e.target.tagName);\r\n\t        },\r\n\r\n\t        onWidgetRegistered: function(callback) {\r\n\t            for (var i = 0, len = kendo.widgets.length; i < len; i++) {\r\n\t                callback(kendo.widgets[i]);\r\n\t            }\r\n\r\n\t            kendo._widgetRegisteredCallbacks.push(callback);\r\n\t        },\r\n\r\n\t        logToConsole: function(message, type) {\r\n\t            var console = window.console;\r\n\r\n\t            if (!kendo.suppressLog && typeof(console) != \"undefined\" && console.log) {\r\n\t                console[type || \"log\"](message);\r\n\t            }\r\n\t        }\r\n\t    });\r\n\r\n\t    var Widget = Observable.extend( {\r\n\t        init: function(element, options) {\r\n\t            var that = this;\r\n\r\n\t            that.element = kendo.jQuery(element).handler(that);\r\n\r\n\t            that.angular(\"init\", options);\r\n\r\n\t            Observable.fn.init.call(that);\r\n\r\n\t            var dataSource = options ? options.dataSource : null;\r\n\r\n\t            if (dataSource) {\r\n\t                // avoid deep cloning the data source\r\n\t                options = extend({}, options, { dataSource: {} });\r\n\t            }\r\n\r\n\t            options = that.options = extend(true, {}, that.options, options);\r\n\r\n\t            if (dataSource) {\r\n\t                options.dataSource = dataSource;\r\n\t            }\r\n\r\n\t            if (!that.element.attr(kendo.attr(\"role\"))) {\r\n\t                that.element.attr(kendo.attr(\"role\"), (options.name || \"\").toLowerCase());\r\n\t            }\r\n\r\n\t            that.element.data(\"kendo\" + options.prefix + options.name, that);\r\n\r\n\t            that.bind(that.events, options);\r\n\t        },\r\n\r\n\t        events: [],\r\n\r\n\t        options: {\r\n\t            prefix: \"\"\r\n\t        },\r\n\r\n\t        _hasBindingTarget: function() {\r\n\t            return !!this.element[0].kendoBindingTarget;\r\n\t        },\r\n\r\n\t        _tabindex: function(target) {\r\n\t            target = target || this.wrapper;\r\n\r\n\t            var element = this.element,\r\n\t                TABINDEX = \"tabindex\",\r\n\t                tabindex = target.attr(TABINDEX) || element.attr(TABINDEX);\r\n\r\n\t            element.removeAttr(TABINDEX);\r\n\r\n\t            target.attr(TABINDEX, !isNaN(tabindex) ? tabindex : 0);\r\n\t        },\r\n\r\n\t        setOptions: function(options) {\r\n\t            this._setEvents(options);\r\n\t            $.extend(this.options, options);\r\n\t        },\r\n\r\n\t        _setEvents: function(options) {\r\n\t            var that = this,\r\n\t                idx = 0,\r\n\t                length = that.events.length,\r\n\t                e;\r\n\r\n\t            for (; idx < length; idx ++) {\r\n\t                e = that.events[idx];\r\n\t                if (that.options[e] && options[e]) {\r\n\t                    that.unbind(e, that.options[e]);\r\n\t                }\r\n\t            }\r\n\r\n\t            that.bind(that.events, options);\r\n\t        },\r\n\r\n\t        resize: function(force) {\r\n\t            var size = this.getSize(),\r\n\t                currentSize = this._size;\r\n\r\n\t            if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\r\n\t                this._size = size;\r\n\t                this._resize(size, force);\r\n\t                this.trigger(\"resize\", size);\r\n\t            }\r\n\t        },\r\n\r\n\t        getSize: function() {\r\n\t            return kendo.dimensions(this.element);\r\n\t        },\r\n\r\n\t        size: function(size) {\r\n\t            if (!size) {\r\n\t                return this.getSize();\r\n\t            } else {\r\n\t                this.setSize(size);\r\n\t            }\r\n\t        },\r\n\r\n\t        setSize: $.noop,\r\n\t        _resize: $.noop,\r\n\r\n\t        destroy: function() {\r\n\t            var that = this;\r\n\r\n\t            that.element.removeData(\"kendo\" + that.options.prefix + that.options.name);\r\n\t            that.element.removeData(\"handler\");\r\n\t            that.unbind();\r\n\t        },\r\n\t        _destroy: function() {\r\n\t            this.destroy();\r\n\t        },\r\n\t        angular: function(){},\r\n\r\n\t        _muteAngularRebind: function(callback) {\r\n\t            this._muteRebind = true;\r\n\r\n\t            callback.call(this);\r\n\r\n\t            this._muteRebind = false;\r\n\t        }\r\n\t    });\r\n\r\n\t    var DataBoundWidget = Widget.extend({\r\n\t        // Angular consumes these.\r\n\t        dataItems: function() {\r\n\t            return this.dataSource.flatView();\r\n\t        },\r\n\r\n\t        _angularItems: function(cmd) {\r\n\t            var that = this;\r\n\t            that.angular(cmd, function(){\r\n\t                return {\r\n\t                    elements: that.items(),\r\n\t                    data: $.map(that.dataItems(), function(dataItem){\r\n\t                        return { dataItem: dataItem };\r\n\t                    })\r\n\t                };\r\n\t            });\r\n\t        }\r\n\t    });\r\n\r\n\t    kendo.dimensions = function(element, dimensions) {\r\n\t        var domElement = element[0];\r\n\r\n\t        if (dimensions) {\r\n\t            element.css(dimensions);\r\n\t        }\r\n\r\n\t        return { width: domElement.offsetWidth, height: domElement.offsetHeight };\r\n\t    };\r\n\r\n\t    kendo.notify = noop;\r\n\r\n\t    var templateRegExp = /template$/i,\r\n\t        jsonRegExp = /^\\s*(?:\\{(?:.|\\r\\n|\\n)*\\}|\\[(?:.|\\r\\n|\\n)*\\])\\s*$/,\r\n\t        jsonFormatRegExp = /^\\{(\\d+)(:[^\\}]+)?\\}|^\\[[A-Za-z_]+\\]$/,\r\n\t        dashRegExp = /([A-Z])/g;\r\n\r\n\t    function parseOption(element, option) {\r\n\t        var value;\r\n\r\n\t        if (option.indexOf(\"data\") === 0) {\r\n\t            option = option.substring(4);\r\n\t            option = option.charAt(0).toLowerCase() + option.substring(1);\r\n\t        }\r\n\r\n\t        option = option.replace(dashRegExp, \"-$1\");\r\n\t        value = element.getAttribute(\"data-\" + kendo.ns + option);\r\n\r\n\t        if (value === null) {\r\n\t            value = undefined;\r\n\t        } else if (value === \"null\") {\r\n\t            value = null;\r\n\t        } else if (value === \"true\") {\r\n\t            value = true;\r\n\t        } else if (value === \"false\") {\r\n\t            value = false;\r\n\t        } else if (numberRegExp.test(value)) {\r\n\t            value = parseFloat(value);\r\n\t        } else if (jsonRegExp.test(value) && !jsonFormatRegExp.test(value)) {\r\n\t            value = new Function(\"return (\" + value + \")\")();\r\n\t        }\r\n\r\n\t        return value;\r\n\t    }\r\n\r\n\t    function parseOptions(element, options) {\r\n\t        var result = {},\r\n\t            option,\r\n\t            value;\r\n\r\n\t        for (option in options) {\r\n\t            value = parseOption(element, option);\r\n\r\n\t            if (value !== undefined) {\r\n\r\n\t                if (templateRegExp.test(option)) {\r\n\t                    if(typeof value === \"string\") {\r\n\t                        value = kendo.template($(\"#\" + value).html());\r\n\t                    } else {\r\n\t                        value = element.getAttribute(option);\r\n\t                    }\r\n\t                }\r\n\r\n\t                result[option] = value;\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    }\r\n\r\n\t    kendo.initWidget = function(element, options, roles) {\r\n\t        var result,\r\n\t            option,\r\n\t            widget,\r\n\t            idx,\r\n\t            length,\r\n\t            role,\r\n\t            value,\r\n\t            dataSource,\r\n\t            fullPath,\r\n\t            widgetKeyRegExp;\r\n\r\n\t        // Preserve backwards compatibility with (element, options, namespace) signature, where namespace was kendo.ui\r\n\t        if (!roles) {\r\n\t            roles = kendo.ui.roles;\r\n\t        } else if (roles.roles) {\r\n\t            roles = roles.roles;\r\n\t        }\r\n\r\n\t        element = element.nodeType ? element : element[0];\r\n\r\n\t        role = element.getAttribute(\"data-\" + kendo.ns + \"role\");\r\n\r\n\t        if (!role) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        fullPath = role.indexOf(\".\") === -1;\r\n\r\n\t        // look for any widget that may be already instantiated based on this role.\r\n\t        // The prefix used is unknown, hence the regexp\r\n\t        //\r\n\r\n\t        if (fullPath) {\r\n\t            widget = roles[role];\r\n\t        } else { // full namespace path - like kendo.ui.Widget\r\n\t            widget = kendo.getter(role)(window);\r\n\t        }\r\n\r\n\t        var data = $(element).data(),\r\n\t            widgetKey = widget ? \"kendo\" + widget.fn.options.prefix + widget.fn.options.name : \"\";\r\n\r\n\t        if (fullPath) {\r\n\t            widgetKeyRegExp = new RegExp(\"^kendo.*\" + role + \"$\", \"i\");\r\n\t        } else { // full namespace path - like kendo.ui.Widget\r\n\t            widgetKeyRegExp = new RegExp(\"^\" + widgetKey + \"$\", \"i\");\r\n\t        }\r\n\r\n\t        for(var key in data) {\r\n\t            if (key.match(widgetKeyRegExp)) {\r\n\t                // we have detected a widget of the same kind - save its reference, we will set its options\r\n\t                if (key === widgetKey) {\r\n\t                    result = data[key];\r\n\t                } else {\r\n\t                    return data[key];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (!widget) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        dataSource = parseOption(element, \"dataSource\");\r\n\r\n\t        options = $.extend({}, parseOptions(element, widget.fn.options), options);\r\n\r\n\t        if (dataSource) {\r\n\t            if (typeof dataSource === STRING) {\r\n\t                options.dataSource = kendo.getter(dataSource)(window);\r\n\t            } else {\r\n\t                options.dataSource = dataSource;\r\n\t            }\r\n\t        }\r\n\r\n\t        for (idx = 0, length = widget.fn.events.length; idx < length; idx++) {\r\n\t            option = widget.fn.events[idx];\r\n\r\n\t            value = parseOption(element, option);\r\n\r\n\t            if (value !== undefined) {\r\n\t                options[option] = kendo.getter(value)(window);\r\n\t            }\r\n\t        }\r\n\r\n\t        if (!result) {\r\n\t            result = new widget(element, options);\r\n\t        } else if (!$.isEmptyObject(options)) {\r\n\t            result.setOptions(options);\r\n\t        }\r\n\r\n\t        return result;\r\n\t    };\r\n\r\n\t    kendo.rolesFromNamespaces = function(namespaces) {\r\n\t        var roles = [],\r\n\t            idx,\r\n\t            length;\r\n\r\n\t        if (!namespaces[0]) {\r\n\t            namespaces = [kendo.ui, kendo.dataviz.ui];\r\n\t        }\r\n\r\n\t        for (idx = 0, length = namespaces.length; idx < length; idx ++) {\r\n\t            roles[idx] = namespaces[idx].roles;\r\n\t        }\r\n\r\n\t        return extend.apply(null, [{}].concat(roles.reverse()));\r\n\t    };\r\n\r\n\t    kendo.init = function(element) {\r\n\t        var roles = kendo.rolesFromNamespaces(slice.call(arguments, 1));\r\n\r\n\t        $(element).find(\"[data-\" + kendo.ns + \"role]\").addBack().each(function(){\r\n\t            kendo.initWidget(this, {}, roles);\r\n\t        });\r\n\t    };\r\n\r\n\t    kendo.destroy = function(element) {\r\n\t        $(element).find(\"[data-\" + kendo.ns + \"role]\").addBack().each(function(){\r\n\t            var data = $(this).data();\r\n\r\n\t            for (var key in data) {\r\n\t                if (key.indexOf(\"kendo\") === 0 && typeof data[key].destroy === FUNCTION) {\r\n\t                    data[key].destroy();\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    };\r\n\r\n\t    function containmentComparer(a, b) {\r\n\t        return $.contains(a, b) ? -1 : 1;\r\n\t    }\r\n\r\n\t    function resizableWidget() {\r\n\t        var widget = $(this);\r\n\t        return ($.inArray(widget.attr(\"data-\" + kendo.ns + \"role\"), [\"slider\", \"rangeslider\"]) > -1) || widget.is(\":visible\");\r\n\t    }\r\n\r\n\t    kendo.resize = function(element, force) {\r\n\t        var widgets = $(element).find(\"[data-\" + kendo.ns + \"role]\").addBack().filter(resizableWidget);\r\n\r\n\t        if (!widgets.length) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        // sort widgets based on their parent-child relation\r\n\t        var widgetsArray = $.makeArray(widgets);\r\n\t        widgetsArray.sort(containmentComparer);\r\n\r\n\t        // resize widgets\r\n\t        $.each(widgetsArray, function () {\r\n\t            var widget = kendo.widgetInstance($(this));\r\n\t            if (widget) {\r\n\t                widget.resize(force);\r\n\t            }\r\n\t        });\r\n\t    };\r\n\r\n\t    kendo.parseOptions = parseOptions;\r\n\r\n\t    extend(kendo.ui, {\r\n\t        Widget: Widget,\r\n\t        DataBoundWidget: DataBoundWidget,\r\n\t        roles: {},\r\n\t        progress: function(container, toggle, options) {\r\n\t            var mask = container.find(\".k-loading-mask\"),\r\n\t                support = kendo.support,\r\n\t                browser = support.browser,\r\n\t                isRtl, leftRight, webkitCorrection, containerScrollLeft, cssClass;\r\n\r\n\t                options = $.extend({}, {\r\n\t                    width: \"100%\",\r\n\t                    height: \"100%\",\r\n\t                    top: container.scrollTop(),\r\n\t                    opacity: false\r\n\t                }, options);\r\n\r\n\t                cssClass = options.opacity ? 'k-loading-mask k-opaque' : 'k-loading-mask';\r\n\r\n\t            if (toggle) {\r\n\t                if (!mask.length) {\r\n\t                    isRtl = support.isRtl(container);\r\n\t                    leftRight = isRtl ? \"right\" : \"left\";\r\n\t                    containerScrollLeft = container.scrollLeft();\r\n\t                    webkitCorrection = browser.webkit ? (!isRtl ? 0 : container[0].scrollWidth - container.width() - 2 * containerScrollLeft) : 0;\r\n\r\n\t                    mask = $(kendo.format(\"<div class='{0}'><span class='k-loading-text'>{1}</span><div class='k-loading-image'/><div class='k-loading-color'/></div>\", cssClass, kendo.ui.progress.messages.loading))\r\n\t                        .width(options.width).height(options.height)\r\n\t                        .css(\"top\", options.top)\r\n\t                        .css(leftRight, Math.abs(containerScrollLeft) + webkitCorrection)\r\n\t                        .prependTo(container);\r\n\t                }\r\n\t            } else if (mask) {\r\n\t                mask.remove();\r\n\t            }\r\n\t        },\r\n\t        plugin: function(widget, register, prefix) {\r\n\t            var name = widget.fn.options.name,\r\n\t                getter;\r\n\r\n\t            register = register || kendo.ui;\r\n\t            prefix = prefix || \"\";\r\n\r\n\t            register[name] = widget;\r\n\r\n\t            register.roles[name.toLowerCase()] = widget;\r\n\r\n\t            getter = \"getKendo\" + prefix + name;\r\n\t            name = \"kendo\" + prefix + name;\r\n\r\n\t            var widgetEntry = { name: name, widget: widget, prefix: prefix || \"\" };\r\n\t            kendo.widgets.push(widgetEntry);\r\n\r\n\t            for (var i = 0, len = kendo._widgetRegisteredCallbacks.length; i < len; i++) {\r\n\t                kendo._widgetRegisteredCallbacks[i](widgetEntry);\r\n\t            }\r\n\r\n\t            $.fn[name] = function(options) {\r\n\t                var value = this,\r\n\t                    args;\r\n\r\n\t                if (typeof options === STRING) {\r\n\t                    args = slice.call(arguments, 1);\r\n\r\n\t                    this.each(function(){\r\n\t                        var widget = $.data(this, name),\r\n\t                            method,\r\n\t                            result;\r\n\r\n\t                        if (!widget) {\r\n\t                            throw new Error(kendo.format(\"Cannot call method '{0}' of {1} before it is initialized\", options, name));\r\n\t                        }\r\n\r\n\t                        method = widget[options];\r\n\r\n\t                        if (typeof method !== FUNCTION) {\r\n\t                            throw new Error(kendo.format(\"Cannot find method '{0}' of {1}\", options, name));\r\n\t                        }\r\n\r\n\t                        result = method.apply(widget, args);\r\n\r\n\t                        if (result !== undefined) {\r\n\t                            value = result;\r\n\t                            return false;\r\n\t                        }\r\n\t                    });\r\n\t                } else {\r\n\t                    this.each(function() {\r\n\t                        return new widget(this, options);\r\n\t                    });\r\n\t                }\r\n\r\n\t                return value;\r\n\t            };\r\n\r\n\t            $.fn[name].widget = widget;\r\n\r\n\t            $.fn[getter] = function() {\r\n\t                return this.data(name);\r\n\t            };\r\n\t        }\r\n\t    });\r\n\r\n\t    kendo.ui.progress.messages = {\r\n\t        loading: \"Loading...\"\r\n\t    };\r\n\r\n\t    var ContainerNullObject = { bind: function () { return this; }, nullObject: true, options: {} };\r\n\r\n\t    var MobileWidget = Widget.extend({\r\n\t        init: function(element, options) {\r\n\t            Widget.fn.init.call(this, element, options);\r\n\t            this.element.autoApplyNS();\r\n\t            this.wrapper = this.element;\r\n\t            this.element.addClass(\"km-widget\");\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            Widget.fn.destroy.call(this);\r\n\t            this.element.kendoDestroy();\r\n\t        },\r\n\r\n\t        options: {\r\n\t            prefix: \"Mobile\"\r\n\t        },\r\n\r\n\t        events: [],\r\n\r\n\t        view: function() {\r\n\t            var viewElement = this.element.closest(kendo.roleSelector(\"view splitview modalview drawer\"));\r\n\t            return kendo.widgetInstance(viewElement, kendo.mobile.ui) || ContainerNullObject;\r\n\t        },\r\n\r\n\t        viewHasNativeScrolling: function() {\r\n\t            var view = this.view();\r\n\t            return view && view.options.useNativeScrolling;\r\n\t        },\r\n\r\n\t        container: function() {\r\n\t            var element = this.element.closest(kendo.roleSelector(\"view layout modalview drawer splitview\"));\r\n\t            return kendo.widgetInstance(element.eq(0), kendo.mobile.ui) || ContainerNullObject;\r\n\t        }\r\n\t    });\r\n\r\n\t    extend(kendo.mobile, {\r\n\t        init: function(element) {\r\n\t            kendo.init(element, kendo.mobile.ui, kendo.ui, kendo.dataviz.ui);\r\n\t        },\r\n\r\n\t        appLevelNativeScrolling: function() {\r\n\t            return kendo.mobile.application && kendo.mobile.application.options && kendo.mobile.application.options.useNativeScrolling;\r\n\t        },\r\n\r\n\t        roles: {},\r\n\r\n\t        ui: {\r\n\t            Widget: MobileWidget,\r\n\t            DataBoundWidget: DataBoundWidget.extend(MobileWidget.prototype),\r\n\t            roles: {},\r\n\t            plugin: function(widget) {\r\n\t                kendo.ui.plugin(widget, kendo.mobile.ui, \"Mobile\");\r\n\t            }\r\n\t        }\r\n\t    });\r\n\r\n\t    deepExtend(kendo.dataviz, {\r\n\t        init: function(element) {\r\n\t            kendo.init(element, kendo.dataviz.ui);\r\n\t        },\r\n\t        ui: {\r\n\t            roles: {},\r\n\t            themes: {},\r\n\t            views: [],\r\n\t            plugin: function(widget) {\r\n\t                kendo.ui.plugin(widget, kendo.dataviz.ui);\r\n\t            }\r\n\t        },\r\n\t        roles: {}\r\n\t    });\r\n\r\n\t    kendo.touchScroller = function(elements, options) {\r\n\t        // return the first touch scroller\r\n\t        if (!options){ options = {}; }\r\n\r\n\t        options.useNative = true;\r\n\r\n\t        return $(elements).map(function(idx, element) {\r\n\t            element = $(element);\r\n\t            if (support.kineticScrollNeeded && kendo.mobile.ui.Scroller && !element.data(\"kendoMobileScroller\")) {\r\n\t                element.kendoMobileScroller(options);\r\n\t                return element.data(\"kendoMobileScroller\");\r\n\t            } else {\r\n\t                return false;\r\n\t            }\r\n\t        })[0];\r\n\t    };\r\n\r\n\t    kendo.preventDefault = function(e) {\r\n\t        e.preventDefault();\r\n\t    };\r\n\r\n\t    kendo.widgetInstance = function(element, suites) {\r\n\t        var role = element.data(kendo.ns + \"role\"),\r\n\t            widgets = [], i, length;\r\n\r\n\t        if (role) {\r\n\t            // HACK!!! mobile view scroller widgets are instantiated on data-role=\"content\" elements. We need to discover them when resizing.\r\n\t            if (role === \"content\") {\r\n\t                role = \"scroller\";\r\n\t            }\r\n\r\n\t            if (suites) {\r\n\t                if (suites[0]) {\r\n\t                    for (i = 0, length = suites.length; i < length; i ++) {\r\n\t                        widgets.push(suites[i].roles[role]);\r\n\t                    }\r\n\t                } else {\r\n\t                    widgets.push(suites.roles[role]);\r\n\t                }\r\n\t            }\r\n\t            else {\r\n\t                widgets = [ kendo.ui.roles[role], kendo.dataviz.ui.roles[role],  kendo.mobile.ui.roles[role] ];\r\n\t            }\r\n\r\n\t            if (role.indexOf(\".\") >= 0) {\r\n\t                widgets = [ kendo.getter(role)(window) ];\r\n\t            }\r\n\r\n\t            for (i = 0, length = widgets.length; i < length; i ++) {\r\n\t                var widget = widgets[i];\r\n\t                if (widget) {\r\n\t                    var instance = element.data(\"kendo\" + widget.fn.options.prefix + widget.fn.options.name);\r\n\t                    if (instance) {\r\n\t                        return instance;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\r\n\t    kendo.onResize = function(callback) {\r\n\t        var handler = callback;\r\n\t        if (support.mobileOS.android) {\r\n\t            handler = function() { setTimeout(callback, 600); };\r\n\t        }\r\n\r\n\t        $(window).on(support.resize, handler);\r\n\t        return handler;\r\n\t    };\r\n\r\n\t    kendo.unbindResize = function(callback) {\r\n\t        $(window).off(support.resize, callback);\r\n\t    };\r\n\r\n\t    kendo.attrValue = function(element, key) {\r\n\t        return element.data(kendo.ns + key);\r\n\t    };\r\n\r\n\t    kendo.days = {\r\n\t        Sunday: 0,\r\n\t        Monday: 1,\r\n\t        Tuesday: 2,\r\n\t        Wednesday: 3,\r\n\t        Thursday: 4,\r\n\t        Friday: 5,\r\n\t        Saturday: 6\r\n\t    };\r\n\r\n\t    function focusable(element, isTabIndexNotNaN) {\r\n\t        var nodeName = element.nodeName.toLowerCase();\r\n\r\n\t        return (/input|select|textarea|button|object/.test(nodeName) ?\r\n\t                !element.disabled :\r\n\t                \"a\" === nodeName ?\r\n\t                element.href || isTabIndexNotNaN :\r\n\t                isTabIndexNotNaN\r\n\t               ) &&\r\n\t            visible(element);\r\n\t    }\r\n\r\n\t    function visible(element) {\r\n\t        return $.expr.filters.visible(element) &&\r\n\t            !$(element).parents().addBack().filter(function() {\r\n\t                return $.css(this,\"visibility\") === \"hidden\";\r\n\t            }).length;\r\n\t    }\r\n\r\n\t    $.extend($.expr[ \":\" ], {\r\n\t        kendoFocusable: function(element) {\r\n\t            var idx = $.attr(element, \"tabindex\");\r\n\t            return focusable(element, !isNaN(idx) && idx > -1);\r\n\t        }\r\n\t    });\r\n\r\n\t    var MOUSE_EVENTS = [\"mousedown\", \"mousemove\", \"mouseenter\", \"mouseleave\", \"mouseover\", \"mouseout\", \"mouseup\", \"click\"];\r\n\t    var EXCLUDE_BUST_CLICK_SELECTOR = \"label, input, [data-rel=external]\";\r\n\r\n\t    var MouseEventNormalizer = {\r\n\t        setupMouseMute: function() {\r\n\t            var idx = 0,\r\n\t                length = MOUSE_EVENTS.length,\r\n\t                element = document.documentElement;\r\n\r\n\t            if (MouseEventNormalizer.mouseTrap || !support.eventCapture) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            MouseEventNormalizer.mouseTrap = true;\r\n\r\n\t            MouseEventNormalizer.bustClick = false;\r\n\t            MouseEventNormalizer.captureMouse = false;\r\n\r\n\t            var handler = function(e) {\r\n\t                if (MouseEventNormalizer.captureMouse) {\r\n\t                    if (e.type === \"click\") {\r\n\t                        if (MouseEventNormalizer.bustClick && !$(e.target).is(EXCLUDE_BUST_CLICK_SELECTOR)) {\r\n\t                            e.preventDefault();\r\n\t                            e.stopPropagation();\r\n\t                        }\r\n\t                    } else {\r\n\t                        e.stopPropagation();\r\n\t                    }\r\n\t                }\r\n\t            };\r\n\r\n\t            for (; idx < length; idx++) {\r\n\t                element.addEventListener(MOUSE_EVENTS[idx], handler, true);\r\n\t            }\r\n\t        },\r\n\r\n\t        muteMouse: function(e) {\r\n\t            MouseEventNormalizer.captureMouse = true;\r\n\t            if (e.data.bustClick) {\r\n\t                MouseEventNormalizer.bustClick = true;\r\n\t            }\r\n\t            clearTimeout(MouseEventNormalizer.mouseTrapTimeoutID);\r\n\t        },\r\n\r\n\t        unMuteMouse: function() {\r\n\t            clearTimeout(MouseEventNormalizer.mouseTrapTimeoutID);\r\n\t            MouseEventNormalizer.mouseTrapTimeoutID = setTimeout(function() {\r\n\t                MouseEventNormalizer.captureMouse = false;\r\n\t                MouseEventNormalizer.bustClick = false;\r\n\t            }, 400);\r\n\t        }\r\n\t    };\r\n\r\n\t    var eventMap = {\r\n\t        down: \"touchstart mousedown\",\r\n\t        move: \"mousemove touchmove\",\r\n\t        up: \"mouseup touchend touchcancel\",\r\n\t        cancel: \"mouseleave touchcancel\"\r\n\t    };\r\n\r\n\t    if (support.touch && (support.mobileOS.ios || support.mobileOS.android)) {\r\n\t        eventMap = {\r\n\t            down: \"touchstart\",\r\n\t            move: \"touchmove\",\r\n\t            up: \"touchend touchcancel\",\r\n\t            cancel: \"touchcancel\"\r\n\t        };\r\n\t    } else if (support.pointers) {\r\n\t        eventMap = {\r\n\t            down: \"pointerdown\",\r\n\t            move: \"pointermove\",\r\n\t            up: \"pointerup\",\r\n\t            cancel: \"pointercancel pointerleave\"\r\n\t        };\r\n\t    } else if (support.msPointers) {\r\n\t        eventMap = {\r\n\t            down: \"MSPointerDown\",\r\n\t            move: \"MSPointerMove\",\r\n\t            up: \"MSPointerUp\",\r\n\t            cancel: \"MSPointerCancel MSPointerLeave\"\r\n\t        };\r\n\t    }\r\n\r\n\t    if (support.msPointers && !(\"onmspointerenter\" in window)) { // IE10\r\n\t        // Create MSPointerEnter/MSPointerLeave events using mouseover/out and event-time checks\r\n\t        $.each({\r\n\t            MSPointerEnter: \"MSPointerOver\",\r\n\t            MSPointerLeave: \"MSPointerOut\"\r\n\t        }, function( orig, fix ) {\r\n\t            $.event.special[ orig ] = {\r\n\t                delegateType: fix,\r\n\t                bindType: fix,\r\n\r\n\t                handle: function( event ) {\r\n\t                    var ret,\r\n\t                        target = this,\r\n\t                        related = event.relatedTarget,\r\n\t                        handleObj = event.handleObj;\r\n\r\n\t                    // For mousenter/leave call the handler if related is outside the target.\r\n\t                    // NB: No relatedTarget if the mouse left/entered the browser window\r\n\t                    if ( !related || (related !== target && !$.contains( target, related )) ) {\r\n\t                        event.type = handleObj.origType;\r\n\t                        ret = handleObj.handler.apply( this, arguments );\r\n\t                        event.type = fix;\r\n\t                    }\r\n\t                    return ret;\r\n\t                }\r\n\t            };\r\n\t        });\r\n\t    }\r\n\r\n\r\n\t    var getEventMap = function(e) { return (eventMap[e] || e); },\r\n\t        eventRegEx = /([^ ]+)/g;\r\n\r\n\t    kendo.applyEventMap = function(events, ns) {\r\n\t        events = events.replace(eventRegEx, getEventMap);\r\n\r\n\t        if (ns) {\r\n\t            events = events.replace(eventRegEx, \"$1.\" + ns);\r\n\t        }\r\n\r\n\t        return events;\r\n\t    };\r\n\r\n\t    var on = $.fn.on;\r\n\r\n\t    function kendoJQuery(selector, context) {\r\n\t        return new kendoJQuery.fn.init(selector, context);\r\n\t    }\r\n\r\n\t    extend(true, kendoJQuery, $);\r\n\r\n\t    kendoJQuery.fn = kendoJQuery.prototype = new $();\r\n\r\n\t    kendoJQuery.fn.constructor = kendoJQuery;\r\n\r\n\t    kendoJQuery.fn.init = function(selector, context) {\r\n\t        if (context && context instanceof $ && !(context instanceof kendoJQuery)) {\r\n\t            context = kendoJQuery(context);\r\n\t        }\r\n\r\n\t        return $.fn.init.call(this, selector, context, rootjQuery);\r\n\t    };\r\n\r\n\t    kendoJQuery.fn.init.prototype = kendoJQuery.fn;\r\n\r\n\t    var rootjQuery = kendoJQuery(document);\r\n\r\n\t    extend(kendoJQuery.fn, {\r\n\t        handler: function(handler) {\r\n\t            this.data(\"handler\", handler);\r\n\t            return this;\r\n\t        },\r\n\r\n\t        autoApplyNS: function(ns) {\r\n\t            this.data(\"kendoNS\", ns || kendo.guid());\r\n\t            return this;\r\n\t        },\r\n\r\n\t        on: function() {\r\n\t            var that = this,\r\n\t                ns = that.data(\"kendoNS\");\r\n\r\n\t            // support for event map signature\r\n\t            if (arguments.length === 1) {\r\n\t                return on.call(that, arguments[0]);\r\n\t            }\r\n\r\n\t            var context = that,\r\n\t                args = slice.call(arguments);\r\n\r\n\t            if (typeof args[args.length -1] === UNDEFINED) {\r\n\t                args.pop();\r\n\t            }\r\n\r\n\t            var callback =  args[args.length - 1],\r\n\t                events = kendo.applyEventMap(args[0], ns);\r\n\r\n\t            // setup mouse trap\r\n\t            if (support.mouseAndTouchPresent && events.search(/mouse|click/) > -1 && this[0] !== document.documentElement) {\r\n\t                MouseEventNormalizer.setupMouseMute();\r\n\r\n\t                var selector = args.length === 2 ? null : args[1],\r\n\t                    bustClick = events.indexOf(\"click\") > -1 && events.indexOf(\"touchend\") > -1;\r\n\r\n\t                on.call(this,\r\n\t                    {\r\n\t                        touchstart: MouseEventNormalizer.muteMouse,\r\n\t                        touchend: MouseEventNormalizer.unMuteMouse\r\n\t                    },\r\n\t                    selector,\r\n\t                    {\r\n\t                        bustClick: bustClick\r\n\t                    });\r\n\t            }\r\n\r\n\t            if (typeof callback === STRING) {\r\n\t                context = that.data(\"handler\");\r\n\t                callback = context[callback];\r\n\r\n\t                args[args.length - 1] = function(e) {\r\n\t                    callback.call(context, e);\r\n\t                };\r\n\t            }\r\n\r\n\t            args[0] = events;\r\n\r\n\t            on.apply(that, args);\r\n\r\n\t            return that;\r\n\t        },\r\n\r\n\t        kendoDestroy: function(ns) {\r\n\t            ns = ns || this.data(\"kendoNS\");\r\n\r\n\t            if (ns) {\r\n\t                this.off(\".\" + ns);\r\n\t            }\r\n\r\n\t            return this;\r\n\t        }\r\n\t    });\r\n\r\n\t    kendo.jQuery = kendoJQuery;\r\n\t    kendo.eventMap = eventMap;\r\n\r\n\t    kendo.timezone = (function(){\r\n\t        var months =  { Jan: 0, Feb: 1, Mar: 2, Apr: 3, May: 4, Jun: 5, Jul: 6, Aug: 7, Sep: 8, Oct: 9, Nov: 10, Dec: 11 };\r\n\t        var days = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };\r\n\r\n\t        function ruleToDate(year, rule) {\r\n\t            var date;\r\n\t            var targetDay;\r\n\t            var ourDay;\r\n\t            var month = rule[3];\r\n\t            var on = rule[4];\r\n\t            var time = rule[5];\r\n\t            var cache = rule[8];\r\n\r\n\t            if (!cache) {\r\n\t                rule[8] = cache = {};\r\n\t            }\r\n\r\n\t            if (cache[year]) {\r\n\t                return cache[year];\r\n\t            }\r\n\r\n\t            if (!isNaN(on)) {\r\n\t                date = new Date(Date.UTC(year, months[month], on, time[0], time[1], time[2], 0));\r\n\t            } else if (on.indexOf(\"last\") === 0) {\r\n\t                date = new Date(Date.UTC(year, months[month] + 1, 1, time[0] - 24, time[1], time[2], 0));\r\n\r\n\t                targetDay = days[on.substr(4, 3)];\r\n\t                ourDay = date.getUTCDay();\r\n\r\n\t                date.setUTCDate(date.getUTCDate() + targetDay - ourDay - (targetDay > ourDay ? 7 : 0));\r\n\t            } else if (on.indexOf(\">=\") >= 0) {\r\n\t                date = new Date(Date.UTC(year, months[month], on.substr(5), time[0], time[1], time[2], 0));\r\n\r\n\t                targetDay = days[on.substr(0, 3)];\r\n\t                ourDay = date.getUTCDay();\r\n\r\n\t                date.setUTCDate(date.getUTCDate() + targetDay - ourDay + (targetDay < ourDay ? 7 : 0));\r\n\t            }\r\n\r\n\t            return cache[year] = date;\r\n\t        }\r\n\r\n\t        function findRule(utcTime, rules, zone) {\r\n\t            rules = rules[zone];\r\n\r\n\t            if (!rules) {\r\n\t                var time = zone.split(\":\");\r\n\t                var offset = 0;\r\n\r\n\t                if (time.length > 1) {\r\n\t                    offset = time[0] * 60 + Number(time[1]);\r\n\t                }\r\n\r\n\t                return [-1000000, 'max', '-', 'Jan', 1, [0, 0, 0], offset, '-'];\r\n\t            }\r\n\r\n\t            var year = new Date(utcTime).getUTCFullYear();\r\n\r\n\t            rules = jQuery.grep(rules, function(rule) {\r\n\t                var from = rule[0];\r\n\t                var to = rule[1];\r\n\r\n\t                return from <= year && (to >= year || (from == year && to == \"only\") || to == \"max\");\r\n\t            });\r\n\r\n\t            rules.push(utcTime);\r\n\r\n\t            rules.sort(function(a, b) {\r\n\t                if (typeof a != \"number\") {\r\n\t                    a = Number(ruleToDate(year, a));\r\n\t                }\r\n\r\n\t                if (typeof b != \"number\") {\r\n\t                    b = Number(ruleToDate(year, b));\r\n\t                }\r\n\r\n\t                return a - b;\r\n\t            });\r\n\r\n\t            var rule = rules[jQuery.inArray(utcTime, rules) - 1] || rules[rules.length - 1];\r\n\r\n\t            return isNaN(rule) ? rule : null;\r\n\t        }\r\n\r\n\t        function findZone(utcTime, zones, timezone) {\r\n\t            var zoneRules = zones[timezone];\r\n\r\n\t            if (typeof zoneRules === \"string\") {\r\n\t                zoneRules = zones[zoneRules];\r\n\t            }\r\n\r\n\t            if (!zoneRules) {\r\n\t                throw new Error('Timezone \"' + timezone + '\" is either incorrect, or kendo.timezones.min.js is not included.');\r\n\t            }\r\n\r\n\t            for (var idx = zoneRules.length - 1; idx >= 0; idx--) {\r\n\t                var until = zoneRules[idx][3];\r\n\r\n\t                if (until && utcTime > until) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\r\n\t            var zone = zoneRules[idx + 1];\r\n\r\n\t            if (!zone) {\r\n\t                throw new Error('Timezone \"' + timezone + '\" not found on ' + utcTime + \".\");\r\n\t            }\r\n\r\n\t            return zone;\r\n\t        }\r\n\r\n\t        function zoneAndRule(utcTime, zones, rules, timezone) {\r\n\t            if (typeof utcTime != NUMBER) {\r\n\t                utcTime = Date.UTC(utcTime.getFullYear(), utcTime.getMonth(),\r\n\t                    utcTime.getDate(), utcTime.getHours(), utcTime.getMinutes(),\r\n\t                    utcTime.getSeconds(), utcTime.getMilliseconds());\r\n\t            }\r\n\r\n\t            var zone = findZone(utcTime, zones, timezone);\r\n\r\n\t            return {\r\n\t                zone: zone,\r\n\t                rule: findRule(utcTime, rules, zone[1])\r\n\t            };\r\n\t        }\r\n\r\n\t        function offset(utcTime, timezone) {\r\n\t            if (timezone == \"Etc/UTC\" || timezone == \"Etc/GMT\") {\r\n\t                return 0;\r\n\t            }\r\n\r\n\t            var info = zoneAndRule(utcTime, this.zones, this.rules, timezone);\r\n\t            var zone = info.zone;\r\n\t            var rule = info.rule;\r\n\r\n\t            return kendo.parseFloat(rule? zone[0] - rule[6] : zone[0]);\r\n\t        }\r\n\r\n\t        function abbr(utcTime, timezone) {\r\n\t            var info = zoneAndRule(utcTime, this.zones, this.rules, timezone);\r\n\t            var zone = info.zone;\r\n\t            var rule = info.rule;\r\n\r\n\t            var base = zone[2];\r\n\r\n\t            if (base.indexOf(\"/\") >= 0) {\r\n\t                return base.split(\"/\")[rule && +rule[6] ? 1 : 0];\r\n\t            } else if (base.indexOf(\"%s\") >= 0) {\r\n\t                return base.replace(\"%s\", (!rule || rule[7] == \"-\") ? '' : rule[7]);\r\n\t            }\r\n\r\n\t            return base;\r\n\t        }\r\n\r\n\t        function convert(date, fromOffset, toOffset) {\r\n\t            var tempToOffset = toOffset;\r\n\t            var diff;\r\n\r\n\t            if (typeof fromOffset == STRING) {\r\n\t                fromOffset = this.offset(date, fromOffset);\r\n\t            }\r\n\r\n\t            if (typeof toOffset == STRING) {\r\n\t                toOffset = this.offset(date, toOffset);\r\n\t            }\r\n\r\n\t            var fromLocalOffset = date.getTimezoneOffset();\r\n\r\n\t            date = new Date(date.getTime() + (fromOffset - toOffset) * 60000);\r\n\r\n\t            var toLocalOffset = date.getTimezoneOffset();\r\n\r\n\t            if (typeof tempToOffset == STRING) {\r\n\t                tempToOffset = this.offset(date, tempToOffset);\r\n\t            }\r\n\r\n\t            diff = (toLocalOffset - fromLocalOffset) + (toOffset - tempToOffset);\r\n\r\n\t            return new Date(date.getTime() + diff * 60000);\r\n\t        }\r\n\r\n\t        function apply(date, timezone) {\r\n\t           return this.convert(date, date.getTimezoneOffset(), timezone);\r\n\t        }\r\n\r\n\t        function remove(date, timezone) {\r\n\t           return this.convert(date, timezone, date.getTimezoneOffset());\r\n\t        }\r\n\r\n\t        function toLocalDate(time) {\r\n\t            return this.apply(new Date(time), \"Etc/UTC\");\r\n\t        }\r\n\r\n\t        return {\r\n\t           zones: {},\r\n\t           rules: {},\r\n\t           offset: offset,\r\n\t           convert: convert,\r\n\t           apply: apply,\r\n\t           remove: remove,\r\n\t           abbr: abbr,\r\n\t           toLocalDate: toLocalDate\r\n\t        };\r\n\t    })();\r\n\r\n\t    kendo.date = (function(){\r\n\t        var MS_PER_MINUTE = 60000,\r\n\t            MS_PER_DAY = 86400000;\r\n\r\n\t        function adjustDST(date, hours) {\r\n\t            if (hours === 0 && date.getHours() === 23) {\r\n\t                date.setHours(date.getHours() + 2);\r\n\t                return true;\r\n\t            }\r\n\r\n\t            return false;\r\n\t        }\r\n\r\n\t        function setDayOfWeek(date, day, dir) {\r\n\t            var hours = date.getHours();\r\n\r\n\t            dir = dir || 1;\r\n\t            day = ((day - date.getDay()) + (7 * dir)) % 7;\r\n\r\n\t            date.setDate(date.getDate() + day);\r\n\t            adjustDST(date, hours);\r\n\t        }\r\n\r\n\t        function dayOfWeek(date, day, dir) {\r\n\t            date = new Date(date);\r\n\t            setDayOfWeek(date, day, dir);\r\n\t            return date;\r\n\t        }\r\n\r\n\t        function firstDayOfMonth(date) {\r\n\t            return new Date(\r\n\t                date.getFullYear(),\r\n\t                date.getMonth(),\r\n\t                1\r\n\t            );\r\n\t        }\r\n\r\n\t        function lastDayOfMonth(date) {\r\n\t            var last = new Date(date.getFullYear(), date.getMonth() + 1, 0),\r\n\t                first = firstDayOfMonth(date),\r\n\t                timeOffset = Math.abs(last.getTimezoneOffset() - first.getTimezoneOffset());\r\n\r\n\t            if (timeOffset) {\r\n\t                last.setHours(first.getHours() + (timeOffset / 60));\r\n\t            }\r\n\r\n\t            return last;\r\n\t        }\r\n\r\n\t        function moveDateToWeekStart(date, weekStartDay) {\r\n\t            if (weekStartDay !== 1) {\r\n\t                return addDays(dayOfWeek(date, weekStartDay, -1), 4);\r\n\t            }\r\n\r\n\t            return addDays(date, (4 - (date.getDay() || 7)));\r\n\t        }\r\n\r\n\t        function calcWeekInYear(date, weekStartDay) {\r\n\t            var firstWeekInYear = new Date(date.getFullYear(), 0, 1, -6);\r\n\r\n\t            var newDate = moveDateToWeekStart(date, weekStartDay);\r\n\r\n\t            var diffInMS = newDate.getTime() - firstWeekInYear.getTime();\r\n\r\n\t            var days = Math.floor(diffInMS / MS_PER_DAY);\r\n\r\n\t            return 1 + Math.floor(days / 7);\r\n\t        }\r\n\r\n\t        function weekInYear(date, weekStartDay) {\r\n\t            if(weekStartDay === undefined) {\r\n\t                weekStartDay = kendo.culture().calendar.firstDay;\r\n\t            }\r\n\r\n\t            var prevWeekDate = addDays(date, -7);\r\n\t            var nextWeekDate = addDays(date, 7);\r\n\r\n\t            var weekNumber = calcWeekInYear(date, weekStartDay);\r\n\r\n\t            if (weekNumber === 0) {\r\n\t                return calcWeekInYear(prevWeekDate, weekStartDay) + 1;\r\n\t            }\r\n\r\n\t            if (weekNumber === 53 && calcWeekInYear(nextWeekDate, weekStartDay) > 1) {\r\n\t                return 1;\r\n\t            }\r\n\r\n\t            return weekNumber;\r\n\t        }\r\n\r\n\t        function getDate(date) {\r\n\t            date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\r\n\t            adjustDST(date, 0);\r\n\t            return date;\r\n\t        }\r\n\r\n\t        function toUtcTime(date) {\r\n\t            return Date.UTC(date.getFullYear(), date.getMonth(),\r\n\t                        date.getDate(), date.getHours(), date.getMinutes(),\r\n\t                        date.getSeconds(), date.getMilliseconds());\r\n\t        }\r\n\r\n\t        function getMilliseconds(date) {\r\n\t            return toInvariantTime(date).getTime() - getDate(toInvariantTime(date));\r\n\t        }\r\n\r\n\t        function isInTimeRange(value, min, max) {\r\n\t            var msMin = getMilliseconds(min),\r\n\t                msMax = getMilliseconds(max),\r\n\t                msValue;\r\n\r\n\t            if (!value || msMin == msMax) {\r\n\t                return true;\r\n\t            }\r\n\r\n\t            if (min >= max) {\r\n\t                max += MS_PER_DAY;\r\n\t            }\r\n\r\n\t            msValue = getMilliseconds(value);\r\n\r\n\t            if (msMin > msValue) {\r\n\t                msValue += MS_PER_DAY;\r\n\t            }\r\n\r\n\t            if (msMax < msMin) {\r\n\t                msMax += MS_PER_DAY;\r\n\t            }\r\n\r\n\t            return msValue >= msMin && msValue <= msMax;\r\n\t        }\r\n\r\n\t        function isInDateRange(value, min, max) {\r\n\t            var msMin = min.getTime(),\r\n\t                msMax = max.getTime(),\r\n\t                msValue;\r\n\r\n\t            if (msMin >= msMax) {\r\n\t                msMax += MS_PER_DAY;\r\n\t            }\r\n\r\n\t            msValue = value.getTime();\r\n\r\n\t            return msValue >= msMin && msValue <= msMax;\r\n\t        }\r\n\r\n\t        function addDays(date, offset) {\r\n\t            var hours = date.getHours();\r\n\t                date = new Date(date);\r\n\r\n\t            setTime(date, offset * MS_PER_DAY);\r\n\t            adjustDST(date, hours);\r\n\t            return date;\r\n\t        }\r\n\r\n\t        function setTime(date, milliseconds, ignoreDST) {\r\n\t            var offset = date.getTimezoneOffset();\r\n\t            var difference;\r\n\r\n\t            date.setTime(date.getTime() + milliseconds);\r\n\r\n\t            if (!ignoreDST) {\r\n\t                difference = date.getTimezoneOffset() - offset;\r\n\t                date.setTime(date.getTime() + difference * MS_PER_MINUTE);\r\n\t            }\r\n\t        }\r\n\r\n\t        function setHours(date, time) {\r\n\t            date = new Date(kendo.date.getDate(date).getTime() + kendo.date.getMilliseconds(time));\r\n\t            adjustDST(date, time.getHours());\r\n\t            return date;\r\n\t        }\r\n\r\n\t        function today() {\r\n\t            return getDate(new Date());\r\n\t        }\r\n\r\n\t        function isToday(date) {\r\n\t           return getDate(date).getTime() == today().getTime();\r\n\t        }\r\n\r\n\t        function toInvariantTime(date) {\r\n\t            var staticDate = new Date(1980, 1, 1, 0, 0, 0);\r\n\r\n\t            if (date) {\r\n\t                staticDate.setHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\r\n\t            }\r\n\r\n\t            return staticDate;\r\n\t        }\r\n\r\n\t        return {\r\n\t            adjustDST: adjustDST,\r\n\t            dayOfWeek: dayOfWeek,\r\n\t            setDayOfWeek: setDayOfWeek,\r\n\t            getDate: getDate,\r\n\t            isInDateRange: isInDateRange,\r\n\t            isInTimeRange: isInTimeRange,\r\n\t            isToday: isToday,\r\n\t            nextDay: function(date) {\r\n\t                return addDays(date, 1);\r\n\t            },\r\n\t            previousDay: function(date) {\r\n\t                return addDays(date, -1);\r\n\t            },\r\n\t            toUtcTime: toUtcTime,\r\n\t            MS_PER_DAY: MS_PER_DAY,\r\n\t            MS_PER_HOUR: 60 * MS_PER_MINUTE,\r\n\t            MS_PER_MINUTE: MS_PER_MINUTE,\r\n\t            setTime: setTime,\r\n\t            setHours: setHours,\r\n\t            addDays: addDays,\r\n\t            today: today,\r\n\t            toInvariantTime: toInvariantTime,\r\n\t            firstDayOfMonth: firstDayOfMonth,\r\n\t            lastDayOfMonth: lastDayOfMonth,\r\n\t            weekInYear: weekInYear,\r\n\t            getMilliseconds: getMilliseconds\r\n\t        };\r\n\t    })();\r\n\r\n\r\n\t    kendo.stripWhitespace = function(element) {\r\n\t        if (document.createNodeIterator) {\r\n\t            var iterator = document.createNodeIterator(element, NodeFilter.SHOW_TEXT, function(node) {\r\n\t                    return node.parentNode == element ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\r\n\t                }, false);\r\n\r\n\t            while (iterator.nextNode()) {\r\n\t                if (iterator.referenceNode && !iterator.referenceNode.textContent.trim()) {\r\n\t                    iterator.referenceNode.parentNode.removeChild(iterator.referenceNode);\r\n\t                }\r\n\t            }\r\n\t        } else { // IE7/8 support\r\n\t            for (var i = 0; i < element.childNodes.length; i++) {\r\n\t                var child = element.childNodes[i];\r\n\r\n\t                if (child.nodeType == 3 && !/\\S/.test(child.nodeValue)) {\r\n\t                    element.removeChild(child);\r\n\t                    i--;\r\n\t                }\r\n\r\n\t                if (child.nodeType == 1) {\r\n\t                    kendo.stripWhitespace(child);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\r\n\t    var animationFrame  = window.requestAnimationFrame       ||\r\n\t                          window.webkitRequestAnimationFrame ||\r\n\t                          window.mozRequestAnimationFrame    ||\r\n\t                          window.oRequestAnimationFrame      ||\r\n\t                          window.msRequestAnimationFrame     ||\r\n\t                          function(callback){ setTimeout(callback, 1000 / 60); };\r\n\r\n\t    kendo.animationFrame = function(callback) {\r\n\t        animationFrame.call(window, callback);\r\n\t    };\r\n\r\n\t    var animationQueue = [];\r\n\r\n\t    kendo.queueAnimation = function(callback) {\r\n\t        animationQueue[animationQueue.length] = callback;\r\n\t        if (animationQueue.length === 1) {\r\n\t            kendo.runNextAnimation();\r\n\t        }\r\n\t    };\r\n\r\n\t    kendo.runNextAnimation = function() {\r\n\t        kendo.animationFrame(function() {\r\n\t            if (animationQueue[0]) {\r\n\t                animationQueue.shift()();\r\n\t                if (animationQueue[0]) {\r\n\t                    kendo.runNextAnimation();\r\n\t                }\r\n\t            }\r\n\t        });\r\n\t    };\r\n\r\n\t    kendo.parseQueryStringParams = function(url) {\r\n\t        var queryString = url.split('?')[1] || \"\",\r\n\t            params = {},\r\n\t            paramParts = queryString.split(/&|=/),\r\n\t            length = paramParts.length,\r\n\t            idx = 0;\r\n\r\n\t        for (; idx < length; idx += 2) {\r\n\t            if(paramParts[idx] !== \"\") {\r\n\t                params[decodeURIComponent(paramParts[idx])] = decodeURIComponent(paramParts[idx + 1]);\r\n\t            }\r\n\t        }\r\n\r\n\t        return params;\r\n\t    };\r\n\r\n\t    kendo.elementUnderCursor = function(e) {\r\n\t        if (typeof e.x.client != \"undefined\") {\r\n\t            return document.elementFromPoint(e.x.client, e.y.client);\r\n\t        }\r\n\t    };\r\n\r\n\t    kendo.wheelDeltaY = function(jQueryEvent) {\r\n\t        var e = jQueryEvent.originalEvent,\r\n\t            deltaY = e.wheelDeltaY,\r\n\t            delta;\r\n\r\n\t            if (e.wheelDelta) { // Webkit and IE\r\n\t                if (deltaY === undefined || deltaY) { // IE does not have deltaY, thus always scroll (horizontal scrolling is treated as vertical)\r\n\t                    delta = e.wheelDelta;\r\n\t                }\r\n\t            } else if (e.detail && e.axis === e.VERTICAL_AXIS) { // Firefox and Opera\r\n\t                delta = (-e.detail) * 10;\r\n\t            }\r\n\r\n\t        return delta;\r\n\t    };\r\n\r\n\t    kendo.throttle = function(fn, delay) {\r\n\t        var timeout;\r\n\t        var lastExecTime = 0;\r\n\r\n\t        if (!delay || delay <= 0) {\r\n\t            return fn;\r\n\t        }\r\n\r\n\t        var throttled = function() {\r\n\t            var that = this;\r\n\t            var elapsed = +new Date() - lastExecTime;\r\n\t            var args = arguments;\r\n\r\n\t            function exec() {\r\n\t                fn.apply(that, args);\r\n\t                lastExecTime = +new Date();\r\n\t            }\r\n\r\n\t            // first execution\r\n\t            if (!lastExecTime) {\r\n\t                return exec();\r\n\t            }\r\n\r\n\t            if (timeout) {\r\n\t                clearTimeout(timeout);\r\n\t            }\r\n\r\n\t            if (elapsed > delay) {\r\n\t                exec();\r\n\t            } else {\r\n\t                timeout = setTimeout(exec, delay - elapsed);\r\n\t            }\r\n\t        };\r\n\r\n\t        throttled.cancel = function() {\r\n\t            clearTimeout(timeout);\r\n\t        };\r\n\r\n\t        return throttled;\r\n\t    };\r\n\r\n\r\n\t    kendo.caret = function (element, start, end) {\r\n\t        var rangeElement;\r\n\t        var isPosition = start !== undefined;\r\n\r\n\t        if (end === undefined) {\r\n\t            end = start;\r\n\t        }\r\n\r\n\t        if (element[0]) {\r\n\t            element = element[0];\r\n\t        }\r\n\r\n\t        if (isPosition && element.disabled) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        try {\r\n\t            if (element.selectionStart !== undefined) {\r\n\t                if (isPosition) {\r\n\t                    element.focus();\r\n\t                    var mobile = support.mobileOS;\r\n\t                    if(mobile.wp || mobile.android) {// without the timeout the caret is at the end of the input\r\n\t                        setTimeout(function() { element.setSelectionRange(start, end); }, 0);\r\n\t                    }\r\n\t                    else {\r\n\t                        element.setSelectionRange(start, end);\r\n\t                    }\r\n\t                } else {\r\n\t                    start = [element.selectionStart, element.selectionEnd];\r\n\t                }\r\n\t            } else if (document.selection) {\r\n\t                if ($(element).is(\":visible\")) {\r\n\t                    element.focus();\r\n\t                }\r\n\r\n\t                rangeElement = element.createTextRange();\r\n\r\n\t                if (isPosition) {\r\n\t                    rangeElement.collapse(true);\r\n\t                    rangeElement.moveStart(\"character\", start);\r\n\t                    rangeElement.moveEnd(\"character\", end - start);\r\n\t                    rangeElement.select();\r\n\t                } else {\r\n\t                    var rangeDuplicated = rangeElement.duplicate(),\r\n\t                        selectionStart, selectionEnd;\r\n\r\n\t                        rangeElement.moveToBookmark(document.selection.createRange().getBookmark());\r\n\t                        rangeDuplicated.setEndPoint('EndToStart', rangeElement);\r\n\t                        selectionStart = rangeDuplicated.text.length;\r\n\t                        selectionEnd = selectionStart + rangeElement.text.length;\r\n\r\n\t                    start = [selectionStart, selectionEnd];\r\n\t                }\r\n\t            }\r\n\t        } catch(e) {\r\n\t            /* element is not focused or it is not in the DOM */\r\n\t            start = [];\r\n\t        }\r\n\r\n\t        return start;\r\n\t    };\r\n\r\n\t    kendo.compileMobileDirective = function(element, scope) {\r\n\t        var angular = window.angular;\r\n\r\n\t        element.attr(\"data-\" + kendo.ns + \"role\", element[0].tagName.toLowerCase().replace('kendo-mobile-', '').replace('-', ''));\r\n\r\n\t        angular.element(element).injector().invoke([\"$compile\", function($compile) {\r\n\t            $compile(element)(scope);\r\n\r\n\t            if (!/^\\$(digest|apply)$/.test(scope.$$phase)) {\r\n\t                scope.$digest();\r\n\t            }\r\n\t        }]);\r\n\r\n\t        return kendo.widgetInstance(element, kendo.mobile.ui);\r\n\t    };\r\n\r\n\t    kendo.antiForgeryTokens = function() {\r\n\t        var tokens = { },\r\n\t            csrf_token = $(\"meta[name=csrf-token],meta[name=_csrf]\").attr(\"content\"),\r\n\t            csrf_param = $(\"meta[name=csrf-param],meta[name=_csrf_header]\").attr(\"content\");\r\n\r\n\t        $(\"input[name^='__RequestVerificationToken']\").each(function() {\r\n\t            tokens[this.name] = this.value;\r\n\t        });\r\n\r\n\t        if (csrf_param !== undefined && csrf_token !== undefined) {\r\n\t          tokens[csrf_param] = csrf_token;\r\n\t        }\r\n\r\n\t        return tokens;\r\n\t    };\r\n\r\n\t    kendo.cycleForm = function(form) {\r\n\t        var firstElement = form.find(\"input, .k-widget\").first();\r\n\t        var lastElement = form.find(\"button, .k-button\").last();\r\n\r\n\t        function focus(el) {\r\n\t            var widget = kendo.widgetInstance(el);\r\n\r\n\t            if (widget && widget.focus) {\r\n\t              widget.focus();\r\n\t            } else {\r\n\t              el.focus();\r\n\t            }\r\n\t        }\r\n\r\n\t        lastElement.on(\"keydown\", function(e) {\r\n\t          if (e.keyCode == kendo.keys.TAB && !e.shiftKey) {\r\n\t            e.preventDefault();\r\n\t            focus(firstElement);\r\n\t          }\r\n\t        });\r\n\r\n\t        firstElement.on(\"keydown\", function(e) {\r\n\t          if (e.keyCode == kendo.keys.TAB && e.shiftKey) {\r\n\t            e.preventDefault();\r\n\t            focus(lastElement);\r\n\t          }\r\n\t        });\r\n\t    };\r\n\r\n\t    kendo.focusElement = function(element) {\r\n\t        var scrollTopPositions = [];\r\n\t        var scrollableParents = element.parentsUntil(\"body\")\r\n\t                .filter(function(index, element) {\r\n\t                    var computedStyle = kendo.getComputedStyles(element, [\"overflow\"]);\r\n\t                    return computedStyle.overflow !== \"visible\";\r\n\t                })\r\n\t                .add(window);\r\n\r\n\t        scrollableParents.each(function(index, parent) {\r\n\t            scrollTopPositions[index] = $(parent).scrollTop();\r\n\t        });\r\n\r\n\t        try {\r\n\t            //The setActive method does not cause the document to scroll to the active object in the current page\r\n\t            element[0].setActive();\r\n\t        } catch (e) {\r\n\t            element[0].focus();\r\n\t        }\r\n\r\n\t        scrollableParents.each(function(index, parent) {\r\n\t            $(parent).scrollTop(scrollTopPositions[index]);\r\n\t        });\r\n\t    };\r\n\r\n\t    // kendo.saveAs -----------------------------------------------\r\n\t    (function() {\r\n\t        function postToProxy(dataURI, fileName, proxyURL, proxyTarget) {\r\n\t            var form = $(\"<form>\").attr({\r\n\t                action: proxyURL,\r\n\t                method: \"POST\",\r\n\t                target: proxyTarget\r\n\t            });\r\n\r\n\t            var data = kendo.antiForgeryTokens();\r\n\t            data.fileName = fileName;\r\n\r\n\t            var parts = dataURI.split(\";base64,\");\r\n\t            data.contentType = parts[0].replace(\"data:\", \"\");\r\n\t            data.base64 = parts[1];\r\n\r\n\t            for (var name in data) {\r\n\t                if (data.hasOwnProperty(name)) {\r\n\t                    $('<input>').attr({\r\n\t                        value: data[name],\r\n\t                        name: name,\r\n\t                        type: \"hidden\"\r\n\t                    }).appendTo(form);\r\n\t                }\r\n\t            }\r\n\r\n\t            form.appendTo(\"body\").submit().remove();\r\n\t        }\r\n\r\n\t        var fileSaver = document.createElement(\"a\");\r\n\t        var downloadAttribute = \"download\" in fileSaver && !kendo.support.browser.edge;\r\n\r\n\t        function saveAsBlob(dataURI, fileName) {\r\n\t            var blob = dataURI; // could be a Blob object\r\n\r\n\t            if (typeof dataURI == \"string\") {\r\n\t                var parts = dataURI.split(\";base64,\");\r\n\t                var contentType = parts[0];\r\n\t                var base64 = atob(parts[1]);\r\n\t                var array = new Uint8Array(base64.length);\r\n\r\n\t                for (var idx = 0; idx < base64.length; idx++) {\r\n\t                    array[idx] = base64.charCodeAt(idx);\r\n\t                }\r\n\t                blob = new Blob([array.buffer], { type: contentType });\r\n\t            }\r\n\r\n\t            navigator.msSaveBlob(blob, fileName);\r\n\t        }\r\n\r\n\t        function saveAsDataURI(dataURI, fileName) {\r\n\t            if (window.Blob && dataURI instanceof Blob) {\r\n\t                dataURI = URL.createObjectURL(dataURI);\r\n\t            }\r\n\r\n\t            fileSaver.download = fileName;\r\n\t            fileSaver.href = dataURI;\r\n\r\n\t            var e = document.createEvent(\"MouseEvents\");\r\n\t            e.initMouseEvent(\"click\", true, false, window,\r\n\t                0, 0, 0, 0, 0, false, false, false, false, 0, null);\r\n\r\n\t            fileSaver.dispatchEvent(e);\r\n\t            setTimeout(function(){\r\n\t                URL.revokeObjectURL(dataURI);\r\n\t            });\r\n\t        }\r\n\r\n\t        kendo.saveAs = function(options) {\r\n\t            var save = postToProxy;\r\n\r\n\t            if (!options.forceProxy) {\r\n\t                if (downloadAttribute) {\r\n\t                    save = saveAsDataURI;\r\n\t                } else if (navigator.msSaveBlob) {\r\n\t                    save = saveAsBlob;\r\n\t                }\r\n\t            }\r\n\r\n\t            save(options.dataURI, options.fileName, options.proxyURL, options.proxyTarget);\r\n\t        };\r\n\t    })();\r\n\r\n\t    // kendo proxySetters\r\n\t    kendo.proxyModelSetters = function proxyModelSetters(data) {\r\n\t        var observable = {};\r\n\r\n\t        Object.keys(data || {}).forEach(function(property) {\r\n\t          Object.defineProperty(observable, property, {\r\n\t            get: function() {\r\n\t              return data[property];\r\n\t            },\r\n\t            set: function(value) {\r\n\t              data[property] = value;\r\n\t              data.dirty = true;\r\n\t            }\r\n\t          });\r\n\t        });\r\n\r\n\t        return observable;\r\n\t    };\r\n\r\n\t})(jQuery, window);\r\n\r\n\treturn window.kendo;\r\n\r\n\t}, __webpack_require__(3));\r\n\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(992)))\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.core.js\n// module id = 24\n// module chunks = 3","/*!\n * jQuery JavaScript Library v3.3.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2018-01-20T17:24Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif ( typeof module === \"object\" && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar document = window.document;\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar concat = arr.concat;\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n      // We don't want to classify *any* DOM node as a function.\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, doc, node ) {\n\t\tdoc = doc || document;\n\n\t\tvar i,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\t\t\t\tif ( node[ i ] ) {\n\t\t\t\t\tscript[ i ] = node[ i ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.3.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t},\n\n\t// Support: Android <=4.0 only\n\t// Make sure we trim BOM and NBSP\n\trtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && Array.isArray( src ) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject( src ) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\n\t\t/* eslint-disable no-unused-vars */\n\t\t// See https://github.com/eslint/eslint/issues/6125\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a global context\n\tglobalEval: function( code ) {\n\t\tDOMEval( code );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// Support: Android <=4.0 only\n\ttrim: function( text ) {\n\t\treturn text == null ?\n\t\t\t\"\" :\n\t\t\t( text + \"\" ).replace( rtrim, \"\" );\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn concat.apply( [], ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.3\n * https://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2016-08-08\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\0-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tdisabledAncestor = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && (\"form\" in elem || \"label\" in elem);\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = \"#\" + nid + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement(\"fieldset\");\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\t\tdisabledAncestor( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( preferredDoc !== document &&\n\t\t(subWindow = document.defaultView) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( el ) {\n\t\tel.appendChild( document.createComment(\"\") );\n\t\treturn !el.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( (elem = elems[i++]) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode(\"id\");\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( el ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll(\":enabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll(\":disabled\").length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( el ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn (sel + \"\").replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( (oldCache = uniqueCache[ key ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( el ) {\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement(\"fieldset\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( el ) {\n\treturn el.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\nreturn Sizzle;\n\n})( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n        if ( nodeName( elem, \"iframe\" ) ) {\n            return elem.contentDocument;\n        }\n\n        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n        // Treat the template element as a regular one in browsers that\n        // don't support it.\n        if ( nodeName( elem, \"template\" ) ) {\n            elem = elem.content || elem;\n        }\n\n        return jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tjQuery.contains( elem.ownerDocument, elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\nvar swap = function( elem, options, callback, args ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.apply( elem, args || [] );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]+)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// Support: IE <=9 only\n\toption: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\n// Support: IE <=9 only\nwrapMap.optgroup = wrapMap.option;\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, contains, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcontains = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( contains ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n} )();\nvar documentElement = document.documentElement;\n\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 only\n// See #13393 for more info\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Don't attach events to noData or text/comment nodes (but allow plain objects)\n\t\tif ( !elemData ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = {};\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\t// Make a writable jQuery.Event from the native event object\n\t\tvar event = jQuery.event.fix( nativeEvent );\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\t\t\thandlers = ( dataPriv.get( this, \"events\" ) || {} )[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// Triggered event must either 1) have no namespace, or 2) have namespace(s)\n\t\t\t\t// a subset or equal to those in the bound event (both can have no namespace).\n\t\t\t\tif ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tfocus: {\n\n\t\t\t// Fire native event if possible so blur/focus sequence is correct\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this !== safeActiveElement() && this.focus ) {\n\t\t\t\t\tthis.focus();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusin\"\n\t\t},\n\t\tblur: {\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this === safeActiveElement() && this.blur ) {\n\t\t\t\t\tthis.blur();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelegateType: \"focusout\"\n\t\t},\n\t\tclick: {\n\n\t\t\t// For checkbox, fire native event so checked state will be right\n\t\t\ttrigger: function() {\n\t\t\t\tif ( this.type === \"checkbox\" && this.click && nodeName( this, \"input\" ) ) {\n\t\t\t\t\tthis.click();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, don't fire native .click() on links\n\t\t\t_default: function( event ) {\n\t\t\t\treturn nodeName( event.target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t/* eslint-disable max-len */\n\n\t// See https://github.com/eslint/eslint/issues/3229\n\trxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)[^>]*)\\/>/gi,\n\n\t/* eslint-enable */\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.access( src );\n\t\tpdataCur = dataPriv.set( dest, pdataOld );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdelete pdataCur.handle;\n\t\t\tpdataCur.events = {};\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = concat.apply( [], args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), doc, node );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && jQuery.contains( node.ownerDocument, node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html.replace( rxhtmlTag, \"<$1></$2>\" );\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = jQuery.contains( elem.ownerDocument, elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = div.offsetWidth === 36 || \"absolute\";\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t},\n\n\tcssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style;\n\n// Return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( name ) {\n\n\t// Shortcut for names that are not vendor prefixed\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a property mapped along what jQuery.cssProps suggests or to\n// a vendor prefixed property.\nfunction finalPropName( name ) {\n\tvar ret = jQuery.cssProps[ name ];\n\tif ( !ret ) {\n\t\tret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;\n\t}\n\treturn ret;\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\t\t) );\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\t\tval = curCSS( elem, dimension, styles ),\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox;\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\t// Check for style in case a browser which returns unreliable values\n\t// for getComputedStyle silently falls back to the reliable elem.style\n\tvalueIsBorderBox = valueIsBorderBox &&\n\t\t( support.boxSizingReliable() || val === elem.style[ dimension ] );\n\n\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t// This happens for inline elements with no explicit setting (gh-3571)\n\t// Support: Android <=4.1 - 4.3 only\n\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\tif ( val === \"auto\" ||\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) {\n\n\t\tval = elem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];\n\n\t\t// offsetWidth/offsetHeight provide border-box values\n\t\tvalueIsBorderBox = true;\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\tif ( type === \"number\" ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\t\t\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra && boxModelAdjustment(\n\t\t\t\t\telem,\n\t\t\t\t\tdimension,\n\t\t\t\t\textra,\n\t\t\t\t\tisBorderBox,\n\t\t\t\t\tstyles\n\t\t\t\t);\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && support.scrollboxSize() === styles.position ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 &&\n\t\t\t\t( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue && type !== false ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = ( dataPriv.get( cur, \"events\" ) || {} )[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = Date.now();\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce++ ) + uncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\n\njQuery._evalUrl = function( url ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\t\t\"throws\": true\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain requests\n\tif ( s.crossDomain ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" ).prop( {\n\t\t\t\t\tcharset: s.scriptCharset,\n\t\t\t\t\tsrc: s.url\n\t\t\t\t} ).on(\n\t\t\t\t\t\"load error\",\n\t\t\t\t\tcallback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( i, name ) {\n\n\t// Handle event binding\n\tjQuery.fn[ name ] = function( data, fn ) {\n\t\treturn arguments.length > 0 ?\n\t\t\tthis.on( name, null, data, fn ) :\n\t\t\tthis.trigger( name );\n\t};\n} );\n\njQuery.fn.extend( {\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t}\n} );\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( \"jquery\", [], function() {\n\t\treturn jQuery;\n\t} );\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( !noGlobal ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jquery/dist/jquery.js\n// module id = 463\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1027);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 993:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo.core\");\n\n/***/ }),\n\n/***/ 1027:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(993), __webpack_require__(1028), __webpack_require__(1029) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"data\",\r\n\t    name: \"Data source\",\r\n\t    category: \"framework\",\r\n\t    description: \"Powerful component for using local and remote data.Fully supports CRUD, Sorting, Paging, Filtering, Grouping, and Aggregates.\",\r\n\t    depends: [ \"core\" ],\r\n\t    features: [ {\r\n\t        id: \"data-odata\",\r\n\t        name: \"OData\",\r\n\t        description: \"Support for accessing Open Data Protocol (OData) services.\",\r\n\t        depends: [ \"data.odata\" ]\r\n\t    }, {\r\n\t        id: \"data-signalr\",\r\n\t        name: \"SignalR\",\r\n\t        description: \"Support for binding to SignalR hubs.\",\r\n\t        depends: [ \"data.signalr\" ]\r\n\t    }, {\r\n\t        id: \"data-XML\",\r\n\t        name: \"XML\",\r\n\t        description: \"Support for binding to XML.\",\r\n\t        depends: [ \"data.xml\" ]\r\n\t    }]\r\n\t};\r\n\r\n\t/*jshint eqnull: true, loopfunc: true, evil: true */\r\n\t(function($, undefined) {\r\n\t    var extend = $.extend,\r\n\t        proxy = $.proxy,\r\n\t        isPlainObject = $.isPlainObject,\r\n\t        isEmptyObject = $.isEmptyObject,\r\n\t        isArray = $.isArray,\r\n\t        grep = $.grep,\r\n\t        ajax = $.ajax,\r\n\t        map,\r\n\t        each = $.each,\r\n\t        noop = $.noop,\r\n\t        kendo = window.kendo,\r\n\t        isFunction = kendo.isFunction,\r\n\t        Observable = kendo.Observable,\r\n\t        Class = kendo.Class,\r\n\t        STRING = \"string\",\r\n\t        FUNCTION = \"function\",\r\n\t        CREATE = \"create\",\r\n\t        READ = \"read\",\r\n\t        UPDATE = \"update\",\r\n\t        DESTROY = \"destroy\",\r\n\t        CHANGE = \"change\",\r\n\t        SYNC = \"sync\",\r\n\t        GET = \"get\",\r\n\t        ERROR = \"error\",\r\n\t        REQUESTSTART = \"requestStart\",\r\n\t        PROGRESS = \"progress\",\r\n\t        REQUESTEND = \"requestEnd\",\r\n\t        crud = [CREATE, READ, UPDATE, DESTROY],\r\n\t        identity = function(o) { return o; },\r\n\t        getter = kendo.getter,\r\n\t        stringify = kendo.stringify,\r\n\t        math = Math,\r\n\t        push = [].push,\r\n\t        join = [].join,\r\n\t        pop = [].pop,\r\n\t        splice = [].splice,\r\n\t        shift = [].shift,\r\n\t        slice = [].slice,\r\n\t        unshift = [].unshift,\r\n\t        toString = {}.toString,\r\n\t        stableSort = kendo.support.stableSort,\r\n\t        dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\r\n\r\n\t    var ObservableArray = Observable.extend({\r\n\t        init: function(array, type) {\r\n\t            var that = this;\r\n\r\n\t            that.type = type || ObservableObject;\r\n\r\n\t            Observable.fn.init.call(that);\r\n\r\n\t            that.length = array.length;\r\n\r\n\t            that.wrapAll(array, that);\r\n\t        },\r\n\r\n\t        at: function(index) {\r\n\t            return this[index];\r\n\t        },\r\n\r\n\t        toJSON: function() {\r\n\t            var idx, length = this.length, value, json = new Array(length);\r\n\r\n\t            for (idx = 0; idx < length; idx++){\r\n\t                value = this[idx];\r\n\r\n\t                if (value instanceof ObservableObject) {\r\n\t                    value = value.toJSON();\r\n\t                }\r\n\r\n\t                json[idx] = value;\r\n\t            }\r\n\r\n\t            return json;\r\n\t        },\r\n\r\n\t        parent: noop,\r\n\r\n\t        wrapAll: function(source, target) {\r\n\t            var that = this,\r\n\t                idx,\r\n\t                length,\r\n\t                parent = function() {\r\n\t                    return that;\r\n\t                };\r\n\r\n\t            target = target || [];\r\n\r\n\t            for (idx = 0, length = source.length; idx < length; idx++) {\r\n\t                target[idx] = that.wrap(source[idx], parent);\r\n\t            }\r\n\r\n\t            return target;\r\n\t        },\r\n\r\n\t        wrap: function(object, parent) {\r\n\t            var that = this,\r\n\t                observable;\r\n\r\n\t            if (object !== null && toString.call(object) === \"[object Object]\") {\r\n\t                observable = object instanceof that.type || object instanceof Model;\r\n\r\n\t                if (!observable) {\r\n\t                    object = object instanceof ObservableObject ? object.toJSON() : object;\r\n\t                    object = new that.type(object);\r\n\t                }\r\n\r\n\t                object.parent = parent;\r\n\r\n\t                object.bind(CHANGE, function(e) {\r\n\t                    that.trigger(CHANGE, {\r\n\t                        field: e.field,\r\n\t                        node: e.node,\r\n\t                        index: e.index,\r\n\t                        items: e.items || [this],\r\n\t                        action: e.node ? (e.action || \"itemloaded\") : \"itemchange\"\r\n\t                    });\r\n\t                });\r\n\t            }\r\n\r\n\t            return object;\r\n\t        },\r\n\r\n\t        push: function() {\r\n\t            var index = this.length,\r\n\t                items = this.wrapAll(arguments),\r\n\t                result;\r\n\r\n\t            result = push.apply(this, items);\r\n\r\n\t            this.trigger(CHANGE, {\r\n\t                action: \"add\",\r\n\t                index: index,\r\n\t                items: items\r\n\t            });\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        slice: slice,\r\n\r\n\t        sort: [].sort,\r\n\r\n\t        join: join,\r\n\r\n\t        pop: function() {\r\n\t            var length = this.length, result = pop.apply(this);\r\n\r\n\t            if (length) {\r\n\t                this.trigger(CHANGE, {\r\n\t                    action: \"remove\",\r\n\t                    index: length - 1,\r\n\t                    items:[result]\r\n\t                });\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        splice: function(index, howMany, item) {\r\n\t            var items = this.wrapAll(slice.call(arguments, 2)),\r\n\t                result, i, len;\r\n\r\n\t            result = splice.apply(this, [index, howMany].concat(items));\r\n\r\n\t            if (result.length) {\r\n\t                this.trigger(CHANGE, {\r\n\t                    action: \"remove\",\r\n\t                    index: index,\r\n\t                    items: result\r\n\t                });\r\n\r\n\t                for (i = 0, len = result.length; i < len; i++) {\r\n\t                    if (result[i] && result[i].children) {\r\n\t                        result[i].unbind(CHANGE);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            if (item) {\r\n\t                this.trigger(CHANGE, {\r\n\t                    action: \"add\",\r\n\t                    index: index,\r\n\t                    items: items\r\n\t                });\r\n\t            }\r\n\t            return result;\r\n\t        },\r\n\r\n\t        shift: function() {\r\n\t            var length = this.length, result = shift.apply(this);\r\n\r\n\t            if (length) {\r\n\t                this.trigger(CHANGE, {\r\n\t                    action: \"remove\",\r\n\t                    index: 0,\r\n\t                    items:[result]\r\n\t                });\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        unshift: function() {\r\n\t            var items = this.wrapAll(arguments),\r\n\t                result;\r\n\r\n\t            result = unshift.apply(this, items);\r\n\r\n\t            this.trigger(CHANGE, {\r\n\t                action: \"add\",\r\n\t                index: 0,\r\n\t                items: items\r\n\t            });\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        indexOf: function(item) {\r\n\t            var that = this,\r\n\t                idx,\r\n\t                length;\r\n\r\n\t            for (idx = 0, length = that.length; idx < length; idx++) {\r\n\t                if (that[idx] === item) {\r\n\t                    return idx;\r\n\t                }\r\n\t            }\r\n\t            return -1;\r\n\t        },\r\n\r\n\t        forEach: function(callback) {\r\n\t            var idx = 0,\r\n\t                length = this.length;\r\n\r\n\t            for (; idx < length; idx++) {\r\n\t                callback(this[idx], idx, this);\r\n\t            }\r\n\t        },\r\n\r\n\t        map: function(callback) {\r\n\t            var idx = 0,\r\n\t                result = [],\r\n\t                length = this.length;\r\n\r\n\t            for (; idx < length; idx++) {\r\n\t                result[idx] = callback(this[idx], idx, this);\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        reduce: function(callback) {\r\n\t            var idx = 0,\r\n\t                result,\r\n\t                length = this.length;\r\n\r\n\t            if (arguments.length == 2) {\r\n\t                result = arguments[1];\r\n\t            } else if (idx < length) {\r\n\t                result = this[idx++];\r\n\t            }\r\n\r\n\t            for (; idx < length; idx++) {\r\n\t                result = callback(result, this[idx], idx, this);\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        reduceRight: function(callback) {\r\n\t            var idx = this.length - 1,\r\n\t                result;\r\n\r\n\t            if (arguments.length == 2) {\r\n\t                result = arguments[1];\r\n\t            } else if (idx > 0) {\r\n\t                result = this[idx--];\r\n\t            }\r\n\r\n\t            for (; idx >= 0; idx--) {\r\n\t                result = callback(result, this[idx], idx, this);\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        filter: function(callback) {\r\n\t            var idx = 0,\r\n\t                result = [],\r\n\t                item,\r\n\t                length = this.length;\r\n\r\n\t            for (; idx < length; idx++) {\r\n\t                item = this[idx];\r\n\t                if (callback(item, idx, this)) {\r\n\t                    result[result.length] = item;\r\n\t                }\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        find: function(callback) {\r\n\t            var idx = 0,\r\n\t                item,\r\n\t                length = this.length;\r\n\r\n\t            for (; idx < length; idx++) {\r\n\t                item = this[idx];\r\n\t                if (callback(item, idx, this)) {\r\n\t                    return item;\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        every: function(callback) {\r\n\t            var idx = 0,\r\n\t                item,\r\n\t                length = this.length;\r\n\r\n\t            for (; idx < length; idx++) {\r\n\t                item = this[idx];\r\n\t                if (!callback(item, idx, this)) {\r\n\t                    return false;\r\n\t                }\r\n\t            }\r\n\r\n\t            return true;\r\n\t        },\r\n\r\n\t        some: function(callback) {\r\n\t            var idx = 0,\r\n\t                item,\r\n\t                length = this.length;\r\n\r\n\t            for (; idx < length; idx++) {\r\n\t                item = this[idx];\r\n\t                if (callback(item, idx, this)) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\r\n\t            return false;\r\n\t        },\r\n\r\n\t        // non-standard collection methods\r\n\t        remove: function(item) {\r\n\t            var idx = this.indexOf(item);\r\n\r\n\t            if (idx !== -1) {\r\n\t                this.splice(idx, 1);\r\n\t            }\r\n\t        },\r\n\r\n\t        empty: function() {\r\n\t            this.splice(0, this.length);\r\n\t        }\r\n\t    });\r\n\r\n\t    // Polyfill for Symbol.iterator\r\n\t    if (typeof Symbol !== \"undefined\" && Symbol.iterator && !ObservableArray.prototype[Symbol.iterator]) {\r\n\t        ObservableArray.prototype[Symbol.iterator] = [][Symbol.iterator];\r\n\t    }\r\n\r\n\t    var LazyObservableArray = ObservableArray.extend({\r\n\t        init: function(data, type) {\r\n\t            Observable.fn.init.call(this);\r\n\r\n\t            this.type = type || ObservableObject;\r\n\r\n\t            for (var idx = 0; idx < data.length; idx++) {\r\n\t                this[idx] = data[idx];\r\n\t            }\r\n\r\n\t            this.length = idx;\r\n\t            this._parent = proxy(function() { return this; }, this);\r\n\t        },\r\n\t        at: function(index) {\r\n\t            var item = this[index];\r\n\r\n\t            if (!(item instanceof this.type)) {\r\n\t                item = this[index] = this.wrap(item, this._parent);\r\n\t            } else {\r\n\t                item.parent = this._parent;\r\n\t            }\r\n\r\n\t            return item;\r\n\t        }\r\n\t    });\r\n\r\n\t    function eventHandler(context, type, field, prefix) {\r\n\t        return function(e) {\r\n\t            var event = {}, key;\r\n\r\n\t            for (key in e) {\r\n\t                event[key] = e[key];\r\n\t            }\r\n\r\n\t            if (prefix) {\r\n\t                event.field = field + \".\" + e.field;\r\n\t            } else {\r\n\t                event.field = field;\r\n\t            }\r\n\r\n\t            if (type == CHANGE && context._notifyChange) {\r\n\t                context._notifyChange(event);\r\n\t            }\r\n\r\n\t            context.trigger(type, event);\r\n\t        };\r\n\t    }\r\n\r\n\t    var ObservableObject = Observable.extend({\r\n\t        init: function(value) {\r\n\t            var that = this,\r\n\t                member,\r\n\t                field,\r\n\t                parent = function() {\r\n\t                    return that;\r\n\t                };\r\n\r\n\t            Observable.fn.init.call(this);\r\n\r\n\t            this._handlers = {};\r\n\r\n\t            for (field in value) {\r\n\t                member = value[field];\r\n\r\n\t                if (typeof member === \"object\" && member && !member.getTime && field.charAt(0) != \"_\") {\r\n\t                    member = that.wrap(member, field, parent);\r\n\t                }\r\n\r\n\t                that[field] = member;\r\n\t            }\r\n\r\n\t            that.uid = kendo.guid();\r\n\t        },\r\n\r\n\t        shouldSerialize: function(field) {\r\n\t            return this.hasOwnProperty(field) && field !== \"_handlers\" && field !== \"_events\" && typeof this[field] !== FUNCTION && field !== \"uid\";\r\n\t        },\r\n\r\n\t        forEach: function(f) {\r\n\t            for (var i in this) {\r\n\t                if (this.shouldSerialize(i)) {\r\n\t                    f(this[i], i);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        toJSON: function() {\r\n\t            var result = {}, value, field;\r\n\r\n\t            for (field in this) {\r\n\t                if (this.shouldSerialize(field)) {\r\n\t                    value = this[field];\r\n\r\n\t                    if (value instanceof ObservableObject || value instanceof ObservableArray) {\r\n\t                        value = value.toJSON();\r\n\t                    }\r\n\r\n\t                    result[field] = value;\r\n\t                }\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        get: function(field) {\r\n\t            var that = this, result;\r\n\r\n\t            that.trigger(GET, { field: field });\r\n\r\n\t            if (field === \"this\") {\r\n\t                result = that;\r\n\t            } else {\r\n\t                result = kendo.getter(field, true)(that);\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        _set: function(field, value) {\r\n\t            var that = this;\r\n\t            var composite = field.indexOf(\".\") >= 0;\r\n\r\n\t            if (composite) {\r\n\t                var paths = field.split(\".\"),\r\n\t                    path = \"\";\r\n\r\n\t                while (paths.length > 1) {\r\n\t                    path += paths.shift();\r\n\t                    var obj = kendo.getter(path, true)(that);\r\n\t                    if (obj instanceof ObservableObject) {\r\n\t                        obj.set(paths.join(\".\"), value);\r\n\t                        return composite;\r\n\t                    }\r\n\t                    path += \".\";\r\n\t                }\r\n\t            }\r\n\r\n\t            kendo.setter(field)(that, value);\r\n\r\n\t            return composite;\r\n\t        },\r\n\r\n\t        set: function(field, value) {\r\n\t            var that = this,\r\n\t                isSetPrevented = false,\r\n\t                composite = field.indexOf(\".\") >= 0,\r\n\t                current = kendo.getter(field, true)(that);\r\n\r\n\t            if (current !== value) {\r\n\t                if (current instanceof Observable && this._handlers[field]) {\r\n\t                    if (this._handlers[field].get) {\r\n\t                       current.unbind(GET, this._handlers[field].get);\r\n\t                    }\r\n\t                    current.unbind(CHANGE, this._handlers[field].change);\r\n\t                }\r\n\r\n\t                isSetPrevented = that.trigger(\"set\", { field: field, value: value });\r\n\r\n\t                if (!isSetPrevented) {\r\n\t                    if (!composite) {\r\n\t                        value = that.wrap(value, field, function() { return that; });\r\n\t                    }\r\n\t                    if (!that._set(field, value) || field.indexOf(\"(\") >= 0 || field.indexOf(\"[\") >= 0) {\r\n\t                        that.trigger(CHANGE, { field: field });\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            return isSetPrevented;\r\n\t        },\r\n\r\n\t        parent: noop,\r\n\r\n\t        wrap: function(object, field, parent) {\r\n\t            var that = this;\r\n\t            var get;\r\n\t            var change;\r\n\t            var type = toString.call(object);\r\n\r\n\t            if (object != null && (type === \"[object Object]\" || type === \"[object Array]\")) {\r\n\t                var isObservableArray = object instanceof ObservableArray;\r\n\t                var isDataSource = object instanceof DataSource;\r\n\r\n\t                if (type === \"[object Object]\" && !isDataSource && !isObservableArray) {\r\n\t                    if (!(object instanceof ObservableObject)) {\r\n\t                        object = new ObservableObject(object);\r\n\t                    }\r\n\r\n\t                    get = eventHandler(that, GET, field, true);\r\n\t                    object.bind(GET, get);\r\n\t                    change = eventHandler(that, CHANGE, field, true);\r\n\t                    object.bind(CHANGE, change);\r\n\r\n\t                    that._handlers[field] = { get: get, change: change };\r\n\t                } else if (type === \"[object Array]\" || isObservableArray || isDataSource) {\r\n\t                    if (!isObservableArray && !isDataSource) {\r\n\t                        object = new ObservableArray(object);\r\n\t                    }\r\n\r\n\t                    change = eventHandler(that, CHANGE, field, false);\r\n\r\n\t                    object.bind(CHANGE, change);\r\n\r\n\t                    that._handlers[field] = { change: change };\r\n\t                }\r\n\r\n\t                object.parent = parent;\r\n\t            }\r\n\r\n\t            return object;\r\n\t        }\r\n\t    });\r\n\r\n\t    function equal(x, y) {\r\n\t        if (x === y) {\r\n\t            return true;\r\n\t        }\r\n\r\n\t        var xtype = $.type(x), ytype = $.type(y), field;\r\n\r\n\t        if (xtype !== ytype) {\r\n\t            return false;\r\n\t        }\r\n\r\n\t        if (xtype === \"date\") {\r\n\t            return x.getTime() === y.getTime();\r\n\t        }\r\n\r\n\t        if (xtype !== \"object\" && xtype !== \"array\") {\r\n\t            return false;\r\n\t        }\r\n\r\n\t        for (field in x) {\r\n\t            if (!equal(x[field], y[field])) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\r\n\t        return true;\r\n\t    }\r\n\r\n\t    var parsers = {\r\n\t        \"number\": function(value) {\r\n\t            return kendo.parseFloat(value);\r\n\t        },\r\n\r\n\t        \"date\": function(value) {\r\n\t            return kendo.parseDate(value);\r\n\t        },\r\n\r\n\t        \"boolean\": function(value) {\r\n\t            if (typeof value === STRING) {\r\n\t                return value.toLowerCase() === \"true\";\r\n\t            }\r\n\t            return value != null ? !!value : value;\r\n\t        },\r\n\r\n\t        \"string\": function(value) {\r\n\t            return value != null ? (value + \"\") : value;\r\n\t        },\r\n\r\n\t        \"default\": function(value) {\r\n\t            return value;\r\n\t        }\r\n\t    };\r\n\r\n\t    var defaultValues = {\r\n\t        \"string\": \"\",\r\n\t        \"number\": 0,\r\n\t        \"date\": new Date(),\r\n\t        \"boolean\": false,\r\n\t        \"default\": \"\"\r\n\t    };\r\n\r\n\t    function getFieldByName(obj, name) {\r\n\t        var field,\r\n\t            fieldName;\r\n\r\n\t        for (fieldName in obj) {\r\n\t            field = obj[fieldName];\r\n\t            if (isPlainObject(field) && field.field && field.field === name) {\r\n\t                return field;\r\n\t            } else if (field === name) {\r\n\t                return field;\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    }\r\n\r\n\t    var Model = ObservableObject.extend({\r\n\t        init: function(data) {\r\n\t            var that = this;\r\n\r\n\t            if (!data || $.isEmptyObject(data)) {\r\n\t                data = $.extend({}, that.defaults, data);\r\n\r\n\t                if (that._initializers) {\r\n\t                    for (var idx = 0; idx < that._initializers.length; idx++) {\r\n\t                         var name = that._initializers[idx];\r\n\t                         data[name] = that.defaults[name]();\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            ObservableObject.fn.init.call(that, data);\r\n\r\n\t            that.dirty = false;\r\n\t            that.dirtyFields = {};\r\n\r\n\t            if (that.idField) {\r\n\t                that.id = that.get(that.idField);\r\n\r\n\t                if (that.id === undefined) {\r\n\t                    that.id = that._defaultId;\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        shouldSerialize: function(field) {\r\n\t            return ObservableObject.fn.shouldSerialize.call(this, field) &&\r\n\t                field !== \"uid\" && !(this.idField !== \"id\" && field === \"id\") &&\r\n\t                field !== \"dirty\" &&  field !== \"dirtyFields\" && field !== \"_accessors\";\r\n\t        },\r\n\r\n\t        _parse: function(field, value) {\r\n\t            var that = this,\r\n\t                fieldName = field,\r\n\t                fields = (that.fields || {}),\r\n\t                parse;\r\n\r\n\t            field = fields[field];\r\n\t            if (!field) {\r\n\t                field = getFieldByName(fields, fieldName);\r\n\t            }\r\n\t            if (field) {\r\n\t                parse = field.parse;\r\n\t                if (!parse && field.type) {\r\n\t                    parse = parsers[field.type.toLowerCase()];\r\n\t                }\r\n\t            }\r\n\r\n\t            return parse ? parse(value) : value;\r\n\t        },\r\n\r\n\t        _notifyChange: function(e) {\r\n\t            var action = e.action;\r\n\r\n\t            if (action == \"add\" || action == \"remove\") {\r\n\t                this.dirty = true;\r\n\t                this.dirtyFields[e.field] = true;\r\n\t            }\r\n\t        },\r\n\r\n\t        editable: function(field) {\r\n\t            field = (this.fields || {})[field];\r\n\t            return field ? field.editable !== false : true;\r\n\t        },\r\n\r\n\t        set: function(field, value, initiator) {\r\n\t            var that = this;\r\n\t            var dirty = that.dirty;\r\n\r\n\t            if (that.editable(field)) {\r\n\t                value = that._parse(field, value);\r\n\r\n\t                if (!equal(value, that.get(field))) {\r\n\t                    that.dirty = true;\r\n\t                    that.dirtyFields[field] = true;\r\n\r\n\t                    if (ObservableObject.fn.set.call(that, field, value, initiator) && !dirty) {\r\n\t                        that.dirty = dirty;\r\n\r\n\t                        if (!that.dirty) {\r\n\t                            that.dirtyFields[field] = false;\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        accept: function(data) {\r\n\t            var that = this,\r\n\t                parent = function() { return that; },\r\n\t                field;\r\n\r\n\t            for (field in data) {\r\n\t                var value = data[field];\r\n\r\n\t                if (field.charAt(0) != \"_\") {\r\n\t                    value = that.wrap(data[field], field, parent);\r\n\t                }\r\n\r\n\t                that._set(field, value);\r\n\t            }\r\n\r\n\t            if (that.idField) {\r\n\t                that.id = that.get(that.idField);\r\n\t            }\r\n\r\n\t            that.dirty = false;\r\n\t            that.dirtyFields = {};\r\n\t        },\r\n\r\n\t        isNew: function() {\r\n\t            return this.id === this._defaultId;\r\n\t        }\r\n\t    });\r\n\r\n\t    Model.define = function(base, options) {\r\n\t        if (options === undefined) {\r\n\t            options = base;\r\n\t            base = Model;\r\n\t        }\r\n\r\n\t        var model,\r\n\t            proto = extend({ defaults: {} }, options),\r\n\t            name,\r\n\t            field,\r\n\t            type,\r\n\t            value,\r\n\t            idx,\r\n\t            length,\r\n\t            fields = {},\r\n\t            originalName,\r\n\t            id = proto.id,\r\n\t            functionFields = [];\r\n\r\n\t        if (id) {\r\n\t            proto.idField = id;\r\n\t        }\r\n\r\n\t        if (proto.id) {\r\n\t            delete proto.id;\r\n\t        }\r\n\r\n\t        if (id) {\r\n\t            proto.defaults[id] = proto._defaultId = \"\";\r\n\t        }\r\n\r\n\t        if (toString.call(proto.fields) === \"[object Array]\") {\r\n\t            for (idx = 0, length = proto.fields.length; idx < length; idx++) {\r\n\t                field = proto.fields[idx];\r\n\t                if (typeof field === STRING) {\r\n\t                    fields[field] = {};\r\n\t                } else if (field.field) {\r\n\t                    fields[field.field] = field;\r\n\t                }\r\n\t            }\r\n\t            proto.fields = fields;\r\n\t        }\r\n\r\n\t        for (name in proto.fields) {\r\n\t            field = proto.fields[name];\r\n\t            type = field.type || \"default\";\r\n\t            value = null;\r\n\t            originalName = name;\r\n\r\n\t            name = typeof (field.field) === STRING ? field.field : name;\r\n\r\n\t            if (!field.nullable) {\r\n\t                value = proto.defaults[originalName !== name ? originalName : name] = field.defaultValue !== undefined ? field.defaultValue : defaultValues[type.toLowerCase()];\r\n\r\n\t                if (typeof value === \"function\") {\r\n\t                    functionFields.push(name);\r\n\t                }\r\n\t            }\r\n\r\n\t            if (options.id === name) {\r\n\t                proto._defaultId = value;\r\n\t            }\r\n\r\n\t            proto.defaults[originalName !== name ? originalName : name] = value;\r\n\r\n\t            field.parse = field.parse || parsers[type];\r\n\t        }\r\n\r\n\t        if (functionFields.length > 0) {\r\n\t            proto._initializers = functionFields;\r\n\t        }\r\n\r\n\t        model = base.extend(proto);\r\n\t        model.define = function(options) {\r\n\t            return Model.define(model, options);\r\n\t        };\r\n\r\n\t        if (proto.fields) {\r\n\t            model.fields = proto.fields;\r\n\t            model.idField = proto.idField;\r\n\t        }\r\n\r\n\t        return model;\r\n\t    };\r\n\r\n\t    var Comparer = {\r\n\t        selector: function(field) {\r\n\t            return isFunction(field) ? field : getter(field);\r\n\t        },\r\n\r\n\t        compare: function(field) {\r\n\t            var selector = this.selector(field);\r\n\t            return function (a, b) {\r\n\t                a = selector(a);\r\n\t                b = selector(b);\r\n\r\n\t                if (a == null && b == null) {\r\n\t                    return 0;\r\n\t                }\r\n\r\n\t                if (a == null) {\r\n\t                    return -1;\r\n\t                }\r\n\r\n\t                if (b == null) {\r\n\t                    return 1;\r\n\t                }\r\n\r\n\t                if (a.localeCompare) {\r\n\t                    return a.localeCompare(b);\r\n\t                }\r\n\r\n\t                return a > b ? 1 : (a < b ? -1 : 0);\r\n\t            };\r\n\t        },\r\n\r\n\t        create: function(sort) {\r\n\t            var compare = sort.compare || this.compare(sort.field);\r\n\r\n\t            if (sort.dir == \"desc\") {\r\n\t                return function(a, b) {\r\n\t                    return compare(b, a, true);\r\n\t                };\r\n\t            }\r\n\r\n\t            return compare;\r\n\t        },\r\n\r\n\t        combine: function(comparers) {\r\n\t            return function(a, b) {\r\n\t                var result = comparers[0](a, b),\r\n\t                    idx,\r\n\t                    length;\r\n\r\n\t                for (idx = 1, length = comparers.length; idx < length; idx ++) {\r\n\t                    result = result || comparers[idx](a, b);\r\n\t                }\r\n\r\n\t                return result;\r\n\t            };\r\n\t        }\r\n\t    };\r\n\r\n\t    var StableComparer = extend({}, Comparer, {\r\n\t        asc: function(field) {\r\n\t            var selector = this.selector(field);\r\n\t            return function (a, b) {\r\n\t                var valueA = selector(a);\r\n\t                var valueB = selector(b);\r\n\r\n\t                if (valueA && valueA.getTime && valueB && valueB.getTime) {\r\n\t                    valueA = valueA.getTime();\r\n\t                    valueB = valueB.getTime();\r\n\t                }\r\n\r\n\t                if (valueA === valueB) {\r\n\t                    return a.__position - b.__position;\r\n\t                }\r\n\r\n\t                if (valueA == null) {\r\n\t                    return -1;\r\n\t                }\r\n\r\n\t                if (valueB == null) {\r\n\t                    return 1;\r\n\t                }\r\n\r\n\t                if (valueA.localeCompare) {\r\n\t                    return valueA.localeCompare(valueB);\r\n\t                }\r\n\r\n\t                return valueA > valueB ? 1 : -1;\r\n\t            };\r\n\t        },\r\n\r\n\t        desc: function(field) {\r\n\t            var selector = this.selector(field);\r\n\t            return function (a, b) {\r\n\t                var valueA = selector(a);\r\n\t                var valueB = selector(b);\r\n\r\n\t                if (valueA && valueA.getTime && valueB && valueB.getTime) {\r\n\t                    valueA = valueA.getTime();\r\n\t                    valueB = valueB.getTime();\r\n\t                }\r\n\r\n\t                if (valueA === valueB) {\r\n\t                    return a.__position - b.__position;\r\n\t                }\r\n\r\n\t                if (valueA == null) {\r\n\t                    return 1;\r\n\t                }\r\n\r\n\t                if (valueB == null) {\r\n\t                    return -1;\r\n\t                }\r\n\r\n\t                if (valueB.localeCompare) {\r\n\t                    return valueB.localeCompare(valueA);\r\n\t                }\r\n\r\n\t                return valueA < valueB ? 1 : -1;\r\n\t            };\r\n\t        },\r\n\t        create: function(sort) {\r\n\t           return this[sort.dir](sort.field);\r\n\t        }\r\n\t    });\r\n\r\n\t    map = function (array, callback) {\r\n\t        var idx, length = array.length, result = new Array(length);\r\n\r\n\t        for (idx = 0; idx < length; idx++) {\r\n\t            result[idx] = callback(array[idx], idx, array);\r\n\t        }\r\n\r\n\t        return result;\r\n\t    };\r\n\r\n\t    var operators = (function(){\r\n\r\n\t        function quote(str) {\r\n\t            if (typeof str == \"string\") {\r\n\t                str = str.replace(/[\\r\\n]+/g, \"\");\r\n\t            }\r\n\t            return JSON.stringify(str);\r\n\t        }\r\n\r\n\t        function textOp(impl) {\r\n\t            return function(a, b, ignore) {\r\n\t                b += \"\";\r\n\t                if (ignore) {\r\n\t                    a = \"(\" + a + \" || '').toLowerCase()\";\r\n\t                    b = b.toLowerCase();\r\n\t                }\r\n\t                return impl(a, quote(b), ignore);\r\n\t            };\r\n\t        }\r\n\r\n\t        function operator(op, a, b, ignore) {\r\n\t            if (b != null) {\r\n\t                if (typeof b === STRING) {\r\n\t                    var date = dateRegExp.exec(b);\r\n\t                    if (date) {\r\n\t                        b = new Date(+date[1]);\r\n\t                    } else if (ignore) {\r\n\t                        b = quote(b.toLowerCase());\r\n\t                        a = \"((\" + a + \" || '')+'').toLowerCase()\";\r\n\t                    } else {\r\n\t                        b = quote(b);\r\n\t                    }\r\n\t                }\r\n\r\n\t                if (b.getTime) {\r\n\t                    //b looks like a Date\r\n\t                    a = \"(\" + a + \"&&\" + a + \".getTime?\" + a + \".getTime():\" + a + \")\";\r\n\t                    b = b.getTime();\r\n\t                }\r\n\t            }\r\n\r\n\t            return a + \" \" + op + \" \" + b;\r\n\t        }\r\n\r\n\t        function getMatchRegexp(pattern) {\r\n\t            // take a pattern, as supported by Excel match filter, and\r\n\t            // convert it to the equivalent JS regular expression.\r\n\t            // Excel patterns support:\r\n\t            //\r\n\t            //   * - match any sequence of characters\r\n\t            //   ? - match a single character\r\n\t            //\r\n\t            // to match a literal * or ?, they must be prefixed by a tilde (~)\r\n\t            for (var rx = \"/^\", esc = false, i = 0; i < pattern.length; ++i) {\r\n\t                var ch = pattern.charAt(i);\r\n\t                if (esc) {\r\n\t                    rx += \"\\\\\" + ch;\r\n\t                } else if (ch == \"~\") {\r\n\t                    esc = true;\r\n\t                    continue;\r\n\t                } else if (ch == \"*\") {\r\n\t                    rx += \".*\";\r\n\t                } else if (ch == \"?\") {\r\n\t                    rx += \".\";\r\n\t                } else if (\".+^$()[]{}|\\\\/\\n\\r\\u2028\\u2029\\xA0\".indexOf(ch) >= 0) {\r\n\t                    rx += \"\\\\\" + ch;\r\n\t                } else {\r\n\t                    rx += ch;\r\n\t                }\r\n\t                esc = false;\r\n\t            }\r\n\t            return rx + \"$/\";\r\n\t        }\r\n\r\n\t        return {\r\n\t            quote: function(value) {\r\n\t                if (value && value.getTime) {\r\n\t                    return \"new Date(\" + value.getTime() + \")\";\r\n\t                }\r\n\t                return quote(value);\r\n\t            },\r\n\t            eq: function(a, b, ignore) {\r\n\t                return operator(\"==\", a, b, ignore);\r\n\t            },\r\n\t            neq: function(a, b, ignore) {\r\n\t                return operator(\"!=\", a, b, ignore);\r\n\t            },\r\n\t            gt: function(a, b, ignore) {\r\n\t                return operator(\">\", a, b, ignore);\r\n\t            },\r\n\t            gte: function(a, b, ignore) {\r\n\t                return operator(\">=\", a, b, ignore);\r\n\t            },\r\n\t            lt: function(a, b, ignore) {\r\n\t                return operator(\"<\", a, b, ignore);\r\n\t            },\r\n\t            lte: function(a, b, ignore) {\r\n\t                return operator(\"<=\", a, b, ignore);\r\n\t            },\r\n\t            startswith: textOp(function(a, b) {\r\n\t                return a + \".lastIndexOf(\" + b + \", 0) == 0\";\r\n\t            }),\r\n\t            doesnotstartwith: textOp(function(a, b) {\r\n\t                return a + \".lastIndexOf(\" + b + \", 0) == -1\";\r\n\t            }),\r\n\t            endswith: textOp(function(a, b) {\r\n\t                var n = b ? b.length - 2 : 0;\r\n\t                return a + \".indexOf(\" + b + \", \" + a + \".length - \" + n + \") >= 0\";\r\n\t            }),\r\n\t            doesnotendwith: textOp(function(a, b) {\r\n\t                var n = b ? b.length - 2 : 0;\r\n\t                return a + \".indexOf(\" + b + \", \" + a + \".length - \" + n + \") < 0\";\r\n\t            }),\r\n\t            contains: textOp(function(a, b) {\r\n\t                return a + \".indexOf(\" + b + \") >= 0\";\r\n\t            }),\r\n\t            doesnotcontain: textOp(function(a, b) {\r\n\t                return a + \".indexOf(\" + b + \") == -1\";\r\n\t            }),\r\n\t            matches: textOp(function(a, b){\r\n\t                b = b.substring(1, b.length - 1);\r\n\t                return getMatchRegexp(b) + \".test(\" + a + \")\";\r\n\t            }),\r\n\t            doesnotmatch: textOp(function(a, b){\r\n\t                b = b.substring(1, b.length - 1);\r\n\t                return \"!\" + getMatchRegexp(b) + \".test(\" + a + \")\";\r\n\t            }),\r\n\t            isempty: function(a) {\r\n\t                return a + \" === ''\";\r\n\t            },\r\n\t            isnotempty: function(a) {\r\n\t                return a + \" !== ''\";\r\n\t            },\r\n\t            isnull: function(a) {\r\n\t                return \"(\" + a + \" == null)\";\r\n\t            },\r\n\t            isnotnull: function(a) {\r\n\t                return \"(\" + a + \" != null)\";\r\n\t            }\r\n\t        };\r\n\t    })();\r\n\r\n\t    function Query(data) {\r\n\t        this.data = data || [];\r\n\t    }\r\n\r\n\t    Query.filterExpr = function(expression) {\r\n\t        var expressions = [],\r\n\t            logic = { and: \" && \", or: \" || \" },\r\n\t            idx,\r\n\t            length,\r\n\t            filter,\r\n\t            expr,\r\n\t            fieldFunctions = [],\r\n\t            operatorFunctions = [],\r\n\t            field,\r\n\t            operator,\r\n\t            filters = expression.filters;\r\n\r\n\t        for (idx = 0, length = filters.length; idx < length; idx++) {\r\n\t            filter = filters[idx];\r\n\t            field = filter.field;\r\n\t            operator = filter.operator;\r\n\r\n\t            if (filter.filters) {\r\n\t                expr = Query.filterExpr(filter);\r\n\t                //Nested function fields or operators - update their index e.g. __o[0] -> __o[1]\r\n\t                filter = expr.expression\r\n\t                .replace(/__o\\[(\\d+)\\]/g, function(match, index) {\r\n\t                    index = +index;\r\n\t                    return \"__o[\" + (operatorFunctions.length + index) + \"]\";\r\n\t                })\r\n\t                .replace(/__f\\[(\\d+)\\]/g, function(match, index) {\r\n\t                    index = +index;\r\n\t                    return \"__f[\" + (fieldFunctions.length + index) + \"]\";\r\n\t                });\r\n\r\n\t                operatorFunctions.push.apply(operatorFunctions, expr.operators);\r\n\t                fieldFunctions.push.apply(fieldFunctions, expr.fields);\r\n\t            } else {\r\n\t                if (typeof field === FUNCTION) {\r\n\t                    expr = \"__f[\" + fieldFunctions.length +\"](d)\";\r\n\t                    fieldFunctions.push(field);\r\n\t                } else {\r\n\t                    expr = kendo.expr(field);\r\n\t                }\r\n\r\n\t                if (typeof operator === FUNCTION) {\r\n\t                    filter = \"__o[\" + operatorFunctions.length + \"](\" + expr + \", \" + operators.quote(filter.value) + \")\";\r\n\t                    operatorFunctions.push(operator);\r\n\t                } else {\r\n\t                    filter = operators[(operator || \"eq\").toLowerCase()](expr, filter.value, filter.ignoreCase !== undefined? filter.ignoreCase : true);\r\n\t                }\r\n\t            }\r\n\r\n\t            expressions.push(filter);\r\n\t        }\r\n\r\n\t        return  { expression: \"(\" + expressions.join(logic[expression.logic]) + \")\", fields: fieldFunctions, operators: operatorFunctions };\r\n\t    };\r\n\r\n\t    function normalizeSort(field, dir) {\r\n\t        if (field) {\r\n\t            var descriptor = typeof field === STRING ? { field: field, dir: dir } : field,\r\n\t            descriptors = isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);\r\n\r\n\t            return grep(descriptors, function(d) { return !!d.dir; });\r\n\t        }\r\n\t    }\r\n\r\n\t    var operatorMap = {\r\n\t        \"==\": \"eq\",\r\n\t        equals: \"eq\",\r\n\t        isequalto: \"eq\",\r\n\t        equalto: \"eq\",\r\n\t        equal: \"eq\",\r\n\t        \"!=\": \"neq\",\r\n\t        ne: \"neq\",\r\n\t        notequals: \"neq\",\r\n\t        isnotequalto: \"neq\",\r\n\t        notequalto: \"neq\",\r\n\t        notequal: \"neq\",\r\n\t        \"<\": \"lt\",\r\n\t        islessthan: \"lt\",\r\n\t        lessthan: \"lt\",\r\n\t        less: \"lt\",\r\n\t        \"<=\": \"lte\",\r\n\t        le: \"lte\",\r\n\t        islessthanorequalto: \"lte\",\r\n\t        lessthanequal: \"lte\",\r\n\t        \">\": \"gt\",\r\n\t        isgreaterthan: \"gt\",\r\n\t        greaterthan: \"gt\",\r\n\t        greater: \"gt\",\r\n\t        \">=\": \"gte\",\r\n\t        isgreaterthanorequalto: \"gte\",\r\n\t        greaterthanequal: \"gte\",\r\n\t        ge: \"gte\",\r\n\t        notsubstringof: \"doesnotcontain\",\r\n\t        isnull: \"isnull\",\r\n\t        isempty: \"isempty\",\r\n\t        isnotempty: \"isnotempty\"\r\n\t    };\r\n\r\n\t    function normalizeOperator(expression) {\r\n\t        var idx,\r\n\t        length,\r\n\t        filter,\r\n\t        operator,\r\n\t        filters = expression.filters;\r\n\r\n\t        if (filters) {\r\n\t            for (idx = 0, length = filters.length; idx < length; idx++) {\r\n\t                filter = filters[idx];\r\n\t                operator = filter.operator;\r\n\r\n\t                if (operator && typeof operator === STRING) {\r\n\t                    filter.operator = operatorMap[operator.toLowerCase()] || operator;\r\n\t                }\r\n\r\n\t                normalizeOperator(filter);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function normalizeFilter(expression) {\r\n\t        if (expression && !isEmptyObject(expression)) {\r\n\t            if (isArray(expression) || !expression.filters) {\r\n\t                expression = {\r\n\t                    logic: \"and\",\r\n\t                    filters: isArray(expression) ? expression : [expression]\r\n\t                };\r\n\t            }\r\n\r\n\t            normalizeOperator(expression);\r\n\r\n\t            return expression;\r\n\t        }\r\n\t    }\r\n\r\n\t    Query.normalizeFilter = normalizeFilter;\r\n\r\n\t    function compareDescriptor(f1, f2) {\r\n\t        if (f1.logic || f2.logic) {\r\n\t            return false;\r\n\t        }\r\n\r\n\t        return f1.field === f2.field && f1.value === f2.value && f1.operator === f2.operator;\r\n\t    }\r\n\r\n\t    function normalizeDescriptor(filter) {\r\n\t        filter = filter || {};\r\n\r\n\t        if (isEmptyObject(filter)) {\r\n\t            return { logic: \"and\", filters: [] };\r\n\t        }\r\n\r\n\t        return normalizeFilter(filter);\r\n\t    }\r\n\r\n\t    function fieldComparer(a, b) {\r\n\t        if (b.logic || (a.field > b.field)) {\r\n\t            return 1;\r\n\t        } else if (a.field < b.field) {\r\n\t            return -1;\r\n\t        } else {\r\n\t            return 0;\r\n\t        }\r\n\t    }\r\n\r\n\t    function compareFilters(expr1, expr2) {\r\n\t        expr1 = normalizeDescriptor(expr1);\r\n\t        expr2 = normalizeDescriptor(expr2);\r\n\r\n\t        if (expr1.logic !== expr2.logic) {\r\n\t            return false;\r\n\t        }\r\n\r\n\t        var f1, f2;\r\n\t        var filters1 = (expr1.filters || []).slice();\r\n\t        var filters2 = (expr2.filters || []).slice();\r\n\r\n\t        if (filters1.length !== filters2.length) {\r\n\t            return false;\r\n\t        }\r\n\r\n\t        filters1 = filters1.sort(fieldComparer);\r\n\t        filters2 = filters2.sort(fieldComparer);\r\n\r\n\t        for (var idx = 0; idx < filters1.length; idx++) {\r\n\t            f1 = filters1[idx];\r\n\t            f2 = filters2[idx];\r\n\r\n\t            if (f1.logic && f2.logic) {\r\n\t                if (!compareFilters(f1, f2)) {\r\n\t                    return false;\r\n\t                }\r\n\t            } else if (!compareDescriptor(f1, f2)) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\r\n\t        return true;\r\n\t    }\r\n\r\n\t    Query.compareFilters = compareFilters;\r\n\r\n\t    function normalizeAggregate(expressions) {\r\n\t        return isArray(expressions) ? expressions : [expressions];\r\n\t    }\r\n\r\n\t    function normalizeGroup(field, dir) {\r\n\t        var descriptor = typeof field === STRING ? { field: field, dir: dir } : field,\r\n\t        descriptors = isArray(descriptor) ? descriptor : (descriptor !== undefined ? [descriptor] : []);\r\n\r\n\t        return map(descriptors, function(d) { return { field: d.field, dir: d.dir || \"asc\", aggregates: d.aggregates }; });\r\n\t    }\r\n\r\n\t    Query.prototype = {\r\n\t        toArray: function () {\r\n\t            return this.data;\r\n\t        },\r\n\t        range: function(index, count) {\r\n\t            return new Query(this.data.slice(index, index + count));\r\n\t        },\r\n\t        skip: function (count) {\r\n\t            return new Query(this.data.slice(count));\r\n\t        },\r\n\t        take: function (count) {\r\n\t            return new Query(this.data.slice(0, count));\r\n\t        },\r\n\t        select: function (selector) {\r\n\t            return new Query(map(this.data, selector));\r\n\t        },\r\n\t        order: function(selector, dir, inPlace) {\r\n\t            var sort = { dir: dir };\r\n\r\n\t            if (selector) {\r\n\t                if (selector.compare) {\r\n\t                    sort.compare = selector.compare;\r\n\t                } else {\r\n\t                    sort.field = selector;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (inPlace) {\r\n\t                return new Query(this.data.sort(Comparer.create(sort)));\r\n\t            }\r\n\t            return new Query(this.data.slice(0).sort(Comparer.create(sort)));\r\n\t        },\r\n\t        orderBy: function(selector, inPlace) {\r\n\t            return this.order(selector, \"asc\", inPlace);\r\n\t        },\r\n\t        orderByDescending: function(selector, inPlace) {\r\n\t            return this.order(selector, \"desc\", inPlace);\r\n\t        },\r\n\t        sort: function(field, dir, comparer, inPlace) {\r\n\t            var idx,\r\n\t            length,\r\n\t            descriptors = normalizeSort(field, dir),\r\n\t            comparers = [];\r\n\r\n\t            comparer = comparer || Comparer;\r\n\r\n\t            if (descriptors.length) {\r\n\t                for (idx = 0, length = descriptors.length; idx < length; idx++) {\r\n\t                    comparers.push(comparer.create(descriptors[idx]));\r\n\t                }\r\n\r\n\t                return this.orderBy({ compare: comparer.combine(comparers) }, inPlace);\r\n\t            }\r\n\r\n\t            return this;\r\n\t        },\r\n\r\n\t        filter: function(expressions) {\r\n\t            var idx,\r\n\t            current,\r\n\t            length,\r\n\t            compiled,\r\n\t            predicate,\r\n\t            data = this.data,\r\n\t            fields,\r\n\t            operators,\r\n\t            result = [],\r\n\t            filter;\r\n\r\n\t            expressions = normalizeFilter(expressions);\r\n\r\n\t            if (!expressions || expressions.filters.length === 0) {\r\n\t                return this;\r\n\t            }\r\n\r\n\t            compiled = Query.filterExpr(expressions);\r\n\t            fields = compiled.fields;\r\n\t            operators = compiled.operators;\r\n\r\n\t            predicate = filter = new Function(\"d, __f, __o\", \"return \" + compiled.expression);\r\n\r\n\t            if (fields.length || operators.length) {\r\n\t                filter = function(d) {\r\n\t                    return predicate(d, fields, operators);\r\n\t                };\r\n\t            }\r\n\r\n\r\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                current = data[idx];\r\n\r\n\t                if (filter(current)) {\r\n\t                    result.push(current);\r\n\t                }\r\n\t            }\r\n\r\n\t            return new Query(result);\r\n\t        },\r\n\r\n\t        group: function(descriptors, allData) {\r\n\t            descriptors =  normalizeGroup(descriptors || []);\r\n\t            allData = allData || this.data;\r\n\r\n\t            var that = this,\r\n\t            result = new Query(that.data),\r\n\t            descriptor;\r\n\r\n\t            if (descriptors.length > 0) {\r\n\t                descriptor = descriptors[0];\r\n\t                result = result.groupBy(descriptor).select(function(group) {\r\n\t                    var data = new Query(allData).filter([ { field: group.field, operator: \"eq\", value: group.value, ignoreCase: false } ]);\r\n\t                    return {\r\n\t                        field: group.field,\r\n\t                        value: group.value,\r\n\t                        items: descriptors.length > 1 ? new Query(group.items).group(descriptors.slice(1), data.toArray()).toArray() : group.items,\r\n\t                        hasSubgroups: descriptors.length > 1,\r\n\t                        aggregates: data.aggregate(descriptor.aggregates)\r\n\t                    };\r\n\t                });\r\n\t            }\r\n\t            return result;\r\n\t        },\r\n\r\n\t        groupBy: function(descriptor) {\r\n\t            if (isEmptyObject(descriptor) || !this.data.length) {\r\n\t                return new Query([]);\r\n\t            }\r\n\r\n\t            var field = descriptor.field,\r\n\t                sorted = this._sortForGrouping(field, descriptor.dir || \"asc\"),\r\n\t                accessor = kendo.accessor(field),\r\n\t                item,\r\n\t                groupValue = accessor.get(sorted[0], field),\r\n\t                group = {\r\n\t                    field: field,\r\n\t                    value: groupValue,\r\n\t                    items: []\r\n\t                },\r\n\t                currentValue,\r\n\t                idx,\r\n\t                len,\r\n\t                result = [group];\r\n\r\n\t            for(idx = 0, len = sorted.length; idx < len; idx++) {\r\n\t                item = sorted[idx];\r\n\t                currentValue = accessor.get(item, field);\r\n\t                if(!groupValueComparer(groupValue, currentValue)) {\r\n\t                    groupValue = currentValue;\r\n\t                    group = {\r\n\t                        field: field,\r\n\t                        value: groupValue,\r\n\t                        items: []\r\n\t                    };\r\n\t                    result.push(group);\r\n\t                }\r\n\t                group.items.push(item);\r\n\t            }\r\n\t            return new Query(result);\r\n\t        },\r\n\r\n\t        _sortForGrouping: function(field, dir) {\r\n\t            var idx, length,\r\n\t                data = this.data;\r\n\r\n\t            if (!stableSort) {\r\n\t                for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                    data[idx].__position = idx;\r\n\t                }\r\n\r\n\t                data = new Query(data).sort(field, dir, StableComparer).toArray();\r\n\r\n\t                for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                    delete data[idx].__position;\r\n\t                }\r\n\t                return data;\r\n\t            }\r\n\t            return this.sort(field, dir).toArray();\r\n\t        },\r\n\r\n\t        aggregate: function (aggregates) {\r\n\t            var idx,\r\n\t                len,\r\n\t                result = {},\r\n\t                state = {};\r\n\r\n\t            if (aggregates && aggregates.length) {\r\n\t                for(idx = 0, len = this.data.length; idx < len; idx++) {\r\n\t                    calculateAggregate(result, aggregates, this.data[idx], idx, len, state);\r\n\t                }\r\n\t            }\r\n\t            return result;\r\n\t        }\r\n\t    };\r\n\r\n\t    function groupValueComparer(a, b) {\r\n\t        if (a && a.getTime && b && b.getTime) {\r\n\t            return a.getTime() === b.getTime();\r\n\t        }\r\n\t        return a === b;\r\n\t    }\r\n\r\n\t    function calculateAggregate(accumulator, aggregates, item, index, length, state) {\r\n\t        aggregates = aggregates || [];\r\n\t        var idx,\r\n\t            aggr,\r\n\t            functionName,\r\n\t            len = aggregates.length;\r\n\r\n\t        for (idx = 0; idx < len; idx++) {\r\n\t            aggr = aggregates[idx];\r\n\t            functionName = aggr.aggregate;\r\n\t            var field = aggr.field;\r\n\t            accumulator[field] = accumulator[field] || {};\r\n\t            state[field] = state[field] || {};\r\n\t            state[field][functionName] = state[field][functionName] || {};\r\n\t            accumulator[field][functionName] = functions[functionName.toLowerCase()](accumulator[field][functionName], item, kendo.accessor(field), index, length, state[field][functionName]);\r\n\t        }\r\n\t    }\r\n\r\n\t    var functions = {\r\n\t        sum: function(accumulator, item, accessor) {\r\n\t            var value = accessor.get(item);\r\n\r\n\t            if (!isNumber(accumulator)) {\r\n\t                accumulator = value;\r\n\t            } else if (isNumber(value)) {\r\n\t                accumulator += value;\r\n\t            }\r\n\r\n\t            return accumulator;\r\n\t        },\r\n\t        count: function(accumulator) {\r\n\t            return (accumulator || 0) + 1;\r\n\t        },\r\n\t        average: function(accumulator, item, accessor, index, length, state) {\r\n\t            var value = accessor.get(item);\r\n\r\n\t            if (state.count === undefined) {\r\n\t                state.count = 0;\r\n\t            }\r\n\r\n\t            if (!isNumber(accumulator)) {\r\n\t                accumulator = value;\r\n\t            } else if (isNumber(value)) {\r\n\t                accumulator += value;\r\n\t            }\r\n\r\n\t            if (isNumber(value)) {\r\n\t                state.count++;\r\n\t            }\r\n\r\n\t            if(index == length - 1 && isNumber(accumulator)) {\r\n\t                accumulator = accumulator / state.count;\r\n\t            }\r\n\t            return accumulator;\r\n\t        },\r\n\t        max: function(accumulator, item, accessor) {\r\n\t            var value = accessor.get(item);\r\n\r\n\t            if (!isNumber(accumulator) && !isDate(accumulator)) {\r\n\t                accumulator = value;\r\n\t            }\r\n\r\n\t            if(accumulator < value && (isNumber(value) || isDate(value))) {\r\n\t                accumulator = value;\r\n\t            }\r\n\t            return accumulator;\r\n\t        },\r\n\t        min: function(accumulator, item, accessor) {\r\n\t            var value = accessor.get(item);\r\n\r\n\t            if (!isNumber(accumulator) && !isDate(accumulator)) {\r\n\t                accumulator = value;\r\n\t            }\r\n\r\n\t            if(accumulator > value && (isNumber(value) || isDate(value))) {\r\n\t                accumulator = value;\r\n\t            }\r\n\t            return accumulator;\r\n\t        }\r\n\t    };\r\n\r\n\t    function isNumber(val) {\r\n\t        return typeof val === \"number\" && !isNaN(val);\r\n\t    }\r\n\r\n\t    function isDate(val) {\r\n\t        return val && val.getTime;\r\n\t    }\r\n\r\n\t    function toJSON(array) {\r\n\t        var idx, length = array.length, result = new Array(length);\r\n\r\n\t        for (idx = 0; idx < length; idx++) {\r\n\t            result[idx] = array[idx].toJSON();\r\n\t        }\r\n\r\n\t        return result;\r\n\t    }\r\n\r\n\t    Query.process = function(data, options, inPlace) {\r\n\t        options = options || {};\r\n\r\n\t        var query = new Query(data),\r\n\t            group = options.group,\r\n\t            sort = normalizeGroup(group || []).concat(normalizeSort(options.sort || [])),\r\n\t            total,\r\n\t            filterCallback = options.filterCallback,\r\n\t            filter = options.filter,\r\n\t            skip = options.skip,\r\n\t            take = options.take;\r\n\r\n\t        if (filter) {\r\n\t            query = query.filter(filter);\r\n\r\n\t            if (filterCallback) {\r\n\t                query = filterCallback(query);\r\n\t            }\r\n\r\n\t            total = query.toArray().length;\r\n\t        }\r\n\r\n\t        if (sort) {\r\n\t            if (inPlace) {\r\n\t                query = query.sort(sort, undefined, undefined, inPlace);\r\n\t            }\r\n\t            else {\r\n\t                query = query.sort(sort);\r\n\t            }\r\n\r\n\t            if (group) {\r\n\t                data = query.toArray();\r\n\t            }\r\n\t        }\r\n\r\n\t        if (skip !== undefined && take !== undefined) {\r\n\t            query = query.range(skip, take);\r\n\t        }\r\n\r\n\t        if (group) {\r\n\t            query = query.group(group, data);\r\n\t        }\r\n\r\n\t        return {\r\n\t            total: total,\r\n\t            data: query.toArray()\r\n\t        };\r\n\t    };\r\n\r\n\t    var LocalTransport = Class.extend({\r\n\t        init: function(options) {\r\n\t            this.data = options.data;\r\n\t        },\r\n\r\n\t        read: function(options) {\r\n\t            options.success(this.data);\r\n\t        },\r\n\t        update: function(options) {\r\n\t            options.success(options.data);\r\n\t        },\r\n\t        create: function(options) {\r\n\t            options.success(options.data);\r\n\t        },\r\n\t        destroy: function(options) {\r\n\t            options.success(options.data);\r\n\t        }\r\n\t    });\r\n\r\n\t    var RemoteTransport = Class.extend( {\r\n\t        init: function(options) {\r\n\t            var that = this, parameterMap;\r\n\r\n\t            options = that.options = extend({}, that.options, options);\r\n\r\n\t            each(crud, function(index, type) {\r\n\t                if (typeof options[type] === STRING) {\r\n\t                    options[type] = {\r\n\t                        url: options[type]\r\n\t                    };\r\n\t                }\r\n\t            });\r\n\r\n\t            that.cache = options.cache? Cache.create(options.cache) : {\r\n\t                find: noop,\r\n\t                add: noop\r\n\t            };\r\n\r\n\t            parameterMap = options.parameterMap;\r\n\r\n\t            if (isFunction(options.push)) {\r\n\t                that.push = options.push;\r\n\t            }\r\n\r\n\t            if (!that.push) {\r\n\t                that.push = identity;\r\n\t            }\r\n\r\n\t            that.parameterMap = isFunction(parameterMap) ? parameterMap : function(options) {\r\n\t                var result = {};\r\n\r\n\t                each(options, function(option, value) {\r\n\t                    if (option in parameterMap) {\r\n\t                        option = parameterMap[option];\r\n\t                        if (isPlainObject(option)) {\r\n\t                            value = option.value(value);\r\n\t                            option = option.key;\r\n\t                        }\r\n\t                    }\r\n\r\n\t                    result[option] = value;\r\n\t                });\r\n\r\n\t                return result;\r\n\t            };\r\n\t        },\r\n\r\n\t        options: {\r\n\t            parameterMap: identity\r\n\t        },\r\n\r\n\t        create: function(options) {\r\n\t            return ajax(this.setup(options, CREATE));\r\n\t        },\r\n\r\n\t        read: function(options) {\r\n\t            var that = this,\r\n\t                success,\r\n\t                error,\r\n\t                result,\r\n\t                cache = that.cache;\r\n\r\n\t            options = that.setup(options, READ);\r\n\r\n\t            success = options.success || noop;\r\n\t            error = options.error || noop;\r\n\r\n\t            result = cache.find(options.data);\r\n\r\n\t            if(result !== undefined) {\r\n\t                success(result);\r\n\t            } else {\r\n\t                options.success = function(result) {\r\n\t                    cache.add(options.data, result);\r\n\r\n\t                    success(result);\r\n\t                };\r\n\r\n\t                $.ajax(options);\r\n\t            }\r\n\t        },\r\n\r\n\t        update: function(options) {\r\n\t            return ajax(this.setup(options, UPDATE));\r\n\t        },\r\n\r\n\t        destroy: function(options) {\r\n\t            return ajax(this.setup(options, DESTROY));\r\n\t        },\r\n\r\n\t        setup: function(options, type) {\r\n\t            options = options || {};\r\n\r\n\t            var that = this,\r\n\t                parameters,\r\n\t                operation = that.options[type],\r\n\t                data = isFunction(operation.data) ? operation.data(options.data) : operation.data;\r\n\r\n\t            options = extend(true, {}, operation, options);\r\n\t            parameters = extend(true, {}, data, options.data);\r\n\r\n\t            options.data = that.parameterMap(parameters, type);\r\n\r\n\t            if (isFunction(options.url)) {\r\n\t                options.url = options.url(parameters);\r\n\t            }\r\n\r\n\t            return options;\r\n\t        }\r\n\t    });\r\n\r\n\t    var Cache = Class.extend({\r\n\t        init: function() {\r\n\t            this._store = {};\r\n\t        },\r\n\t        add: function(key, data) {\r\n\t            if(key !== undefined) {\r\n\t                this._store[stringify(key)] = data;\r\n\t            }\r\n\t        },\r\n\t        find: function(key) {\r\n\t            return this._store[stringify(key)];\r\n\t        },\r\n\t        clear: function() {\r\n\t            this._store = {};\r\n\t        },\r\n\t        remove: function(key) {\r\n\t            delete this._store[stringify(key)];\r\n\t        }\r\n\t    });\r\n\r\n\t    Cache.create = function(options) {\r\n\t        var store = {\r\n\t            \"inmemory\": function() { return new Cache(); }\r\n\t        };\r\n\r\n\t        if (isPlainObject(options) && isFunction(options.find)) {\r\n\t            return options;\r\n\t        }\r\n\r\n\t        if (options === true) {\r\n\t            return new Cache();\r\n\t        }\r\n\r\n\t        return store[options]();\r\n\t    };\r\n\r\n\t    function serializeRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {\r\n\t        var record,\r\n\t            getter,\r\n\t            originalName,\r\n\t            idx,\r\n\t            setters = {},\r\n\t            length;\r\n\r\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t            record = data[idx];\r\n\t            for (getter in getters) {\r\n\t                originalName = fieldNames[getter];\r\n\r\n\t                if (originalName && originalName !== getter) {\r\n\t                    if (!setters[originalName]) {\r\n\t                        setters[originalName] = kendo.setter(originalName);\r\n\t                    }\r\n\t                    setters[originalName](record, getters[getter](record));\r\n\t                    delete record[getter];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function convertRecords(data, getters, modelInstance, originalFieldNames, fieldNames) {\r\n\t        var record,\r\n\t            getter,\r\n\t            originalName,\r\n\t            idx,\r\n\t            length;\r\n\r\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t            record = data[idx];\r\n\t            for (getter in getters) {\r\n\t                record[getter] = modelInstance._parse(getter, getters[getter](record));\r\n\r\n\t                originalName = fieldNames[getter];\r\n\t                if (originalName && originalName !== getter) {\r\n\t                    delete record[originalName];\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function convertGroup(data, getters, modelInstance, originalFieldNames, fieldNames) {\r\n\t        var record,\r\n\t            idx,\r\n\t            fieldName,\r\n\t            length;\r\n\r\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t            record = data[idx];\r\n\r\n\t            fieldName = originalFieldNames[record.field];\r\n\t            if (fieldName && fieldName != record.field) {\r\n\t                record.field = fieldName;\r\n\t            }\r\n\r\n\t            record.value = modelInstance._parse(record.field, record.value);\r\n\r\n\t            if (record.hasSubgroups) {\r\n\t                convertGroup(record.items, getters, modelInstance, originalFieldNames, fieldNames);\r\n\t            } else {\r\n\t                convertRecords(record.items, getters, modelInstance, originalFieldNames, fieldNames);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function wrapDataAccess(originalFunction, model, converter, getters, originalFieldNames, fieldNames) {\r\n\t        return function(data) {\r\n\t            data = originalFunction(data);\r\n\r\n\t            if (data && !isEmptyObject(getters)) {\r\n\t                if (toString.call(data) !== \"[object Array]\" && !(data instanceof ObservableArray)) {\r\n\t                    data = [data];\r\n\t                }\r\n\r\n\t                converter(data, getters, new model(), originalFieldNames, fieldNames);\r\n\t            }\r\n\r\n\t            return data || [];\r\n\t        };\r\n\t    }\r\n\r\n\t    var DataReader = Class.extend({\r\n\t        init: function(schema) {\r\n\t            var that = this, member, get, model, base;\r\n\r\n\t            schema = schema || {};\r\n\r\n\t            for (member in schema) {\r\n\t                get = schema[member];\r\n\r\n\t                that[member] = typeof get === STRING ? getter(get) : get;\r\n\t            }\r\n\r\n\t            base = schema.modelBase || Model;\r\n\r\n\t            if (isPlainObject(that.model)) {\r\n\t                that.model = model = base.define(that.model);\r\n\t            }\r\n\r\n\t            var dataFunction = proxy(that.data, that);\r\n\r\n\t            that._dataAccessFunction = dataFunction;\r\n\r\n\t            if (that.model) {\r\n\t                var groupsFunction = proxy(that.groups, that),\r\n\t                    serializeFunction = proxy(that.serialize, that),\r\n\t                    originalFieldNames = {},\r\n\t                    getters = {},\r\n\t                    serializeGetters = {},\r\n\t                    fieldNames = {},\r\n\t                    shouldSerialize = false,\r\n\t                    fieldName;\r\n\r\n\t                model = that.model;\r\n\r\n\t                if (model.fields) {\r\n\t                    each(model.fields, function(field, value) {\r\n\t                        var fromName;\r\n\r\n\t                        fieldName = field;\r\n\r\n\t                        if (isPlainObject(value) && value.field) {\r\n\t                            fieldName = value.field;\r\n\t                        } else if (typeof value === STRING) {\r\n\t                            fieldName = value;\r\n\t                        }\r\n\r\n\t                        if (isPlainObject(value) && value.from) {\r\n\t                            fromName = value.from;\r\n\t                        }\r\n\r\n\t                        shouldSerialize = shouldSerialize || (fromName && fromName !== field) || fieldName !== field;\r\n\r\n\t                        getters[field] = getter(fromName || fieldName);\r\n\t                        serializeGetters[field] = getter(field);\r\n\t                        originalFieldNames[fromName || fieldName] = field;\r\n\t                        fieldNames[field] = fromName || fieldName;\r\n\t                    });\r\n\r\n\t                    if (!schema.serialize && shouldSerialize) {\r\n\t                        that.serialize = wrapDataAccess(serializeFunction, model, serializeRecords, serializeGetters, originalFieldNames, fieldNames);\r\n\t                    }\r\n\t                }\r\n\r\n\t                that._dataAccessFunction = dataFunction;\r\n\t                that.data = wrapDataAccess(dataFunction, model, convertRecords, getters, originalFieldNames, fieldNames);\r\n\t                that.groups = wrapDataAccess(groupsFunction, model, convertGroup, getters, originalFieldNames, fieldNames);\r\n\t            }\r\n\t        },\r\n\t        errors: function(data) {\r\n\t            return data ? data.errors : null;\r\n\t        },\r\n\t        parse: identity,\r\n\t        data: identity,\r\n\t        total: function(data) {\r\n\t            return data.length;\r\n\t        },\r\n\t        groups: identity,\r\n\t        aggregates: function() {\r\n\t            return {};\r\n\t        },\r\n\t        serialize: function(data) {\r\n\t            return data;\r\n\t        }\r\n\t    });\r\n\r\n\t    function mergeGroups(target, dest, skip, take) {\r\n\t        var group,\r\n\t            idx = 0,\r\n\t            items;\r\n\r\n\t        while (dest.length && take) {\r\n\t            group = dest[idx];\r\n\t            items = group.items;\r\n\r\n\t            var length = items.length;\r\n\r\n\t            if (target && target.field === group.field && target.value === group.value) {\r\n\t                if (target.hasSubgroups && target.items.length) {\r\n\t                    mergeGroups(target.items[target.items.length - 1], group.items, skip, take);\r\n\t                } else {\r\n\t                    items = items.slice(skip, skip + take);\r\n\t                    target.items = target.items.concat(items);\r\n\t                }\r\n\t                dest.splice(idx--, 1);\r\n\t            } else if (group.hasSubgroups && items.length) {\r\n\t                mergeGroups(group, items, skip, take);\r\n\t                if (!group.items.length) {\r\n\t                    dest.splice(idx--, 1);\r\n\t                }\r\n\t            } else {\r\n\t                items = items.slice(skip, skip + take);\r\n\t                group.items = items;\r\n\r\n\t                if (!group.items.length) {\r\n\t                    dest.splice(idx--, 1);\r\n\t                }\r\n\t            }\r\n\r\n\t            if (items.length === 0) {\r\n\t                skip -= length;\r\n\t            } else {\r\n\t                skip = 0;\r\n\t                take -= items.length;\r\n\t            }\r\n\r\n\t            if (++idx >= dest.length) {\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        if (idx < dest.length) {\r\n\t            dest.splice(idx, dest.length - idx);\r\n\t        }\r\n\t    }\r\n\r\n\t    function flattenGroups(data) {\r\n\t        var idx,\r\n\t            result = [],\r\n\t            length,\r\n\t            items,\r\n\t            itemIndex;\r\n\r\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t            var group = data.at(idx);\r\n\t            if (group.hasSubgroups) {\r\n\t                result = result.concat(flattenGroups(group.items));\r\n\t            } else {\r\n\t                items = group.items;\r\n\t                for (itemIndex = 0; itemIndex < items.length; itemIndex++) {\r\n\t                    result.push(items.at(itemIndex));\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return result;\r\n\t    }\r\n\r\n\t    function wrapGroupItems(data, model) {\r\n\t        var idx, length, group;\r\n\t        if (model) {\r\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                group = data.at(idx);\r\n\r\n\t                if (group.hasSubgroups) {\r\n\t                    wrapGroupItems(group.items, model);\r\n\t                } else {\r\n\t                    group.items = new LazyObservableArray(group.items, model);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function eachGroupItems(data, func) {\r\n\t        for (var idx = 0, length = data.length; idx < length; idx++) {\r\n\t            if (data[idx].hasSubgroups) {\r\n\t                if (eachGroupItems(data[idx].items, func)) {\r\n\t                    return true;\r\n\t                }\r\n\t            } else if (func(data[idx].items, data[idx])) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function replaceInRanges(ranges, data, item, observable) {\r\n\t        for (var idx = 0; idx < ranges.length; idx++) {\r\n\t            if (ranges[idx].data === data) {\r\n\t                break;\r\n\t            }\r\n\t            if (replaceInRange(ranges[idx].data, item, observable)) {\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function replaceInRange(items, item, observable) {\r\n\t        for (var idx = 0, length = items.length; idx < length; idx++) {\r\n\t            if (items[idx] && items[idx].hasSubgroups) {\r\n\t                return replaceInRange(items[idx].items, item, observable);\r\n\t            } else if (items[idx] === item || items[idx] === observable) {\r\n\t               items[idx] = observable;\r\n\t               return true;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function replaceWithObservable(view, data, ranges, type, serverGrouping) {\r\n\t        for (var viewIndex = 0, length = view.length; viewIndex < length; viewIndex++) {\r\n\t            var item = view[viewIndex];\r\n\r\n\t            if (!item || item instanceof type) {\r\n\t                continue;\r\n\t            }\r\n\r\n\t            if (item.hasSubgroups !== undefined && !serverGrouping) {\r\n\t                replaceWithObservable(item.items, data, ranges, type, serverGrouping);\r\n\t            } else {\r\n\t                for (var idx = 0; idx < data.length; idx++) {\r\n\t                    if (data[idx] === item) {\r\n\t                        view[viewIndex] = data.at(idx);\r\n\t                        replaceInRanges(ranges, data, item, view[viewIndex]);\r\n\t                        break;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function removeModel(data, model, skip, take) {\r\n\t        var length = data.length;\r\n\t        var startIndex = skip || 0;\r\n\t        var endIndex = typeof(take) !== \"undefined\" ? math.min(startIndex + take, length) : length;\r\n\t        var idx;\r\n\r\n\t        for (idx = startIndex; idx < endIndex; idx++) {\r\n\t            var dataItem = data.at(idx);\r\n\t            if (dataItem.uid == model.uid) {\r\n\t                data.splice(idx, 1);\r\n\t                return dataItem;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    function indexOfPristineModel(data, model) {\r\n\t        if (model) {\r\n\t            return indexOf(data, function(item) {\r\n\t                return (item.uid && item.uid == model.uid) || (item[model.idField] === model.id && model.id !== model._defaultId);\r\n\t            });\r\n\t        }\r\n\t        return -1;\r\n\t    }\r\n\r\n\t    function indexOfModel(data, model) {\r\n\t        if (model) {\r\n\t            return indexOf(data, function(item) {\r\n\t                return item.uid == model.uid;\r\n\t            });\r\n\t        }\r\n\t        return -1;\r\n\t    }\r\n\r\n\t    function indexOf(data, comparer) {\r\n\t        var idx, length;\r\n\r\n\t        for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t            if (comparer(data[idx])) {\r\n\t                return idx;\r\n\t            }\r\n\t        }\r\n\r\n\t        return -1;\r\n\t    }\r\n\r\n\t    function fieldNameFromModel(fields, name) {\r\n\t        if (fields && !isEmptyObject(fields)) {\r\n\t            var descriptor = fields[name];\r\n\t            var fieldName;\r\n\t            if (isPlainObject(descriptor)) {\r\n\t                fieldName = descriptor.from || descriptor.field || name;\r\n\t            } else {\r\n\t                fieldName = fields[name] || name;\r\n\t            }\r\n\r\n\t            if (isFunction(fieldName)) {\r\n\t                return name;\r\n\t            }\r\n\r\n\t            return fieldName;\r\n\t        }\r\n\t        return name;\r\n\t    }\r\n\r\n\t    function convertFilterDescriptorsField(descriptor, model) {\r\n\t        var idx,\r\n\t            length,\r\n\t            target = {};\r\n\r\n\t        for (var field in descriptor) {\r\n\t            if (field !== \"filters\") {\r\n\t                target[field] = descriptor[field];\r\n\t            }\r\n\t        }\r\n\r\n\t        if (descriptor.filters) {\r\n\t            target.filters = [];\r\n\t            for (idx = 0, length = descriptor.filters.length; idx < length; idx++) {\r\n\t                target.filters[idx] = convertFilterDescriptorsField(descriptor.filters[idx], model);\r\n\t            }\r\n\t        } else {\r\n\t            target.field = fieldNameFromModel(model.fields, target.field);\r\n\t        }\r\n\t        return target;\r\n\t    }\r\n\r\n\t    function convertDescriptorsField(descriptors, model) {\r\n\t        var idx,\r\n\t            length,\r\n\t            result = [],\r\n\t            target,\r\n\t            descriptor;\r\n\r\n\t        for (idx = 0, length = descriptors.length; idx < length; idx ++) {\r\n\t            target = {};\r\n\r\n\t            descriptor = descriptors[idx];\r\n\r\n\t            for (var field in descriptor) {\r\n\t                target[field] = descriptor[field];\r\n\t            }\r\n\r\n\t            target.field = fieldNameFromModel(model.fields, target.field);\r\n\r\n\t            if (target.aggregates && isArray(target.aggregates)) {\r\n\t                target.aggregates = convertDescriptorsField(target.aggregates, model);\r\n\t            }\r\n\t            result.push(target);\r\n\t        }\r\n\t        return result;\r\n\t    }\r\n\r\n\t    var DataSource = Observable.extend({\r\n\t        init: function(options) {\r\n\t            var that = this, model, data;\r\n\r\n\t            if (options) {\r\n\t                data = options.data;\r\n\t            }\r\n\r\n\t            options = that.options = extend({}, that.options, options);\r\n\r\n\t            that._map = {};\r\n\t            that._prefetch = {};\r\n\t            that._data = [];\r\n\t            that._pristineData = [];\r\n\t            that._ranges = [];\r\n\t            that._view = [];\r\n\t            that._pristineTotal = 0;\r\n\t            that._destroyed = [];\r\n\t            that._pageSize = options.pageSize;\r\n\t            that._page = options.page  || (options.pageSize ? 1 : undefined);\r\n\t            that._sort = normalizeSort(options.sort);\r\n\t            that._filter = normalizeFilter(options.filter);\r\n\t            that._group = normalizeGroup(options.group);\r\n\t            that._aggregate = options.aggregate;\r\n\t            that._total = options.total;\r\n\r\n\t            that._shouldDetachObservableParents = true;\r\n\r\n\t            Observable.fn.init.call(that);\r\n\r\n\t            that.transport = Transport.create(options, data, that);\r\n\r\n\t            if (isFunction(that.transport.push)) {\r\n\t                that.transport.push({\r\n\t                    pushCreate: proxy(that._pushCreate, that),\r\n\t                    pushUpdate: proxy(that._pushUpdate, that),\r\n\t                    pushDestroy: proxy(that._pushDestroy, that)\r\n\t                });\r\n\t            }\r\n\r\n\t            if (options.offlineStorage != null) {\r\n\t                if (typeof options.offlineStorage == \"string\") {\r\n\t                    var key = options.offlineStorage;\r\n\r\n\t                    that._storage = {\r\n\t                        getItem: function() {\r\n\t                            return JSON.parse(localStorage.getItem(key));\r\n\t                        },\r\n\t                        setItem: function(item) {\r\n\t                            localStorage.setItem(key, stringify(that.reader.serialize(item)));\r\n\t                        }\r\n\t                    };\r\n\t                } else {\r\n\t                    that._storage = options.offlineStorage;\r\n\t                }\r\n\t            }\r\n\r\n\t            that.reader = new kendo.data.readers[options.schema.type || \"json\" ](options.schema);\r\n\r\n\t            model = that.reader.model || {};\r\n\r\n\t            that._detachObservableParents();\r\n\r\n\t            that._data = that._observe(that._data);\r\n\t            that._online = true;\r\n\r\n\t            that.bind([\"push\", ERROR, CHANGE, REQUESTSTART, SYNC, REQUESTEND, PROGRESS], options);\r\n\t        },\r\n\r\n\t        options: {\r\n\t            data: null,\r\n\t            schema: {\r\n\t               modelBase: Model\r\n\t            },\r\n\t            offlineStorage: null,\r\n\t            serverSorting: false,\r\n\t            serverPaging: false,\r\n\t            serverFiltering: false,\r\n\t            serverGrouping: false,\r\n\t            serverAggregates: false,\r\n\t            batch: false,\r\n\t            inPlaceSort: false\r\n\t        },\r\n\r\n\t        clone: function() {\r\n\t            return this;\r\n\t        },\r\n\r\n\t        online: function(value) {\r\n\t            if (value !== undefined) {\r\n\t                if (this._online != value) {\r\n\t                    this._online = value;\r\n\r\n\t                    if (value) {\r\n\t                        return this.sync();\r\n\t                    }\r\n\t                }\r\n\r\n\t                return $.Deferred().resolve().promise();\r\n\t            } else {\r\n\t                return this._online;\r\n\t            }\r\n\t        },\r\n\r\n\t        offlineData: function(state) {\r\n\t            if (this.options.offlineStorage == null) {\r\n\t                return null;\r\n\t            }\r\n\r\n\t            if (state !== undefined) {\r\n\t                return this._storage.setItem(state);\r\n\t            }\r\n\r\n\t            return this._storage.getItem() || [];\r\n\t        },\r\n\r\n\t        _isServerGrouped: function() {\r\n\t            var group = this.group() || [];\r\n\r\n\t            return this.options.serverGrouping && group.length;\r\n\t        },\r\n\r\n\t        _pushCreate: function(result) {\r\n\t            this._push(result, \"pushCreate\");\r\n\t        },\r\n\r\n\t        _pushUpdate: function(result) {\r\n\t            this._push(result, \"pushUpdate\");\r\n\t        },\r\n\r\n\t        _pushDestroy: function(result) {\r\n\t            this._push(result, \"pushDestroy\");\r\n\t        },\r\n\r\n\t        _push: function(result, operation) {\r\n\t            var data = this._readData(result);\r\n\r\n\t            if (!data) {\r\n\t                data = result;\r\n\t            }\r\n\r\n\t            this[operation](data);\r\n\t        },\r\n\r\n\t        _flatData: function(data, skip) {\r\n\t            if (data) {\r\n\t                if (this._isServerGrouped()) {\r\n\t                    return flattenGroups(data);\r\n\t                }\r\n\r\n\t                if (!skip) {\r\n\t                    for (var idx = 0; idx < data.length; idx++) {\r\n\t                        data.at(idx);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            return data;\r\n\t        },\r\n\r\n\t        parent: noop,\r\n\r\n\t        get: function(id) {\r\n\t            var idx, length, data = this._flatData(this._data, this.options.useRanges);\r\n\r\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                if (data[idx].id == id) {\r\n\t                    return data[idx];\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        getByUid: function(id) {\r\n\t            return this._getByUid(id, this._data);\r\n\t        },\r\n\r\n\t        _getByUid: function(id, dataItems) {\r\n\t            var idx, length, data = this._flatData(dataItems, this.options.useRanges);\r\n\r\n\t            if (!data) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                if (data[idx].uid == id) {\r\n\t                    return data[idx];\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        indexOf: function(model) {\r\n\t            return indexOfModel(this._data, model);\r\n\t        },\r\n\r\n\t        at: function(index) {\r\n\t            return this._data.at(index);\r\n\t        },\r\n\r\n\t        data: function(value) {\r\n\t            var that = this;\r\n\t            if (value !== undefined) {\r\n\t                that._detachObservableParents();\r\n\t                that._data = this._observe(value);\r\n\r\n\t                that._pristineData = value.slice(0);\r\n\r\n\t                that._storeData();\r\n\r\n\t                that._ranges = [];\r\n\t                that.trigger(\"reset\");\r\n\t                that._addRange(that._data);\r\n\r\n\t                that._total = that._data.length;\r\n\t                that._pristineTotal = that._total;\r\n\r\n\t                that._process(that._data);\r\n\t            } else {\r\n\t                if (that._data) {\r\n\t                    for (var idx = 0; idx < that._data.length; idx++) {\r\n\t                        that._data.at(idx);\r\n\t                    }\r\n\t                }\r\n\r\n\t                return that._data;\r\n\t            }\r\n\t        },\r\n\r\n\t        view: function(value) {\r\n\t            if (value === undefined) {\r\n\t                return this._view;\r\n\t            } else {\r\n\t                this._view = this._observeView(value);\r\n\t            }\r\n\t        },\r\n\r\n\t        _observeView: function(data) {\r\n\t            var that = this;\r\n\t            replaceWithObservable(data, that._data, that._ranges, that.reader.model || ObservableObject, that._isServerGrouped());\r\n\r\n\t            var view = new LazyObservableArray(data, that.reader.model);\r\n\t            view.parent = function() { return that.parent(); };\r\n\t            return view;\r\n\t        },\r\n\r\n\t        flatView: function() {\r\n\t            var groups = this.group() || [];\r\n\r\n\t            if (groups.length) {\r\n\t                return flattenGroups(this._view);\r\n\t            } else {\r\n\t                return this._view;\r\n\t            }\r\n\t        },\r\n\r\n\t        add: function(model) {\r\n\t            return this.insert(this._data.length, model);\r\n\t        },\r\n\r\n\t        _createNewModel: function(model) {\r\n\t            if (this.reader.model) {\r\n\t                return new this.reader.model(model);\r\n\t            }\r\n\r\n\t            if (model instanceof ObservableObject) {\r\n\t                return model;\r\n\t            }\r\n\r\n\t            return new ObservableObject(model);\r\n\t        },\r\n\r\n\t        insert: function(index, model) {\r\n\t            if (!model) {\r\n\t                model = index;\r\n\t                index = 0;\r\n\t            }\r\n\r\n\t            if (!(model instanceof Model)) {\r\n\t                model = this._createNewModel(model);\r\n\t            }\r\n\r\n\t            if (this._isServerGrouped()) {\r\n\t                this._data.splice(index, 0, this._wrapInEmptyGroup(model));\r\n\t            } else {\r\n\t                this._data.splice(index, 0, model);\r\n\t            }\r\n\r\n\t            this._insertModelInRange(index, model);\r\n\r\n\t            return model;\r\n\t        },\r\n\r\n\t        pushInsert: function(index, items) {\r\n\t            if (!items) {\r\n\t                items = index;\r\n\t                index = 0;\r\n\t            }\r\n\r\n\t            if (!isArray(items)) {\r\n\t                items = [items];\r\n\t            }\r\n\r\n\t            var pushed = [];\r\n\t            var autoSync = this.options.autoSync;\r\n\t            this.options.autoSync = false;\r\n\r\n\t            try {\r\n\t                for (var idx = 0; idx < items.length; idx ++) {\r\n\t                    var item = items[idx];\r\n\r\n\t                    var result = this.insert(index, item);\r\n\r\n\t                    pushed.push(result);\r\n\r\n\t                    var pristine = result.toJSON();\r\n\r\n\t                    if (this._isServerGrouped()) {\r\n\t                        pristine = this._wrapInEmptyGroup(pristine);\r\n\t                    }\r\n\r\n\t                    this._pristineData.push(pristine);\r\n\r\n\t                    index++;\r\n\t                }\r\n\t            } finally {\r\n\t                this.options.autoSync = autoSync;\r\n\t            }\r\n\r\n\t            if (pushed.length) {\r\n\t                this.trigger(\"push\", {\r\n\t                    type: \"create\",\r\n\t                    items: pushed\r\n\t                });\r\n\t            }\r\n\t        },\r\n\r\n\t        pushCreate: function(items) {\r\n\t            this.pushInsert(this._data.length, items);\r\n\t        },\r\n\r\n\t        pushUpdate: function(items) {\r\n\t            if (!isArray(items)) {\r\n\t                items = [items];\r\n\t            }\r\n\r\n\t            var pushed = [];\r\n\r\n\t            for (var idx = 0; idx < items.length; idx ++) {\r\n\t                var item = items[idx];\r\n\t                var model = this._createNewModel(item);\r\n\r\n\t                var target = this.get(model.id);\r\n\r\n\t                if (target) {\r\n\t                    pushed.push(target);\r\n\r\n\t                    target.accept(item);\r\n\r\n\t                    target.trigger(CHANGE);\r\n\r\n\t                    this._updatePristineForModel(target, item);\r\n\t                } else {\r\n\t                    this.pushCreate(item);\r\n\t                }\r\n\t            }\r\n\r\n\t            if (pushed.length) {\r\n\t                this.trigger(\"push\", {\r\n\t                    type: \"update\",\r\n\t                    items: pushed\r\n\t                });\r\n\t            }\r\n\t        },\r\n\r\n\t        pushDestroy: function(items) {\r\n\t            var pushed = this._removeItems(items);\r\n\r\n\t            if (pushed.length) {\r\n\t                this.trigger(\"push\", {\r\n\t                    type: \"destroy\",\r\n\t                    items: pushed\r\n\t                });\r\n\t            }\r\n\t        },\r\n\r\n\t        _removeItems: function(items) {\r\n\t            if (!isArray(items)) {\r\n\t                items = [items];\r\n\t            }\r\n\r\n\t            var destroyed = [];\r\n\t            var autoSync = this.options.autoSync;\r\n\t            this.options.autoSync = false;\r\n\t            try {\r\n\t                for (var idx = 0; idx < items.length; idx ++) {\r\n\t                    var item = items[idx];\r\n\t                    var model = this._createNewModel(item);\r\n\t                    var found = false;\r\n\r\n\t                    this._eachItem(this._data, function(items){\r\n\t                        for (var idx = 0; idx < items.length; idx++) {\r\n\t                            var item = items.at(idx);\r\n\t                            if (item.id === model.id) {\r\n\t                                destroyed.push(item);\r\n\t                                items.splice(idx, 1);\r\n\t                                found = true;\r\n\t                                break;\r\n\t                            }\r\n\t                        }\r\n\t                    });\r\n\r\n\t                    if (found) {\r\n\t                        this._removePristineForModel(model);\r\n\t                        this._destroyed.pop();\r\n\t                    }\r\n\t                }\r\n\t            } finally {\r\n\t                this.options.autoSync = autoSync;\r\n\t            }\r\n\r\n\t            return destroyed;\r\n\t        },\r\n\r\n\t        remove: function(model) {\r\n\t            var result,\r\n\t                that = this,\r\n\t                hasGroups = that._isServerGrouped();\r\n\r\n\t            this._eachItem(that._data, function(items) {\r\n\t                if (that.options.useRanges && !that.options.serverPaging) {\r\n\t                    result = removeModel(items, model, that.currentRangeStart(), that.take());\r\n\t                } else {\r\n\t                    result = removeModel(items, model);\r\n\t                }\r\n\r\n\t                if (result && hasGroups) {\r\n\t                    if (!result.isNew || !result.isNew()) {\r\n\t                        that._destroyed.push(result);\r\n\t                    }\r\n\t                    return true;\r\n\t                }\r\n\t            });\r\n\r\n\t            this._removeModelFromRanges(model);\r\n\r\n\t            return model;\r\n\t        },\r\n\r\n\t        destroyed: function() {\r\n\t            return this._destroyed;\r\n\t        },\r\n\r\n\t        created: function() {\r\n\t            var idx,\r\n\t                length,\r\n\t                result = [],\r\n\t                data = this._flatData(this._data, this.options.useRanges);\r\n\r\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                if (data[idx].isNew && data[idx].isNew()) {\r\n\t                    result.push(data[idx]);\r\n\t                }\r\n\t            }\r\n\t            return result;\r\n\t        },\r\n\r\n\t        updated: function() {\r\n\t            var idx,\r\n\t                length,\r\n\t                result = [],\r\n\t                data = this._flatData(this._data, this.options.useRanges);\r\n\r\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                if ((data[idx].isNew && !data[idx].isNew()) && data[idx].dirty) {\r\n\t                    result.push(data[idx]);\r\n\t                }\r\n\t            }\r\n\t            return result;\r\n\t        },\r\n\r\n\t        sync: function() {\r\n\t            var that = this,\r\n\t                created = [],\r\n\t                updated = [],\r\n\t                destroyed = that._destroyed;\r\n\r\n\t            var promise = $.Deferred().resolve().promise();\r\n\r\n\t            if (that.online()) {\r\n\r\n\t                if (!that.reader.model) {\r\n\t                    return promise;\r\n\t                }\r\n\r\n\t                created = that.created();\r\n\t                updated = that.updated();\r\n\r\n\t                var promises = [];\r\n\r\n\t                if (that.options.batch && that.transport.submit) {\r\n\t                    promises = that._sendSubmit(created, updated, destroyed);\r\n\t                } else {\r\n\t                    promises.push.apply(promises, that._send(\"create\", created));\r\n\t                    promises.push.apply(promises, that._send(\"update\", updated));\r\n\t                    promises.push.apply(promises, that._send(\"destroy\", destroyed));\r\n\t                }\r\n\r\n\t                promise = $.when\r\n\t                 .apply(null, promises)\r\n\t                 .then(function() {\r\n\t                    var idx, length;\r\n\r\n\t                    for (idx = 0, length = arguments.length; idx < length; idx++){\r\n\t                        if (arguments[idx]) {\r\n\t                            that._accept(arguments[idx]);\r\n\t                        }\r\n\t                    }\r\n\r\n\t                    that._storeData(true);\r\n\r\n\t                    that._change({ action: \"sync\" });\r\n\r\n\t                    that.trigger(SYNC);\r\n\t                });\r\n\t            } else {\r\n\t                that._storeData(true);\r\n\r\n\t                that._change({ action: \"sync\" });\r\n\t            }\r\n\r\n\t            return promise;\r\n\t        },\r\n\r\n\t        cancelChanges: function(model) {\r\n\t            var that = this;\r\n\r\n\t            if (model instanceof kendo.data.Model) {\r\n\t                that._cancelModel(model);\r\n\t            } else {\r\n\t                that._destroyed = [];\r\n\t                that._detachObservableParents();\r\n\t                that._data = that._observe(that._pristineData);\r\n\t                if (that.options.serverPaging) {\r\n\t                    that._total = that._pristineTotal;\r\n\t                }\r\n\r\n\t                that._ranges = [];\r\n\t                that._addRange(that._data, 0);\r\n\r\n\t                that._change();\r\n\r\n\t                that._markOfflineUpdatesAsDirty();\r\n\t            }\r\n\t        },\r\n\r\n\t        _markOfflineUpdatesAsDirty: function() {\r\n\t            var that = this;\r\n\r\n\t            if (that.options.offlineStorage != null) {\r\n\t                that._eachItem(that._data, function(items) {\r\n\t                    for (var idx = 0; idx < items.length; idx++) {\r\n\t                        var item = items.at(idx);\r\n\t                        if (item.__state__ == \"update\" || item.__state__ == \"create\") {\r\n\t                            item.dirty = true;\r\n\t                        }\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t        },\r\n\r\n\t        hasChanges: function() {\r\n\t            var idx,\r\n\t                length,\r\n\t                data = this._flatData(this._data, this.options.useRanges);\r\n\r\n\t            if (this._destroyed.length) {\r\n\t                return true;\r\n\t            }\r\n\r\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                if ((data[idx].isNew && data[idx].isNew()) || data[idx].dirty) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\r\n\t            return false;\r\n\t        },\r\n\r\n\t        _accept: function(result) {\r\n\t            var that = this,\r\n\t                models = result.models,\r\n\t                response = result.response,\r\n\t                idx = 0,\r\n\t                serverGroup = that._isServerGrouped(),\r\n\t                pristine = that._pristineData,\r\n\t                type = result.type,\r\n\t                length;\r\n\r\n\t            that.trigger(REQUESTEND, { response: response, type: type });\r\n\r\n\t            if (response && !isEmptyObject(response)) {\r\n\t                response = that.reader.parse(response);\r\n\r\n\t                if (that._handleCustomErrors(response)) {\r\n\t                    return;\r\n\t                }\r\n\r\n\t                response = that.reader.data(response);\r\n\r\n\t                if (!isArray(response)) {\r\n\t                    response = [response];\r\n\t                }\r\n\t            } else {\r\n\t                response = $.map(models, function(model) { return model.toJSON(); } );\r\n\t            }\r\n\r\n\t            if (type === \"destroy\") {\r\n\t                that._destroyed = [];\r\n\t            }\r\n\r\n\t            for (idx = 0, length = models.length; idx < length; idx++) {\r\n\t                if (type !== \"destroy\") {\r\n\t                    models[idx].accept(response[idx]);\r\n\r\n\t                    if (type === \"create\") {\r\n\t                        pristine.push(serverGroup ? that._wrapInEmptyGroup(models[idx]) : response[idx]);\r\n\t                    } else if (type === \"update\") {\r\n\t                        that._updatePristineForModel(models[idx], response[idx]);\r\n\t                    }\r\n\t                } else {\r\n\t                    that._removePristineForModel(models[idx]);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _updatePristineForModel: function(model, values) {\r\n\t            this._executeOnPristineForModel(model, function(index, items) {\r\n\t                kendo.deepExtend(items[index], values);\r\n\t            });\r\n\t        },\r\n\r\n\t        _executeOnPristineForModel: function(model, callback) {\r\n\t            this._eachPristineItem(\r\n\t                function(items) {\r\n\t                    var index = indexOfPristineModel(items, model);\r\n\t                    if (index > -1) {\r\n\t                        callback(index, items);\r\n\t                        return true;\r\n\t                    }\r\n\t                });\r\n\t        },\r\n\r\n\t        _removePristineForModel: function(model) {\r\n\t            this._executeOnPristineForModel(model, function(index, items) {\r\n\t                items.splice(index, 1);\r\n\t            });\r\n\t        },\r\n\r\n\t        _readData: function(data) {\r\n\t            var read = !this._isServerGrouped() ? this.reader.data : this.reader.groups;\r\n\t            return read.call(this.reader, data);\r\n\t        },\r\n\r\n\t        _eachPristineItem: function(callback) {\r\n\t            this._eachItem(this._pristineData, callback);\r\n\t        },\r\n\r\n\t       _eachItem: function(data, callback) {\r\n\t            if (data && data.length) {\r\n\t                if (this._isServerGrouped()) {\r\n\t                    eachGroupItems(data, callback);\r\n\t                } else {\r\n\t                    callback(data);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _pristineForModel: function(model) {\r\n\t            var pristine,\r\n\t                idx,\r\n\t                callback = function(items) {\r\n\t                    idx = indexOfPristineModel(items, model);\r\n\t                    if (idx > -1) {\r\n\t                        pristine = items[idx];\r\n\t                        return true;\r\n\t                    }\r\n\t                };\r\n\r\n\t            this._eachPristineItem(callback);\r\n\r\n\t            return pristine;\r\n\t        },\r\n\r\n\t        _cancelModel: function(model) {\r\n\t            var that = this;\r\n\t            var pristine = this._pristineForModel(model);\r\n\r\n\t            this._eachItem(this._data, function(items) {\r\n\t                var idx = indexOfModel(items, model);\r\n\t                if (idx >= 0) {\r\n\t                    if (pristine && (!model.isNew() || pristine.__state__)) {\r\n\t                        items[idx].accept(pristine);\r\n\r\n\t                        if (pristine.__state__ == \"update\") {\r\n\t                            items[idx].dirty = true;\r\n\t                        }\r\n\r\n\t                    } else {\r\n\t                        items.splice(idx, 1);\r\n\r\n\t                        that._removeModelFromRanges(model);\r\n\t                    }\r\n\t                }\r\n\t            });\r\n\t        },\r\n\r\n\t        _submit: function(promises, data) {\r\n\t            var that = this;\r\n\r\n\t            that.trigger(REQUESTSTART, { type: \"submit\" });\r\n\r\n\t            that.trigger(PROGRESS);\r\n\r\n\t            that.transport.submit(extend({\r\n\t                success: function(response, type) {\r\n\t                    var promise = $.grep(promises, function(x) {\r\n\t                        return x.type == type;\r\n\t                    })[0];\r\n\r\n\t                    if (promise) {\r\n\t                        promise.resolve({\r\n\t                            response: response,\r\n\t                            models: promise.models,\r\n\t                            type: type\r\n\t                        });\r\n\t                    }\r\n\t                },\r\n\t                error: function(response, status, error) {\r\n\t                    for (var idx = 0; idx < promises.length; idx++) {\r\n\t                        promises[idx].reject(response);\r\n\t                    }\r\n\r\n\t                    that.error(response, status, error);\r\n\t                }\r\n\t            }, data));\r\n\t        },\r\n\r\n\t        _sendSubmit: function(created, updated, destroyed) {\r\n\t            var that = this,\r\n\t                promises = [];\r\n\r\n\t            if (that.options.batch) {\r\n\t                if (created.length) {\r\n\t                    promises.push($.Deferred(function(deferred) {\r\n\t                        deferred.type = \"create\";\r\n\t                        deferred.models = created;\r\n\t                    }));\r\n\t                }\r\n\r\n\t                if (updated.length) {\r\n\t                    promises.push($.Deferred(function(deferred) {\r\n\t                        deferred.type = \"update\";\r\n\t                        deferred.models = updated;\r\n\t                    }));\r\n\t                }\r\n\r\n\t                if (destroyed.length) {\r\n\t                    promises.push($.Deferred(function(deferred) {\r\n\t                        deferred.type = \"destroy\";\r\n\t                        deferred.models = destroyed;\r\n\t                    }));\r\n\t                }\r\n\r\n\t                that._submit(promises, {\r\n\t                    data: {\r\n\t                        created: that.reader.serialize(toJSON(created)),\r\n\t                        updated: that.reader.serialize(toJSON(updated)),\r\n\t                        destroyed: that.reader.serialize(toJSON(destroyed))\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\r\n\t            return promises;\r\n\t        },\r\n\r\n\t        _promise: function(data, models, type) {\r\n\t            var that = this;\r\n\r\n\t            return $.Deferred(function(deferred) {\r\n\t                that.trigger(REQUESTSTART, { type: type });\r\n\r\n\t                that.trigger(PROGRESS);\r\n\r\n\t                that.transport[type].call(that.transport, extend({\r\n\t                    success: function(response) {\r\n\t                        deferred.resolve({\r\n\t                            response: response,\r\n\t                            models: models,\r\n\t                            type: type\r\n\t                        });\r\n\t                    },\r\n\t                    error: function(response, status, error) {\r\n\t                        deferred.reject(response);\r\n\t                        that.error(response, status, error);\r\n\t                    }\r\n\t                }, data));\r\n\t            }).promise();\r\n\t        },\r\n\r\n\t        _send: function(method, data) {\r\n\t            var that = this,\r\n\t                idx,\r\n\t                length,\r\n\t                promises = [],\r\n\t                converted = that.reader.serialize(toJSON(data));\r\n\r\n\t            if (that.options.batch) {\r\n\t                if (data.length) {\r\n\t                    promises.push(that._promise( { data: { models: converted } }, data , method));\r\n\t                }\r\n\t            } else {\r\n\t                for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                    promises.push(that._promise( { data: converted[idx] }, [ data[idx] ], method));\r\n\t                }\r\n\t            }\r\n\r\n\t            return promises;\r\n\t        },\r\n\r\n\t        read: function(data) {\r\n\t            var that = this, params = that._params(data);\r\n\t            var deferred = $.Deferred();\r\n\r\n\t            that._queueRequest(params, function() {\r\n\t                var isPrevented = that.trigger(REQUESTSTART, { type: \"read\" });\r\n\t                if (!isPrevented) {\r\n\t                    that.trigger(PROGRESS);\r\n\r\n\t                    that._ranges = [];\r\n\t                    that.trigger(\"reset\");\r\n\t                    if (that.online()) {\r\n\t                        that.transport.read({\r\n\t                            data: params,\r\n\t                            success: function(data) {\r\n\t                                that._ranges = [];\r\n\t                                that.success(data, params);\r\n\r\n\t                                deferred.resolve();\r\n\t                            },\r\n\t                            error: function() {\r\n\t                                var args = slice.call(arguments);\r\n\r\n\t                                that.error.apply(that, args);\r\n\r\n\t                                deferred.reject.apply(deferred, args);\r\n\t                            }\r\n\t                        });\r\n\t                    } else if (that.options.offlineStorage != null){\r\n\t                        that.success(that.offlineData(), params);\r\n\r\n\t                        deferred.resolve();\r\n\t                    }\r\n\t                } else {\r\n\t                    that._dequeueRequest();\r\n\r\n\t                    deferred.resolve(isPrevented);\r\n\t                }\r\n\t            });\r\n\r\n\t            return deferred.promise();\r\n\t        },\r\n\r\n\t        _readAggregates: function(data) {\r\n\t            return this.reader.aggregates(data);\r\n\t        },\r\n\r\n\t        success: function(data) {\r\n\t            var that = this,\r\n\t                options = that.options,\r\n\t                requestParams;\r\n\r\n\t            that.trigger(REQUESTEND, { response: data, type: \"read\" });\r\n\r\n\t            if (that.online()) {\r\n\t                data = that.reader.parse(data);\r\n\r\n\t                if (that._handleCustomErrors(data)) {\r\n\t                    that._dequeueRequest();\r\n\t                    return;\r\n\t                }\r\n\r\n\t                that._total = that.reader.total(data);\r\n\r\n\t                if (that._aggregate && options.serverAggregates) {\r\n\t                    that._aggregateResult = that._readAggregates(data);\r\n\t                }\r\n\r\n\t                requestParams = arguments.length > 1 ? arguments[1] : undefined;\r\n\t                data = that._readData(data, requestParams);\r\n\r\n\t                that._destroyed = [];\r\n\t            } else {\r\n\t                data = that._readData(data);\r\n\r\n\t                var items = [];\r\n\t                var itemIds = {};\r\n\t                var model = that.reader.model;\r\n\t                var idField = model ? model.idField : \"id\";\r\n\t                var idx;\r\n\r\n\t                for (idx = 0; idx < this._destroyed.length; idx++) {\r\n\t                    var id = this._destroyed[idx][idField];\r\n\t                    itemIds[id] = id;\r\n\t                }\r\n\r\n\t                for (idx = 0; idx < data.length; idx++) {\r\n\t                    var item = data[idx];\r\n\t                    var state = item.__state__;\r\n\t                    if (state == \"destroy\") {\r\n\t                        if (!itemIds[item[idField]]) {\r\n\t                            this._destroyed.push(this._createNewModel(item));\r\n\t                        }\r\n\t                    } else {\r\n\t                        items.push(item);\r\n\t                    }\r\n\t                }\r\n\r\n\t                data = items;\r\n\r\n\t                that._total = data.length;\r\n\t            }\r\n\r\n\t            that._pristineTotal = that._total;\r\n\r\n\t            that._pristineData = data.slice(0);\r\n\r\n\t            that._detachObservableParents();\r\n\r\n\t            if (that.options.endless) {\r\n\t                that._data.unbind(CHANGE, that._changeHandler);\r\n\t                data = that._observe(data);\r\n\t                for (var i = 0; i < data.length; i++) {\r\n\t                    that._data.push(data[i]);\r\n\t                }\r\n\t                that._data.bind(CHANGE, that._changeHandler);\r\n\t            } else {\r\n\t                that._data = that._observe(data);\r\n\t            }\r\n\r\n\t            that._markOfflineUpdatesAsDirty();\r\n\r\n\t            that._storeData();\r\n\r\n\t            that._addRange(that._data);\r\n\r\n\t            that._process(that._data);\r\n\r\n\t            that._dequeueRequest();\r\n\t        },\r\n\r\n\t        _detachObservableParents: function() {\r\n\t            if (this._data && this._shouldDetachObservableParents) {\r\n\t                for (var idx = 0; idx < this._data.length; idx++) {\r\n\t                    if (this._data[idx].parent) {\r\n\t                        this._data[idx].parent = noop;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _storeData: function(updatePristine) {\r\n\t            var serverGrouping = this._isServerGrouped();\r\n\t            var model = this.reader.model;\r\n\r\n\t            function items(data) {\r\n\t                var state = [];\r\n\r\n\t                for (var idx = 0; idx < data.length; idx++) {\r\n\t                    var dataItem = data.at(idx);\r\n\t                    var item = dataItem.toJSON();\r\n\r\n\t                    if (serverGrouping && dataItem.items) {\r\n\t                        item.items = items(dataItem.items);\r\n\t                    } else {\r\n\t                        item.uid = dataItem.uid;\r\n\r\n\t                        if (model) {\r\n\t                            if (dataItem.isNew()) {\r\n\t                                item.__state__ = \"create\";\r\n\t                            } else if (dataItem.dirty) {\r\n\t                                item.__state__ = \"update\";\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t                    state.push(item);\r\n\t                }\r\n\r\n\t                return state;\r\n\t            }\r\n\r\n\t            if (this.options.offlineStorage != null) {\r\n\t                var state = items(this._data);\r\n\r\n\t                var destroyed = [];\r\n\r\n\t                for (var idx = 0; idx < this._destroyed.length; idx++) {\r\n\t                    var item = this._destroyed[idx].toJSON();\r\n\t                    item.__state__ = \"destroy\";\r\n\t                    destroyed.push(item);\r\n\t                }\r\n\r\n\t                this.offlineData(state.concat(destroyed));\r\n\r\n\t                if (updatePristine) {\r\n\t                    this._pristineData = this._readData(state);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _addRange: function(data, skip) {\r\n\t            var that = this,\r\n\t                start = typeof(skip) !== \"undefined\" ? skip : (that._skip || 0),\r\n\t                end = start + that._flatData(data, true).length;\r\n\r\n\t            that._ranges.push({ start: start, end: end, data: data, timestamp: new Date().getTime() });\r\n\t            that._ranges.sort( function(x, y) { return x.start - y.start; } );\r\n\t        },\r\n\r\n\t        error: function(xhr, status, errorThrown) {\r\n\t            this._dequeueRequest();\r\n\t            this.trigger(REQUESTEND, { });\r\n\t            this.trigger(ERROR, { xhr: xhr, status: status, errorThrown: errorThrown });\r\n\t        },\r\n\r\n\t        _params: function(data) {\r\n\t            var that = this,\r\n\t                options =  extend({\r\n\t                    take: that.take(),\r\n\t                    skip: that.skip(),\r\n\t                    page: that.page(),\r\n\t                    pageSize: that.pageSize(),\r\n\t                    sort: that._sort,\r\n\t                    filter: that._filter,\r\n\t                    group: that._group,\r\n\t                    aggregate: that._aggregate\r\n\t                }, data);\r\n\r\n\t            if (!that.options.serverPaging) {\r\n\t                delete options.take;\r\n\t                delete options.skip;\r\n\t                delete options.page;\r\n\t                delete options.pageSize;\r\n\t            }\r\n\r\n\t            if (!that.options.serverGrouping) {\r\n\t                delete options.group;\r\n\t            } else if (that.reader.model && options.group) {\r\n\t                options.group = convertDescriptorsField(options.group, that.reader.model);\r\n\t            }\r\n\r\n\t            if (!that.options.serverFiltering) {\r\n\t                delete options.filter;\r\n\t            } else if (that.reader.model && options.filter) {\r\n\t               options.filter = convertFilterDescriptorsField(options.filter, that.reader.model);\r\n\t            }\r\n\r\n\t            if (!that.options.serverSorting) {\r\n\t                delete options.sort;\r\n\t            } else if (that.reader.model && options.sort) {\r\n\t                options.sort = convertDescriptorsField(options.sort, that.reader.model);\r\n\t            }\r\n\r\n\t            if (!that.options.serverAggregates) {\r\n\t                delete options.aggregate;\r\n\t            } else if (that.reader.model && options.aggregate) {\r\n\t                options.aggregate = convertDescriptorsField(options.aggregate, that.reader.model);\r\n\t            }\r\n\r\n\t            return options;\r\n\t        },\r\n\r\n\t        _queueRequest: function(options, callback) {\r\n\t            var that = this;\r\n\t            if (!that._requestInProgress) {\r\n\t                that._requestInProgress = true;\r\n\t                that._pending = undefined;\r\n\t                callback();\r\n\t            } else {\r\n\t                that._pending = { callback: proxy(callback, that), options: options };\r\n\t            }\r\n\t        },\r\n\r\n\t        _dequeueRequest: function() {\r\n\t            var that = this;\r\n\t            that._requestInProgress = false;\r\n\t            if (that._pending) {\r\n\t                that._queueRequest(that._pending.options, that._pending.callback);\r\n\t            }\r\n\t        },\r\n\r\n\t        _handleCustomErrors: function(response) {\r\n\t            if (this.reader.errors) {\r\n\t                var errors = this.reader.errors(response);\r\n\t                if (errors) {\r\n\t                    this.trigger(ERROR, { xhr: null, status: \"customerror\", errorThrown: \"custom error\", errors: errors });\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t            return false;\r\n\t        },\r\n\r\n\t        _shouldWrap: function(data) {\r\n\t            var model = this.reader.model;\r\n\r\n\t            if (model && data.length) {\r\n\t                return !(data[0] instanceof model);\r\n\t            }\r\n\r\n\t            return false;\r\n\t        },\r\n\r\n\t        _observe: function(data) {\r\n\t            var that = this,\r\n\t                model = that.reader.model;\r\n\r\n\t            that._shouldDetachObservableParents = true;\r\n\r\n\t            if (data instanceof ObservableArray) {\r\n\t                that._shouldDetachObservableParents = false;\r\n\t                if (that._shouldWrap(data)) {\r\n\t                    data.type = that.reader.model;\r\n\t                    data.wrapAll(data, data);\r\n\t                }\r\n\t            } else {\r\n\t                var arrayType = that.pageSize() && !that.options.serverPaging ? LazyObservableArray : ObservableArray;\r\n\t                data = new arrayType(data, that.reader.model);\r\n\t                data.parent = function() { return that.parent(); };\r\n\t            }\r\n\r\n\t            if (that._isServerGrouped()) {\r\n\t                wrapGroupItems(data, model);\r\n\t            }\r\n\r\n\t            if (that._changeHandler && that._data && that._data instanceof ObservableArray) {\r\n\t                that._data.unbind(CHANGE, that._changeHandler);\r\n\t            } else {\r\n\t                that._changeHandler = proxy(that._change, that);\r\n\t            }\r\n\r\n\t            return data.bind(CHANGE, that._changeHandler);\r\n\t        },\r\n\r\n\t        _updateTotalForAction: function(action, items) {\r\n\t            var that = this;\r\n\r\n\t            var total = parseInt(that._total, 10);\r\n\r\n\t            if (!isNumber(that._total)) {\r\n\t                total = parseInt(that._pristineTotal, 10);\r\n\t            }\r\n\t            if (action === \"add\") {\r\n\t                total += items.length;\r\n\t            } else if (action === \"remove\") {\r\n\t                total -= items.length;\r\n\t            } else if (action !== \"itemchange\" && action !== \"sync\" && !that.options.serverPaging) {\r\n\t                total = that._pristineTotal;\r\n\t            } else if (action === \"sync\") {\r\n\t                total = that._pristineTotal = parseInt(that._total, 10);\r\n\t            }\r\n\r\n\t            that._total = total;\r\n\t        },\r\n\r\n\t        _change: function(e) {\r\n\t            var that = this, idx, length, action = e ? e.action : \"\";\r\n\r\n\t            if (action === \"remove\") {\r\n\t                for (idx = 0, length = e.items.length; idx < length; idx++) {\r\n\t                    if (!e.items[idx].isNew || !e.items[idx].isNew()) {\r\n\t                        that._destroyed.push(e.items[idx]);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            if (that.options.autoSync && (action === \"add\" || action === \"remove\" || action === \"itemchange\")) {\r\n\r\n\t                var handler = function(args) {\r\n\t                    if (args.action === \"sync\") {\r\n\t                        that.unbind(\"change\", handler);\r\n\t                        that._updateTotalForAction(action, e.items);\r\n\t                    }\r\n\t                };\r\n\r\n\t                that.first(\"change\", handler);\r\n\r\n\t                that.sync();\r\n\r\n\t            } else {\r\n\t                that._updateTotalForAction(action, e ? e.items : []);\r\n\r\n\t                that._process(that._data, e);\r\n\t            }\r\n\t        },\r\n\r\n\t        _calculateAggregates: function (data, options) {\r\n\t            options = options || {};\r\n\r\n\t            var query = new Query(data),\r\n\t                aggregates = options.aggregate,\r\n\t                filter = options.filter;\r\n\r\n\t            if (filter) {\r\n\t                query = query.filter(filter);\r\n\t            }\r\n\r\n\t            return query.aggregate(aggregates);\r\n\t        },\r\n\r\n\t        _process: function (data, e) {\r\n\t            var that = this,\r\n\t                options = {},\r\n\t                result;\r\n\r\n\t            if (that.options.serverPaging !== true) {\r\n\t                options.skip = that._skip;\r\n\t                options.take = that._take || that._pageSize;\r\n\r\n\t                if(options.skip === undefined && that._page !== undefined && that._pageSize !== undefined) {\r\n\t                    options.skip = (that._page - 1) * that._pageSize;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (that.options.serverSorting !== true) {\r\n\t                options.sort = that._sort;\r\n\t            }\r\n\r\n\t            if (that.options.serverFiltering !== true) {\r\n\t                options.filter = that._filter;\r\n\t            }\r\n\r\n\t            if (that.options.serverGrouping !== true) {\r\n\t                options.group = that._group;\r\n\t            }\r\n\r\n\t            if (that.options.serverAggregates !== true) {\r\n\t                options.aggregate = that._aggregate;\r\n\t                that._aggregateResult = that._calculateAggregates(data, options);\r\n\t            }\r\n\r\n\t            result = that._queryProcess(data, options);\r\n\r\n\t            that.view(result.data);\r\n\r\n\t            if (result.total !== undefined && !that.options.serverFiltering) {\r\n\t                that._total = result.total;\r\n\t            }\r\n\r\n\t            e = e || {};\r\n\r\n\t            e.items = e.items || that._view;\r\n\r\n\t            that.trigger(CHANGE, e);\r\n\t        },\r\n\r\n\t        _queryProcess: function(data, options) {\r\n\t            if (this.options.inPlaceSort) {\r\n\t                return Query.process(data, options, this.options.inPlaceSort);\r\n\t            }\r\n\t            else {\r\n\t                return Query.process(data, options);\r\n\t            }\r\n\t        },\r\n\r\n\t        _mergeState: function(options) {\r\n\t            var that = this;\r\n\r\n\t            if (options !== undefined) {\r\n\t                that._pageSize = options.pageSize;\r\n\t                that._page = options.page;\r\n\t                that._sort = options.sort;\r\n\t                that._filter = options.filter;\r\n\t                that._group = options.group;\r\n\t                that._aggregate = options.aggregate;\r\n\t                that._skip = that._currentRangeStart = options.skip;\r\n\t                that._take = options.take;\r\n\r\n\t                if(that._skip === undefined) {\r\n\t                    that._skip = that._currentRangeStart = that.skip();\r\n\t                    options.skip = that.skip();\r\n\t                }\r\n\r\n\t                if(that._take === undefined && that._pageSize !== undefined) {\r\n\t                    that._take = that._pageSize;\r\n\t                    options.take = that._take;\r\n\t                }\r\n\r\n\t                if (options.sort) {\r\n\t                    that._sort = options.sort = normalizeSort(options.sort);\r\n\t                }\r\n\r\n\t                if (options.filter) {\r\n\t                    that._filter = options.filter = normalizeFilter(options.filter);\r\n\t                }\r\n\r\n\t                if (options.group) {\r\n\t                    that._group = options.group = normalizeGroup(options.group);\r\n\t                }\r\n\t                if (options.aggregate) {\r\n\t                    that._aggregate = options.aggregate = normalizeAggregate(options.aggregate);\r\n\t                }\r\n\t            }\r\n\t            return options;\r\n\t        },\r\n\r\n\t        query: function(options) {\r\n\t            var result;\r\n\t            var remote = this.options.serverSorting || this.options.serverPaging || this.options.serverFiltering || this.options.serverGrouping || this.options.serverAggregates;\r\n\r\n\t            if (remote || ((this._data === undefined || this._data.length === 0) && !this._destroyed.length)) {\r\n\t                if (this.options.endless) {\r\n\t                    var moreItemsCount = options.pageSize - this.pageSize();\r\n\t                    if (moreItemsCount > 0) {\r\n\t                        moreItemsCount = this.pageSize();\r\n\t                        options.page = options.pageSize / moreItemsCount;\r\n\t                        options.pageSize = moreItemsCount;\r\n\t                    } else {\r\n\t                        options.page = 1;\r\n\t                        this.options.endless = false;\r\n\t                    }\r\n\t                }\r\n\t                return this.read(this._mergeState(options));\r\n\t            }\r\n\r\n\t            var isPrevented = this.trigger(REQUESTSTART, { type: \"read\" });\r\n\t            if (!isPrevented) {\r\n\t                this.trigger(PROGRESS);\r\n\r\n\t                result = this._queryProcess(this._data, this._mergeState(options));\r\n\r\n\t                if (!this.options.serverFiltering) {\r\n\t                    if (result.total !== undefined) {\r\n\t                        this._total = result.total;\r\n\t                    } else {\r\n\t                        this._total = this._data.length;\r\n\t                    }\r\n\t                }\r\n\r\n\t                this._aggregateResult = this._calculateAggregates(this._data, options);\r\n\t                this.view(result.data);\r\n\t                this.trigger(REQUESTEND, { type: \"read\" });\r\n\t                this.trigger(CHANGE, { items: result.data });\r\n\t            }\r\n\r\n\t            return $.Deferred().resolve(isPrevented).promise();\r\n\t        },\r\n\r\n\t        fetch: function(callback) {\r\n\t            var that = this;\r\n\t            var fn = function(isPrevented) {\r\n\t                if (isPrevented !== true && isFunction(callback)) {\r\n\t                    callback.call(that);\r\n\t                }\r\n\t            };\r\n\r\n\t            return this._query().then(fn);\r\n\t        },\r\n\r\n\t        _query: function(options) {\r\n\t            var that = this;\r\n\r\n\t            return that.query(extend({}, {\r\n\t                page: that.page(),\r\n\t                pageSize: that.pageSize(),\r\n\t                sort: that.sort(),\r\n\t                filter: that.filter(),\r\n\t                group: that.group(),\r\n\t                aggregate: that.aggregate()\r\n\t            }, options));\r\n\t        },\r\n\r\n\t        next: function(options) {\r\n\t            var that = this,\r\n\t                page = that.page(),\r\n\t                total = that.total();\r\n\r\n\t            options = options || {};\r\n\r\n\t            if (!page || (total && page + 1 > that.totalPages())) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            that._skip = that._currentRangeStart = page * that.take();\r\n\r\n\t            page += 1;\r\n\t            options.page = page;\r\n\r\n\t            that._query(options);\r\n\r\n\t            return page;\r\n\t        },\r\n\r\n\t        prev: function(options) {\r\n\t            var that = this,\r\n\t                page = that.page();\r\n\r\n\t            options = options || {};\r\n\r\n\t            if (!page || page === 1) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            that._skip = that._currentRangeStart = that._skip - that.take();\r\n\r\n\t            page -= 1;\r\n\t            options.page = page;\r\n\r\n\t            that._query(options);\r\n\r\n\t            return page;\r\n\t        },\r\n\r\n\t        page: function(val) {\r\n\t            var that = this,\r\n\t            skip;\r\n\r\n\t            if(val !== undefined) {\r\n\t                val = math.max(math.min(math.max(val, 1), that.totalPages()), 1);\r\n\t                that._query({ page: val });\r\n\t                return;\r\n\t            }\r\n\t            skip = that.skip();\r\n\r\n\t            return skip !== undefined ? math.round((skip || 0) / (that.take() || 1)) + 1 : undefined;\r\n\t        },\r\n\r\n\t        pageSize: function(val) {\r\n\t            var that = this;\r\n\r\n\t            if (val !== undefined) {\r\n\t                that._query({ pageSize: val, page: 1 });\r\n\t                return;\r\n\t            }\r\n\r\n\t            return that.take();\r\n\t        },\r\n\r\n\t        sort: function(val) {\r\n\t            var that = this;\r\n\r\n\t            if(val !== undefined) {\r\n\t                that._query({ sort: val });\r\n\t                return;\r\n\t            }\r\n\r\n\t            return that._sort;\r\n\t        },\r\n\r\n\t        filter: function(val) {\r\n\t            var that = this;\r\n\r\n\t            if (val === undefined) {\r\n\t                return that._filter;\r\n\t            }\r\n\r\n\t            that.trigger(\"reset\");\r\n\t            that._query({ filter: val, page: 1 });\r\n\t        },\r\n\r\n\t        group: function(val) {\r\n\t            var that = this;\r\n\r\n\t            if(val !== undefined) {\r\n\t                that._query({ group: val });\r\n\t                return;\r\n\t            }\r\n\r\n\t            return that._group;\r\n\t        },\r\n\r\n\t        total: function() {\r\n\t            return parseInt(this._total || 0, 10);\r\n\t        },\r\n\r\n\t        aggregate: function(val) {\r\n\t            var that = this;\r\n\r\n\t            if(val !== undefined) {\r\n\t                that._query({ aggregate: val });\r\n\t                return;\r\n\t            }\r\n\r\n\t            return that._aggregate;\r\n\t        },\r\n\r\n\t        aggregates: function() {\r\n\t            var result = this._aggregateResult;\r\n\r\n\t            if (isEmptyObject(result)) {\r\n\t                result = this._emptyAggregates(this.aggregate());\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        _emptyAggregates: function(aggregates) {\r\n\t            var result = {};\r\n\r\n\t            if (!isEmptyObject(aggregates)) {\r\n\t                var aggregate = {};\r\n\r\n\t                if (!isArray(aggregates)){\r\n\t                    aggregates = [aggregates];\r\n\t                }\r\n\r\n\t                for (var idx = 0; idx <aggregates.length; idx++) {\r\n\t                    aggregate[aggregates[idx].aggregate] = 0;\r\n\t                    result[aggregates[idx].field] = aggregate;\r\n\t                }\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        _wrapInEmptyGroup: function(model) {\r\n\t            var groups = this.group(),\r\n\t                parent,\r\n\t                group,\r\n\t                idx,\r\n\t                length;\r\n\r\n\t            for (idx = groups.length-1, length = 0; idx >= length; idx--) {\r\n\t                group = groups[idx];\r\n\t                parent = {\r\n\t                    value: model.get(group.field),\r\n\t                    field: group.field,\r\n\t                    items: parent ? [parent] : [model],\r\n\t                    hasSubgroups: !!parent,\r\n\t                    aggregates: this._emptyAggregates(group.aggregates)\r\n\t                };\r\n\t            }\r\n\r\n\t            return parent;\r\n\t        },\r\n\r\n\t        totalPages: function() {\r\n\t            var that = this,\r\n\t            pageSize = that.pageSize() || that.total();\r\n\r\n\t            return math.ceil((that.total() || 0) / pageSize);\r\n\t        },\r\n\r\n\t        inRange: function(skip, take) {\r\n\t            var that = this,\r\n\t                end = math.min(skip + take, that.total());\r\n\r\n\t            if (!that.options.serverPaging && that._data.length > 0) {\r\n\t                return true;\r\n\t            }\r\n\r\n\t            return that._findRange(skip, end).length > 0;\r\n\t        },\r\n\r\n\t        lastRange: function() {\r\n\t            var ranges = this._ranges;\r\n\t            return ranges[ranges.length - 1] || { start: 0, end: 0, data: [] };\r\n\t        },\r\n\r\n\t        firstItemUid: function() {\r\n\t            var ranges = this._ranges;\r\n\t            return ranges.length && ranges[0].data.length && ranges[0].data[0].uid;\r\n\t        },\r\n\r\n\t        enableRequestsInProgress: function() {\r\n\t            this._skipRequestsInProgress = false;\r\n\t        },\r\n\r\n\t        _timeStamp: function() {\r\n\t            return new Date().getTime();\r\n\t        },\r\n\r\n\t        range: function(skip, take, callback) {\r\n\t            this._currentRequestTimeStamp = this._timeStamp();\r\n\t            this._skipRequestsInProgress = true;\r\n\r\n\t            skip = math.min(skip || 0, this.total());\r\n\r\n\t            var that = this,\r\n\t                pageSkip = math.max(math.floor(skip / take), 0) * take,\r\n\t                size = math.min(pageSkip + take, that.total()),\r\n\t                data;\r\n\r\n\t            data = that._findRange(skip, math.min(skip + take, that.total()));\r\n\r\n\t            if (data.length) {\r\n\r\n\t                that._pending = undefined;\r\n\r\n\t                that._skip = skip > that.skip() ? math.min(size, (that.totalPages() - 1) * that.take()) : pageSkip;\r\n\r\n\t                that._currentRangeStart = skip;\r\n\r\n\t                that._take = take;\r\n\r\n\t                var paging = that.options.serverPaging;\r\n\t                var sorting = that.options.serverSorting;\r\n\t                var filtering = that.options.serverFiltering;\r\n\t                var aggregates = that.options.serverAggregates;\r\n\t                try {\r\n\t                    that.options.serverPaging = true;\r\n\t                    if (!that._isServerGrouped() && !(that.group() && that.group().length)) {\r\n\t                        that.options.serverSorting = true;\r\n\t                    }\r\n\t                    that.options.serverFiltering = true;\r\n\t                    that.options.serverPaging = true;\r\n\t                    that.options.serverAggregates = true;\r\n\r\n\t                    if (paging) {\r\n\t                        that._detachObservableParents();\r\n\t                        that._data = data = that._observe(data);\r\n\t                    }\r\n\t                    that._process(data);\r\n\t                } finally {\r\n\t                    that.options.serverPaging = paging;\r\n\t                    that.options.serverSorting = sorting;\r\n\t                    that.options.serverFiltering = filtering;\r\n\t                    that.options.serverAggregates = aggregates;\r\n\t                }\r\n\r\n\t                if (isFunction(callback)) {\r\n\t                    callback();\r\n\t                }\r\n\r\n\t                return;\r\n\t            }\r\n\r\n\t            if (take !== undefined) {\r\n\t                if (!that._rangeExists(pageSkip, size)) {\r\n\t                    that.prefetch(pageSkip, take, function() {\r\n\t                        if (skip > pageSkip && size < that.total() && !that._rangeExists(size, math.min(size + take, that.total()))) {\r\n\t                            that.prefetch(size, take, function() {\r\n\t                                that.range(skip, take, callback );\r\n\t                            });\r\n\t                        } else {\r\n\t                            that.range(skip, take, callback);\r\n\t                        }\r\n\t                    });\r\n\t                } else if (pageSkip < skip) {\r\n\t                    that.prefetch(size, take, function() {\r\n\t                        that.range(skip, take, callback );\r\n\t                    });\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _findRange: function(start, end) {\r\n\t            var that = this,\r\n\t                ranges = that._ranges,\r\n\t                range,\r\n\t                data = [],\r\n\t                skipIdx,\r\n\t                takeIdx,\r\n\t                startIndex,\r\n\t                endIndex,\r\n\t                rangeData,\r\n\t                rangeEnd,\r\n\t                processed,\r\n\t                options = that.options,\r\n\t                remote = options.serverSorting || options.serverPaging || options.serverFiltering || options.serverGrouping || options.serverAggregates,\r\n\t                flatData,\r\n\t                count,\r\n\t                length;\r\n\r\n\t            for (skipIdx = 0, length = ranges.length; skipIdx < length; skipIdx++) {\r\n\t                range = ranges[skipIdx];\r\n\t                if (start >= range.start && start <= range.end) {\r\n\t                    count = 0;\r\n\r\n\t                    for (takeIdx = skipIdx; takeIdx < length; takeIdx++) {\r\n\t                        range = ranges[takeIdx];\r\n\t                        flatData = that._flatData(range.data, true);\r\n\r\n\t                        if (flatData.length && start + count >= range.start) {\r\n\t                            rangeData = range.data;\r\n\t                            rangeEnd = range.end;\r\n\r\n\t                            if (!remote) {\r\n\t                                if (options.inPlaceSort) {\r\n\t                                    processed = that._queryProcess(range.data, { filter: that.filter() });\r\n\t                                } else {\r\n\t                                    var sort = normalizeGroup(that.group() || []).concat(normalizeSort(that.sort() || []));\r\n\t                                    processed = that._queryProcess(range.data, { sort: sort, filter: that.filter() });\r\n\t                                }\r\n\t                                flatData = rangeData = processed.data;\r\n\r\n\t                                if (processed.total !== undefined) {\r\n\t                                    rangeEnd = processed.total;\r\n\t                                }\r\n\t                            }\r\n\r\n\t                            startIndex = 0;\r\n\t                            if (start + count > range.start) {\r\n\t                                startIndex = (start + count) - range.start;\r\n\t                            }\r\n\t                            endIndex = flatData.length;\r\n\t                            if (rangeEnd > end) {\r\n\t                                endIndex = endIndex - (rangeEnd - end);\r\n\t                            }\r\n\t                            count += endIndex - startIndex;\r\n\t                            data = that._mergeGroups(data, rangeData, startIndex, endIndex);\r\n\r\n\t                            if (end <= range.end && count == end - start) {\r\n\t                                return data;\r\n\t                            }\r\n\t                        }\r\n\t                    }\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            return [];\r\n\t        },\r\n\r\n\t        _mergeGroups: function(data, range, skip, take) {\r\n\t            if (this._isServerGrouped()) {\r\n\t                var temp = range.toJSON(),\r\n\t                    prevGroup;\r\n\r\n\t                if (data.length) {\r\n\t                    prevGroup = data[data.length - 1];\r\n\t                }\r\n\r\n\t                mergeGroups(prevGroup, temp, skip, take);\r\n\r\n\t                return data.concat(temp);\r\n\t            }\r\n\t            return data.concat(range.slice(skip, take));\r\n\t        },\r\n\r\n\t        skip: function() {\r\n\t            var that = this;\r\n\r\n\t            if (that._skip === undefined) {\r\n\t                return (that._page !== undefined ? (that._page  - 1) * (that.take() || 1) : undefined);\r\n\t            }\r\n\t            return that._skip;\r\n\t        },\r\n\r\n\t        currentRangeStart: function() {\r\n\t            return this._currentRangeStart || 0;\r\n\t        },\r\n\r\n\t        take: function() {\r\n\t            return this._take || this._pageSize;\r\n\t        },\r\n\r\n\t        _prefetchSuccessHandler: function (skip, size, callback, force) {\r\n\t            var that = this;\r\n\t            var timestamp = that._timeStamp();\r\n\r\n\t            return function(data) {\r\n\t                var found = false,\r\n\t                    range = { start: skip, end: size, data: [], timestamp: that._timeStamp() },\r\n\t                    idx,\r\n\t                    length,\r\n\t                    temp;\r\n\r\n\t                that._dequeueRequest();\r\n\r\n\t                that.trigger(REQUESTEND, { response: data, type: \"read\" });\r\n\r\n\t                data = that.reader.parse(data);\r\n\r\n\t                temp = that._readData(data);\r\n\r\n\t                if (temp.length) {\r\n\r\n\t                    for (idx = 0, length = that._ranges.length; idx < length; idx++) {\r\n\t                        if (that._ranges[idx].start === skip) {\r\n\t                            found = true;\r\n\t                            range = that._ranges[idx];\r\n\t                            break;\r\n\t                        }\r\n\t                    }\r\n\t                    if (!found) {\r\n\t                        that._ranges.push(range);\r\n\t                    }\r\n\t                }\r\n\r\n\t                range.data = that._observe(temp);\r\n\t                range.end = range.start + that._flatData(range.data, true).length;\r\n\t                that._ranges.sort( function(x, y) { return x.start - y.start; } );\r\n\t                that._total = that.reader.total(data);\r\n\r\n\t                if (force || (timestamp >= that._currentRequestTimeStamp || !that._skipRequestsInProgress)) {\r\n\t                    if (callback && temp.length) {\r\n\t                        callback();\r\n\t                    } else {\r\n\t                        that.trigger(CHANGE, {});\r\n\t                    }\r\n\t                }\r\n\t            };\r\n\t        },\r\n\r\n\t        prefetch: function(skip, take, callback) {\r\n\t            var that = this,\r\n\t                size = math.min(skip + take, that.total()),\r\n\t                options = {\r\n\t                    take: take,\r\n\t                    skip: skip,\r\n\t                    page: skip / take + 1,\r\n\t                    pageSize: take,\r\n\t                    sort: that._sort,\r\n\t                    filter: that._filter,\r\n\t                    group: that._group,\r\n\t                    aggregate: that._aggregate\r\n\t                };\r\n\r\n\t            if (!that._rangeExists(skip, size)) {\r\n\t                clearTimeout(that._timeout);\r\n\r\n\t                that._timeout = setTimeout(function() {\r\n\t                    that._queueRequest(options, function() {\r\n\t                        if (!that.trigger(REQUESTSTART, { type: \"read\" })) {\r\n\t                            that.transport.read({\r\n\t                                data: that._params(options),\r\n\t                                success: that._prefetchSuccessHandler(skip, size, callback),\r\n\t                                error: function() {\r\n\t                                    var args = slice.call(arguments);\r\n\t                                    that.error.apply(that, args);\r\n\t                                }\r\n\t                            });\r\n\t                        } else {\r\n\t                            that._dequeueRequest();\r\n\t                        }\r\n\t                    });\r\n\t                }, 100);\r\n\t            } else if (callback) {\r\n\t                callback();\r\n\t            }\r\n\t        },\r\n\r\n\t        _multiplePrefetch: function(skip, take, callback) {\r\n\t            var that = this,\r\n\t                size = math.min(skip + take, that.total()),\r\n\t                options = {\r\n\t                    take: take,\r\n\t                    skip: skip,\r\n\t                    page: skip / take + 1,\r\n\t                    pageSize: take,\r\n\t                    sort: that._sort,\r\n\t                    filter: that._filter,\r\n\t                    group: that._group,\r\n\t                    aggregate: that._aggregate\r\n\t                };\r\n\r\n\t            if (!that._rangeExists(skip, size)) {\r\n\t                if (!that.trigger(REQUESTSTART, { type: \"read\" })) {\r\n\t                    that.transport.read({\r\n\t                        data: that._params(options),\r\n\t                        success: that._prefetchSuccessHandler(skip, size, callback, true)\r\n\t                    });\r\n\t                }\r\n\t            } else if (callback) {\r\n\t                callback();\r\n\t            }\r\n\t        },\r\n\r\n\t        _rangeExists: function(start, end) {\r\n\t            var that = this,\r\n\t                ranges = that._ranges,\r\n\t                idx,\r\n\t                length;\r\n\r\n\t            for (idx = 0, length = ranges.length; idx < length; idx++) {\r\n\t                if (ranges[idx].start <= start && ranges[idx].end >= end) {\r\n\t                    return true;\r\n\t                }\r\n\t            }\r\n\t            return false;\r\n\t        },\r\n\r\n\t        _removeModelFromRanges: function(model) {\r\n\t            var that = this;\r\n\t            var result,\r\n\t                found,\r\n\t                range;\r\n\r\n\t            for (var idx = 0, length = this._ranges.length; idx < length; idx++) {\r\n\t                range = this._ranges[idx];\r\n\r\n\t                this._eachItem(range.data, function(items) {\r\n\t                    if (that.options.useRanges && !that.options.serverPaging) {\r\n\t                        result = removeModel(items, model, that.currentRangeStart(), that.take());\r\n\t                    } else {\r\n\t                        result = removeModel(items, model);\r\n\t                    }\r\n\r\n\t                    if (result) {\r\n\t                        found = true;\r\n\t                    }\r\n\t                });\r\n\r\n\t                if (found) {\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\r\n\t            that._updateRangesLength();\r\n\t        },\r\n\r\n\t        _insertModelInRange: function(index, model) {\r\n\t            var that = this;\r\n\t            var ranges = that._ranges || [];\r\n\t            var rangesLength = ranges.length;\r\n\t            var range;\r\n\t            var i;\r\n\r\n\t            for (i = 0; i < rangesLength; i++) {\r\n\t                range = ranges[i];\r\n\r\n\t                if (range.start <= index && range.end >= index) {\r\n\t                    if (!that._getByUid(model.uid, range.data)) {\r\n\t                        if (that._isServerGrouped()) {\r\n\t                            range.data.splice(index, 0, that._wrapInEmptyGroup(model));\r\n\t                        } else {\r\n\t                            range.data.splice(index, 0, model);\r\n\t                        }\r\n\t                    }\r\n\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\r\n\t            that._updateRangesLength();\r\n\t        },\r\n\r\n\t        _updateRangesLength: function() {\r\n\t            var that = this;\r\n\t            var ranges = that._ranges || [];\r\n\t            var rangesLength = ranges.length;\r\n\t            var mismatchFound = false;\r\n\t            var mismatchLength = 0;\r\n\t            var lengthDifference = 0;\r\n\t            var range;\r\n\t            var i;\r\n\r\n\t            for (i = 0; i < rangesLength; i++) {\r\n\t                range = ranges[i];\r\n\t                lengthDifference = that._flatData(range.data, true).length - math.abs(range.end - range.start);\r\n\r\n\t                if (!mismatchFound && lengthDifference !== 0) {\r\n\t                    mismatchFound = true;\r\n\t                    mismatchLength = lengthDifference;\r\n\t                    range.end += mismatchLength;\r\n\t                    continue;\r\n\t                }\r\n\r\n\t                if (mismatchFound) {\r\n\t                    range.start += mismatchLength;\r\n\t                    range.end += mismatchLength;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    });\r\n\r\n\t    var Transport = {};\r\n\r\n\t    Transport.create = function(options, data, dataSource) {\r\n\t        var transport,\r\n\t            transportOptions = options.transport ? $.extend({}, options.transport) : null;\r\n\r\n\t        if (transportOptions) {\r\n\t            transportOptions.read = typeof transportOptions.read === STRING ? { url: transportOptions.read } : transportOptions.read;\r\n\r\n\t            if (options.type === \"jsdo\") {\r\n\t                transportOptions.dataSource = dataSource;\r\n\t            }\r\n\r\n\t            if (options.type) {\r\n\t                kendo.data.transports = kendo.data.transports || {};\r\n\t                kendo.data.schemas = kendo.data.schemas || {};\r\n\r\n\t                if (!kendo.data.transports[options.type]) {\r\n\t                    kendo.logToConsole(\"Unknown DataSource transport type '\" + options.type + \"'.\\nVerify that registration scripts for this type are included after Kendo UI on the page.\", \"warn\");\r\n\t                } else if (!isPlainObject(kendo.data.transports[options.type])) {\r\n\t                    transport = new kendo.data.transports[options.type](extend(transportOptions, { data: data }));\r\n\t                } else {\r\n\t                    transportOptions = extend(true, {}, kendo.data.transports[options.type], transportOptions);\r\n\t                }\r\n\r\n\t                options.schema = extend(true, {}, kendo.data.schemas[options.type], options.schema);\r\n\t            }\r\n\r\n\t            if (!transport) {\r\n\t                transport = isFunction(transportOptions.read) ? transportOptions : new RemoteTransport(transportOptions);\r\n\t            }\r\n\t        } else {\r\n\t            transport = new LocalTransport({ data: options.data || [] });\r\n\t        }\r\n\t        return transport;\r\n\t    };\r\n\r\n\t    DataSource.create = function(options) {\r\n\t        if (isArray(options) || options instanceof ObservableArray) {\r\n\t           options = { data: options };\r\n\t        }\r\n\r\n\t        var dataSource = options || {},\r\n\t            data = dataSource.data,\r\n\t            fields = dataSource.fields,\r\n\t            table = dataSource.table,\r\n\t            select = dataSource.select,\r\n\t            idx,\r\n\t            length,\r\n\t            model = {},\r\n\t            field;\r\n\r\n\t        if (!data && fields && !dataSource.transport) {\r\n\t            if (table) {\r\n\t                data = inferTable(table, fields);\r\n\t            } else if (select) {\r\n\t                data = inferSelect(select, fields);\r\n\r\n\t                if (dataSource.group === undefined && data[0] && data[0].optgroup !== undefined) {\r\n\t                    dataSource.group = \"optgroup\";\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (kendo.data.Model && fields && (!dataSource.schema || !dataSource.schema.model)) {\r\n\t            for (idx = 0, length = fields.length; idx < length; idx++) {\r\n\t                field = fields[idx];\r\n\t                if (field.type) {\r\n\t                    model[field.field] = field;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (!isEmptyObject(model)) {\r\n\t                dataSource.schema = extend(true, dataSource.schema, { model:  { fields: model } });\r\n\t            }\r\n\t        }\r\n\r\n\t        dataSource.data = data;\r\n\r\n\t        select = null;\r\n\t        dataSource.select = null;\r\n\t        table = null;\r\n\t        dataSource.table = null;\r\n\r\n\t        return dataSource instanceof DataSource ? dataSource : new DataSource(dataSource);\r\n\t    };\r\n\r\n\t    function inferSelect(select, fields) {\r\n\t        select = $(select)[0];\r\n\t        var options = select.options;\r\n\t        var firstField = fields[0];\r\n\t        var secondField = fields[1];\r\n\r\n\t        var data = [];\r\n\t        var idx, length;\r\n\t        var optgroup;\r\n\t        var option;\r\n\t        var record;\r\n\t        var value;\r\n\r\n\t        for (idx = 0, length = options.length; idx < length; idx++) {\r\n\t            record = {};\r\n\t            option = options[idx];\r\n\t            optgroup = option.parentNode;\r\n\r\n\t            if (optgroup === select) {\r\n\t                optgroup = null;\r\n\t            }\r\n\r\n\t            if (option.disabled || (optgroup && optgroup.disabled)) {\r\n\t                continue;\r\n\t            }\r\n\r\n\t            if (optgroup) {\r\n\t                record.optgroup = optgroup.label;\r\n\t            }\r\n\r\n\t            record[firstField.field] = option.text;\r\n\r\n\t            value = option.attributes.value;\r\n\r\n\t            if (value && value.specified) {\r\n\t                value = option.value;\r\n\t            } else {\r\n\t                value = option.text;\r\n\t            }\r\n\r\n\t            record[secondField.field] = value;\r\n\r\n\t            data.push(record);\r\n\t        }\r\n\r\n\t        return data;\r\n\t    }\r\n\r\n\t    function inferTable(table, fields) {\r\n\t        var tbody = $(table)[0].tBodies[0],\r\n\t        rows = tbody ? tbody.rows : [],\r\n\t        idx,\r\n\t        length,\r\n\t        fieldIndex,\r\n\t        fieldCount = fields.length,\r\n\t        data = [],\r\n\t        cells,\r\n\t        record,\r\n\t        cell,\r\n\t        empty;\r\n\r\n\t        for (idx = 0, length = rows.length; idx < length; idx++) {\r\n\t            record = {};\r\n\t            empty = true;\r\n\t            cells = rows[idx].cells;\r\n\r\n\t            for (fieldIndex = 0; fieldIndex < fieldCount; fieldIndex++) {\r\n\t                cell = cells[fieldIndex];\r\n\t                if(cell.nodeName.toLowerCase() !== \"th\") {\r\n\t                    empty = false;\r\n\t                    record[fields[fieldIndex].field] = cell.innerHTML;\r\n\t                }\r\n\t            }\r\n\t            if(!empty) {\r\n\t                data.push(record);\r\n\t            }\r\n\t        }\r\n\r\n\t        return data;\r\n\t    }\r\n\r\n\t    var Node = Model.define({\r\n\t        idField: \"id\",\r\n\r\n\t        init: function(value) {\r\n\t            var that = this,\r\n\t                hasChildren = that.hasChildren || value && value.hasChildren,\r\n\t                childrenField = \"items\",\r\n\t                childrenOptions = {};\r\n\r\n\t            kendo.data.Model.fn.init.call(that, value);\r\n\r\n\t            if (typeof that.children === STRING) {\r\n\t                childrenField = that.children;\r\n\t            }\r\n\r\n\t            childrenOptions = {\r\n\t                schema: {\r\n\t                    data: childrenField,\r\n\t                    model: {\r\n\t                        hasChildren: hasChildren,\r\n\t                        id: that.idField,\r\n\t                        fields: that.fields\r\n\t                    }\r\n\t                }\r\n\t            };\r\n\r\n\t            if (typeof that.children !== STRING) {\r\n\t                extend(childrenOptions, that.children);\r\n\t            }\r\n\r\n\t            childrenOptions.data = value;\r\n\r\n\t            if (!hasChildren) {\r\n\t                hasChildren = childrenOptions.schema.data;\r\n\t            }\r\n\r\n\t            if (typeof hasChildren === STRING) {\r\n\t                hasChildren = kendo.getter(hasChildren);\r\n\t            }\r\n\r\n\t            if (isFunction(hasChildren)) {\r\n\t                var hasChildrenObject = hasChildren.call(that, that);\r\n\r\n\t                if(hasChildrenObject && hasChildrenObject.length === 0){\r\n\t                    that.hasChildren = false;\r\n\t                } else{\r\n\t                    that.hasChildren = !!hasChildrenObject;\r\n\t                }\r\n\t            }\r\n\r\n\t            that._childrenOptions = childrenOptions;\r\n\r\n\t            if (that.hasChildren) {\r\n\t                that._initChildren();\r\n\t            }\r\n\r\n\t            that._loaded = !!(value && value._loaded);\r\n\t        },\r\n\r\n\t        _initChildren: function() {\r\n\t            var that = this;\r\n\t            var children, transport, parameterMap;\r\n\r\n\t            if (!(that.children instanceof HierarchicalDataSource)) {\r\n\t                children = that.children = new HierarchicalDataSource(that._childrenOptions);\r\n\r\n\t                transport = children.transport;\r\n\t                parameterMap = transport.parameterMap;\r\n\r\n\t                transport.parameterMap = function(data, type) {\r\n\t                    data[that.idField || \"id\"] = that.id;\r\n\r\n\t                    if (parameterMap) {\r\n\t                        data = parameterMap(data, type);\r\n\t                    }\r\n\r\n\t                    return data;\r\n\t                };\r\n\r\n\t                children.parent = function(){\r\n\t                    return that;\r\n\t                };\r\n\r\n\t                children.bind(CHANGE, function(e){\r\n\t                    e.node = e.node || that;\r\n\t                    that.trigger(CHANGE, e);\r\n\t                });\r\n\r\n\t                children.bind(ERROR, function(e){\r\n\t                    var collection = that.parent();\r\n\r\n\t                    if (collection) {\r\n\t                        e.node = e.node || that;\r\n\t                        collection.trigger(ERROR, e);\r\n\t                    }\r\n\t                });\r\n\r\n\t                that._updateChildrenField();\r\n\t            }\r\n\t        },\r\n\r\n\t        append: function(model) {\r\n\t            this._initChildren();\r\n\t            this.loaded(true);\r\n\t            this.children.add(model);\r\n\t        },\r\n\r\n\t        hasChildren: false,\r\n\r\n\t        level: function() {\r\n\t            var parentNode = this.parentNode(),\r\n\t                level = 0;\r\n\r\n\t            while (parentNode && parentNode.parentNode) {\r\n\t                level++;\r\n\t                parentNode = parentNode.parentNode ? parentNode.parentNode() : null;\r\n\t            }\r\n\r\n\t            return level;\r\n\t        },\r\n\r\n\t        _updateChildrenField: function() {\r\n\t            var fieldName = this._childrenOptions.schema.data;\r\n\r\n\t            this[fieldName || \"items\"] = this.children.data();\r\n\t        },\r\n\r\n\t        _childrenLoaded: function() {\r\n\t            this._loaded = true;\r\n\r\n\t            this._updateChildrenField();\r\n\t        },\r\n\r\n\t        load: function() {\r\n\t            var options = {};\r\n\t            var method = \"_query\";\r\n\t            var children, promise;\r\n\r\n\t            if (this.hasChildren) {\r\n\t                this._initChildren();\r\n\r\n\t                children = this.children;\r\n\r\n\t                options[this.idField || \"id\"] = this.id;\r\n\r\n\t                if (!this._loaded) {\r\n\t                    children._data = undefined;\r\n\t                    method = \"read\";\r\n\t                }\r\n\r\n\t                children.one(CHANGE, proxy(this._childrenLoaded, this));\r\n\r\n\t                if(this._matchFilter){\r\n\t                    options.filter = { field: '_matchFilter', operator: 'eq', value: true };\r\n\t                }\r\n\r\n\t                promise = children[method](options);\r\n\t            } else {\r\n\t                this.loaded(true);\r\n\t            }\r\n\r\n\t            return promise || $.Deferred().resolve().promise();\r\n\t        },\r\n\r\n\t        parentNode: function() {\r\n\t            var array = this.parent();\r\n\r\n\t            return array.parent();\r\n\t        },\r\n\r\n\t        loaded: function(value) {\r\n\t            if (value !== undefined) {\r\n\t                this._loaded = value;\r\n\t            } else {\r\n\t                return this._loaded;\r\n\t            }\r\n\t        },\r\n\r\n\t        shouldSerialize: function(field) {\r\n\t            return Model.fn.shouldSerialize.call(this, field) &&\r\n\t                    field !== \"children\" &&\r\n\t                    field !== \"_loaded\" &&\r\n\t                    field !== \"hasChildren\" &&\r\n\t                    field !== \"_childrenOptions\";\r\n\t        }\r\n\t    });\r\n\r\n\t    function dataMethod(name) {\r\n\t        return function() {\r\n\t            var data = this._data,\r\n\t                result = DataSource.fn[name].apply(this, slice.call(arguments));\r\n\r\n\t            if (this._data != data) {\r\n\t                this._attachBubbleHandlers();\r\n\t            }\r\n\r\n\t            return result;\r\n\t        };\r\n\t    }\r\n\r\n\t    var HierarchicalDataSource = DataSource.extend({\r\n\t        init: function(options) {\r\n\t            var node = Node.define({\r\n\t                children: options\r\n\t            });\r\n\r\n\t            if(options.filter && !options.serverFiltering){\r\n\t                this._hierarchicalFilter = options.filter;\r\n\t                options.filter = null;\r\n\t            }\r\n\r\n\t            DataSource.fn.init.call(this, extend(true, {}, { schema: { modelBase: node, model: node } }, options));\r\n\r\n\t            this._attachBubbleHandlers();\r\n\t        },\r\n\r\n\t        _attachBubbleHandlers: function() {\r\n\t            var that = this;\r\n\r\n\t            that._data.bind(ERROR, function(e) {\r\n\t                that.trigger(ERROR, e);\r\n\t            });\r\n\t        },\r\n\r\n\t        read: function(data) {\r\n\t            var result = DataSource.fn.read.call(this, data);\r\n\r\n\t            if(this._hierarchicalFilter){\r\n\t                if(this._data && this._data.length > 0){\r\n\t                    this.filter(this._hierarchicalFilter);\r\n\t                }else{\r\n\t                    this.options.filter = this._hierarchicalFilter;\r\n\t                    this._filter = normalizeFilter(this.options.filter);\r\n\t                    this._hierarchicalFilter = null;\r\n\t                }\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        remove: function(node){\r\n\t            var parentNode = node.parentNode(),\r\n\t                dataSource = this,\r\n\t                result;\r\n\r\n\t            if (parentNode && parentNode._initChildren) {\r\n\t                dataSource = parentNode.children;\r\n\t            }\r\n\r\n\t            result = DataSource.fn.remove.call(dataSource, node);\r\n\r\n\t            if (parentNode && !dataSource.data().length) {\r\n\t                parentNode.hasChildren = false;\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        success: dataMethod(\"success\"),\r\n\r\n\t        data: dataMethod(\"data\"),\r\n\r\n\t        insert: function(index, model) {\r\n\t            var parentNode = this.parent();\r\n\r\n\t            if (parentNode && parentNode._initChildren) {\r\n\t                parentNode.hasChildren = true;\r\n\t                parentNode._initChildren();\r\n\t            }\r\n\r\n\t            return DataSource.fn.insert.call(this, index, model);\r\n\t        },\r\n\r\n\t        filter: function(val) {\r\n\t            if (val === undefined) {\r\n\t                 return this._filter;\r\n\t            }\r\n\r\n\t            if(!this.options.serverFiltering && this._markHierarchicalQuery(val)){\r\n\t                val = { logic: \"or\", filters: [val, {field:'_matchFilter', operator: 'equals', value: true }]};\r\n\t            }\r\n\r\n\t            this.trigger(\"reset\");\r\n\t            this._query({ filter: val, page: 1 });\r\n\t        },\r\n\r\n\t        _markHierarchicalQuery: function(expressions){\r\n\t            var compiled;\r\n\t            var predicate;\r\n\t            var fields;\r\n\t            var operators;\r\n\t            var filter;\r\n\r\n\t            expressions = normalizeFilter(expressions);\r\n\r\n\t            if (!expressions || expressions.filters.length === 0) {\r\n\t                this._updateHierarchicalFilter(function(){return true;});\r\n\t                return false;\r\n\t            }\r\n\r\n\t            compiled = Query.filterExpr(expressions);\r\n\t            fields = compiled.fields;\r\n\t            operators = compiled.operators;\r\n\r\n\t            predicate = filter = new Function(\"d, __f, __o\", \"return \" + compiled.expression);\r\n\r\n\t            if (fields.length || operators.length) {\r\n\t                filter = function(d) {\r\n\t                    return predicate(d, fields, operators);\r\n\t                };\r\n\t            }\r\n\r\n\t            this._updateHierarchicalFilter(filter);\r\n\t            return true;\r\n\t        },\r\n\r\n\t         _updateHierarchicalFilter: function(filter){\r\n\t            var current;\r\n\t            var data = this._data;\r\n\t            var result = false;\r\n\r\n\t            for (var idx = 0; idx < data.length; idx++) {\r\n\t                 current = data[idx];\r\n\r\n\t                 if(current.hasChildren){\r\n\t                     current._matchFilter = current.children._updateHierarchicalFilter(filter);\r\n\t                    if(!current._matchFilter){\r\n\t                        current._matchFilter = filter(current);\r\n\t                    }\r\n\t                }else{\r\n\t                    current._matchFilter = filter(current);\r\n\t                }\r\n\r\n\t                if(current._matchFilter){\r\n\t                    result = true;\r\n\t                }\r\n\t            }\r\n\t            return result;\r\n\t        },\r\n\r\n\t        _find: function(method, value) {\r\n\t            var idx, length, node, children;\r\n\t            var data = this._data;\r\n\r\n\t            if (!data) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            node = DataSource.fn[method].call(this, value);\r\n\r\n\t            if (node) {\r\n\t                return node;\r\n\t            }\r\n\r\n\t            data = this._flatData(this._data);\r\n\r\n\t            for (idx = 0, length = data.length; idx < length; idx++) {\r\n\t                children = data[idx].children;\r\n\r\n\t                if (!(children instanceof HierarchicalDataSource)) {\r\n\t                    continue;\r\n\t                }\r\n\r\n\t                node = children[method](value);\r\n\r\n\t                if (node) {\r\n\t                    return node;\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        get: function(id) {\r\n\t            return this._find(\"get\", id);\r\n\t        },\r\n\r\n\t        getByUid: function(uid) {\r\n\t            return this._find(\"getByUid\", uid);\r\n\t        }\r\n\t    });\r\n\r\n\t    function inferList(list, fields) {\r\n\t        var items = $(list).children(),\r\n\t            idx,\r\n\t            length,\r\n\t            data = [],\r\n\t            record,\r\n\t            textField = fields[0].field,\r\n\t            urlField = fields[1] && fields[1].field,\r\n\t            spriteCssClassField = fields[2] && fields[2].field,\r\n\t            imageUrlField = fields[3] && fields[3].field,\r\n\t            item,\r\n\t            id,\r\n\t            textChild,\r\n\t            className,\r\n\t            children;\r\n\r\n\t        function elements(collection, tagName) {\r\n\t            return collection.filter(tagName).add(collection.find(tagName));\r\n\t        }\r\n\r\n\t        for (idx = 0, length = items.length; idx < length; idx++) {\r\n\t            record = { _loaded: true };\r\n\t            item = items.eq(idx);\r\n\r\n\t            textChild = item[0].firstChild;\r\n\t            children = item.children();\r\n\t            list = children.filter(\"ul\");\r\n\t            children = children.filter(\":not(ul)\");\r\n\r\n\t            id = item.attr(\"data-id\");\r\n\r\n\t            if (id) {\r\n\t                record.id = id;\r\n\t            }\r\n\r\n\t            if (textChild) {\r\n\t                record[textField] = textChild.nodeType == 3 ? textChild.nodeValue : children.text();\r\n\t            }\r\n\r\n\t            if (urlField) {\r\n\t                record[urlField] = elements(children, \"a\").attr(\"href\");\r\n\t            }\r\n\r\n\t            if (imageUrlField) {\r\n\t                record[imageUrlField] = elements(children, \"img\").attr(\"src\");\r\n\t            }\r\n\r\n\t            if (spriteCssClassField) {\r\n\t                className = elements(children, \".k-sprite\").prop(\"className\");\r\n\t                record[spriteCssClassField] = className && $.trim(className.replace(\"k-sprite\", \"\"));\r\n\t            }\r\n\r\n\t            if (list.length) {\r\n\t                record.items = inferList(list.eq(0), fields);\r\n\t            }\r\n\r\n\t            if (item.attr(\"data-hasChildren\") == \"true\") {\r\n\t                record.hasChildren = true;\r\n\t            }\r\n\r\n\t            data.push(record);\r\n\t        }\r\n\r\n\t        return data;\r\n\t    }\r\n\r\n\t    HierarchicalDataSource.create = function(options) {\r\n\t        options = options && options.push ? { data: options } : options;\r\n\r\n\t        var dataSource = options || {},\r\n\t            data = dataSource.data,\r\n\t            fields = dataSource.fields,\r\n\t            list = dataSource.list;\r\n\r\n\t        if (data && data._dataSource) {\r\n\t            return data._dataSource;\r\n\t        }\r\n\r\n\t        if (!data && fields && !dataSource.transport) {\r\n\t            if (list) {\r\n\t                data = inferList(list, fields);\r\n\t            }\r\n\t        }\r\n\r\n\t        dataSource.data = data;\r\n\r\n\t        return dataSource instanceof HierarchicalDataSource ? dataSource : new HierarchicalDataSource(dataSource);\r\n\t    };\r\n\r\n\t    var Buffer = kendo.Observable.extend({\r\n\t        init: function(dataSource, viewSize, disablePrefetch) {\r\n\t            kendo.Observable.fn.init.call(this);\r\n\r\n\t            this._prefetching = false;\r\n\t            this.dataSource = dataSource;\r\n\t            this.prefetch = !disablePrefetch;\r\n\r\n\t            var buffer = this;\r\n\r\n\t            dataSource.bind(\"change\", function() {\r\n\t                buffer._change();\r\n\t            });\r\n\r\n\t            dataSource.bind(\"reset\", function() {\r\n\t                buffer._reset();\r\n\t            });\r\n\r\n\t            this._syncWithDataSource();\r\n\r\n\t            this.setViewSize(viewSize);\r\n\t        },\r\n\r\n\t        setViewSize: function(viewSize) {\r\n\t            this.viewSize = viewSize;\r\n\t            this._recalculate();\r\n\t        },\r\n\r\n\t        at: function(index)  {\r\n\t            var pageSize = this.pageSize,\r\n\t                itemPresent = true;\r\n\r\n\t            if (index >= this.total()) {\r\n\t                this.trigger(\"endreached\", {index: index });\r\n\t                return null;\r\n\t            }\r\n\r\n\t            if (!this.useRanges) {\r\n\t               return this.dataSource.view()[index];\r\n\t            }\r\n\t            if (this.useRanges) {\r\n\t                // out of range request\r\n\t                if (index < this.dataOffset || index >= this.skip + pageSize) {\r\n\t                    itemPresent = this.range(Math.floor(index / pageSize) * pageSize);\r\n\t                }\r\n\r\n\t                // prefetch\r\n\t                if (index === this.prefetchThreshold) {\r\n\t                    this._prefetch();\r\n\t                }\r\n\r\n\t                // mid-range jump - prefetchThreshold and nextPageThreshold may be equal, do not change to else if\r\n\t                if (index === this.midPageThreshold) {\r\n\t                    this.range(this.nextMidRange, true);\r\n\t                }\r\n\t                // next range jump\r\n\t                else if (index === this.nextPageThreshold) {\r\n\t                    this.range(this.nextFullRange);\r\n\t                }\r\n\t                // pull-back\r\n\t                else if (index === this.pullBackThreshold) {\r\n\t                    if (this.offset === this.skip) { // from full range to mid range\r\n\t                        this.range(this.previousMidRange);\r\n\t                    } else { // from mid range to full range\r\n\t                        this.range(this.previousFullRange);\r\n\t                    }\r\n\t                }\r\n\r\n\t                if (itemPresent) {\r\n\t                    return this.dataSource.at(index - this.dataOffset);\r\n\t                } else {\r\n\t                    this.trigger(\"endreached\", { index: index });\r\n\t                    return null;\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        indexOf: function(item) {\r\n\t            return this.dataSource.data().indexOf(item) + this.dataOffset;\r\n\t        },\r\n\r\n\t        total: function() {\r\n\t            return parseInt(this.dataSource.total(), 10);\r\n\t        },\r\n\r\n\t        next: function() {\r\n\t            var buffer = this,\r\n\t                pageSize = buffer.pageSize,\r\n\t                offset = buffer.skip - buffer.viewSize + pageSize,\r\n\t                pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize;\r\n\r\n\t            this.offset = offset;\r\n\t            this.dataSource.prefetch(pageSkip, pageSize, function() {\r\n\t                buffer._goToRange(offset, true);\r\n\t            });\r\n\t        },\r\n\r\n\t        range: function(offset, nextRange) {\r\n\t            if (this.offset === offset) {\r\n\t                return true;\r\n\t            }\r\n\r\n\t            var buffer = this,\r\n\t                pageSize = this.pageSize,\r\n\t                pageSkip = math.max(math.floor(offset / pageSize), 0) * pageSize,\r\n\t                dataSource = this.dataSource;\r\n\r\n\t            if (nextRange) {\r\n\t                pageSkip += pageSize;\r\n\t            }\r\n\r\n\t            if (dataSource.inRange(offset, pageSize)) {\r\n\t                this.offset = offset;\r\n\t                this._recalculate();\r\n\t                this._goToRange(offset);\r\n\t                return true;\r\n\t            } else if (this.prefetch) {\r\n\t                dataSource.prefetch(pageSkip, pageSize, function() {\r\n\t                    buffer.offset = offset;\r\n\t                    buffer._recalculate();\r\n\t                    buffer._goToRange(offset, true);\r\n\t                });\r\n\t                return false;\r\n\t            }\r\n\r\n\t            return true;\r\n\t        },\r\n\r\n\t        syncDataSource: function() {\r\n\t            var offset = this.offset;\r\n\t            this.offset = null;\r\n\t            this.range(offset);\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            this.unbind();\r\n\t        },\r\n\r\n\t        _prefetch: function() {\r\n\t            var buffer = this,\r\n\t                pageSize = this.pageSize,\r\n\t                prefetchOffset = this.skip + pageSize,\r\n\t                dataSource = this.dataSource;\r\n\r\n\t            if (!dataSource.inRange(prefetchOffset, pageSize) && !this._prefetching && this.prefetch) {\r\n\t                this._prefetching = true;\r\n\t                this.trigger(\"prefetching\", { skip: prefetchOffset, take: pageSize });\r\n\r\n\t                dataSource.prefetch(prefetchOffset, pageSize, function() {\r\n\t                    buffer._prefetching = false;\r\n\t                    buffer.trigger(\"prefetched\", { skip: prefetchOffset, take: pageSize });\r\n\t                });\r\n\t            }\r\n\t        },\r\n\r\n\t        _goToRange: function(offset, expanding) {\r\n\t            if (this.offset !== offset) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            this.dataOffset = offset;\r\n\t            this._expanding = expanding;\r\n\t            this.dataSource.range(offset, this.pageSize);\r\n\t            this.dataSource.enableRequestsInProgress();\r\n\t        },\r\n\r\n\t        _reset: function() {\r\n\t            this._syncPending = true;\r\n\t        },\r\n\r\n\t        _change: function() {\r\n\t            var dataSource = this.dataSource;\r\n\r\n\t            this.length = this.useRanges ? dataSource.lastRange().end : dataSource.view().length;\r\n\r\n\t            if (this._syncPending) {\r\n\t                this._syncWithDataSource();\r\n\t                this._recalculate();\r\n\t                this._syncPending = false;\r\n\t                this.trigger(\"reset\", { offset: this.offset });\r\n\t            }\r\n\r\n\t            this.trigger(\"resize\");\r\n\r\n\t            if (this._expanding) {\r\n\t                this.trigger(\"expand\");\r\n\t            }\r\n\r\n\t            delete this._expanding;\r\n\t        },\r\n\r\n\t        _syncWithDataSource: function() {\r\n\t            var dataSource = this.dataSource;\r\n\r\n\t            this._firstItemUid = dataSource.firstItemUid();\r\n\t            this.dataOffset = this.offset = dataSource.skip() || 0;\r\n\t            this.pageSize = dataSource.pageSize();\r\n\t            this.useRanges = dataSource.options.serverPaging;\r\n\t        },\r\n\r\n\t        _recalculate: function() {\r\n\t            var pageSize = this.pageSize,\r\n\t                offset = this.offset,\r\n\t                viewSize = this.viewSize,\r\n\t                skip = Math.ceil(offset / pageSize) * pageSize;\r\n\r\n\t            this.skip = skip;\r\n\t            this.midPageThreshold = skip + pageSize - 1;\r\n\t            this.nextPageThreshold = skip + viewSize - 1;\r\n\t            this.prefetchThreshold = skip + Math.floor(pageSize / 3 * 2);\r\n\t            this.pullBackThreshold = this.offset - 1;\r\n\r\n\t            this.nextMidRange = skip + pageSize - viewSize;\r\n\t            this.nextFullRange = skip;\r\n\t            this.previousMidRange = offset - viewSize;\r\n\t            this.previousFullRange = skip - pageSize;\r\n\t        }\r\n\t    });\r\n\r\n\t    var BatchBuffer = kendo.Observable.extend({\r\n\t        init: function(dataSource, batchSize) {\r\n\t            var batchBuffer = this;\r\n\r\n\t            kendo.Observable.fn.init.call(batchBuffer);\r\n\r\n\t            this.dataSource = dataSource;\r\n\t            this.batchSize = batchSize;\r\n\t            this._total = 0;\r\n\r\n\t            this.buffer = new Buffer(dataSource, batchSize * 3);\r\n\r\n\t            this.buffer.bind({\r\n\t                \"endreached\": function (e) {\r\n\t                    batchBuffer.trigger(\"endreached\", { index: e.index });\r\n\t                },\r\n\t                \"prefetching\": function (e) {\r\n\t                    batchBuffer.trigger(\"prefetching\", { skip: e.skip, take: e.take });\r\n\t                },\r\n\t                \"prefetched\": function (e) {\r\n\t                    batchBuffer.trigger(\"prefetched\", { skip: e.skip, take: e.take });\r\n\t                },\r\n\t                \"reset\": function () {\r\n\t                    batchBuffer._total = 0;\r\n\t                    batchBuffer.trigger(\"reset\");\r\n\t                },\r\n\t                \"resize\": function () {\r\n\t                    batchBuffer._total = Math.ceil(this.length / batchBuffer.batchSize);\r\n\t                    batchBuffer.trigger(\"resize\", { total: batchBuffer.total(), offset: this.offset });\r\n\t                }\r\n\t            });\r\n\t        },\r\n\r\n\t        syncDataSource: function() {\r\n\t            this.buffer.syncDataSource();\r\n\t        },\r\n\r\n\t        at: function(index) {\r\n\t            var buffer = this.buffer,\r\n\t                skip = index * this.batchSize,\r\n\t                take = this.batchSize,\r\n\t                view = [],\r\n\t                item;\r\n\r\n\t            if (buffer.offset > skip) {\r\n\t                buffer.at(buffer.offset - 1);\r\n\t            }\r\n\r\n\t            for (var i = 0; i < take; i++) {\r\n\t                item = buffer.at(skip + i);\r\n\r\n\t                if (item === null) {\r\n\t                    break;\r\n\t                }\r\n\r\n\t                view.push(item);\r\n\t            }\r\n\r\n\t            return view;\r\n\t        },\r\n\r\n\t        total: function() {\r\n\t            return this._total;\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            this.buffer.destroy();\r\n\t            this.unbind();\r\n\t        }\r\n\t    });\r\n\r\n\t    extend(true, kendo.data, {\r\n\t        readers: {\r\n\t            json: DataReader\r\n\t        },\r\n\t        Query: Query,\r\n\t        DataSource: DataSource,\r\n\t        HierarchicalDataSource: HierarchicalDataSource,\r\n\t        Node: Node,\r\n\t        ObservableObject: ObservableObject,\r\n\t        ObservableArray: ObservableArray,\r\n\t        LazyObservableArray: LazyObservableArray,\r\n\t        LocalTransport: LocalTransport,\r\n\t        RemoteTransport: RemoteTransport,\r\n\t        Cache: Cache,\r\n\t        DataReader: DataReader,\r\n\t        Model: Model,\r\n\t        Buffer: Buffer,\r\n\t        BatchBuffer: BatchBuffer\r\n\t    });\r\n\t})(window.kendo.jQuery);\r\n\r\n\treturn window.kendo;\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ }),\n\n/***/ 1028:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo.data.odata\");\n\n/***/ }),\n\n/***/ 1029:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo.data.xml\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.data.js\n// module id = 464\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1321);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 993:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo.core\");\n\n/***/ }),\n\n/***/ 1321:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(993) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"userevents\",\r\n\t    name: \"User Events\",\r\n\t    category: \"framework\",\r\n\t    depends: [ \"core\" ],\r\n\t    hidden: true\r\n\t};\r\n\r\n\t(function ($, undefined) {\r\n\t    var kendo = window.kendo,\r\n\t        support = kendo.support,\r\n\t        Class = kendo.Class,\r\n\t        Observable = kendo.Observable,\r\n\t        now = $.now,\r\n\t        extend = $.extend,\r\n\t        OS = support.mobileOS,\r\n\t        invalidZeroEvents = OS && OS.android,\r\n\t        DEFAULT_MIN_HOLD = 800,\r\n\t        DEFAULT_THRESHOLD = support.browser.msie ? 5 : 0, // WP8 and W8 are very sensitive and always report move.\r\n\r\n\t        // UserEvents events\r\n\t        PRESS = \"press\",\r\n\t        HOLD = \"hold\",\r\n\t        SELECT = \"select\",\r\n\t        START = \"start\",\r\n\t        MOVE = \"move\",\r\n\t        END = \"end\",\r\n\t        CANCEL = \"cancel\",\r\n\t        TAP = \"tap\",\r\n\t        RELEASE = \"release\",\r\n\t        GESTURESTART = \"gesturestart\",\r\n\t        GESTURECHANGE = \"gesturechange\",\r\n\t        GESTUREEND = \"gestureend\",\r\n\t        GESTURETAP = \"gesturetap\";\r\n\r\n\t    var THRESHOLD = {\r\n\t        \"api\": 0,\r\n\t        \"touch\": 0,\r\n\t        \"mouse\": 9,\r\n\t        \"pointer\": 9\r\n\t    };\r\n\r\n\t    var ENABLE_GLOBAL_SURFACE = (!support.touch || support.mouseAndTouchPresent);\r\n\r\n\t    function touchDelta(touch1, touch2) {\r\n\t        var x1 = touch1.x.location,\r\n\t            y1 = touch1.y.location,\r\n\t            x2 = touch2.x.location,\r\n\t            y2 = touch2.y.location,\r\n\t            dx = x1 - x2,\r\n\t            dy = y1 - y2;\r\n\r\n\t        return {\r\n\t            center: {\r\n\t               x: (x1 + x2) / 2,\r\n\t               y: (y1 + y2) / 2\r\n\t            },\r\n\r\n\t            distance: Math.sqrt(dx*dx + dy*dy)\r\n\t        };\r\n\t    }\r\n\r\n\t    function getTouches(e) {\r\n\t        var touches = [],\r\n\t            originalEvent = e.originalEvent,\r\n\t            currentTarget = e.currentTarget,\r\n\t            idx = 0, length,\r\n\t            changedTouches,\r\n\t            touch;\r\n\r\n\t        if (e.api) {\r\n\t            touches.push({\r\n\t                id: 2,  // hardcoded ID for API call;\r\n\t                event: e,\r\n\t                target: e.target,\r\n\t                currentTarget: e.target,\r\n\t                location: e,\r\n\t                type: \"api\"\r\n\t            });\r\n\t        }\r\n\t        else if (e.type.match(/touch/)) {\r\n\t            changedTouches = originalEvent ? originalEvent.changedTouches : [];\r\n\t            for (length = changedTouches.length; idx < length; idx ++) {\r\n\t                touch = changedTouches[idx];\r\n\t                touches.push({\r\n\t                    location: touch,\r\n\t                    event: e,\r\n\t                    target: touch.target,\r\n\t                    currentTarget: currentTarget,\r\n\t                    id: touch.identifier,\r\n\t                    type: \"touch\"\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t        else if (support.pointers || support.msPointers) {\r\n\t            touches.push({\r\n\t                location: originalEvent,\r\n\t                event: e,\r\n\t                target: e.target,\r\n\t                currentTarget: currentTarget,\r\n\t                id: originalEvent.pointerId,\r\n\t                type: \"pointer\"\r\n\t            });\r\n\t        } else {\r\n\t            touches.push({\r\n\t                id: 1, // hardcoded ID for mouse event;\r\n\t                event: e,\r\n\t                target: e.target,\r\n\t                currentTarget: currentTarget,\r\n\t                location: e,\r\n\t                type: \"mouse\"\r\n\t            });\r\n\t        }\r\n\r\n\t        return touches;\r\n\t    }\r\n\r\n\t    var TouchAxis = Class.extend({\r\n\t        init: function(axis, location) {\r\n\t            var that = this;\r\n\r\n\t            that.axis = axis;\r\n\r\n\t            that._updateLocationData(location);\r\n\r\n\t            that.startLocation = that.location;\r\n\t            that.velocity = that.delta = 0;\r\n\t            that.timeStamp = now();\r\n\t        },\r\n\r\n\t        move: function(location) {\r\n\t            var that = this,\r\n\t                offset = location[\"page\" + that.axis],\r\n\t                timeStamp = now(),\r\n\t                timeDelta = (timeStamp - that.timeStamp) || 1; // Firing manually events in tests can make this 0;\r\n\r\n\t            if (!offset && invalidZeroEvents) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            that.delta = offset - that.location;\r\n\r\n\t            that._updateLocationData(location);\r\n\r\n\t            that.initialDelta = offset - that.startLocation;\r\n\t            that.velocity = that.delta / timeDelta;\r\n\t            that.timeStamp = timeStamp;\r\n\t        },\r\n\r\n\t        _updateLocationData: function(location) {\r\n\t            var that = this, axis = that.axis;\r\n\r\n\t            that.location = location[\"page\" + axis];\r\n\t            that.client = location[\"client\" + axis];\r\n\t            that.screen = location[\"screen\" + axis];\r\n\t        }\r\n\t    });\r\n\r\n\t    var Touch = Class.extend({\r\n\t        init: function(userEvents, target, touchInfo) {\r\n\t            extend(this, {\r\n\t                x: new TouchAxis(\"X\", touchInfo.location),\r\n\t                y: new TouchAxis(\"Y\", touchInfo.location),\r\n\t                type: touchInfo.type,\r\n\t                useClickAsTap: userEvents.useClickAsTap,\r\n\t                threshold: userEvents.threshold || THRESHOLD[touchInfo.type],\r\n\t                userEvents: userEvents,\r\n\t                target: target,\r\n\t                currentTarget: touchInfo.currentTarget,\r\n\t                initialTouch: touchInfo.target,\r\n\t                id: touchInfo.id,\r\n\t                pressEvent: touchInfo,\r\n\t                _moved: false,\r\n\t                _finished: false\r\n\t            });\r\n\t        },\r\n\r\n\t        press: function() {\r\n\t            this._holdTimeout = setTimeout($.proxy(this, \"_hold\"), this.userEvents.minHold);\r\n\t            this._trigger(PRESS, this.pressEvent);\r\n\t        },\r\n\r\n\t        _hold: function() {\r\n\t            this._trigger(HOLD, this.pressEvent);\r\n\t        },\r\n\r\n\t        move: function(touchInfo) {\r\n\t            var that = this;\r\n\r\n\t            if (that._finished) { return; }\r\n\r\n\t            that.x.move(touchInfo.location);\r\n\t            that.y.move(touchInfo.location);\r\n\r\n\t            if (!that._moved) {\r\n\t                if (that._withinIgnoreThreshold()) {\r\n\t                    return;\r\n\t                }\r\n\r\n\t                if (!UserEvents.current || UserEvents.current === that.userEvents) {\r\n\t                    that._start(touchInfo);\r\n\t                } else {\r\n\t                    return that.dispose();\r\n\t                }\r\n\t            }\r\n\r\n\t            // Event handlers may cancel the drag in the START event handler, hence the double check for pressed.\r\n\t            if (!that._finished) {\r\n\t                that._trigger(MOVE, touchInfo);\r\n\t            }\r\n\t        },\r\n\r\n\t        end: function(touchInfo) {\r\n\t            this.endTime = now();\r\n\r\n\t            if (this._finished) { return; }\r\n\r\n\t            // Mark the object as finished if there are blocking operations in the event handlers (alert/confirm)\r\n\t            this._finished = true;\r\n\r\n\t            this._trigger(RELEASE, touchInfo); // Release should be fired before TAP (as click is after mouseup/touchend)\r\n\r\n\t            if (this._moved) {\r\n\t                this._trigger(END, touchInfo);\r\n\t            } else {\r\n\t                if (!this.useClickAsTap) {\r\n\t                    this._trigger(TAP, touchInfo);\r\n\t                }\r\n\t            }\r\n\r\n\t            clearTimeout(this._holdTimeout);\r\n\r\n\t            this.dispose();\r\n\t        },\r\n\r\n\t        dispose: function() {\r\n\t            var userEvents = this.userEvents,\r\n\t                activeTouches = userEvents.touches;\r\n\r\n\t            this._finished = true;\r\n\t            this.pressEvent = null;\r\n\t            clearTimeout(this._holdTimeout);\r\n\r\n\t            activeTouches.splice($.inArray(this, activeTouches), 1);\r\n\t        },\r\n\r\n\t        skip: function() {\r\n\t            this.dispose();\r\n\t        },\r\n\r\n\t        cancel: function() {\r\n\t            this.dispose();\r\n\t        },\r\n\r\n\t        isMoved: function() {\r\n\t            return this._moved;\r\n\t        },\r\n\r\n\t        _start: function(touchInfo) {\r\n\t            clearTimeout(this._holdTimeout);\r\n\r\n\t            this.startTime = now();\r\n\t            this._moved = true;\r\n\t            this._trigger(START, touchInfo);\r\n\t        },\r\n\r\n\t        _trigger: function(name, touchInfo) {\r\n\t            var that = this,\r\n\t                jQueryEvent = touchInfo.event,\r\n\t                data = {\r\n\t                    touch: that,\r\n\t                    x: that.x,\r\n\t                    y: that.y,\r\n\t                    target: that.target,\r\n\t                    event: jQueryEvent\r\n\t                };\r\n\r\n\t            if(that.userEvents.notify(name, data)) {\r\n\t                jQueryEvent.preventDefault();\r\n\t            }\r\n\t        },\r\n\r\n\t        _withinIgnoreThreshold: function() {\r\n\t            var xDelta = this.x.initialDelta,\r\n\t                yDelta = this.y.initialDelta;\r\n\r\n\t            return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;\r\n\t        }\r\n\t    });\r\n\r\n\t    function withEachUpEvent(callback) {\r\n\t        var downEvents = kendo.eventMap.up.split(\" \"),\r\n\t            idx = 0,\r\n\t            length = downEvents.length;\r\n\r\n\t        for(; idx < length; idx ++) {\r\n\t            callback(downEvents[idx]);\r\n\t        }\r\n\t    }\r\n\r\n\t    var UserEvents = Observable.extend({\r\n\t        init: function(element, options) {\r\n\t            var that = this,\r\n\t                filter,\r\n\t                ns = kendo.guid();\r\n\r\n\t            options = options || {};\r\n\t            filter = that.filter = options.filter;\r\n\t            that.threshold = options.threshold || DEFAULT_THRESHOLD;\r\n\t            that.minHold = options.minHold || DEFAULT_MIN_HOLD;\r\n\t            that.touches = [];\r\n\t            that._maxTouches = options.multiTouch ? 2 : 1;\r\n\t            that.allowSelection = options.allowSelection;\r\n\t            that.captureUpIfMoved = options.captureUpIfMoved;\r\n\t            that.useClickAsTap = !options.fastTap && !support.delayedClick();\r\n\t            that.eventNS = ns;\r\n\r\n\t            element = $(element).handler(that);\r\n\t            Observable.fn.init.call(that);\r\n\r\n\t            extend(that, {\r\n\t                element: element,\r\n\t                // the touch events lock to the element anyway, so no need for the global setting\r\n\t                surface: options.global && ENABLE_GLOBAL_SURFACE ? $(element[0].ownerDocument.documentElement) : $(options.surface || element),\r\n\t                stopPropagation: options.stopPropagation,\r\n\t                pressed: false\r\n\t            });\r\n\r\n\t            that.surface.handler(that)\r\n\t                .on(kendo.applyEventMap(\"move\", ns), \"_move\")\r\n\t                .on(kendo.applyEventMap(\"up cancel\", ns), \"_end\");\r\n\r\n\t            element.on(kendo.applyEventMap(\"down\", ns), filter, \"_start\");\r\n\r\n\t            if (that.useClickAsTap) {\r\n\t                element.on(kendo.applyEventMap(\"click\", ns), filter, \"_click\");\r\n\t            }\r\n\r\n\t            if (support.pointers || support.msPointers) {\r\n\t                //touch-action:none will not work for IE10\r\n\t                if (support.browser.version < 11) {\r\n\t                    var defaultAction = \"pinch-zoom double-tap-zoom\";\r\n\t                    element.css(\"-ms-touch-action\", options.touchAction && options.touchAction != \"none\" ? defaultAction + \" \" + options.touchAction : defaultAction);\r\n\t                } else {\r\n\t                    element.css(\"touch-action\", options.touchAction || \"none\");\r\n\t                }\r\n\t            }\r\n\r\n\t            if (options.preventDragEvent) {\r\n\t                element.on(kendo.applyEventMap(\"dragstart\", ns), kendo.preventDefault);\r\n\t            }\r\n\r\n\t            element.on(kendo.applyEventMap(\"mousedown\", ns), filter, { root: element }, \"_select\");\r\n\r\n\t            if (that.captureUpIfMoved && support.eventCapture) {\r\n\t                var surfaceElement = that.surface[0],\r\n\t                    preventIfMovingProxy = $.proxy(that.preventIfMoving, that);\r\n\r\n\t                withEachUpEvent(function(eventName) {\r\n\t                    surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);\r\n\t                });\r\n\t            }\r\n\r\n\t            that.bind([\r\n\t            PRESS,\r\n\t            HOLD,\r\n\t            TAP,\r\n\t            START,\r\n\t            MOVE,\r\n\t            END,\r\n\t            RELEASE,\r\n\t            CANCEL,\r\n\t            GESTURESTART,\r\n\t            GESTURECHANGE,\r\n\t            GESTUREEND,\r\n\t            GESTURETAP,\r\n\t            SELECT\r\n\t            ], options);\r\n\t        },\r\n\r\n\t        preventIfMoving: function(e) {\r\n\t            if (this._isMoved()) {\r\n\t                e.preventDefault();\r\n\t            }\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            var that = this;\r\n\r\n\t            if (that._destroyed) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            that._destroyed = true;\r\n\r\n\t            if (that.captureUpIfMoved && support.eventCapture) {\r\n\t                var surfaceElement = that.surface[0];\r\n\t                withEachUpEvent(function(eventName) {\r\n\t                    surfaceElement.removeEventListener(eventName, that.preventIfMoving);\r\n\t                });\r\n\t            }\r\n\r\n\t            that.element.kendoDestroy(that.eventNS);\r\n\t            that.surface.kendoDestroy(that.eventNS);\r\n\t            that.element.removeData(\"handler\");\r\n\t            that.surface.removeData(\"handler\");\r\n\t            that._disposeAll();\r\n\r\n\t            that.unbind();\r\n\t            delete that.surface;\r\n\t            delete that.element;\r\n\t            delete that.currentTarget;\r\n\t        },\r\n\r\n\t        capture: function() {\r\n\t            UserEvents.current = this;\r\n\t        },\r\n\r\n\t        cancel: function() {\r\n\t            this._disposeAll();\r\n\t            this.trigger(CANCEL);\r\n\t        },\r\n\r\n\t        notify: function(eventName, data) {\r\n\t            var that = this,\r\n\t                touches = that.touches;\r\n\r\n\t            if (this._isMultiTouch()) {\r\n\t                switch(eventName) {\r\n\t                    case MOVE:\r\n\t                        eventName = GESTURECHANGE;\r\n\t                        break;\r\n\t                    case END:\r\n\t                        eventName = GESTUREEND;\r\n\t                        break;\r\n\t                    case TAP:\r\n\t                        eventName = GESTURETAP;\r\n\t                        break;\r\n\t                }\r\n\r\n\t                extend(data, {touches: touches}, touchDelta(touches[0], touches[1]));\r\n\t            }\r\n\r\n\t            return this.trigger(eventName, extend(data, {type: eventName}));\r\n\t        },\r\n\r\n\t        // API\r\n\t        press: function(x, y, target) {\r\n\t            this._apiCall(\"_start\", x, y, target);\r\n\t        },\r\n\r\n\t        move: function(x, y) {\r\n\t            this._apiCall(\"_move\", x, y);\r\n\t        },\r\n\r\n\t        end: function(x, y) {\r\n\t            this._apiCall(\"_end\", x, y);\r\n\t        },\r\n\r\n\t        _isMultiTouch: function() {\r\n\t            return this.touches.length > 1;\r\n\t        },\r\n\r\n\t        _maxTouchesReached: function() {\r\n\t            return this.touches.length >= this._maxTouches;\r\n\t        },\r\n\r\n\t        _disposeAll: function() {\r\n\t            var touches = this.touches;\r\n\t            while (touches.length > 0) {\r\n\t                touches.pop().dispose();\r\n\t            }\r\n\t        },\r\n\r\n\t        _isMoved: function() {\r\n\t            return $.grep(this.touches, function(touch) {\r\n\t                return touch.isMoved();\r\n\t            }).length;\r\n\t        },\r\n\r\n\t        _select: function(e) {\r\n\t           if (!this.allowSelection || this.trigger(SELECT, { event: e })) {\r\n\t               e.preventDefault();\r\n\t           }\r\n\t        },\r\n\r\n\t        _start: function(e) {\r\n\t            var that = this,\r\n\t                idx = 0,\r\n\t                filter = that.filter,\r\n\t                target,\r\n\t                touches = getTouches(e),\r\n\t                length = touches.length,\r\n\t                touch,\r\n\t                which = e.which;\r\n\r\n\t            if ((which && which > 1) || (that._maxTouchesReached())){\r\n\t                return;\r\n\t            }\r\n\r\n\t            UserEvents.current = null;\r\n\r\n\t            that.currentTarget = e.currentTarget;\r\n\r\n\t            if (that.stopPropagation) {\r\n\t                e.stopPropagation();\r\n\t            }\r\n\r\n\t            for (; idx < length; idx ++) {\r\n\t                if (that._maxTouchesReached()) {\r\n\t                    break;\r\n\t                }\r\n\r\n\t                touch = touches[idx];\r\n\r\n\t                if (filter) {\r\n\t                    target = $(touch.currentTarget); // target.is(filter) ? target : target.closest(filter, that.element);\r\n\t                } else {\r\n\t                    target = that.element;\r\n\t                }\r\n\r\n\t                if (!target.length) {\r\n\t                    continue;\r\n\t                }\r\n\r\n\t                touch = new Touch(that, target, touch);\r\n\t                that.touches.push(touch);\r\n\t                touch.press();\r\n\r\n\t                if (that._isMultiTouch()) {\r\n\t                    that.notify(\"gesturestart\", {});\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _move: function(e) {\r\n\t            this._eachTouch(\"move\", e);\r\n\t        },\r\n\r\n\t        _end: function(e) {\r\n\t            this._eachTouch(\"end\", e);\r\n\t        },\r\n\r\n\t        _click: function(e) {\r\n\t            var data = {\r\n\t                touch: {\r\n\t                    initialTouch: e.target,\r\n\t                    target: $(e.currentTarget),\r\n\t                    endTime: now(),\r\n\t                    x: {\r\n\t                        location: e.pageX,\r\n\t                        client: e.clientX\r\n\t                    },\r\n\t                    y: {\r\n\t                        location: e.pageY,\r\n\t                        client: e.clientY\r\n\t                    }\r\n\t                },\r\n\t                x: e.pageX,\r\n\t                y: e.pageY,\r\n\t                target: $(e.currentTarget),\r\n\t                event: e,\r\n\t                type: \"tap\"\r\n\t            };\r\n\r\n\t            if (this.trigger(\"tap\", data)) {\r\n\t                e.preventDefault();\r\n\t            }\r\n\t        },\r\n\r\n\t        _eachTouch: function(methodName, e) {\r\n\t            var that = this,\r\n\t                dict = {},\r\n\t                touches = getTouches(e),\r\n\t                activeTouches = that.touches,\r\n\t                idx,\r\n\t                touch,\r\n\t                touchInfo,\r\n\t                matchingTouch;\r\n\r\n\t            for (idx = 0; idx < activeTouches.length; idx ++) {\r\n\t                touch = activeTouches[idx];\r\n\t                dict[touch.id] = touch;\r\n\t            }\r\n\r\n\t            for (idx = 0; idx < touches.length; idx ++) {\r\n\t                touchInfo = touches[idx];\r\n\t                matchingTouch = dict[touchInfo.id];\r\n\r\n\t                if (matchingTouch) {\r\n\t                    matchingTouch[methodName](touchInfo);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _apiCall: function(type, x, y, target) {\r\n\t            this[type]({\r\n\t                api: true,\r\n\t                pageX: x,\r\n\t                pageY: y,\r\n\t                clientX: x,\r\n\t                clientY: y,\r\n\t                target: $(target || this.element)[0],\r\n\t                stopPropagation: $.noop,\r\n\t                preventDefault: $.noop\r\n\t            });\r\n\t        }\r\n\t    });\r\n\r\n\t    UserEvents.defaultThreshold = function(value) {\r\n\t        DEFAULT_THRESHOLD = value;\r\n\t    };\r\n\r\n\t    UserEvents.minHold = function(value) {\r\n\t        DEFAULT_MIN_HOLD = value;\r\n\t    };\r\n\r\n\t    kendo.getTouches = getTouches;\r\n\t    kendo.touchDelta = touchDelta;\r\n\t    kendo.UserEvents = UserEvents;\r\n\t })(window.kendo.jQuery);\r\n\r\n\treturn window.kendo;\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.userevents.js\n// module id = 465\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1240);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 993:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo.core\");\n\n/***/ }),\n\n/***/ 1240:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(993) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"popup\",\r\n\t    name: \"Pop-up\",\r\n\t    category: \"framework\",\r\n\t    depends: [ \"core\" ],\r\n\t    advanced: true\r\n\t};\r\n\r\n\t(function($, undefined) {\r\n\t    var kendo = window.kendo,\r\n\t        ui = kendo.ui,\r\n\t        Widget = ui.Widget,\r\n\t        Class = kendo.Class,\r\n\t        support = kendo.support,\r\n\t        getOffset = kendo.getOffset,\r\n\t        outerWidth = kendo._outerWidth,\r\n\t        outerHeight = kendo._outerHeight,\r\n\t        OPEN = \"open\",\r\n\t        CLOSE = \"close\",\r\n\t        DEACTIVATE = \"deactivate\",\r\n\t        ACTIVATE = \"activate\",\r\n\t        CENTER = \"center\",\r\n\t        LEFT = \"left\",\r\n\t        RIGHT = \"right\",\r\n\t        TOP = \"top\",\r\n\t        BOTTOM = \"bottom\",\r\n\t        ABSOLUTE = \"absolute\",\r\n\t        HIDDEN = \"hidden\",\r\n\t        BODY = \"body\",\r\n\t        LOCATION = \"location\",\r\n\t        POSITION = \"position\",\r\n\t        VISIBLE = \"visible\",\r\n\t        EFFECTS = \"effects\",\r\n\t        ACTIVE = \"k-state-active\",\r\n\t        ACTIVEBORDER = \"k-state-border\",\r\n\t        ACTIVEBORDERREGEXP = /k-state-border-(\\w+)/,\r\n\t        ACTIVECHILDREN = \".k-picker-wrap, .k-dropdown-wrap, .k-link\",\r\n\t        MOUSEDOWN = \"down\",\r\n\t        DOCUMENT_ELEMENT = $(document.documentElement),\r\n\t        proxy = $.proxy,\r\n\t        WINDOW = $(window),\r\n\t        SCROLL = \"scroll\",\r\n\t        cssPrefix = support.transitions.css,\r\n\t        TRANSFORM = cssPrefix + \"transform\",\r\n\t        extend = $.extend,\r\n\t        NS = \".kendoPopup\",\r\n\t        styles = [\"font-size\",\r\n\t                  \"font-family\",\r\n\t                  \"font-stretch\",\r\n\t                  \"font-style\",\r\n\t                  \"font-weight\",\r\n\t                  \"line-height\"];\r\n\r\n\t    function contains(container, target) {\r\n\t        if (!container || !target) {\r\n\t            return false;\r\n\t        }\r\n\t        return container === target || $.contains(container, target);\r\n\t    }\r\n\r\n\t    var Popup = Widget.extend({\r\n\t        init: function(element, options) {\r\n\t            var that = this, parentPopup;\r\n\r\n\t            options = options || {};\r\n\r\n\t            if (options.isRtl) {\r\n\t                options.origin = options.origin || BOTTOM + \" \" + RIGHT;\r\n\t                options.position = options.position || TOP + \" \" + RIGHT;\r\n\t            }\r\n\r\n\t            Widget.fn.init.call(that, element, options);\r\n\r\n\t            element = that.element;\r\n\t            options = that.options;\r\n\r\n\t            that.collisions = options.collision ? options.collision.split(\" \") : [];\r\n\t            that.downEvent = kendo.applyEventMap(MOUSEDOWN, kendo.guid());\r\n\r\n\t            if (that.collisions.length === 1) {\r\n\t                that.collisions.push(that.collisions[0]);\r\n\t            }\r\n\r\n\t            parentPopup = $(that.options.anchor).closest(\".k-popup,.k-group\").filter(\":not([class^=km-])\"); // When popup is in another popup, make it relative.\r\n\r\n\t            options.appendTo = $($(options.appendTo)[0] || parentPopup[0] || document.body);\r\n\r\n\t            that.element.hide()\r\n\t                .addClass(\"k-popup k-group k-reset\")\r\n\t                .toggleClass(\"k-rtl\", !!options.isRtl)\r\n\t                .css({ position : ABSOLUTE })\r\n\t                .appendTo(options.appendTo)\r\n\t                .attr(\"aria-hidden\", true)\r\n\t                .on(\"mouseenter\" + NS, function() {\r\n\t                    that._hovered = true;\r\n\t                })\r\n\t                .on(\"wheel\" + NS, function(e) {\r\n\t                    var scrollArea = $(this).find(\".k-list\").parent();\r\n\t                    if ((scrollArea.scrollTop() === 0 && e.originalEvent.deltaY < 0) ||\r\n\t                        (scrollArea.scrollTop() === scrollArea.prop('scrollHeight') - scrollArea.prop('offsetHeight') && e.originalEvent.deltaY > 0)) {\r\n\t                            e.preventDefault();\r\n\t                    }\r\n\t                })\r\n\t                .on(\"mouseleave\" + NS, function() {\r\n\t                    that._hovered = false;\r\n\t                });\r\n\r\n\t            that.wrapper = $();\r\n\r\n\t            if (options.animation === false) {\r\n\t                options.animation = { open: { effects: {} }, close: { hide: true, effects: {} } };\r\n\t            }\r\n\r\n\t            extend(options.animation.open, {\r\n\t                complete: function() {\r\n\t                    that.wrapper.css({ overflow: VISIBLE }); // Forcing refresh causes flickering in mobile.\r\n\t                    that._activated = true;\r\n\t                    that._trigger(ACTIVATE);\r\n\t                }\r\n\t            });\r\n\r\n\t            extend(options.animation.close, {\r\n\t                complete: function() {\r\n\t                    that._animationClose();\r\n\t                }\r\n\t            });\r\n\r\n\t            that._mousedownProxy = function(e) {\r\n\t                that._mousedown(e);\r\n\t            };\r\n\r\n\t            if (support.mobileOS.android) {\r\n\t                that._resizeProxy = function(e) {\r\n\t                    setTimeout(function() {\r\n\t                        that._resize(e);\r\n\t                    }, 600); //Logic from kendo.onResize\r\n\t                };\r\n\t            } else {\r\n\t                that._resizeProxy = function(e) {\r\n\t                    that._resize(e);\r\n\t                };\r\n\t            }\r\n\r\n\t            if (options.toggleTarget) {\r\n\t                $(options.toggleTarget).on(options.toggleEvent + NS, $.proxy(that.toggle, that));\r\n\t            }\r\n\t        },\r\n\r\n\t        events: [\r\n\t            OPEN,\r\n\t            ACTIVATE,\r\n\t            CLOSE,\r\n\t            DEACTIVATE\r\n\t        ],\r\n\r\n\t        options: {\r\n\t            name: \"Popup\",\r\n\t            toggleEvent: \"click\",\r\n\t            origin: BOTTOM + \" \" + LEFT,\r\n\t            position: TOP + \" \" + LEFT,\r\n\t            anchor: BODY,\r\n\t            appendTo: null,\r\n\t            collision: \"flip fit\",\r\n\t            viewport: window,\r\n\t            copyAnchorStyles: true,\r\n\t            autosize: false,\r\n\t            modal: false,\r\n\t            adjustSize: {\r\n\t                width: 0,\r\n\t                height: 0\r\n\t            },\r\n\t            animation: {\r\n\t                open: {\r\n\t                    effects: \"slideIn:down\",\r\n\t                    transition: true,\r\n\t                    duration: 200\r\n\t                },\r\n\t                close: { // if close animation effects are defined, they will be used instead of open.reverse\r\n\t                    duration: 100,\r\n\t                    hide: true\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _animationClose: function() {\r\n\t            var that = this;\r\n\t            var location = that.wrapper.data(LOCATION);\r\n\r\n\t            that.wrapper.hide();\r\n\r\n\t            if (location) {\r\n\t                that.wrapper.css(location);\r\n\t            }\r\n\r\n\t            if (that.options.anchor != BODY) {\r\n\t                that._hideDirClass();\r\n\t            }\r\n\r\n\t            that._closing = false;\r\n\t            that._trigger(DEACTIVATE);\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            var that = this,\r\n\t                options = that.options,\r\n\t                element = that.element.off(NS),\r\n\t                parent;\r\n\r\n\t            Widget.fn.destroy.call(that);\r\n\r\n\t            if (options.toggleTarget) {\r\n\t                $(options.toggleTarget).off(NS);\r\n\t            }\r\n\r\n\t            if (!options.modal) {\r\n\t                DOCUMENT_ELEMENT.unbind(that.downEvent, that._mousedownProxy);\r\n\t                that._toggleResize(false);\r\n\t            }\r\n\r\n\t            kendo.destroy(that.element.children());\r\n\t            element.removeData();\r\n\r\n\t            if (options.appendTo[0] === document.body) {\r\n\t                parent = element.parent(\".k-animation-container\");\r\n\r\n\t                if (parent[0]) {\r\n\t                    parent.remove();\r\n\t                } else {\r\n\t                    element.remove();\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        open: function(x, y) {\r\n\t            var that = this,\r\n\t                fixed = { isFixed: !isNaN(parseInt(y,10)), x: x, y: y },\r\n\t                element = that.element,\r\n\t                options = that.options,\r\n\t                animation, wrapper,\r\n\t                anchor = $(options.anchor),\r\n\t                mobile = element[0] && element.hasClass(\"km-widget\");\r\n\r\n\t            if (!that.visible()) {\r\n\t                if (options.copyAnchorStyles) {\r\n\t                    if (mobile && styles[0] == \"font-size\") {\r\n\t                        styles.shift();\r\n\t                    }\r\n\t                    element.css(kendo.getComputedStyles(anchor[0], styles));\r\n\t                }\r\n\r\n\t                if (element.data(\"animating\") || that._trigger(OPEN)) {\r\n\t                    return;\r\n\t                }\r\n\r\n\t                that._activated = false;\r\n\r\n\t                if (!options.modal) {\r\n\t                    DOCUMENT_ELEMENT.unbind(that.downEvent, that._mousedownProxy)\r\n\t                                .bind(that.downEvent, that._mousedownProxy);\r\n\r\n\t                    // this binding hangs iOS in editor\r\n\t                    // all elements in IE7/8 fire resize event, causing mayhem\r\n\t                    that._toggleResize(false);\r\n\t                    that._toggleResize(true);\r\n\t                }\r\n\r\n\t                that.wrapper = wrapper = kendo.wrap(element, options.autosize)\r\n\t                                        .css({\r\n\t                                            overflow: HIDDEN,\r\n\t                                            display: \"block\",\r\n\t                                            position: ABSOLUTE\r\n\t                                        })\r\n\t                                        .attr(\"aria-hidden\", false);\r\n\r\n\t                if (support.mobileOS.android) {\r\n\t                    wrapper.css(TRANSFORM, \"translatez(0)\"); // Android is VERY slow otherwise. Should be tested in other droids as well since it may cause blur.\r\n\t                }\r\n\r\n\t                wrapper.css(POSITION);\r\n\r\n\t                if ($(options.appendTo)[0] == document.body) {\r\n\t                    wrapper.css(TOP, \"-10000px\");\r\n\t                }\r\n\r\n\t                that.flipped = that._position(fixed);\r\n\t                animation = that._openAnimation();\r\n\r\n\t                if (options.anchor != BODY) {\r\n\t                    that._showDirClass(animation);\r\n\t                }\r\n\r\n\t                element.data(EFFECTS, animation.effects)\r\n\t                       .kendoStop(true)\r\n\t                       .kendoAnimate(animation)\r\n\t                       .attr(\"aria-hidden\", false);\r\n\t            }\r\n\t        },\r\n\r\n\t        _location: function(isFixed) {\r\n\t            var that = this,\r\n\t                element = that.element,\r\n\t                options = that.options,\r\n\t                wrapper,\r\n\t                anchor = $(options.anchor),\r\n\t                mobile = element[0] && element.hasClass(\"km-widget\");\r\n\r\n\t            if (options.copyAnchorStyles) {\r\n\t                if (mobile && styles[0] == \"font-size\") {\r\n\t                    styles.shift();\r\n\t                }\r\n\t                element.css(kendo.getComputedStyles(anchor[0], styles));\r\n\t            }\r\n\r\n\t            that.wrapper = wrapper = kendo.wrap(element, options.autosize)\r\n\t                                    .css({\r\n\t                                        overflow: HIDDEN,\r\n\t                                        display: \"block\",\r\n\t                                        position: ABSOLUTE\r\n\t                                    });\r\n\r\n\t            if (support.mobileOS.android) {\r\n\t                wrapper.css(TRANSFORM, \"translatez(0)\"); // Android is VERY slow otherwise. Should be tested in other droids as well since it may cause blur.\r\n\t            }\r\n\r\n\t            wrapper.css(POSITION);\r\n\r\n\t            if ($(options.appendTo)[0] == document.body) {\r\n\t                wrapper.css(TOP, \"-10000px\");\r\n\t            }\r\n\r\n\t            that._position(isFixed || {});\r\n\r\n\t            var offset = wrapper.offset();\r\n\t            return {\r\n\t                width: kendo._outerWidth(wrapper),\r\n\t                height: kendo._outerHeight(wrapper),\r\n\t                left: offset.left,\r\n\t                top: offset.top\r\n\t            };\r\n\t        },\r\n\r\n\t        _openAnimation: function() {\r\n\t            var animation = extend(true, {}, this.options.animation.open);\r\n\t            animation.effects = kendo.parseEffects(animation.effects, this.flipped);\r\n\r\n\t            return animation;\r\n\t        },\r\n\r\n\t        _hideDirClass: function() {\r\n\t            var anchor = $(this.options.anchor);\r\n\t            var direction = ((anchor.attr(\"class\") || \"\").match(ACTIVEBORDERREGEXP) || [\"\", \"down\"])[1];\r\n\t            var dirClass = ACTIVEBORDER + \"-\" + direction;\r\n\r\n\t            anchor\r\n\t                .removeClass(dirClass)\r\n\t                .children(ACTIVECHILDREN)\r\n\t                .removeClass(ACTIVE)\r\n\t                .removeClass(dirClass);\r\n\r\n\t            this.element.removeClass(ACTIVEBORDER + \"-\" + kendo.directions[direction].reverse);\r\n\t        },\r\n\r\n\t        _showDirClass: function(animation) {\r\n\t            var direction = animation.effects.slideIn ? animation.effects.slideIn.direction : \"down\";\r\n\t            var dirClass = ACTIVEBORDER + \"-\" + direction;\r\n\r\n\t            $(this.options.anchor)\r\n\t                .addClass(dirClass)\r\n\t                .children(ACTIVECHILDREN)\r\n\t                .addClass(ACTIVE)\r\n\t                .addClass(dirClass);\r\n\r\n\t            this.element.addClass(ACTIVEBORDER + \"-\" + kendo.directions[direction].reverse);\r\n\t        },\r\n\r\n\t        position: function() {\r\n\t            if (this.visible()) {\r\n\t                this.flipped = this._position();\r\n\t                //this._hideDirClass();\r\n\t                //this._showDirClass(this._openAnimation());\r\n\t            }\r\n\t        },\r\n\r\n\t        toggle: function() {\r\n\t            var that = this;\r\n\r\n\t            that[that.visible() ? CLOSE : OPEN]();\r\n\t        },\r\n\r\n\t        visible: function() {\r\n\t            return this.element.is(\":\" + VISIBLE);\r\n\t        },\r\n\r\n\t        close: function(skipEffects) {\r\n\t            var that = this,\r\n\t                options = that.options, wrap,\r\n\t                animation, openEffects, closeEffects;\r\n\r\n\t            if (that.visible()) {\r\n\t                wrap = (that.wrapper[0] ? that.wrapper : kendo.wrap(that.element).hide());\r\n\r\n\t                that._toggleResize(false);\r\n\r\n\t                if (that._closing || that._trigger(CLOSE)) {\r\n\t                    that._toggleResize(true);\r\n\t                    return;\r\n\t                }\r\n\r\n\t                // Close all inclusive popups.\r\n\t                that.element.find(\".k-popup\").each(function () {\r\n\t                    var that = $(this),\r\n\t                        popup = that.data(\"kendoPopup\");\r\n\r\n\t                    if (popup) {\r\n\t                        popup.close(skipEffects);\r\n\t                    }\r\n\t                });\r\n\r\n\t                DOCUMENT_ELEMENT.unbind(that.downEvent, that._mousedownProxy);\r\n\r\n\t                if (skipEffects) {\r\n\t                    animation = { hide: true, effects: {} };\r\n\t                } else {\r\n\t                    animation = extend(true, {}, options.animation.close);\r\n\t                    openEffects = that.element.data(EFFECTS);\r\n\t                    closeEffects = animation.effects;\r\n\r\n\t                    if (!closeEffects && !kendo.size(closeEffects) && openEffects && kendo.size(openEffects)) {\r\n\t                        animation.effects = openEffects;\r\n\t                        animation.reverse = true;\r\n\t                    }\r\n\r\n\t                    that._closing = true;\r\n\t                }\r\n\r\n\t                that.element\r\n\t                        .kendoStop(true)\r\n\t                        .attr(\"aria-hidden\", true);\r\n\t                wrap\r\n\t                    .css({ overflow: HIDDEN }) // stop callback will remove hidden overflow\r\n\t                    .attr(\"aria-hidden\", true);\r\n\t                that.element.kendoAnimate(animation);\r\n\r\n\t                if (skipEffects) {\r\n\t                    that._animationClose();\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _trigger: function(ev) {\r\n\t            return this.trigger(ev, { type: ev });\r\n\t        },\r\n\r\n\t        _resize: function(e) {\r\n\t            var that = this;\r\n\r\n\t            if (support.resize.indexOf(e.type) !== -1) {\r\n\t                clearTimeout(that._resizeTimeout);\r\n\t                that._resizeTimeout = setTimeout(function() {\r\n\t                    that._position();\r\n\t                    that._resizeTimeout = null;\r\n\t                }, 50);\r\n\t            } else {\r\n\t                if (!that._hovered || (that._activated && that.element.hasClass(\"k-list-container\"))) {\r\n\t                    that.close();\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _toggleResize: function(toggle) {\r\n\t            var method = toggle ? \"on\" : \"off\";\r\n\t            var eventNames = support.resize;\r\n\r\n\t            if (!(support.mobileOS.ios || support.mobileOS.android)) {\r\n\t                eventNames += \" \" + SCROLL;\r\n\t            }\r\n\r\n\t            this._scrollableParents()[method](SCROLL, this._resizeProxy);\r\n\t            WINDOW[method](eventNames, this._resizeProxy);\r\n\t        },\r\n\r\n\t        _mousedown: function(e) {\r\n\t            var that = this,\r\n\t                container = that.element[0],\r\n\t                options = that.options,\r\n\t                anchor = $(options.anchor)[0],\r\n\t                toggleTarget = options.toggleTarget,\r\n\t                target = kendo.eventTarget(e),\r\n\t                popup = $(target).closest(\".k-popup\"),\r\n\t                mobile = popup.parent().parent(\".km-shim\").length;\r\n\r\n\t            popup = popup[0];\r\n\t            if (!mobile && popup && popup !== that.element[0]){\r\n\t                return;\r\n\t            }\r\n\r\n\t            // This MAY result in popup not closing in certain cases.\r\n\t            if ($(e.target).closest(\"a\").data(\"rel\") === \"popover\") {\r\n\t                return;\r\n\t            }\r\n\r\n\t            if (!contains(container, target) && !contains(anchor, target) && !(toggleTarget && contains($(toggleTarget)[0], target))) {\r\n\t                that.close();\r\n\t            }\r\n\t        },\r\n\r\n\t        _fit: function(position, size, viewPortSize) {\r\n\t            var output = 0;\r\n\r\n\t            if (position + size > viewPortSize) {\r\n\t                output = viewPortSize - (position + size);\r\n\t            }\r\n\r\n\t            if (position < 0) {\r\n\t                output = -position;\r\n\t            }\r\n\r\n\t            return output;\r\n\t        },\r\n\r\n\t        _flip: function(offset, size, anchorSize, viewPortSize, origin, position, boxSize) {\r\n\t            var output = 0;\r\n\t                boxSize = boxSize || size;\r\n\r\n\t            if (position !== origin && position !== CENTER && origin !== CENTER) {\r\n\t                if (offset + boxSize > viewPortSize) {\r\n\t                    output += -(anchorSize + size);\r\n\t                }\r\n\r\n\t                if (offset + output < 0) {\r\n\t                    output += anchorSize + size;\r\n\t                }\r\n\t            }\r\n\t            return output;\r\n\t        },\r\n\r\n\t        _scrollableParents: function() {\r\n\t            return $(this.options.anchor)\r\n\t                       .parentsUntil(\"body\")\r\n\t                       .filter(function(index, element) {\r\n\t                           return kendo.isScrollable(element);\r\n\t                       });\r\n\t        },\r\n\r\n\t        _position: function(fixed) {\r\n\t            var that = this,\r\n\t                //element = that.element.css(POSITION, \"\"), /* fixes telerik/kendo-ui-core#790, comes from telerik/kendo#615 */\r\n\t                element = that.element,\r\n\t                wrapper = that.wrapper,\r\n\t                options = that.options,\r\n\t                viewport = $(options.viewport),\r\n\t                zoomLevel = support.zoomLevel(),\r\n\t                isWindow = !!((viewport[0] == window) && window.innerWidth && (zoomLevel <= 1.02)),\r\n\t                anchor = $(options.anchor),\r\n\t                origins = options.origin.toLowerCase().split(\" \"),\r\n\t                positions = options.position.toLowerCase().split(\" \"),\r\n\t                collisions = that.collisions,\r\n\t                siblingContainer, parents,\r\n\t                parentZIndex, zIndex = 10002,\r\n\t                idx = 0,\r\n\t                docEl = document.documentElement,\r\n\t                length, viewportOffset, viewportWidth, viewportHeight;\r\n\r\n\t            if (options.viewport === window) {\r\n\t                viewportOffset = {\r\n\t                    top: (window.pageYOffset || document.documentElement.scrollTop || 0),\r\n\t                    left: (window.pageXOffset || document.documentElement.scrollLeft || 0)\r\n\t                };\r\n\t            } else {\r\n\t                viewportOffset = viewport.offset();\r\n\t            }\r\n\r\n\t            if (isWindow) {\r\n\t                viewportWidth = window.innerWidth;\r\n\t                viewportHeight = window.innerHeight;\r\n\t            } else {\r\n\t                viewportWidth = viewport.width();\r\n\t                viewportHeight = viewport.height();\r\n\t            }\r\n\r\n\t            if (isWindow && docEl.scrollHeight - docEl.clientHeight > 0) {\r\n\t                 var sign = options.isRtl ? -1 : 1;\r\n\r\n\t                 viewportWidth -= sign * kendo.support.scrollbar();\r\n\t            }\r\n\r\n\t            siblingContainer = anchor.parents().filter(wrapper.siblings());\r\n\r\n\t            if (siblingContainer[0]) {\r\n\t                parentZIndex = Math.max(Number(siblingContainer.css(\"zIndex\")), 0);\r\n\r\n\t                // set z-index to be more than that of the container/sibling\r\n\t                // compensate with more units for window z-stack\r\n\t                if (parentZIndex) {\r\n\t                    zIndex = parentZIndex + 10;\r\n\t                } else {\r\n\t                    parents = anchor.parentsUntil(siblingContainer);\r\n\t                    for (length = parents.length; idx < length; idx++) {\r\n\t                        parentZIndex = Number($(parents[idx]).css(\"zIndex\"));\r\n\t                        if (parentZIndex && zIndex < parentZIndex) {\r\n\t                            zIndex = parentZIndex + 10;\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            wrapper.css(\"zIndex\", zIndex);\r\n\r\n\t            if (fixed && fixed.isFixed) {\r\n\t                wrapper.css({ left: fixed.x, top: fixed.y });\r\n\t            } else {\r\n\t                wrapper.css(that._align(origins, positions));\r\n\t            }\r\n\r\n\t            var pos = getOffset(wrapper, POSITION, anchor[0] === wrapper.offsetParent()[0]),\r\n\t                offset = getOffset(wrapper),\r\n\t                anchorParent = anchor.offsetParent().parent(\".k-animation-container,.k-popup,.k-group\"); // If the parent is positioned, get the current positions\r\n\r\n\t            if (anchorParent.length) {\r\n\t                pos = getOffset(wrapper, POSITION, true);\r\n\t                offset = getOffset(wrapper);\r\n\t            }\r\n\r\n\t            offset.top -= viewportOffset.top;\r\n\t            offset.left -= viewportOffset.left;\r\n\r\n\t            if (!that.wrapper.data(LOCATION)) { // Needed to reset the popup location after every closure - fixes the resize bugs.\r\n\t                wrapper.data(LOCATION, extend({}, pos));\r\n\t            }\r\n\r\n\t            var offsets = extend({}, offset),\r\n\t                location = extend({}, pos),\r\n\t                adjustSize = options.adjustSize;\r\n\r\n\t            if (collisions[0] === \"fit\") {\r\n\t                location.top += that._fit(offsets.top, outerHeight(wrapper) + adjustSize.height, viewportHeight / zoomLevel);\r\n\t            }\r\n\r\n\t            if (collisions[1] === \"fit\") {\r\n\t                location.left += that._fit(offsets.left, outerWidth(wrapper) + adjustSize.width, viewportWidth / zoomLevel);\r\n\t            }\r\n\r\n\t            var flipPos = extend({}, location);\r\n\t            var elementHeight = outerHeight(element);\r\n\t            var wrapperHeight =  outerHeight(wrapper);\r\n\r\n\t            if (!wrapper.height() && elementHeight) {\r\n\t                wrapperHeight = wrapperHeight + elementHeight;\r\n\t            }\r\n\r\n\t            if (collisions[0] === \"flip\") {\r\n\t                location.top += that._flip(offsets.top, elementHeight, outerHeight(anchor), viewportHeight / zoomLevel, origins[0], positions[0], wrapperHeight);\r\n\t            }\r\n\r\n\t            if (collisions[1] === \"flip\") {\r\n\t                location.left += that._flip(offsets.left, outerWidth(element), outerWidth(anchor), viewportWidth / zoomLevel, origins[1], positions[1], outerWidth(wrapper));\r\n\t            }\r\n\r\n\t            element.css(POSITION, ABSOLUTE);\r\n\t            wrapper.css(location);\r\n\r\n\t            return (location.left != flipPos.left || location.top != flipPos.top);\r\n\t        },\r\n\r\n\t        _align: function(origin, position) {\r\n\t            var that = this,\r\n\t                element = that.wrapper,\r\n\t                anchor = $(that.options.anchor),\r\n\t                verticalOrigin = origin[0],\r\n\t                horizontalOrigin = origin[1],\r\n\t                verticalPosition = position[0],\r\n\t                horizontalPosition = position[1],\r\n\t                anchorOffset = getOffset(anchor),\r\n\t                appendTo = $(that.options.appendTo),\r\n\t                appendToOffset,\r\n\t                width = outerWidth(element),\r\n\t                height = outerHeight(element) || outerHeight(element.children().first()),\r\n\t                anchorWidth = outerWidth(anchor),\r\n\t                anchorHeight = outerHeight(anchor),\r\n\t                top = anchorOffset.top,\r\n\t                left = anchorOffset.left,\r\n\t                round = Math.round;\r\n\r\n\t            if (appendTo[0] != document.body) {\r\n\t                appendToOffset = getOffset(appendTo);\r\n\t                top -= appendToOffset.top;\r\n\t                left -= appendToOffset.left;\r\n\t            }\r\n\r\n\r\n\t            if (verticalOrigin === BOTTOM) {\r\n\t                top += anchorHeight;\r\n\t            }\r\n\r\n\t            if (verticalOrigin === CENTER) {\r\n\t                top += round(anchorHeight / 2);\r\n\t            }\r\n\r\n\t            if (verticalPosition === BOTTOM) {\r\n\t                top -= height;\r\n\t            }\r\n\r\n\t            if (verticalPosition === CENTER) {\r\n\t                top -= round(height / 2);\r\n\t            }\r\n\r\n\t            if (horizontalOrigin === RIGHT) {\r\n\t                left += anchorWidth;\r\n\t            }\r\n\r\n\t            if (horizontalOrigin === CENTER) {\r\n\t                left += round(anchorWidth / 2);\r\n\t            }\r\n\r\n\t            if (horizontalPosition === RIGHT) {\r\n\t                left -= width;\r\n\t            }\r\n\r\n\t            if (horizontalPosition === CENTER) {\r\n\t                left -= round(width / 2);\r\n\t            }\r\n\r\n\t            return {\r\n\t                top: top,\r\n\t                left: left\r\n\t            };\r\n\t        }\r\n\t    });\r\n\r\n\t    ui.plugin(Popup);\r\n\r\n\t    var stableSort = kendo.support.stableSort;\r\n\t    var tabKeyTrapNS = \"kendoTabKeyTrap\";\r\n\t    var focusableNodesSelector = \"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex], *[contenteditable]\";\r\n\t    var TabKeyTrap = Class.extend({\r\n\t        init: function(element) {\r\n\t            this.element = $(element);\r\n\t            this.element.autoApplyNS(tabKeyTrapNS);\r\n\t        },\r\n\r\n\t        trap: function() {\r\n\t            this.element.on(\"keydown\", proxy(this._keepInTrap, this));\r\n\t        },\r\n\r\n\t        removeTrap: function() {\r\n\t            this.element.kendoDestroy(tabKeyTrapNS);\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            this.element.kendoDestroy(tabKeyTrapNS);\r\n\t            this.element = undefined;\r\n\t        },\r\n\r\n\t        shouldTrap: function () {\r\n\t            return true;\r\n\t        },\r\n\r\n\t        _keepInTrap: function(e) {\r\n\t            if (e.which !== 9 || !this.shouldTrap() || e.isDefaultPrevented()) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            var elements = this._focusableElements();\r\n\t            var sortedElements = this._sortFocusableElements(elements);\r\n\t            var next = this._nextFocusable(e, sortedElements);\r\n\r\n\t            this._focus(next);\r\n\r\n\t            e.preventDefault();\r\n\t        },\r\n\t        _focusableElements: function(){\r\n\t            var elements = this.element.find(focusableNodesSelector).filter(function(i, item){\r\n\t                return item.tabIndex >= 0 && $(item).is(':visible') && !$(item).is(':disabled');\r\n\t            });\r\n\r\n\t            if (this.element.is(\"[tabindex]\")) {\r\n\t                elements.push(this.element[0]);\r\n\t            }\r\n\r\n\t            return elements;\r\n\t        },\r\n\t        _sortFocusableElements: function(elements){\r\n\t            var sortedElements;\r\n\r\n\t            if (stableSort) {\r\n\t                sortedElements = elements.sort(function(prev, next) {\r\n\t                    return prev.tabIndex - next.tabIndex;\r\n\t                });\r\n\t            } else {\r\n\t                var attrName = \"__k_index\";\r\n\t                elements.each(function(i, item){\r\n\t                    item.setAttribute(attrName, i);\r\n\t                });\r\n\r\n\t                sortedElements = elements.sort(function(prev, next) {\r\n\t                    return prev.tabIndex === next.tabIndex ?\r\n\t                        parseInt(prev.getAttribute(attrName), 10) - parseInt(next.getAttribute(attrName), 10) :\r\n\t                        prev.tabIndex - next.tabIndex;\r\n\t                });\r\n\r\n\t                elements.removeAttr(attrName);\r\n\t            }\r\n\r\n\t            return sortedElements;\r\n\t        },\r\n\t        _nextFocusable: function(e, elements){\r\n\t            var count = elements.length;\r\n\t            var current = elements.index(e.target);\r\n\r\n\t            return elements.get((current + (e.shiftKey ? -1 : 1)) % count);\r\n\t        },\r\n\t        _focus: function(element){\r\n\t            element.focus();\r\n\t            if (element.nodeName == \"INPUT\" && element.setSelectionRange && this._haveSelectionRange(element)) {\r\n\t                element.setSelectionRange(0, element.value.length);\r\n\t            }\r\n\t        },\r\n\t        _haveSelectionRange: function(element){\r\n\t            var elementType = element.type.toLowerCase();\r\n\r\n\t            return elementType === \"text\" || elementType === \"search\" ||\r\n\t            elementType === \"url\" || elementType === \"tel\" ||\r\n\t            elementType === \"password\";\r\n\t        }\r\n\t    });\r\n\t    ui.Popup.TabKeyTrap = TabKeyTrap;\r\n\t})(window.kendo.jQuery);\r\n\r\n\r\n\r\n\treturn window.kendo;\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.popup.js\n// module id = 466\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(919);\n\tmodule.exports = __webpack_require__(919);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 919:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(920)], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function($) {\r\n\r\n\t    function createPromise() {\r\n\t        return $.Deferred();\r\n\t    }\r\n\r\n\t    function promiseAll(promises) {\r\n\t        return $.when.apply($, promises);\r\n\t    }\r\n\r\n\t    kendo.drawing.util = kendo.drawing.util || {};\r\n\t    kendo.deepExtend(kendo.drawing.util, {\r\n\t        createPromise: createPromise,\r\n\t        promiseAll: promiseAll\r\n\t    });\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\treturn window.kendo;\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 920:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../kendo.core\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/drawing/util.js\n// module id = 467\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(917);\n\tmodule.exports = __webpack_require__(917);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 910:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo-drawing\");\n\n/***/ }),\n\n/***/ 917:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(918), __webpack_require__(910) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function ($) {\r\n\r\n\t    var NS = \".kendo\";\r\n\t    var kendo = window.kendo;\r\n\t    var deepExtend = kendo.deepExtend;\r\n\t    var utils = kendo.drawing.util;\r\n\t    var defined = utils.defined;\r\n\t    var limitValue = utils.limitValue;\r\n\t    var eventCoordinates = utils.eventCoordinates;\r\n\t    var outerWidth = kendo._outerWidth;\r\n\t    var outerHeight = kendo._outerHeight;\r\n\t    var proxy = $.proxy;\r\n\r\n\t    var TOOLTIP_TEMPLATE = '<div class=\"k-tooltip\">' +\r\n\t            '<div class=\"k-tooltip-content\"></div>' +\r\n\t        '</div>';\r\n\t    var TOOLTIP_CLOSE_TEMPLATE = '<div class=\"k-tooltip-button\"><a href=\"\\\\#\" class=\"k-icon k-i-close\">close</a></div>';\r\n\r\n\t    var SurfaceTooltip = kendo.Class.extend({\r\n\t        init: function(surface, options) {\r\n\t            this.element = $(TOOLTIP_TEMPLATE);\r\n\t            this.content = this.element.children(\".k-tooltip-content\");\r\n\r\n\t            options = options || {};\r\n\r\n\t            this.options = deepExtend({}, this.options, this._tooltipOptions(options));\r\n\t            this.popupOptions = {\r\n\t                appendTo: options.appendTo,\r\n\t                animation: options.animation,\r\n\t                copyAnchorStyles: false,\r\n\t                collision: \"fit fit\"\r\n\t            };\r\n\r\n\t            this._openPopupHandler = $.proxy(this._openPopup, this);\r\n\r\n\t            this.surface = surface;\r\n\t            this._bindEvents();\r\n\t        },\r\n\r\n\t        options: {\r\n\t            position: \"top\",\r\n\t            showOn: \"mouseenter\",\r\n\t            offset: 7,\r\n\t            autoHide: true,\r\n\t            hideDelay: 0,\r\n\t            showAfter: 100\r\n\t        },\r\n\r\n\t        _bindEvents: function() {\r\n\t            this._showHandler = proxy(this._showEvent, this);\r\n\t            this._surfaceLeaveHandler = proxy(this._surfaceLeave, this);\r\n\t            this._mouseleaveHandler = proxy(this._mouseleave, this);\r\n\t            this._mousemoveHandler = proxy(this._mousemove, this);\r\n\r\n\t            this.surface.bind(\"click\", this._showHandler);\r\n\t            this.surface.bind(\"mouseenter\", this._showHandler);\r\n\t            this.surface.bind(\"mouseleave\", this._mouseleaveHandler);\r\n\t            this.surface.bind(\"mousemove\", this._mousemoveHandler);\r\n\r\n\t            this.surface.element.on(\"mouseleave\" + NS, this._surfaceLeaveHandler);\r\n\r\n\t            this.element.on(\"click\" + NS, \".k-tooltip-button\", proxy(this._hideClick, this));\r\n\t        },\r\n\r\n\t        getPopup: function() {\r\n\t            if (!this.popup) {\r\n\t                this.popup = new kendo.ui.Popup(this.element, this.popupOptions);\r\n\t            }\r\n\r\n\t            return this.popup;\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            var popup = this.popup;\r\n\r\n\t            this.surface.unbind(\"click\", this._showHandler);\r\n\t            this.surface.unbind(\"mouseenter\", this._showHandler);\r\n\t            this.surface.unbind(\"mouseleave\", this._mouseleaveHandler);\r\n\t            this.surface.unbind(\"mousemove\", this._mousemoveHandler);\r\n\r\n\t            this.surface.element.off(\"mouseleave\" + NS, this._surfaceLeaveHandler);\r\n\t            this.element.off(\"click\" + NS);\r\n\r\n\t            if (popup) {\r\n\t                popup.destroy();\r\n\t                delete this.popup;\r\n\t            }\r\n\t            delete this.popupOptions;\r\n\r\n\t            clearTimeout(this._timeout);\r\n\r\n\t            delete this.element;\r\n\t            delete this.content;\r\n\t            delete this.surface;\r\n\t        },\r\n\r\n\t        _tooltipOptions: function(options) {\r\n\t            options = options || {};\r\n\t            return {\r\n\t                position: options.position,\r\n\t                showOn: options.showOn,\r\n\t                offset: options.offset,\r\n\t                autoHide: options.autoHide,\r\n\t                width: options.width,\r\n\t                height: options.height,\r\n\t                content: options.content,\r\n\t                shared: options.shared,\r\n\t                hideDelay: options.hideDelay,\r\n\t                showAfter: options.showAfter\r\n\t            };\r\n\t        },\r\n\r\n\t        _tooltipShape: function(shape) {\r\n\t            while(shape && !shape.options.tooltip) {\r\n\t                shape = shape.parent;\r\n\t            }\r\n\t            return shape;\r\n\t        },\r\n\r\n\t        _updateContent: function(target, shape, options) {\r\n\t            var content = options.content;\r\n\t            if (kendo.isFunction(content)) {\r\n\t                content = content({\r\n\t                    element: shape,\r\n\t                    target: target\r\n\t                });\r\n\t            }\r\n\r\n\t            if (content) {\r\n\t                this.content.html(content);\r\n\t                return true;\r\n\t            }\r\n\t        },\r\n\r\n\t        _position: function(shape, options, elementSize, event) {\r\n\t            var position = options.position;\r\n\t            var tooltipOffset = options.offset || 0;\r\n\t            var surface = this.surface;\r\n\t            var offset = surface._instance._elementOffset();\r\n\t            var size = surface.getSize();\r\n\t            var surfaceOffset = surface._instance._offset;\r\n\t            var bbox = shape.bbox();\r\n\t            var width = elementSize.width;\r\n\t            var height = elementSize.height;\r\n\t            var left = 0, top = 0;\r\n\r\n\t            bbox.origin.translate(offset.left, offset.top);\r\n\t            if (surfaceOffset) {\r\n\t                bbox.origin.translate(-surfaceOffset.x, -surfaceOffset.y);\r\n\t            }\r\n\r\n\t            if (position == \"cursor\" && event) {\r\n\t                var coord = eventCoordinates(event);\r\n\t                left = coord.x - width / 2;\r\n\t                top = coord.y - height - tooltipOffset;\r\n\t            } else if (position == \"left\") {\r\n\t                left = bbox.origin.x - width - tooltipOffset;\r\n\t                top = bbox.center().y - height / 2;\r\n\t            } else if (position == \"right\") {\r\n\t                left = bbox.bottomRight().x + tooltipOffset;\r\n\t                top = bbox.center().y - height / 2;\r\n\t            } else if (position == \"bottom\") {\r\n\t                left = bbox.center().x - width / 2;\r\n\t                top = bbox.bottomRight().y + tooltipOffset;\r\n\t            } else {\r\n\t                left = bbox.center().x - width / 2;\r\n\t                top = bbox.origin.y - height - tooltipOffset;\r\n\t            }\r\n\r\n\t            return {\r\n\t                left: limitValue(left, offset.left, offset.left + size.width),\r\n\t                top: limitValue(top, offset.top, offset.top + size.height)\r\n\t            };\r\n\t        },\r\n\r\n\t        show: function(shape, options) {\r\n\t            this._show(shape, shape, deepExtend({}, this.options, this._tooltipOptions(shape.options.tooltip), options));\r\n\t        },\r\n\r\n\t        hide: function() {\r\n\t            var popup = this.popup;\r\n\t            var current = this._current;\r\n\t            delete this._current;\r\n\t            clearTimeout(this._showTimeout);\r\n\t            if (popup && popup.visible() && current &&\r\n\t                !this.surface.trigger(\"tooltipClose\", { element: current.shape, target: current.target, popup: popup})) {\r\n\t                popup.close();\r\n\t            }\r\n\t        },\r\n\r\n\t        _hideClick: function(e) {\r\n\t            e.preventDefault();\r\n\t            this.hide();\r\n\t        },\r\n\r\n\t        _show: function(target, shape, options, event, delay) {\r\n\t            var current = this._current;\r\n\r\n\t            clearTimeout(this._timeout);\r\n\r\n\t            if (current && ((current.shape === shape && options.shared) || current.target === target)) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            clearTimeout(this._showTimeout);\r\n\r\n\t            var popup = this.getPopup();\r\n\r\n\t            if (!this.surface.trigger(\"tooltipOpen\", { element: shape, target: target, popup: popup }) &&\r\n\t                this._updateContent(target, shape, options)) {\r\n\r\n\t                this._autoHide(options);\r\n\t                var elementSize = this._measure(options);\r\n\r\n\t                if (popup.visible()) {\r\n\t                    popup.close(true);\r\n\t                }\r\n\r\n\t                this._current = {\r\n\t                    options: options,\r\n\t                    elementSize: elementSize,\r\n\t                    shape: shape,\r\n\t                    target: target,\r\n\t                    position: this._position(options.shared ? shape: target, options, elementSize, event)\r\n\t                };\r\n\r\n\t                if (delay) {\r\n\t                    this._showTimeout = setTimeout(this._openPopupHandler, options.showAfter || 0);\r\n\t                } else {\r\n\t                    this._openPopup();\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _openPopup: function() {\r\n\t            var current = this._current;\r\n\t            var position = current.position;\r\n\r\n\t            this.getPopup().open(position.left, position.top);\r\n\t        },\r\n\r\n\t        _autoHide: function(options) {\r\n\t            if (options.autoHide && this._closeButton) {\r\n\t                this.element.removeClass(\"k-tooltip-closable\");\r\n\t                this._closeButton.remove();\r\n\t                delete this._closeButton;\r\n\t            }\r\n\r\n\t            if (!options.autoHide && !this._closeButton) {\r\n\t                this.element.addClass(\"k-tooltip-closable\");\r\n\t                this._closeButton = $(TOOLTIP_CLOSE_TEMPLATE).prependTo(this.element);\r\n\t            }\r\n\t        },\r\n\r\n\t        _showEvent: function(e) {\r\n\t            var shape = this._tooltipShape(e.element);\r\n\t            if (shape) {\r\n\t                var options = deepExtend({}, this.options, this._tooltipOptions(shape.options.tooltip));\r\n\r\n\t                if (options && options.showOn == e.type) {\r\n\t                    this._show(e.element, shape, options, e.originalEvent, true);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _measure: function(options) {\r\n\t            var popup = this.getPopup();\r\n\t            var width, height;\r\n\t            this.element.css({\r\n\t                width: \"auto\",\r\n\t                height: \"auto\"\r\n\t            });\r\n\t            var visible = popup.visible();\r\n\t            if (!visible) {\r\n\t                popup.wrapper.show();\r\n\t            }\r\n\r\n\t            this.element.css({\r\n\t                width: defined(options.width) ? options.width : \"auto\",\r\n\t                height: defined(options.height) ? options.height : \"auto\"\r\n\t            });\r\n\r\n\t            width = outerWidth(this.element);\r\n\t            height = outerHeight(this.element);\r\n\r\n\t            if (!visible) {\r\n\t                popup.wrapper.hide();\r\n\t            }\r\n\r\n\t            return {\r\n\t                width: width,\r\n\t                height: height\r\n\t            };\r\n\t        },\r\n\r\n\t        _mouseleave: function(e) {\r\n\t            if (this.popup && !this._popupRelatedTarget(e.originalEvent)) {\r\n\t                var tooltip = this;\r\n\t                var current = tooltip._current;\r\n\r\n\t                if (current && current.options.autoHide) {\r\n\t                    tooltip._timeout = setTimeout(function() {\r\n\t                        clearTimeout(tooltip._showTimeout);\r\n\t                        tooltip.hide();\r\n\t                    }, current.options.hideDelay || 0);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _mousemove: function(e) {\r\n\t            var current = this._current;\r\n\t            if (current && e.element) {\r\n\t                var options = current.options;\r\n\t                if (options.position == \"cursor\") {\r\n\t                    var position = this._position(e.element, options, current.elementSize, e.originalEvent);\r\n\t                    current.position = position;\r\n\t                    this.getPopup().wrapper.css({left: position.left, top: position.top});\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _surfaceLeave: function(e) {\r\n\t            if (this.popup && !this._popupRelatedTarget(e)) {\r\n\t                clearTimeout(this._showTimeout);\r\n\t                this.hide();\r\n\t            }\r\n\t        },\r\n\r\n\t        _popupRelatedTarget: function(e) {\r\n\t            return e.relatedTarget && $(e.relatedTarget).closest(this.popup.wrapper).length;\r\n\t        }\r\n\t    });\r\n\r\n\t    kendo.drawing.SurfaceTooltip = SurfaceTooltip;\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 918:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../kendo.popup\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/drawing/surface-tooltip.js\n// module id = 468\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(859);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 852:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.drawing\");\n\n/***/ }),\n\n/***/ 855:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.core\");\n\n/***/ }),\n\n/***/ 859:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n\t        __webpack_require__(855),\r\n\t        __webpack_require__(852)\r\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function ($) {\r\n\t/* jshint curly:false */\r\n\r\n\twindow.kendo.dataviz = window.kendo.dataviz || {};\r\n\tvar drawing = kendo.drawing;\r\n\tvar util = drawing.util;\r\n\tvar Path = drawing.Path;\r\n\tvar Group = drawing.Group;\r\n\tvar Class = kendo.Class;\r\n\tvar geometry = kendo.geometry;\r\n\tvar Rect = geometry.Rect;\r\n\tvar Circle = geometry.Circle;\r\n\tvar geometryTransform = geometry.transform;\r\n\tvar Segment = geometry.Segment;\r\n\tvar dataviz = kendo.dataviz;\r\n\r\n\tvar deepExtend = kendo.deepExtend;\r\n\tvar isFunction = kendo.isFunction;\r\n\tvar __common_getter_js = kendo.getter;\r\n\r\n\tvar X = \"x\";\r\n\tvar Y = \"y\";\r\n\tvar TOP = \"top\";\r\n\tvar BOTTOM = \"bottom\";\r\n\tvar LEFT = \"left\";\r\n\tvar RIGHT = \"right\";\r\n\tvar CENTER = \"center\";\r\n\tvar WIDTH = \"width\";\r\n\tvar HEIGHT = \"height\";\r\n\tvar COORD_PRECISION = 3;\r\n\tvar MAX_VALUE = Number.MAX_VALUE;\r\n\tvar MIN_VALUE = -Number.MAX_VALUE;\r\n\tvar DEFAULT_WIDTH = 600;\r\n\tvar DEFAULT_HEIGHT = 400;\r\n\tvar WHITE = \"#fff\";\r\n\tvar BLACK = \"#000\";\r\n\tvar DEFAULT_FONT = \"12px sans-serif\";\r\n\tvar DEFAULT_PRECISION = 10;\r\n\tvar AXIS_LABEL_CLICK = \"axisLabelClick\";\r\n\tvar NOTE_CLICK = \"noteClick\";\r\n\tvar NOTE_HOVER = \"noteHover\";\r\n\tvar OUTSIDE = \"outside\";\r\n\tvar NONE = \"none\";\r\n\tvar CIRCLE = \"circle\";\r\n\tvar TRIANGLE = \"triangle\";\r\n\tvar CROSS = \"cross\";\r\n\tvar ARC = \"arc\";\r\n\tvar INSIDE = \"inside\";\r\n\tvar VALUE = \"value\";\r\n\tvar STRING = \"string\";\r\n\tvar OBJECT = \"object\";\r\n\tvar DATE = \"date\";\r\n\tvar FORMAT_REGEX = /\\{\\d+:?/;\r\n\tvar HIGHLIGHT_ZINDEX = 100;\r\n\r\n\tvar constants = {\r\n\t\tX: X,\r\n\t\tY: Y,\r\n\t\tWIDTH: WIDTH,\r\n\t\tHEIGHT: HEIGHT,\r\n\t\tDEFAULT_HEIGHT: DEFAULT_HEIGHT,\r\n\t\tDEFAULT_WIDTH: DEFAULT_WIDTH,\r\n\t\tTOP: TOP,\r\n\t\tLEFT: LEFT,\r\n\t\tBOTTOM: BOTTOM,\r\n\t\tRIGHT: RIGHT,\r\n\t\tCENTER: CENTER,\r\n\t\tCOORD_PRECISION: COORD_PRECISION,\r\n\t\tDEFAULT_PRECISION: DEFAULT_PRECISION,\r\n\t\tCIRCLE: CIRCLE,\r\n\t\tTRIANGLE: TRIANGLE,\r\n\t\tCROSS: CROSS,\r\n\t\tMAX_VALUE: MAX_VALUE,\r\n\t\tMIN_VALUE: MIN_VALUE,\r\n\t\tWHITE: WHITE,\r\n\t\tBLACK: BLACK,\r\n\t\tDEFAULT_FONT: DEFAULT_FONT,\r\n\t\tAXIS_LABEL_CLICK: AXIS_LABEL_CLICK,\r\n\t\tOUTSIDE: OUTSIDE,\r\n\t\tINSIDE: INSIDE,\r\n\t\tNONE: NONE,\r\n\t\tNOTE_CLICK: NOTE_CLICK,\r\n\t\tNOTE_HOVER: NOTE_HOVER,\r\n\t\tVALUE: VALUE,\r\n\t\tSTRING: STRING,\r\n\t\tOBJECT: OBJECT,\r\n\t\tDATE: DATE,\r\n\t\tARC: ARC,\r\n\t\tFORMAT_REGEX: FORMAT_REGEX,\r\n\t\tHIGHLIGHT_ZINDEX: HIGHLIGHT_ZINDEX\r\n\t};\r\n\r\n\tfunction isArray(value) {\r\n\t    return Array.isArray(value);\r\n\t}\r\n\r\n\tfunction addClass(element, classes) {\r\n\t    var classArray = isArray(classes) ? classes : [ classes ];\r\n\r\n\t    for (var idx = 0; idx < classArray.length; idx++) {\r\n\t        var className = classArray[idx];\r\n\t        if (element.className.indexOf(className) === -1) {\r\n\t            element.className += \" \" + className;\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tvar SPACE_REGEX = /\\s+/g;\r\n\r\n\tfunction removeClass(element, className) {\r\n\t    if (element && element.className) {\r\n\t        element.className = element.className.replace(className, \"\").replace(SPACE_REGEX, \" \");\r\n\t    }\r\n\t}\r\n\r\n\tfunction alignPathToPixel(path) {\r\n\t    var offset = 0.5;\r\n\t    if (path.options.stroke && kendo.drawing.util.defined(path.options.stroke.width)) {\r\n\t        if (path.options.stroke.width % 2 === 0) {\r\n\t            offset = 0;\r\n\t        }\r\n\t    }\r\n\r\n\t    for (var i = 0; i < path.segments.length; i++) {\r\n\t        path.segments[i].anchor().round(0).translate(offset, offset);\r\n\t    }\r\n\r\n\t    return path;\r\n\t}\r\n\r\n\tfunction clockwise(angle1, angle2) {\r\n\t    // True if angle2 is clockwise of angle1\r\n\t    // assuming angles grow in clock-wise direction\r\n\t    // (as in the pie and radar charts)\r\n\t    return -angle1.x * angle2.y + angle1.y * angle2.x < 0;\r\n\t}\r\n\r\n\tfunction isNumber(value) {\r\n\t    return typeof value === \"number\" && !isNaN(value);\r\n\t}\r\n\r\n\tfunction isString(value) {\r\n\t    return typeof value === STRING;\r\n\t}\r\n\r\n\tfunction convertableToNumber(value) {\r\n\t    return isNumber(value) || (isString(value) && isFinite(value));\r\n\t}\r\n\r\n\tfunction isObject(value) {\r\n\t    return typeof value === \"object\";\r\n\t}\r\n\r\n\tfunction styleValue(value) {\r\n\t    if (isNumber(value)) {\r\n\t        return value + \"px\";\r\n\t    }\r\n\t    return value;\r\n\t}\r\n\r\n\tvar SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;\r\n\r\n\tfunction isSizeField(field) {\r\n\t    return SIZE_STYLES_REGEX.test(field);\r\n\t}\r\n\r\n\tfunction elementStyles(element, styles) {\r\n\t    var stylesArray = isString(styles) ? [ styles ] : styles;\r\n\r\n\t    if (isArray(stylesArray)) {\r\n\t        var result = {};\r\n\t        var style = window.getComputedStyle(element);\r\n\r\n\t        for (var idx = 0; idx < stylesArray.length; idx++) {\r\n\t            var field = stylesArray[idx];\r\n\t            result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];\r\n\t        }\r\n\r\n\t        return result;\r\n\t    } else if (isObject(styles)) {\r\n\t        for (var field$1 in styles) {\r\n\t            element.style[field$1] = styleValue(styles[field$1]);\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction getSpacing(value, defaultSpacing) {\r\n\t    if (defaultSpacing === void 0) { defaultSpacing = 0; }\r\n\r\n\t    var spacing = { top: 0, right: 0, bottom: 0, left: 0 };\r\n\r\n\t    if (typeof(value) === \"number\") {\r\n\t        spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value;\r\n\t    } else {\r\n\t        spacing[TOP] = value[TOP] || defaultSpacing;\r\n\t        spacing[RIGHT] = value[RIGHT] || defaultSpacing;\r\n\t        spacing[BOTTOM] = value[BOTTOM] || defaultSpacing;\r\n\t        spacing[LEFT] = value[LEFT] || defaultSpacing;\r\n\t    }\r\n\r\n\t    return spacing;\r\n\t}\r\n\r\n\tvar defaultImplementation = {\r\n\t    format: function (format, value) { return value; },\r\n\r\n\t    toString: function (value) { return value; },\r\n\r\n\t    parseDate: function (value) { return new Date(value); }\r\n\t};\r\n\r\n\tvar current = defaultImplementation;\r\n\r\n\tvar IntlService = Class.extend({\r\n\r\n\t});\r\n\r\n\tIntlService.register = function(userImplementation) {\r\n\t    current = userImplementation;\r\n\t};\r\n\r\n\tif (Object.defineProperties) {\r\n\t    Object.defineProperties(IntlService, {\r\n\t        implementation: {\r\n\t            get: function() {\r\n\t                return current;\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t}\r\n\r\n\tvar FORMAT_REPLACE_REGEX = /\\{(\\d+)(:[^\\}]+)?\\}/g;\r\n\r\n\tvar FormatService = Class.extend({\r\n\t    init: function(intlService) {\r\n\t        this._intlService = intlService;\r\n\t    },\r\n\r\n\t    auto: function(formatString) {\r\n\t        var values = [], len = arguments.length - 1;\r\n\t        while ( len-- > 0 ) values[ len ] = arguments[ len + 1 ];\r\n\r\n\t        var intl = this.intlService;\r\n\r\n\t        if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\r\n\t            return intl.format.apply(intl, [ formatString ].concat( values ));\r\n\t        }\r\n\r\n\t        return intl.toString(values[0], formatString);\r\n\t    },\r\n\r\n\t    localeAuto: function(formatString, values, locale) {\r\n\t        var intl = this.intlService;\r\n\t        var result;\r\n\r\n\t        if (isString(formatString) && formatString.match(FORMAT_REGEX)) {\r\n\t            result = formatString.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {\r\n\t                var value = values[parseInt(index, 10)];\r\n\r\n\t                return intl.toString(value, placeholderFormat ? placeholderFormat.substring(1) : \"\", locale);\r\n\t            });\r\n\t        } else {\r\n\t            result = intl.toString(values[0], formatString, locale);\r\n\t        }\r\n\r\n\t        return result;\r\n\t    }\r\n\t});\r\n\r\n\tif (Object.defineProperties) {\r\n\t    Object.defineProperties(FormatService.fn, {\r\n\t        intlService: {\r\n\t            get: function() {\r\n\t                return this._intlService || IntlService.implementation;\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t}\r\n\r\n\tvar ChartService = Class.extend({\r\n\t    init: function(chart, context) {\r\n\t        if (context === void 0) { context = {}; }\r\n\r\n\t        this._intlService = context.intlService;\r\n\t        this.sender = context.sender || chart;\r\n\t        this.format = new FormatService(context.intlService);\r\n\t        this.chart = chart;\r\n\t        this.rtl = context.rtl;\r\n\t    },\r\n\r\n\t    notify: function(name, args) {\r\n\t        this.chart.trigger(name, args);\r\n\t    }\r\n\t});\r\n\r\n\tif (Object.defineProperties) {\r\n\t    Object.defineProperties(ChartService.fn, {\r\n\t        intl: {\r\n\t            get: function() {\r\n\t                return this._intlService || IntlService.implementation;\r\n\t            }\r\n\t        }\r\n\t    });\r\n\t}\r\n\r\n\tvar current$1;\r\n\r\n\tvar DomEventsBuilder = Class.extend({\r\n\r\n\t});\r\n\r\n\tDomEventsBuilder.register = function(userImplementation) {\r\n\t    current$1 = userImplementation;\r\n\t};\r\n\r\n\tDomEventsBuilder.create = function(element, events) {\r\n\t    if (current$1) {\r\n\t        return current$1.create(element, events);\r\n\t    }\r\n\t};\r\n\r\n\tvar current$2 = {\r\n\t    compile: function(template) {\r\n\t        return template;\r\n\t    }\r\n\t};\r\n\r\n\tvar TemplateService = Class.extend({\r\n\r\n\t});\r\n\r\n\tTemplateService.register = function(userImplementation) {\r\n\t    current$2 = userImplementation;\r\n\t};\r\n\r\n\tTemplateService.compile = function(template) {\r\n\t    return current$2.compile(template);\r\n\t};\r\n\r\n\tvar services = {\r\n\t\tChartService: ChartService,\r\n\t\tDomEventsBuilder: DomEventsBuilder,\r\n\t\tFormatService: FormatService,\r\n\t\tIntlService: IntlService,\r\n\t\tTemplateService: TemplateService\r\n\t};\r\n\r\n\tfunction getTemplate(options) {\r\n\t    if (options === void 0) { options = {}; }\r\n\r\n\t    var template;\r\n\t    if (options.template) {\r\n\t        options.template = template = TemplateService.compile(options.template);\r\n\t    } else if (isFunction(options.content)) {\r\n\t        template = options.content;\r\n\t    }\r\n\r\n\t    return template;\r\n\t}\r\n\r\n\tfunction grep(array, callback) {\r\n\t    var length = array.length;\r\n\t    var result = [];\r\n\t    for (var idx = 0; idx < length; idx++) {\r\n\t        if (callback(array[idx])) {\r\n\t            result .push(array[idx]);\r\n\t        }\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction hasClasses(element, classNames) {\r\n\t    if (element.className) {\r\n\t        var names = classNames.split(\" \");\r\n\t        for (var idx = 0; idx < names.length; idx++) {\r\n\t            if (element.className.indexOf(names[idx]) !== -1) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction inArray(value, array) {\r\n\t    if (array) {\r\n\t        return array.indexOf(value) !== -1;\r\n\t    }\r\n\t}\r\n\r\n\tfunction interpolateValue(start, end, progress) {\r\n\t    return kendo.drawing.util.round(start + (end - start) * progress, COORD_PRECISION);\r\n\t}\r\n\r\n\tvar TRIGGER = 'trigger';\r\n\r\n\tvar InstanceObserver = Class.extend({\r\n\t    init: function(observer, handlers) {\r\n\t        this.observer = observer;\r\n\t        this.handlerMap = deepExtend({}, this.handlerMap, handlers);\r\n\t    },\r\n\r\n\t    trigger: function(name, args) {\r\n\t        var ref = this;\r\n\t        var observer = ref.observer;\r\n\t        var handlerMap = ref.handlerMap;\r\n\t        var isDefaultPrevented;\r\n\t        if (handlerMap[name]) {\r\n\t            isDefaultPrevented = this.callObserver(handlerMap[name], args);\r\n\t        } else if (observer[TRIGGER]) {\r\n\t            isDefaultPrevented = this.callObserver(TRIGGER, name, args);\r\n\t        }\r\n\r\n\t        return isDefaultPrevented;\r\n\t    },\r\n\r\n\t    callObserver: function(fnName) {\r\n\t        var args = [], len = arguments.length - 1;\r\n\t        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\r\n\r\n\t        return this.observer[fnName].apply(this.observer, args);\r\n\t    },\r\n\r\n\t    requiresHandlers: function(names) {\r\n\t        var this$1 = this;\r\n\r\n\t        if (this.observer.requiresHandlers) {\r\n\t            return this.observer.requiresHandlers(names);\r\n\t        }\r\n\r\n\t        for (var idx = 0; idx < names.length; idx++) {\r\n\t            if (this$1.handlerMap[names[idx]]) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tfunction map(array, callback) {\r\n\t    var length = array.length;\r\n\t    var result = [];\r\n\t    for (var idx = 0; idx < length; idx++) {\r\n\t        var value = callback(array[idx]);\r\n\t        if (kendo.drawing.util.defined(value)) {\r\n\t            result.push(value);\r\n\t        }\r\n\t    }\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction mousewheelDelta(e) {\r\n\t    var delta = 0;\r\n\r\n\t    if (e.wheelDelta) {\r\n\t        delta = -e.wheelDelta / 120;\r\n\t        delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);\r\n\t    }\r\n\r\n\t    if (e.detail) {\r\n\t        delta = kendo.drawing.util.round(e.detail / 3);\r\n\t    }\r\n\r\n\t    return delta;\r\n\t}\r\n\r\n\tvar ref = kendo.drawing.util;\r\n\tvar append = ref.append;\r\n\tvar bindEvents = ref.bindEvents;\r\n\tvar defined = ref.defined;\r\n\tvar deg = ref.deg;\r\n\tvar elementOffset = ref.elementOffset;\r\n\tvar elementSize = ref.elementSize;\r\n\tvar eventElement = ref.eventElement;\r\n\tvar eventCoordinates = ref.eventCoordinates;\r\n\tvar last = ref.last;\r\n\tvar limitValue = ref.limitValue;\r\n\tvar objectKey = ref.objectKey;\r\n\tvar rad = ref.rad;\r\n\tvar round = ref.round;\r\n\tvar unbindEvents = ref.unbindEvents;\r\n\tvar valueOrDefault = ref.valueOrDefault;\r\n\r\n\tvar FontLoader = Class.extend({\r\n\r\n\t});\r\n\r\n\tFontLoader.fetchFonts = function(options, fonts, state) {\r\n\t    if (state === void 0) { state = { depth: 0 }; }\r\n\r\n\t    var MAX_DEPTH = 5;\r\n\r\n\t    if (!options || state.depth > MAX_DEPTH || !document.fonts) {\r\n\t        return;\r\n\t    }\r\n\r\n\t    Object.keys(options).forEach(function(key) {\r\n\t        var value = options[key];\r\n\t        if (key === \"dataSource\" || key[0] === \"$\" || !value) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        if (key === \"font\") {\r\n\t            fonts.push(value);\r\n\t        } else if (typeof value === \"object\") {\r\n\t            state.depth++;\r\n\t            FontLoader.fetchFonts(value, fonts, state);\r\n\t            state.depth--;\r\n\t        }\r\n\t    });\r\n\t};\r\n\r\n\tFontLoader.loadFonts = function(fonts, callback) {\r\n\t    var promises = [];\r\n\r\n\t    if (fonts.length > 0 && document.fonts) {\r\n\t        try {\r\n\t            promises = fonts.map(function(font) {\r\n\t                return document.fonts.load(font);\r\n\t            });\r\n\t        } catch (e) {\r\n\t            // Silence font-loading errors\r\n\t            kendo.logToConsole(e);\r\n\t        }\r\n\r\n\t        Promise.all(promises).then(callback, callback);\r\n\t    } else {\r\n\t        callback();\r\n\t    }\r\n\t};\r\n\r\n\tFontLoader.preloadFonts = function(options, callback) {\r\n\t    var fonts = [];\r\n\t    FontLoader.fetchFonts(options, fonts);\r\n\r\n\t    FontLoader.loadFonts(fonts, callback);\r\n\t};\r\n\r\n\tfunction setDefaultOptions(type, options) {\r\n\t    var proto = type.prototype;\r\n\t    if (proto.options) {\r\n\t        proto.options = deepExtend({}, proto.options, options);\r\n\t    } else {\r\n\t        proto.options = options;\r\n\t    }\r\n\t}\r\n\r\n\tfunction sparseArrayLimits(arr) {\r\n\t    var min = MAX_VALUE;\r\n\t    var max = MIN_VALUE;\r\n\r\n\t    for (var idx = 0, length = arr.length; idx < length; idx++) {\r\n\t        var value = arr[idx];\r\n\t        if (value !== null && isFinite(value)) {\r\n\t            min = Math.min(min, value);\r\n\t            max = Math.max(max, value);\r\n\t        }\r\n\t    }\r\n\r\n\t    return {\r\n\t        min: min === MAX_VALUE ? undefined : min,\r\n\t        max: max === MIN_VALUE ? undefined : max\r\n\t    };\r\n\t}\r\n\r\n\tvar Point = Class.extend({\r\n\t    init: function(x, y) {\r\n\r\n\t        this.x = x || 0;\r\n\t        this.y = y || 0;\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Point(this.x, this.y);\r\n\t    },\r\n\r\n\t    equals: function(point) {\r\n\t        return point && this.x === point.x && this.y === point.y;\r\n\t    },\r\n\r\n\t    rotate: function(center, degrees) {\r\n\t        var theta = rad(degrees);\r\n\t        var cosT = Math.cos(theta);\r\n\t        var sinT = Math.sin(theta);\r\n\t        var cx = center.x;\r\n\t        var cy = center.y;\r\n\t        var ref = this;\r\n\t        var x = ref.x;\r\n\t        var y = ref.y;\r\n\r\n\t        this.x = round(\r\n\t            cx + (x - cx) * cosT + (y - cy) * sinT,\r\n\t            COORD_PRECISION\r\n\t        );\r\n\r\n\t        this.y = round(\r\n\t            cy + (y - cy) * cosT - (x - cx) * sinT,\r\n\t            COORD_PRECISION\r\n\t        );\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    multiply: function(a) {\r\n\r\n\t        this.x *= a;\r\n\t        this.y *= a;\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    distanceTo: function(point) {\r\n\t        var dx = this.x - point.x;\r\n\t        var dy = this.y - point.y;\r\n\r\n\t        return Math.sqrt(dx * dx + dy * dy);\r\n\t    }\r\n\t});\r\n\r\n\tPoint.onCircle = function(center, angle, radius) {\r\n\t    var radians = rad(angle);\r\n\r\n\t    return new Point(\r\n\t        center.x - radius * Math.cos(radians),\r\n\t        center.y - radius * Math.sin(radians)\r\n\t    );\r\n\t};\r\n\r\n\tvar Box = Class.extend({\r\n\t    init: function(x1, y1, x2, y2) {\r\n\r\n\t        this.x1 = x1 || 0;\r\n\t        this.y1 = y1 || 0;\r\n\t        this.x2 = x2 || 0;\r\n\t        this.y2 = y2 || 0;\r\n\t    },\r\n\r\n\t    equals: function(box) {\r\n\t        return this.x1 === box.x1 && this.x2 === box.x2 &&\r\n\t            this.y1 === box.y1 && this.y2 === box.y2;\r\n\t    },\r\n\r\n\t    width: function() {\r\n\t        return this.x2 - this.x1;\r\n\t    },\r\n\r\n\t    height: function() {\r\n\t        return this.y2 - this.y1;\r\n\t    },\r\n\r\n\t    translate: function(dx, dy) {\r\n\t        this.x1 += dx;\r\n\t        this.x2 += dx;\r\n\t        this.y1 += dy;\r\n\t        this.y2 += dy;\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    move: function(x, y) {\r\n\t        var height = this.height();\r\n\t        var width = this.width();\r\n\r\n\t        if (defined(x)) {\r\n\t            this.x1 = x;\r\n\t            this.x2 = this.x1 + width;\r\n\t        }\r\n\r\n\t        if (defined(y)) {\r\n\t            this.y1 = y;\r\n\t            this.y2 = this.y1 + height;\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    wrap: function(targetBox) {\r\n\t        this.x1 = Math.min(this.x1, targetBox.x1);\r\n\t        this.y1 = Math.min(this.y1, targetBox.y1);\r\n\t        this.x2 = Math.max(this.x2, targetBox.x2);\r\n\t        this.y2 = Math.max(this.y2, targetBox.y2);\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    wrapPoint: function(point) {\r\n\t        var arrayPoint = isArray(point);\r\n\t        var x = arrayPoint ? point[0] : point.x;\r\n\t        var y = arrayPoint ? point[1] : point.y;\r\n\t        this.wrap(new Box(x, y, x, y));\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    snapTo: function(targetBox, axis) {\r\n\r\n\t        if (axis === X || !axis) {\r\n\t            this.x1 = targetBox.x1;\r\n\t            this.x2 = targetBox.x2;\r\n\t        }\r\n\r\n\t        if (axis === Y || !axis) {\r\n\t            this.y1 = targetBox.y1;\r\n\t            this.y2 = targetBox.y2;\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    alignTo: function(targetBox, anchor) {\r\n\t        var height = this.height();\r\n\t        var width = this.width();\r\n\t        var axis = anchor === TOP || anchor === BOTTOM ? Y : X;\r\n\t        var offset = axis === Y ? height : width;\r\n\r\n\t        if (anchor === CENTER) {\r\n\t            var targetCenter = targetBox.center();\r\n\t            var center = this.center();\r\n\r\n\t            this.x1 += targetCenter.x - center.x;\r\n\t            this.y1 += targetCenter.y - center.y;\r\n\t        } else if (anchor === TOP || anchor === LEFT) {\r\n\t            this[axis + 1] = targetBox[axis + 1] - offset;\r\n\t        } else {\r\n\t            this[axis + 1] = targetBox[axis + 2];\r\n\t        }\r\n\r\n\t        this.x2 = this.x1 + width;\r\n\t        this.y2 = this.y1 + height;\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    shrink: function(dw, dh) {\r\n\r\n\t        this.x2 -= dw;\r\n\t        this.y2 -= dh;\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    expand: function(dw, dh) {\r\n\t        this.shrink(-dw, -dh);\r\n\t        return this;\r\n\t    },\r\n\r\n\t    pad: function(padding) {\r\n\t        var spacing = getSpacing(padding);\r\n\r\n\t        this.x1 -= spacing.left;\r\n\t        this.x2 += spacing.right;\r\n\t        this.y1 -= spacing.top;\r\n\t        this.y2 += spacing.bottom;\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    unpad: function(padding) {\r\n\t        var spacing = getSpacing(padding);\r\n\r\n\t        spacing.left = -spacing.left;\r\n\t        spacing.top = -spacing.top;\r\n\t        spacing.right = -spacing.right;\r\n\t        spacing.bottom = -spacing.bottom;\r\n\r\n\t        return this.pad(spacing);\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Box(this.x1, this.y1, this.x2, this.y2);\r\n\t    },\r\n\r\n\t    center: function() {\r\n\t        return new Point(\r\n\t            this.x1 + this.width() / 2,\r\n\t            this.y1 + this.height() / 2\r\n\t        );\r\n\t    },\r\n\r\n\t    containsPoint: function(point) {\r\n\r\n\t        return point.x >= this.x1 && point.x <= this.x2 &&\r\n\t               point.y >= this.y1 && point.y <= this.y2;\r\n\t    },\r\n\r\n\t    points: function() {\r\n\t        return [\r\n\t            new Point(this.x1, this.y1),\r\n\t            new Point(this.x2, this.y1),\r\n\t            new Point(this.x2, this.y2),\r\n\t            new Point(this.x1, this.y2)\r\n\t        ];\r\n\t    },\r\n\r\n\t    getHash: function() {\r\n\t        return [ this.x1, this.y1, this.x2, this.y2 ].join(\",\");\r\n\t    },\r\n\r\n\t    overlaps: function(box) {\r\n\t        return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);\r\n\t    },\r\n\r\n\t    rotate: function(rotation) {\r\n\t        var width = this.width();\r\n\t        var height = this.height();\r\n\t        var ref = this.center();\r\n\t        var cx = ref.x;\r\n\t        var cy = ref.y;\r\n\r\n\t        var r1 = rotatePoint(0, 0, cx, cy, rotation);\r\n\t        var r2 = rotatePoint(width, 0, cx, cy, rotation);\r\n\t        var r3 = rotatePoint(width, height, cx, cy, rotation);\r\n\t        var r4 = rotatePoint(0, height, cx, cy, rotation);\r\n\r\n\t        width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);\r\n\t        height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);\r\n\r\n\t        this.x2 = this.x1 + width;\r\n\t        this.y2 = this.y1 + height;\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    toRect: function() {\r\n\t        return new Rect([ this.x1, this.y1 ], [ this.width(), this.height() ]);\r\n\t    },\r\n\r\n\t    hasSize: function() {\r\n\t        return this.width() !== 0 && this.height() !== 0;\r\n\t    },\r\n\r\n\t    align: function(targetBox, axis, alignment) {\r\n\t        var c1 = axis + 1;\r\n\t        var c2 = axis + 2;\r\n\t        var sizeFunc = axis === X ? WIDTH : HEIGHT;\r\n\t        var size = this[sizeFunc]();\r\n\r\n\t        if (inArray(alignment, [ LEFT, TOP ])) {\r\n\t            this[c1] = targetBox[c1];\r\n\t            this[c2] = this[c1] + size;\r\n\t        } else if (inArray(alignment, [ RIGHT, BOTTOM ])) {\r\n\t            this[c2] = targetBox[c2];\r\n\t            this[c1] = this[c2] - size;\r\n\t        } else if (alignment === CENTER) {\r\n\t            this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;\r\n\t            this[c2] = this[c1] + size;\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tfunction rotatePoint(x, y, cx, cy, angle) {\r\n\t    var theta = rad(angle);\r\n\r\n\t    return new Point(\r\n\t        cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),\r\n\t        cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)\r\n\t    );\r\n\t}\r\n\r\n\tvar Ring = Class.extend({\r\n\t    init: function(center, innerRadius, radius, startAngle, angle) {\r\n\r\n\t        this.center = center;\r\n\t        this.innerRadius = innerRadius;\r\n\t        this.radius = radius;\r\n\t        this.startAngle = startAngle;\r\n\t        this.angle = angle;\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\r\n\t    },\r\n\r\n\t    middle: function() {\r\n\t        return this.startAngle + this.angle / 2;\r\n\t    },\r\n\r\n\t    setRadius: function(newRadius, innerRadius) {\r\n\t        if (innerRadius) {\r\n\t            this.innerRadius = newRadius;\r\n\t        } else {\r\n\t            this.radius = newRadius;\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    point: function(angle, innerRadius) {\r\n\t        var radianAngle = rad(angle);\r\n\t        var ax = Math.cos(radianAngle);\r\n\t        var ay = Math.sin(radianAngle);\r\n\t        var radius = innerRadius ? this.innerRadius : this.radius;\r\n\t        var x = round(this.center.x - (ax * radius), COORD_PRECISION);\r\n\t        var y = round(this.center.y - (ay * radius), COORD_PRECISION);\r\n\r\n\t        return new Point(x, y);\r\n\t    },\r\n\r\n\t    adjacentBox: function(distance, width, height) {\r\n\t        var sector = this.clone().expand(distance);\r\n\t        var midAndle = sector.middle();\r\n\t        var midPoint = sector.point(midAndle);\r\n\t        var hw = width / 2;\r\n\t        var hh = height / 2;\r\n\t        var sa = Math.sin(rad(midAndle));\r\n\t        var ca = Math.cos(rad(midAndle));\r\n\t        var x = midPoint.x - hw;\r\n\t        var y = midPoint.y - hh;\r\n\r\n\t        if (Math.abs(sa) < 0.9) {\r\n\t            x += hw * -ca / Math.abs(ca);\r\n\t        }\r\n\r\n\t        if (Math.abs(ca) < 0.9) {\r\n\t            y += hh * -sa / Math.abs(sa);\r\n\t        }\r\n\r\n\t        return new Box(x, y, x + width, y + height);\r\n\t    },\r\n\r\n\t    containsPoint: function(p) {\r\n\t        var center = this.center;\r\n\t        var innerRadius = this.innerRadius;\r\n\t        var radius = this.radius;\r\n\t        var startAngle = this.startAngle;\r\n\t        var endAngle = this.startAngle + this.angle;\r\n\t        var dx = p.x - center.x;\r\n\t        var dy = p.y - center.y;\r\n\t        var vector = new Point(dx, dy);\r\n\t        var startPoint = this.point(startAngle);\r\n\t        var startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\r\n\t        var endPoint = this.point(endAngle);\r\n\t        var endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\r\n\t        var dist = round(dx * dx + dy * dy, COORD_PRECISION);\r\n\r\n\t        return (startVector.equals(vector) || clockwise(startVector, vector)) &&\r\n\t               !clockwise(endVector, vector) &&\r\n\t               dist >= innerRadius * innerRadius && dist <= radius * radius;\r\n\t    },\r\n\r\n\t    getBBox: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\r\n\t        var startAngle = round(this.startAngle % 360);\r\n\t        var endAngle = round((startAngle + this.angle) % 360);\r\n\t        var innerRadius = this.innerRadius;\r\n\t        var allAngles = [ 0, 90, 180, 270, startAngle, endAngle ].sort(numericComparer);\r\n\t        var startAngleIndex = allAngles.indexOf(startAngle);\r\n\t        var endAngleIndex = allAngles.indexOf(endAngle);\r\n\t        var angles;\r\n\r\n\t        if (startAngle === endAngle) {\r\n\t            angles = allAngles;\r\n\t        } else {\r\n\t            if (startAngleIndex < endAngleIndex) {\r\n\t                angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\r\n\t            } else {\r\n\t                angles = [].concat(\r\n\t                    allAngles.slice(0, endAngleIndex + 1),\r\n\t                    allAngles.slice(startAngleIndex, allAngles.length)\r\n\t                );\r\n\t            }\r\n\t        }\r\n\r\n\t        for (var i = 0; i < angles.length; i++) {\r\n\t            var point = this$1.point(angles[i]);\r\n\t            box.wrapPoint(point);\r\n\t            box.wrapPoint(point, innerRadius);\r\n\t        }\r\n\r\n\t        if (!innerRadius) {\r\n\t            box.wrapPoint(this.center);\r\n\t        }\r\n\r\n\t        return box;\r\n\t    },\r\n\r\n\t    expand: function(value) {\r\n\t        this.radius += value;\r\n\t        return this;\r\n\t    }\r\n\t});\r\n\r\n\tfunction numericComparer(a, b) {\r\n\t    return a - b;\r\n\t}\r\n\r\n\tvar Sector = Ring.extend({\r\n\t    init: function(center, radius, startAngle, angle) {\r\n\t        Ring.fn.init.call(this, center, 0, radius, startAngle, angle);\r\n\t    },\r\n\r\n\t    expand: function(value) {\r\n\t        return Ring.fn.expand.call(this, value);\r\n\t    },\r\n\r\n\t    clone: function() {\r\n\t        return new Sector(this.center, this.radius, this.startAngle, this.angle);\r\n\t    },\r\n\r\n\t    setRadius: function(newRadius) {\r\n\t        this.radius = newRadius;\r\n\r\n\t        return this;\r\n\t    }\r\n\t});\r\n\r\n\tvar DIRECTION_ANGLE = 0.001; //any value that will make the endAngle bigger than the start angle will work here.\r\n\r\n\tvar ShapeBuilder = Class.extend({\r\n\t    createRing: function(sector, options) {\r\n\t        var startAngle = sector.startAngle + 180;\r\n\t        var endAngle = sector.angle + startAngle;\r\n\r\n\t        //required in order to avoid reversing the arc direction in cases like 0.000000000000001 + 100 === 100\r\n\t        if (sector.angle > 0 && startAngle === endAngle) {\r\n\t            endAngle += DIRECTION_ANGLE;\r\n\t        }\r\n\r\n\t        var center = new geometry.Point(sector.center.x, sector.center.y);\r\n\t        var radius = Math.max(sector.radius, 0);\r\n\t        var innerRadius = Math.max(sector.innerRadius, 0);\r\n\t        var arc = new geometry.Arc(center, {\r\n\t            startAngle: startAngle,\r\n\t            endAngle: endAngle,\r\n\t            radiusX: radius,\r\n\t            radiusY: radius\r\n\t        });\r\n\t        var path = Path.fromArc(arc, options).close();\r\n\r\n\t        if (innerRadius) {\r\n\t            arc.radiusX = arc.radiusY = innerRadius;\r\n\t            var innerEnd = arc.pointAt(endAngle);\r\n\t            path.lineTo(innerEnd.x, innerEnd.y);\r\n\t            path.arc(endAngle, startAngle, innerRadius, innerRadius, true);\r\n\t        } else {\r\n\t            path.lineTo(center.x, center.y);\r\n\t        }\r\n\r\n\t        return path;\r\n\t    }\r\n\t});\r\n\r\n\tShapeBuilder.current = new ShapeBuilder();\r\n\r\n\tvar ChartElement = Class.extend({\r\n\t    init: function(options) {\r\n\r\n\t        this.children = [];\r\n\r\n\t        this.options = deepExtend({}, this.options, options);\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var children = this.children;\r\n\t        var box;\r\n\r\n\t        for (var i = 0; i < children.length; i++) {\r\n\t            var currentChild = children[i];\r\n\t            currentChild.reflow(targetBox);\r\n\r\n\t            box = box ? box.wrap(currentChild.box) : currentChild.box.clone();\r\n\t        }\r\n\r\n\t        this.box = box || targetBox;\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        var children = this.children;\r\n\r\n\t        if (this.animation) {\r\n\t            this.animation.destroy();\r\n\t        }\r\n\r\n\t        for (var i = 0; i < children.length; i++) {\r\n\t            children[i].destroy();\r\n\t        }\r\n\t    },\r\n\r\n\t    getRoot: function() {\r\n\t        var parent = this.parent;\r\n\r\n\t        return parent ? parent.getRoot() : null;\r\n\t    },\r\n\r\n\t    getSender: function() {\r\n\t        var service = this.getService();\r\n\t        if (service) {\r\n\t            return service.sender;\r\n\t        }\r\n\t    },\r\n\r\n\t    getService: function() {\r\n\t        var element = this;\r\n\t        while (element) {\r\n\t            if (element.chartService) {\r\n\t                return element.chartService;\r\n\t            }\r\n\t            element = element.parent;\r\n\t        }\r\n\t    },\r\n\r\n\t    translateChildren: function(dx, dy) {\r\n\t        var children = this.children;\r\n\t        var childrenCount = children.length;\r\n\r\n\t        for (var i = 0; i < childrenCount; i++) {\r\n\t            children[i].box.translate(dx, dy);\r\n\t        }\r\n\t    },\r\n\r\n\t    append: function() {\r\n\t        var arguments$1 = arguments;\r\n\t        var this$1 = this;\r\n\r\n\t        for (var i = 0; i < arguments.length; i++) {\r\n\t            var item = arguments$1[i];\r\n\t            this$1.children.push(item);\r\n\t            item.parent = this$1;\r\n\t        }\r\n\t    },\r\n\r\n\t    renderVisual: function() {\r\n\t        if (this.options.visible === false) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        this.createVisual();\r\n\r\n\t        this.addVisual();\r\n\r\n\t        this.renderChildren();\r\n\r\n\t        this.createAnimation();\r\n\t        this.renderComplete();\r\n\t    },\r\n\r\n\t    addVisual: function() {\r\n\t        if (this.visual) {\r\n\t            this.visual.chartElement = this;\r\n\r\n\t            if (this.parent) {\r\n\t                this.parent.appendVisual(this.visual);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    renderChildren: function() {\r\n\t        var children = this.children;\r\n\t        var length = children.length;\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            children[i].renderVisual();\r\n\t        }\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        this.visual = new Group({\r\n\t            zIndex: this.options.zIndex,\r\n\t            visible: valueOrDefault(this.options.visible, true)\r\n\t        });\r\n\t    },\r\n\r\n\t    createAnimation: function() {\r\n\t        if (this.visual) {\r\n\t            this.animation = drawing.Animation.create(\r\n\t                this.visual, this.options.animation\r\n\t            );\r\n\t        }\r\n\t    },\r\n\r\n\t    appendVisual: function(childVisual) {\r\n\t        if (!childVisual.chartElement) {\r\n\t            childVisual.chartElement = this;\r\n\t        }\r\n\r\n\t        if (childVisual.options.noclip) {\r\n\t            this.clipRoot().visual.append(childVisual);\r\n\t        } else if (defined(childVisual.options.zIndex)) {\r\n\t            this.stackRoot().stackVisual(childVisual);\r\n\t        } else if (this.isStackRoot) {\r\n\t            this.stackVisual(childVisual);\r\n\t        } else if (this.visual) {\r\n\t            this.visual.append(childVisual);\r\n\t        } else {\r\n\t            // Allow chart elements without visuals to\r\n\t            // pass through child visuals\r\n\t            this.parent.appendVisual(childVisual);\r\n\t        }\r\n\t    },\r\n\r\n\t    clipRoot: function() {\r\n\t        if (this.parent) {\r\n\t            return this.parent.clipRoot();\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    stackRoot: function() {\r\n\t        if (this.parent) {\r\n\t            return this.parent.stackRoot();\r\n\t        }\r\n\r\n\t        return this;\r\n\t    },\r\n\r\n\t    stackVisual: function(childVisual) {\r\n\t        var zIndex = childVisual.options.zIndex || 0;\r\n\t        var visuals = this.visual.children;\r\n\t        var length = visuals.length;\r\n\t        var pos;\r\n\r\n\t        for (pos = 0; pos < length; pos++) {\r\n\t            var sibling = visuals[pos];\r\n\t            var here = valueOrDefault(sibling.options.zIndex, 0);\r\n\t            if (here > zIndex) {\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        this.visual.insert(pos, childVisual);\r\n\t    },\r\n\r\n\t    traverse: function(callback) {\r\n\t        var children = this.children;\r\n\t        var length = children.length;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var child = children[i];\r\n\r\n\t            callback(child);\r\n\t            if (child.traverse) {\r\n\t                child.traverse(callback);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    closest: function(match) {\r\n\t        var element = this;\r\n\t        var matched = false;\r\n\r\n\t        while (element && !matched) {\r\n\t            matched = match(element);\r\n\r\n\t            if (!matched) {\r\n\t                element = element.parent;\r\n\t            }\r\n\t        }\r\n\r\n\t        if (matched) {\r\n\t            return element;\r\n\t        }\r\n\t    },\r\n\r\n\t    renderComplete: function() {},\r\n\r\n\t    hasHighlight: function() {\r\n\t        var options = (this.options || {}).highlight;\r\n\t        return !(!this.createHighlight || (options && options.visible === false));\r\n\t    },\r\n\r\n\t    toggleHighlight: function(show) {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = (this.options || {}).highlight || {};\r\n\t        var customVisual = options.visual;\r\n\t        var highlight = this._highlight;\r\n\r\n\t        if (!highlight) {\r\n\t            var highlightOptions = {\r\n\t                fill: {\r\n\t                    color: WHITE,\r\n\t                    opacity: 0.2\r\n\t                },\r\n\t                stroke: {\r\n\t                    color: WHITE,\r\n\t                    width: 1,\r\n\t                    opacity: 0.2\r\n\t                }\r\n\t            };\r\n\r\n\t            if (customVisual) {\r\n\t                highlight = this._highlight = customVisual(\r\n\t                    $.extend(this.highlightVisualArgs(), {\r\n\t                        createVisual: function () { return this$1.createHighlight(highlightOptions); },\r\n\t                        sender: this.getSender(),\r\n\t                        series: this.series,\r\n\t                        dataItem: this.dataItem,\r\n\t                        category: this.category,\r\n\t                        value: this.value,\r\n\t                        percentage: this.percentage,\r\n\t                        runningTotal: this.runningTotal,\r\n\t                        total: this.total\r\n\t                    }\r\n\t                ));\r\n\r\n\t                if (!highlight) {\r\n\t                    return;\r\n\t                }\r\n\t            } else {\r\n\t                highlight = this._highlight = this.createHighlight(highlightOptions);\r\n\t            }\r\n\r\n\t            if (!defined(highlight.options.zIndex)) {\r\n\t                highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);\r\n\t            }\r\n\r\n\t            this.appendVisual(highlight);\r\n\t        }\r\n\r\n\t        highlight.visible(show);\r\n\t    },\r\n\r\n\t    createGradientOverlay: function(element, options, gradientOptions) {\r\n\t        var overlay = new Path($.extend({\r\n\t            stroke: {\r\n\t                color: \"none\"\r\n\t            },\r\n\t            fill: this.createGradient(gradientOptions),\r\n\t            closed: element.options.closed\r\n\t        }, options));\r\n\r\n\t        overlay.segments.elements(element.segments.elements());\r\n\r\n\t        return overlay;\r\n\t    },\r\n\r\n\t    createGradient: function(options) {\r\n\t        if (this.parent) {\r\n\t            return this.parent.createGradient(options);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tChartElement.prototype.options = { };\r\n\r\n\tvar BoxElement = ChartElement.extend({\r\n\t    init: function(options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.options.margin = getSpacing(this.options.margin);\r\n\t        this.options.padding = getSpacing(this.options.padding);\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var width = options.width;\r\n\t        var height = options.height;\r\n\t        var shrinkToFit = options.shrinkToFit;\r\n\t        var hasSetSize = width && height;\r\n\t        var margin = options.margin;\r\n\t        var padding = options.padding;\r\n\t        var borderWidth = options.border.width;\r\n\t        var box;\r\n\r\n\t        var reflowPaddingBox = function () {\r\n\t            this$1.align(targetBox, X, options.align);\r\n\t            this$1.align(targetBox, Y, options.vAlign);\r\n\t            this$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);\r\n\t        };\r\n\r\n\t        var contentBox = targetBox.clone();\r\n\t        if (hasSetSize) {\r\n\t            contentBox.x2 = contentBox.x1 + width;\r\n\t            contentBox.y2 = contentBox.y1 + height;\r\n\t        }\r\n\r\n\t        if (shrinkToFit) {\r\n\t            contentBox.unpad(margin).unpad(borderWidth).unpad(padding);\r\n\t        }\r\n\r\n\t        ChartElement.fn.reflow.call(this, contentBox);\r\n\r\n\t        if (hasSetSize) {\r\n\t            box = this.box = new Box(0, 0, width, height);\r\n\t        } else {\r\n\t            box = this.box;\r\n\t        }\r\n\r\n\t        if (shrinkToFit && hasSetSize) {\r\n\t            reflowPaddingBox();\r\n\t            contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);\r\n\t        } else {\r\n\t            contentBox = this.contentBox = box.clone();\r\n\t            box.pad(padding).pad(borderWidth).pad(margin);\r\n\t            reflowPaddingBox();\r\n\t        }\r\n\r\n\t        this.translateChildren(\r\n\t            box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,\r\n\t            box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top\r\n\t        );\r\n\r\n\t        var children = this.children;\r\n\t        for (var i = 0; i < children.length; i++) {\r\n\t            var item = children[i];\r\n\t            item.reflow(item.box);\r\n\t        }\r\n\t    },\r\n\r\n\t    align: function(targetBox, axis, alignment) {\r\n\t        this.box.align(targetBox, axis, alignment);\r\n\t    },\r\n\r\n\t    hasBox: function() {\r\n\t        var options = this.options;\r\n\t        return options.border.width || options.background;\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\r\n\t        var options = this.options;\r\n\t        if (options.visible && this.hasBox()) {\r\n\t            this.visual.append(Path.fromRect(\r\n\t                this.paddingBox.toRect(),\r\n\t                this.visualStyle()\r\n\t            ));\r\n\t        }\r\n\t    },\r\n\r\n\t    visualStyle: function() {\r\n\t        var options = this.options;\r\n\t        var border = options.border || {};\r\n\r\n\t        return {\r\n\t            stroke: {\r\n\t                width: border.width,\r\n\t                color: border.color,\r\n\t                opacity: valueOrDefault(border.opacity, options.opacity),\r\n\t                dashType: border.dashType\r\n\t            },\r\n\t            fill: {\r\n\t                color: options.background,\r\n\t                opacity: options.opacity\r\n\t            },\r\n\t            cursor: options.cursor\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(BoxElement, {\r\n\t    align: LEFT,\r\n\t    vAlign: TOP,\r\n\t    margin: {},\r\n\t    padding: {},\r\n\t    border: {\r\n\t        color: BLACK,\r\n\t        width: 0\r\n\t    },\r\n\t    background: \"\",\r\n\t    shrinkToFit: false,\r\n\t    width: 0,\r\n\t    height: 0,\r\n\t    visible: true\r\n\t});\r\n\r\n\tvar ShapeElement = BoxElement.extend({\r\n\t    init: function(options, pointData) {\r\n\t        BoxElement.fn.init.call(this, options);\r\n\r\n\t        this.pointData = pointData;\r\n\t    },\r\n\r\n\t    getElement: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var box = ref.paddingBox;\r\n\t        var type = options.type;\r\n\t        var rotation = options.rotation;\r\n\t        var center = box.center();\r\n\t        var halfWidth = box.width() / 2;\r\n\r\n\t        if (!options.visible || !this.hasBox()) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        var style = this.visualStyle();\r\n\t        var element;\r\n\r\n\t        if (type === CIRCLE) {\r\n\t            element = new drawing.Circle(\r\n\t                new Circle([\r\n\t                    round(box.x1 + halfWidth, COORD_PRECISION),\r\n\t                    round(box.y1 + box.height() / 2, COORD_PRECISION)\r\n\t                ], halfWidth),\r\n\t                style\r\n\t            );\r\n\t        } else if (type === TRIANGLE) {\r\n\t            element = Path.fromPoints([\r\n\t                [ box.x1 + halfWidth, box.y1 ],\r\n\t                [ box.x1, box.y2 ],\r\n\t                [ box.x2, box.y2 ]\r\n\t            ], style).close();\r\n\t        } else if (type === CROSS) {\r\n\t            element = new drawing.MultiPath(style);\r\n\r\n\t            element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);\r\n\t            element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);\r\n\t        } else {\r\n\t            element = Path.fromRect(box.toRect(), style);\r\n\t        }\r\n\r\n\t        if (rotation) {\r\n\t            element.transform(geometryTransform()\r\n\t                .rotate(-rotation, [ center.x, center.y ])\r\n\t            );\r\n\t        }\r\n\r\n\t        element.options.zIndex = options.zIndex;\r\n\t        return element;\r\n\t    },\r\n\r\n\t    createElement: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var customVisual = this.options.visual;\r\n\t        var pointData = this.pointData || {};\r\n\t        var visual;\r\n\r\n\t        if (customVisual) {\r\n\t            visual = customVisual({\r\n\t                value: pointData.value,\r\n\t                dataItem: pointData.dataItem,\r\n\t                sender: this.getSender(),\r\n\t                series: pointData.series,\r\n\t                category: pointData.category,\r\n\t                rect: this.paddingBox.toRect(),\r\n\t                options: this.visualOptions(),\r\n\t                createVisual: function () { return this$1.getElement(); }\r\n\t            });\r\n\t        } else {\r\n\t            visual = this.getElement();\r\n\t        }\r\n\r\n\t        return visual;\r\n\t    },\r\n\r\n\t    visualOptions: function() {\r\n\t        var options = this.options;\r\n\t        return {\r\n\t            background: options.background,\r\n\t            border: options.border,\r\n\t            margin: options.margin,\r\n\t            padding: options.padding,\r\n\t            type: options.type,\r\n\t            size: options.width,\r\n\t            visible: options.visible\r\n\t        };\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        this.visual = this.createElement();\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(ShapeElement, {\r\n\t    type: CIRCLE,\r\n\t    align: CENTER,\r\n\t    vAlign: CENTER\r\n\t});\r\n\r\n\tvar LINEAR = \"linear\";\r\n\tvar RADIAL = \"radial\";\r\n\r\n\tvar GRADIENTS = {\r\n\t    glass: {\r\n\t        type: LINEAR,\r\n\t        rotation: 0,\r\n\t        stops: [ {\r\n\t            offset: 0,\r\n\t            color: WHITE,\r\n\t            opacity: 0\r\n\t        }, {\r\n\t            offset: 0.25,\r\n\t            color: WHITE,\r\n\t            opacity: 0.3\r\n\t        }, {\r\n\t            offset: 1,\r\n\t            color: WHITE,\r\n\t            opacity: 0\r\n\t        } ]\r\n\t    },\r\n\t    sharpBevel: {\r\n\t        type: RADIAL,\r\n\t        stops: [ {\r\n\t            offset: 0,\r\n\t            color: WHITE,\r\n\t            opacity: 0.55\r\n\t        }, {\r\n\t            offset: 0.65,\r\n\t            color: WHITE,\r\n\t            opacity: 0\r\n\t        }, {\r\n\t            offset: 0.95,\r\n\t            color: WHITE,\r\n\t            opacity: 0.25\r\n\t        } ]\r\n\t    },\r\n\t    roundedBevel: {\r\n\t        type: RADIAL,\r\n\t        stops: [ {\r\n\t            offset: 0.33,\r\n\t            color: WHITE,\r\n\t            opacity: 0.06\r\n\t        }, {\r\n\t            offset: 0.83,\r\n\t            color: WHITE,\r\n\t            opacity: 0.2\r\n\t        }, {\r\n\t            offset: 0.95,\r\n\t            color: WHITE,\r\n\t            opacity: 0\r\n\t        } ]\r\n\t    },\r\n\t    roundedGlass: {\r\n\t        type: RADIAL,\r\n\t        supportVML: false,\r\n\t        stops: [ {\r\n\t            offset: 0,\r\n\t            color: WHITE,\r\n\t            opacity: 0\r\n\t        }, {\r\n\t            offset: 0.5,\r\n\t            color: WHITE,\r\n\t            opacity: 0.3\r\n\t        }, {\r\n\t            offset: 0.99,\r\n\t            color: WHITE,\r\n\t            opacity: 0\r\n\t        } ]\r\n\t    },\r\n\t    sharpGlass: {\r\n\t        type: RADIAL,\r\n\t        supportVML: false,\r\n\t        stops: [ {\r\n\t            offset: 0,\r\n\t            color: WHITE,\r\n\t            opacity: 0.2\r\n\t        }, {\r\n\t            offset: 0.15,\r\n\t            color: WHITE,\r\n\t            opacity: 0.15\r\n\t        }, {\r\n\t            offset: 0.17,\r\n\t            color: WHITE,\r\n\t            opacity: 0.35\r\n\t        }, {\r\n\t            offset: 0.85,\r\n\t            color: WHITE,\r\n\t            opacity: 0.05\r\n\t        }, {\r\n\t            offset: 0.87,\r\n\t            color: WHITE,\r\n\t            opacity: 0.15\r\n\t        }, {\r\n\t            offset: 0.99,\r\n\t            color: WHITE,\r\n\t            opacity: 0\r\n\t        } ]\r\n\t    },\r\n\t    bubbleShadow: {\r\n\t        type: RADIAL,\r\n\t        center: [ 0.5, 0.5 ],\r\n\t        radius: 0.5\r\n\t    }\r\n\t};\r\n\r\n\tfunction boxDiff(r, s) {\r\n\t    if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {\r\n\t        return s;\r\n\t    }\r\n\r\n\t    var a = Math.min(r.x1, s.x1);\r\n\t    var b = Math.max(r.x1, s.x1);\r\n\t    var c = Math.min(r.x2, s.x2);\r\n\t    var d = Math.max(r.x2, s.x2);\r\n\t    var e = Math.min(r.y1, s.y1);\r\n\t    var f = Math.max(r.y1, s.y1);\r\n\t    var g = Math.min(r.y2, s.y2);\r\n\t    var h = Math.max(r.y2, s.y2);\r\n\t    var boxes = [];\r\n\r\n\t    // X = intersection, 0-7 = possible difference areas\r\n\t    // h +-+-+-+\r\n\t    // . |5|6|7|\r\n\t    // g +-+-+-+\r\n\t    // . |3|X|4|\r\n\t    // f +-+-+-+\r\n\t    // . |0|1|2|\r\n\t    // e +-+-+-+\r\n\t    // . a b c d\r\n\r\n\t    // we'll always have rectangles 1, 3, 4 and 6\r\n\t    boxes[0] = new Box(b, e, c, f);\r\n\t    boxes[1] = new Box(a, f, b, g);\r\n\t    boxes[2] = new Box(c, f, d, g);\r\n\t    boxes[3] = new Box(b, g, c, h);\r\n\r\n\t    // decide which corners\r\n\t    if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) { // corners 0 and 7\r\n\t        boxes[4] = new Box(a, e, b, f);\r\n\t        boxes[5] = new Box(c, g, d, h);\r\n\t    } else { // corners 2 and 5\r\n\t        boxes[4] = new Box(c, e, d, f);\r\n\t        boxes[5] = new Box(a, g, b, h);\r\n\t    }\r\n\r\n\t    return grep(boxes, function(box) {\r\n\t        return box.height() > 0 && box.width() > 0;\r\n\t    })[0];\r\n\t}\r\n\r\n\tvar RootElement = ChartElement.extend({\r\n\t    init: function(options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        var rootOptions = this.options;\r\n\t        rootOptions.width = parseInt(rootOptions.width, 10);\r\n\t        rootOptions.height = parseInt(rootOptions.height, 10);\r\n\r\n\t        this.gradients = {};\r\n\t    },\r\n\r\n\t    reflow: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var children = ref.children;\r\n\t        var currentBox = new Box(0, 0, options.width, options.height);\r\n\r\n\t        this.box = currentBox.unpad(options.margin);\r\n\r\n\t        for (var i = 0; i < children.length; i++) {\r\n\t            children[i].reflow(currentBox);\r\n\t            currentBox = boxDiff(currentBox, children[i].box) || new Box();\r\n\t        }\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        this.visual = new Group();\r\n\t        this.createBackground();\r\n\t    },\r\n\r\n\t    createBackground: function() {\r\n\t        var options = this.options;\r\n\t        var border = options.border || {};\r\n\t        var box = this.box.clone().pad(options.margin).unpad(border.width);\r\n\r\n\t        var background = Path.fromRect(box.toRect(), {\r\n\t            stroke: {\r\n\t                color: border.width ? border.color : \"\",\r\n\t                width: border.width,\r\n\t                dashType: border.dashType\r\n\t            },\r\n\t            fill: {\r\n\t                color: options.background,\r\n\t                opacity: options.opacity\r\n\t            },\r\n\t            zIndex: -10\r\n\t        });\r\n\r\n\t        this.visual.append(background);\r\n\t    },\r\n\r\n\t    getRoot: function() {\r\n\t        return this;\r\n\t    },\r\n\r\n\t    createGradient: function(options) {\r\n\t        var gradients = this.gradients;\r\n\t        var hashCode = objectKey(options);\r\n\t        var gradient = GRADIENTS[options.gradient];\r\n\t        var drawingGradient;\r\n\r\n\t        if (gradients[hashCode]) {\r\n\t            drawingGradient = gradients[hashCode];\r\n\t        } else {\r\n\t            var gradientOptions = $.extend({}, gradient, options);\r\n\t            if (gradient.type === \"linear\") {\r\n\t                drawingGradient = new drawing.LinearGradient(gradientOptions);\r\n\t            } else {\r\n\t                if (options.innerRadius) {\r\n\t                    gradientOptions.stops = innerRadialStops(gradientOptions);\r\n\t                }\r\n\t                drawingGradient = new drawing.RadialGradient(gradientOptions);\r\n\t                drawingGradient.supportVML = gradient.supportVML !== false;\r\n\t            }\r\n\t            gradients[hashCode] = drawingGradient;\r\n\t        }\r\n\r\n\t        return drawingGradient;\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(RootElement, {\r\n\t    width: DEFAULT_WIDTH,\r\n\t    height: DEFAULT_HEIGHT,\r\n\t    background: WHITE,\r\n\t    border: {\r\n\t        color: BLACK,\r\n\t        width: 0\r\n\t    },\r\n\t    margin: getSpacing(5),\r\n\t    zIndex: -2\r\n\t});\r\n\r\n\tfunction innerRadialStops(options) {\r\n\t    var stops = options.stops;\r\n\t    var usedSpace = ((options.innerRadius / options.radius) * 100);\r\n\t    var length = stops.length;\r\n\t    var currentStops = [];\r\n\r\n\t    for (var i = 0; i < length; i++) {\r\n\t        var currentStop = $.extend({}, stops[i]);\r\n\t        currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;\r\n\t        currentStops.push(currentStop);\r\n\t    }\r\n\r\n\t    return currentStops;\r\n\t}\r\n\r\n\tvar FloatElement = ChartElement.extend({\r\n\t    init: function(options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\t        this._initDirection();\r\n\t    },\r\n\r\n\t    _initDirection: function() {\r\n\t        var options = this.options;\r\n\t        if (options.vertical) {\r\n\t            this.groupAxis = X;\r\n\t            this.elementAxis = Y;\r\n\t            this.groupSizeField = WIDTH;\r\n\t            this.elementSizeField = HEIGHT;\r\n\t            this.groupSpacing = options.spacing;\r\n\t            this.elementSpacing = options.vSpacing;\r\n\t        } else {\r\n\t            this.groupAxis = Y;\r\n\t            this.elementAxis = X;\r\n\t            this.groupSizeField = HEIGHT;\r\n\t            this.elementSizeField = WIDTH;\r\n\t            this.groupSpacing = options.vSpacing;\r\n\t            this.elementSpacing = options.spacing;\r\n\t        }\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        this.box = targetBox.clone();\r\n\t        this.reflowChildren();\r\n\t    },\r\n\r\n\t    reflowChildren: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var box = ref.box;\r\n\t        var elementAxis = ref.elementAxis;\r\n\t        var groupAxis = ref.groupAxis;\r\n\t        var elementSizeField = ref.elementSizeField;\r\n\t        var groupSizeField = ref.groupSizeField;\r\n\t        var ref$1 = this.groupOptions();\r\n\t        var groups = ref$1.groups;\r\n\t        var groupsSize = ref$1.groupsSize;\r\n\t        var maxGroupElementsSize = ref$1.maxGroupElementsSize;\r\n\t        var groupsCount = groups.length;\r\n\t        var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());\r\n\r\n\t        if (groupsCount) {\r\n\t            var groupStart = groupsStart;\r\n\r\n\t            for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {\r\n\t                var group = groups[groupIdx];\r\n\t                var groupElements = group.groupElements;\r\n\t                var elementStart = box[elementAxis + 1];\r\n\t                var groupElementsCount = groupElements.length;\r\n\r\n\t                for (var idx = 0; idx < groupElementsCount; idx++) {\r\n\t                    var element = groupElements[idx];\r\n\t                    var elementSize$$1 = this$1.elementSize(element);\r\n\t                    var groupElementStart = groupStart + this$1.alignStart(elementSize$$1[groupSizeField], group.groupSize);\r\n\r\n\t                    var elementBox = new Box();\r\n\t                    elementBox[groupAxis + 1] = groupElementStart;\r\n\t                    elementBox[groupAxis + 2] = groupElementStart + elementSize$$1[groupSizeField];\r\n\t                    elementBox[elementAxis + 1] = elementStart;\r\n\t                    elementBox[elementAxis + 2] = elementStart + elementSize$$1[elementSizeField];\r\n\r\n\t                    element.reflow(elementBox);\r\n\r\n\t                    elementStart += elementSize$$1[elementSizeField] + this$1.elementSpacing;\r\n\t                }\r\n\t                groupStart += group.groupSize + this$1.groupSpacing;\r\n\t            }\r\n\t            box[groupAxis + 1] = groupsStart;\r\n\t            box[groupAxis + 2] = groupsStart + groupsSize;\r\n\t            box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;\r\n\t        }\r\n\t    },\r\n\r\n\t    alignStart: function(size, maxSize) {\r\n\t        var start = 0;\r\n\t        var align = this.options.align;\r\n\t        if (align === RIGHT || align === BOTTOM) {\r\n\t            start = maxSize - size;\r\n\t        } else if (align === CENTER) {\r\n\t            start = (maxSize - size) / 2;\r\n\t        }\r\n\t        return start;\r\n\t    },\r\n\r\n\t    groupOptions: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var box = ref.box;\r\n\t        var children = ref.children;\r\n\t        var elementSizeField = ref.elementSizeField;\r\n\t        var groupSizeField = ref.groupSizeField;\r\n\t        var elementSpacing = ref.elementSpacing;\r\n\t        var groupSpacing = ref.groupSpacing;\r\n\t        var maxSize = round(box[elementSizeField]());\r\n\t        var childrenCount = children.length;\r\n\t        var groups = [];\r\n\r\n\t        var groupSize = 0;\r\n\t        var groupElementsSize = 0;\r\n\t        var groupsSize = 0;\r\n\t        var maxGroupElementsSize = 0;\r\n\t        var groupElements = [];\r\n\r\n\t        for (var idx = 0; idx < childrenCount; idx++) {\r\n\t            var element = children[idx];\r\n\t            if (!element.box) {\r\n\t                element.reflow(box);\r\n\t            }\r\n\r\n\t            var elementSize$$1 = this$1.elementSize(element);\r\n\t            if (this$1.options.wrap && round(groupElementsSize + elementSpacing + elementSize$$1[elementSizeField]) > maxSize) {\r\n\t                groups.push({\r\n\t                    groupElements: groupElements,\r\n\t                    groupSize: groupSize,\r\n\t                    groupElementsSize: groupElementsSize\r\n\t                });\r\n\t                maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\r\n\t                groupsSize += groupSpacing + groupSize;\r\n\t                groupSize = 0;\r\n\t                groupElementsSize = 0;\r\n\t                groupElements = [];\r\n\t            }\r\n\t            groupSize = Math.max(groupSize, elementSize$$1[groupSizeField]);\r\n\t            if (groupElementsSize > 0) {\r\n\t                groupElementsSize += elementSpacing;\r\n\t            }\r\n\t            groupElementsSize += elementSize$$1[elementSizeField];\r\n\t            groupElements.push(element);\r\n\t        }\r\n\r\n\t        groups.push({\r\n\t            groupElements: groupElements,\r\n\t            groupSize: groupSize,\r\n\t            groupElementsSize: groupElementsSize\r\n\t        });\r\n\t        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);\r\n\t        groupsSize += groupSize;\r\n\r\n\t        return {\r\n\t            groups: groups,\r\n\t            groupsSize: groupsSize,\r\n\t            maxGroupElementsSize: maxGroupElementsSize\r\n\t        };\r\n\t    },\r\n\r\n\t    elementSize: function(element) {\r\n\t        return {\r\n\t            width: element.box.width(),\r\n\t            height: element.box.height()\r\n\t        };\r\n\t    },\r\n\r\n\t    createVisual: function() {}\r\n\t});\r\n\r\n\tsetDefaultOptions(FloatElement, {\r\n\t    vertical: true,\r\n\t    wrap: true,\r\n\t    vSpacing: 0,\r\n\t    spacing: 0\r\n\t});\r\n\r\n\tvar DrawingText = drawing.Text;\r\n\r\n\tvar Text = ChartElement.extend({\r\n\t    init: function(content, options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.content = content;\r\n\r\n\t        // Calculate size\r\n\t        this.reflow(new Box());\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var options = this.options;\r\n\t        var size = options.size = util.measureText(this.content, { font: options.font });\r\n\r\n\t        this.baseline = size.baseline;\r\n\r\n\t        this.box = new Box(targetBox.x1, targetBox.y1,\r\n\t                targetBox.x1 + size.width, targetBox.y1 + size.height);\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        var ref = this.options;\r\n\t        var font = ref.font;\r\n\t        var color = ref.color;\r\n\t        var opacity = ref.opacity;\r\n\t        var cursor = ref.cursor;\r\n\r\n\t        this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {\r\n\t            font: font,\r\n\t            fill: { color: color, opacity: opacity },\r\n\t            cursor: cursor\r\n\t        });\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(Text, {\r\n\t    font: DEFAULT_FONT,\r\n\t    color: BLACK\r\n\t});\r\n\r\n\tfunction rectToBox(rect) {\r\n\t    var origin = rect.origin;\r\n\t    var bottomRight = rect.bottomRight();\r\n\r\n\t    return new Box(origin.x, origin.y, bottomRight.x, bottomRight.y);\r\n\t}\r\n\r\n\tvar ROWS_SPLIT_REGEX = /\\n/m;\r\n\r\n\tvar TextBox = BoxElement.extend({\r\n\t    init: function(content, options) {\r\n\t        BoxElement.fn.init.call(this, options);\r\n\t        this.content = content;\r\n\r\n\t        this._initContainer();\r\n\t        if (this.options._autoReflow !== false) {\r\n\t            this.reflow(new Box());\r\n\t        }\r\n\t    },\r\n\r\n\t    _initContainer: function() {\r\n\t        var options = this.options;\r\n\t        var rows = String(this.content).split(ROWS_SPLIT_REGEX);\r\n\t        var floatElement = new FloatElement({ vertical: true, align: options.align, wrap: false });\r\n\t        var textOptions = deepExtend({ }, options, { opacity: 1, animation: null });\r\n\r\n\t        this.container = floatElement;\r\n\t        this.append(floatElement);\r\n\r\n\t        for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {\r\n\t            var text = new Text(rows[rowIdx].trim(), textOptions);\r\n\t            floatElement.append(text);\r\n\t        }\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var options = this.options;\r\n\t        var visualFn = options.visual;\r\n\t        this.container.options.align = options.align;\r\n\r\n\t        if (visualFn && !this._boxReflow) {\r\n\t            var visualBox = targetBox;\r\n\t            if (!visualBox.hasSize()) {\r\n\t                this._boxReflow = true;\r\n\t                this.reflow(visualBox);\r\n\t                this._boxReflow = false;\r\n\t                visualBox = this.box;\r\n\t            }\r\n\t            var visual = this.visual = visualFn(this.visualContext(visualBox));\r\n\r\n\t            if (visual) {\r\n\t                visualBox = rectToBox(visual.clippedBBox() || new Rect());\r\n\r\n\t                visual.options.zIndex = options.zIndex;\r\n\t            }\r\n\r\n\t            this.box = this.contentBox = this.paddingBox = visualBox;\r\n\t        } else {\r\n\t            BoxElement.fn.reflow.call(this, targetBox);\r\n\r\n\t            if (options.rotation) {\r\n\t                var margin = getSpacing(options.margin);\r\n\t                var box = this.box.unpad(margin);\r\n\r\n\t                this.targetBox = targetBox;\r\n\t                this.normalBox = box.clone();\r\n\r\n\t                box = this.rotate();\r\n\t                box.translate(margin.left - margin.right, margin.top - margin.bottom);\r\n\r\n\t                this.rotatedBox = box.clone();\r\n\r\n\t                box.pad(margin);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        var options = this.options;\r\n\r\n\t        if (!options.visible) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        this.visual = new Group({\r\n\t            transform: this.rotationTransform(),\r\n\t            zIndex: options.zIndex,\r\n\t            noclip: options.noclip\r\n\t        });\r\n\r\n\t        if (this.hasBox()) {\r\n\t            var box = Path.fromRect(this.paddingBox.toRect(), this.visualStyle());\r\n\t            this.visual.append(box);\r\n\t        }\r\n\t    },\r\n\r\n\t    renderVisual: function() {\r\n\t        if (this.options.visual) {\r\n\t            var visual = this.visual;\r\n\t            if (visual && !defined(visual.options.noclip)) {\r\n\t                visual.options.noclip = this.options.noclip;\r\n\t            }\r\n\t            this.addVisual();\r\n\t            this.createAnimation();\r\n\t        } else {\r\n\t            BoxElement.fn.renderVisual.call(this);\r\n\t        }\r\n\t    },\r\n\r\n\t    visualOptions: function() {\r\n\t        var options = this.options;\r\n\t        return {\r\n\t            background: options.background,\r\n\t            border: options.border,\r\n\t            color: options.color,\r\n\t            font: options.font,\r\n\t            margin: options.margin,\r\n\t            padding: options.padding,\r\n\t            visible: options.visible\r\n\t        };\r\n\t    },\r\n\r\n\t    visualContext: function(targetBox) {\r\n\t        var this$1 = this;\r\n\r\n\t        return {\r\n\t            text: this.content,\r\n\t            rect: targetBox.toRect(),\r\n\t            sender: this.getSender(),\r\n\t            options: this.visualOptions(),\r\n\t            createVisual: function () {\r\n\t                this$1._boxReflow = true;\r\n\t                this$1.reflow(targetBox);\r\n\t                this$1._boxReflow = false;\r\n\t                return this$1.getDefaultVisual();\r\n\t            }\r\n\t        };\r\n\t    },\r\n\r\n\t    getDefaultVisual: function() {\r\n\t        this.createVisual();\r\n\t        this.renderChildren();\r\n\t        var visual = this.visual;\r\n\t        delete this.visual;\r\n\t        return visual;\r\n\t    },\r\n\r\n\t    rotate: function() {\r\n\t        var options = this.options;\r\n\t        this.box.rotate(options.rotation);\r\n\t        this.align(this.targetBox, X, options.align);\r\n\t        this.align(this.targetBox, Y, options.vAlign);\r\n\t        return this.box;\r\n\t    },\r\n\r\n\t    rotationTransform: function() {\r\n\t        var rotation = this.options.rotation;\r\n\t        if (!rotation) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        var ref = this.normalBox.center();\r\n\t        var cx = ref.x;\r\n\t        var cy = ref.y;\r\n\t        var boxCenter = this.rotatedBox.center();\r\n\r\n\t        return geometryTransform()\r\n\t                   .translate(boxCenter.x - cx, boxCenter.y - cy)\r\n\t                   .rotate(rotation, [ cx, cy ]);\r\n\t    }\r\n\t});\r\n\r\n\tvar Title = ChartElement.extend({\r\n\t    init: function(options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.append(\r\n\t            new TextBox(this.options.text, $.extend({}, this.options, {\r\n\t                vAlign: this.options.position\r\n\t            }))\r\n\t        );\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        ChartElement.fn.reflow.call(this, targetBox);\r\n\t        this.box.snapTo(targetBox, X);\r\n\t    }\r\n\t});\r\n\r\n\tTitle.buildTitle = function(options, parent, defaultOptions) {\r\n\t    var titleOptions = options;\r\n\r\n\t    if (typeof options === \"string\") {\r\n\t        titleOptions = { text: options };\r\n\t    }\r\n\r\n\t    titleOptions = $.extend({ visible: true }, defaultOptions, titleOptions);\r\n\r\n\t    var title;\r\n\t    if (titleOptions && titleOptions.visible && titleOptions.text) {\r\n\t        title = new Title(titleOptions);\r\n\t        parent.append(title);\r\n\t    }\r\n\r\n\t    return title;\r\n\t};\r\n\r\n\tsetDefaultOptions(Title, {\r\n\t    color: BLACK,\r\n\t    position: TOP,\r\n\t    align: CENTER,\r\n\t    margin: getSpacing(5),\r\n\t    padding: getSpacing(5)\r\n\t});\r\n\r\n\tvar AxisLabel = TextBox.extend({\r\n\t    init: function(value, text, index, dataItem, options) {\r\n\t        TextBox.fn.init.call(this, text, options);\r\n\r\n\t        this.text = text;\r\n\t        this.value = value;\r\n\t        this.index = index;\r\n\t        this.dataItem = dataItem;\r\n\t        this.reflow(new Box());\r\n\t    },\r\n\r\n\t    visualContext: function(targetBox) {\r\n\t        var context = TextBox.fn.visualContext.call(this, targetBox);\r\n\r\n\t        context.value = this.value;\r\n\t        context.dataItem = this.dataItem;\r\n\t        context.format = this.options.format;\r\n\t        context.culture = this.options.culture;\r\n\r\n\t        return context;\r\n\t    },\r\n\r\n\t    click: function(widget, e) {\r\n\r\n\t        widget.trigger(AXIS_LABEL_CLICK, {\r\n\t            element: eventElement(e),\r\n\t            value: this.value,\r\n\t            text: this.text,\r\n\t            index: this.index,\r\n\t            dataItem: this.dataItem,\r\n\t            axis: this.parent.options\r\n\t        });\r\n\t    },\r\n\r\n\t    rotate: function() {\r\n\t        if (this.options.alignRotation !== CENTER) {\r\n\t            var box = this.normalBox.toRect();\r\n\t            var transform = this.rotationTransform();\r\n\r\n\t            this.box = rectToBox(box.bbox(transform.matrix()));\r\n\t        } else {\r\n\t            TextBox.fn.rotate.call(this);\r\n\t        }\r\n\r\n\t        return this.box;\r\n\t    },\r\n\r\n\t    rotationTransform: function() {\r\n\t        var options = this.options;\r\n\t        var rotation = options.rotation;\r\n\t        if (!rotation) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        if (options.alignRotation === CENTER) {\r\n\t            return TextBox.fn.rotationTransform.call(this);\r\n\t        }\r\n\r\n\t        var rotationMatrix = geometryTransform().rotate(rotation).matrix();\r\n\t        var box = this.normalBox.toRect();\r\n\t        var rect = this.targetBox.toRect();\r\n\r\n\t        var rotationOrigin = options.rotationOrigin || TOP;\r\n\t        var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;\r\n\t        var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;\r\n\t        var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();\r\n\r\n\t        var topLeft = box.topLeft().transformCopy(rotationMatrix);\r\n\t        var topRight = box.topRight().transformCopy(rotationMatrix);\r\n\t        var bottomRight = box.bottomRight().transformCopy(rotationMatrix);\r\n\t        var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);\r\n\t        var rotatedBox = Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);\r\n\r\n\t        var translate = {};\r\n\t        translate[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];\r\n\r\n\t        var distanceLeft = Math.abs(topLeft[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\r\n\t        var distanceRight = Math.abs(topRight[distanceAxis] + translate[distanceAxis] - axisAnchor[distanceAxis]);\r\n\r\n\t        var alignStart, alignEnd;\r\n\r\n\t        if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {\r\n\t            alignStart = topLeft;\r\n\t            alignEnd = topRight;\r\n\t        } else if (distanceRight < distanceLeft) {\r\n\t            alignStart = topRight;\r\n\t            alignEnd = bottomRight;\r\n\t        } else {\r\n\t            alignStart = topLeft;\r\n\t            alignEnd = bottomLeft;\r\n\t        }\r\n\r\n\t        var alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;\r\n\t        translate[alignAxis] = rect.center()[alignAxis] - alignCenter;\r\n\r\n\t        return geometryTransform()\r\n\t            .translate(translate.x, translate.y)\r\n\t            .rotate(rotation);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(AxisLabel, {\r\n\t    _autoReflow: false\r\n\t});\r\n\r\n\tvar DEFAULT_ICON_SIZE = 7;\r\n\tvar DEFAULT_LABEL_COLOR = \"#fff\";\r\n\r\n\tvar Note = BoxElement.extend({\r\n\t    init: function(fields, options, chartService) {\r\n\t        BoxElement.fn.init.call(this, options);\r\n\r\n\t        this.fields = fields;\r\n\t        this.chartService = chartService;\r\n\r\n\t        this.render();\r\n\t    },\r\n\r\n\t    hide: function() {\r\n\t        this.options.visible = false;\r\n\t    },\r\n\r\n\t    show: function() {\r\n\t        this.options.visible = true;\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        var options = this.options;\r\n\r\n\t        if (options.visible) {\r\n\t            var label = options.label;\r\n\t            var icon = options.icon;\r\n\t            var box = new Box();\r\n\t            var size = icon.size;\r\n\t            var text = this.fields.text;\r\n\t            var width, height;\r\n\r\n\t            if (defined(label) && label.visible) {\r\n\t                var noteTemplate = getTemplate(label);\r\n\t                if (noteTemplate) {\r\n\t                    text = noteTemplate(this.fields);\r\n\t                } else if (label.format) {\r\n\t                    text = this.chartService.format.auto(label.format, text);\r\n\t                }\r\n\r\n\t                if (!label.color) {\r\n\t                    label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\r\n\t                }\r\n\r\n\t                this.label = new TextBox(text, deepExtend({}, label));\r\n\r\n\t                if (label.position === INSIDE && !defined(size)) {\r\n\t                    if (icon.type === CIRCLE) {\r\n\t                        size = Math.max(this.label.box.width(), this.label.box.height());\r\n\t                    } else {\r\n\t                        width = this.label.box.width();\r\n\t                        height = this.label.box.height();\r\n\t                    }\r\n\t                    box.wrap(this.label.box);\r\n\t                }\r\n\t            }\r\n\r\n\t            icon.width = width || size || DEFAULT_ICON_SIZE;\r\n\t            icon.height = height || size || DEFAULT_ICON_SIZE;\r\n\r\n\t            var marker = new ShapeElement(deepExtend({}, icon));\r\n\r\n\t            this.marker = marker;\r\n\t            this.append(marker);\r\n\r\n\t            if (this.label) {\r\n\t                this.append(this.label);\r\n\t            }\r\n\r\n\t            marker.reflow(new Box());\r\n\t            this.wrapperBox = box.wrap(marker.box);\r\n\t        }\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var label = ref.label;\r\n\t        var marker = ref.marker;\r\n\t        var wrapperBox = ref.wrapperBox;\r\n\t        var center = targetBox.center();\r\n\t        var length = options.line.length;\r\n\t        var position = options.position;\r\n\r\n\t        // TODO: Review\r\n\t        if (options.visible) {\r\n\t            var lineStart, box, contentBox;\r\n\r\n\t            if (inArray(position, [ LEFT, RIGHT ])) {\r\n\t                if (position === LEFT) {\r\n\t                    contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\r\n\r\n\t                    if (options.line.visible) {\r\n\t                        lineStart = [ targetBox.x1, center.y ];\r\n\t                        this.linePoints = [\r\n\t                            lineStart,\r\n\t                            [ contentBox.x2, center.y ]\r\n\t                        ];\r\n\t                        box = contentBox.clone().wrapPoint(lineStart);\r\n\t                    }\r\n\t                } else {\r\n\t                    contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\r\n\r\n\t                    if (options.line.visible) {\r\n\t                        lineStart = [ targetBox.x2, center.y ];\r\n\t                        this.linePoints = [\r\n\t                            lineStart,\r\n\t                            [ contentBox.x1, center.y ]\r\n\t                        ];\r\n\t                        box = contentBox.clone().wrapPoint(lineStart);\r\n\t                    }\r\n\t                }\r\n\t            } else {\r\n\t                if (position === BOTTOM) {\r\n\t                    contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\r\n\r\n\t                    if (options.line.visible) {\r\n\t                        lineStart = [ center.x, targetBox.y2 ];\r\n\t                        this.linePoints = [\r\n\t                            lineStart,\r\n\t                            [ center.x, contentBox.y1 ]\r\n\t                        ];\r\n\t                        box = contentBox.clone().wrapPoint(lineStart);\r\n\t                    }\r\n\t                } else {\r\n\t                    contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\r\n\r\n\t                    if (options.line.visible) {\r\n\t                        lineStart = [ center.x, targetBox.y1 ];\r\n\t                        this.linePoints = [\r\n\t                            lineStart,\r\n\t                            [ center.x, contentBox.y2 ]\r\n\t                        ];\r\n\t                        box = contentBox.clone().wrapPoint(lineStart);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            if (marker) {\r\n\t                marker.reflow(contentBox);\r\n\t            }\r\n\r\n\t            if (label) {\r\n\t                label.reflow(contentBox);\r\n\t                if (marker) {\r\n\t                    if (options.label.position === OUTSIDE) {\r\n\t                        label.box.alignTo(marker.box, position);\r\n\t                    }\r\n\t                    label.reflow(label.box);\r\n\t                }\r\n\t            }\r\n\r\n\t            this.contentBox = contentBox;\r\n\t            this.targetBox = targetBox;\r\n\t            this.box = box || contentBox;\r\n\t        }\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        BoxElement.fn.createVisual.call(this);\r\n\t        this.visual.options.noclip = this.options.noclip;\r\n\r\n\t        if (this.options.visible) {\r\n\t            this.createLine();\r\n\t        }\r\n\t    },\r\n\r\n\t    renderVisual: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var customVisual = options.visual;\r\n\t        if (options.visible && customVisual) {\r\n\t            this.visual = customVisual($.extend(this.fields, {\r\n\t                sender: this.getSender(),\r\n\t                rect: this.targetBox.toRect(),\r\n\t                options: {\r\n\t                    background: options.background,\r\n\t                    border: options.background,\r\n\t                    icon: options.icon,\r\n\t                    label: options.label,\r\n\t                    line: options.line,\r\n\t                    position: options.position,\r\n\t                    visible: options.visible\r\n\t                },\r\n\t                createVisual: function () {\r\n\t                    this$1.createVisual();\r\n\t                    this$1.renderChildren();\r\n\t                    var defaultVisual = this$1.visual;\r\n\t                    delete this$1.visual;\r\n\t                    return defaultVisual;\r\n\t                }\r\n\t            }));\r\n\t            this.addVisual();\r\n\t        } else {\r\n\t            BoxElement.fn.renderVisual.call(this);\r\n\t        }\r\n\t    },\r\n\r\n\t    createLine: function() {\r\n\t        var options = this.options.line;\r\n\r\n\t        if (this.linePoints) {\r\n\t            var path = Path.fromPoints(this.linePoints, {\r\n\t                stroke: {\r\n\t                    color: options.color,\r\n\t                    width: options.width,\r\n\t                    dashType: options.dashType\r\n\t                }\r\n\t            });\r\n\r\n\t            alignPathToPixel(path);\r\n\t            this.visual.append(path);\r\n\t        }\r\n\t    },\r\n\r\n\t    click: function(widget, e) {\r\n\t        var args = this.eventArgs(e);\r\n\r\n\t        if (!widget.trigger(NOTE_CLICK, args)) {\r\n\t            e.preventDefault();\r\n\t        }\r\n\t    },\r\n\r\n\t    hover: function(widget, e) {\r\n\t        var args = this.eventArgs(e);\r\n\r\n\t        if (!widget.trigger(NOTE_HOVER, args)) {\r\n\t            e.preventDefault();\r\n\t        }\r\n\t    },\r\n\r\n\t    leave: function(widget) {\r\n\t        widget._unsetActivePoint();\r\n\t    },\r\n\r\n\t    eventArgs: function(e) {\r\n\t        var options = this.options;\r\n\r\n\t        return $.extend(this.fields, {\r\n\t            element: eventElement(e),\r\n\t            text: defined(options.label) ? options.label.text : \"\",\r\n\t            visual: this.visual\r\n\t        });\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(Note, {\r\n\t    icon: {\r\n\t        visible: true,\r\n\t        type: CIRCLE\r\n\t    },\r\n\t    label: {\r\n\t        position: INSIDE,\r\n\t        visible: true,\r\n\t        align: CENTER,\r\n\t        vAlign: CENTER\r\n\t    },\r\n\t    line: {\r\n\t        visible: true\r\n\t    },\r\n\t    visible: true,\r\n\t    position: TOP,\r\n\t    zIndex: 2\r\n\t});\r\n\r\n\tfunction createAxisTick(options, tickOptions) {\r\n\t    var tickX = options.tickX;\r\n\t    var tickY = options.tickY;\r\n\t    var position = options.position;\r\n\r\n\t    var tick = new Path({\r\n\t        stroke: {\r\n\t            width: tickOptions.width,\r\n\t            color: tickOptions.color\r\n\t        }\r\n\t    });\r\n\r\n\t    if (options.vertical) {\r\n\t        tick.moveTo(tickX, position)\r\n\t            .lineTo(tickX + tickOptions.size, position);\r\n\t    } else {\r\n\t        tick.moveTo(position, tickY)\r\n\t            .lineTo(position, tickY + tickOptions.size);\r\n\t    }\r\n\r\n\t    alignPathToPixel(tick);\r\n\r\n\t    return tick;\r\n\t}\r\n\r\n\tfunction createAxisGridLine(options, gridLine) {\r\n\t    var lineStart = options.lineStart;\r\n\t    var lineEnd = options.lineEnd;\r\n\t    var position = options.position;\r\n\r\n\t    var line = new Path({\r\n\t        stroke: {\r\n\t            width: gridLine.width,\r\n\t            color: gridLine.color,\r\n\t            dashType: gridLine.dashType\r\n\t        }\r\n\t    });\r\n\r\n\t    if (options.vertical) {\r\n\t        line.moveTo(lineStart, position)\r\n\t            .lineTo(lineEnd, position);\r\n\t    } else {\r\n\t        line.moveTo(position, lineStart)\r\n\t            .lineTo(position, lineEnd);\r\n\t    }\r\n\r\n\t    alignPathToPixel(line);\r\n\r\n\t    return line;\r\n\t}\r\n\r\n\tvar Axis = ChartElement.extend({\r\n\t    init: function(options, chartService) {\r\n\t        if (chartService === void 0) { chartService = new ChartService(); }\r\n\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.chartService = chartService;\r\n\r\n\t        if (!this.options.visible) {\r\n\t            this.options = deepExtend({}, this.options, {\r\n\t                labels: {\r\n\t                    visible: false\r\n\t                },\r\n\t                line: {\r\n\t                    visible: false\r\n\t                },\r\n\t                margin: 0,\r\n\t                majorTickSize: 0,\r\n\t                minorTickSize: 0\r\n\t            });\r\n\t        }\r\n\r\n\t        this.options.minorTicks = deepExtend({}, {\r\n\t            color: this.options.line.color,\r\n\t            width: this.options.line.width,\r\n\t            visible: this.options.minorTickType !== NONE\r\n\t        }, this.options.minorTicks, {\r\n\t            size: this.options.minorTickSize,\r\n\t            align: this.options.minorTickType\r\n\t        });\r\n\r\n\t        this.options.majorTicks = deepExtend({}, {\r\n\t            color: this.options.line.color,\r\n\t            width: this.options.line.width,\r\n\t            visible: this.options.majorTickType !== NONE\r\n\t        }, this.options.majorTicks, {\r\n\t            size: this.options.majorTickSize,\r\n\t            align: this.options.majorTickType\r\n\t        });\r\n\r\n\t        if (!this.options._deferLabels) {\r\n\t            this.createLabels();\r\n\t        }\r\n\r\n\t        this.createTitle();\r\n\t        this.createNotes();\r\n\t    },\r\n\r\n\t    labelsRange: function() {\r\n\t        return {\r\n\t            min: this.options.labels.skip,\r\n\t            max: this.labelsCount()\r\n\t        };\r\n\t    },\r\n\r\n\t    createLabels: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var align = options.vertical ? RIGHT : CENTER;\r\n\t        var labelOptions = deepExtend({ }, options.labels, {\r\n\t            align: align,\r\n\t            zIndex: options.zIndex\r\n\t        });\r\n\t        var step = Math.max(1, labelOptions.step);\r\n\r\n\t        this.children = grep(this.children, function (child) { return !(child instanceof AxisLabel); });\r\n\r\n\t        this.labels = [];\r\n\r\n\t        if (labelOptions.visible) {\r\n\t            var range = this.labelsRange();\r\n\t            var rotation = labelOptions.rotation;\r\n\r\n\t            if (isObject(rotation)) {\r\n\t                labelOptions.alignRotation = rotation.align;\r\n\t                labelOptions.rotation = rotation.angle;\r\n\t            }\r\n\r\n\t            if (labelOptions.rotation === \"auto\") {\r\n\t                labelOptions.rotation = 0;\r\n\t                options.autoRotateLabels = true;\r\n\t            }\r\n\r\n\t            for (var idx = range.min; idx < range.max; idx += step) {\r\n\t                var label = this$1.createAxisLabel(idx, labelOptions);\r\n\t                if (label) {\r\n\t                    this$1.append(label);\r\n\t                    this$1.labels.push(label);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    lineBox: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var box = ref.box;\r\n\t        var vertical = options.vertical;\r\n\t        var mirror = options.labels.mirror;\r\n\t        var axisX = mirror ? box.x1 : box.x2;\r\n\t        var axisY = mirror ? box.y2 : box.y1;\r\n\t        var lineWidth = options.line.width || 0;\r\n\r\n\t        return vertical ?\r\n\t            new Box(axisX, box.y1, axisX, box.y2 - lineWidth) :\r\n\t            new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\r\n\t    },\r\n\r\n\t    createTitle: function() {\r\n\t        var options = this.options;\r\n\t        var titleOptions = deepExtend({\r\n\t            rotation: options.vertical ? -90 : 0,\r\n\t            text: \"\",\r\n\t            zIndex: 1,\r\n\t            visualSize: true\r\n\t        }, options.title);\r\n\r\n\t        if (titleOptions.visible && titleOptions.text) {\r\n\t            var title = new TextBox(titleOptions.text, titleOptions);\r\n\t            this.append(title);\r\n\t            this.title = title;\r\n\t        }\r\n\t    },\r\n\r\n\t    createNotes: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var notes = options.notes;\r\n\t        var items = notes.data || [];\r\n\r\n\t        this.notes = [];\r\n\r\n\t        for (var i = 0; i < items.length; i++) {\r\n\t            var item = deepExtend({}, notes, items[i]);\r\n\t            item.value = this$1.parseNoteValue(item.value);\r\n\r\n\t            var note = new Note({\r\n\t                value: item.value,\r\n\t                text: item.label.text,\r\n\t                dataItem: item\r\n\t            }, item, this$1.chartService);\r\n\r\n\t            if (note.options.visible) {\r\n\t                if (defined(note.options.position)) {\r\n\t                    if (options.vertical && !inArray(note.options.position, [ LEFT, RIGHT ])) {\r\n\t                        note.options.position = options.reverse ? LEFT : RIGHT;\r\n\t                    } else if (!options.vertical && !inArray(note.options.position, [ TOP, BOTTOM ])) {\r\n\t                        note.options.position = options.reverse ? BOTTOM : TOP;\r\n\t                    }\r\n\t                } else {\r\n\t                    if (options.vertical) {\r\n\t                        note.options.position = options.reverse ? LEFT : RIGHT;\r\n\t                    } else {\r\n\t                        note.options.position = options.reverse ? BOTTOM : TOP;\r\n\t                    }\r\n\t                }\r\n\t                this$1.append(note);\r\n\t                this$1.notes.push(note);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    parseNoteValue: function(value) {\r\n\t        return value;\r\n\t    },\r\n\r\n\t    renderVisual: function() {\r\n\t        ChartElement.fn.renderVisual.call(this);\r\n\r\n\t        this.createPlotBands();\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\r\n\t        this.createBackground();\r\n\t        this.createLine();\r\n\t    },\r\n\r\n\t    gridLinesVisual: function() {\r\n\t        var gridLines = this._gridLines;\r\n\t        if (!gridLines) {\r\n\t            gridLines = this._gridLines = new Group({\r\n\t                zIndex: -2\r\n\t            });\r\n\t            this.appendVisual(this._gridLines);\r\n\t        }\r\n\r\n\t        return gridLines;\r\n\t    },\r\n\r\n\t    createTicks: function(lineGroup) {\r\n\t        var options = this.options;\r\n\t        var lineBox = this.lineBox();\r\n\t        var mirror = options.labels.mirror;\r\n\t        var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\r\n\t        var tickLineOptions = {\r\n\t            // TODO\r\n\t            // _alignLines: options._alignLines,\r\n\t            vertical: options.vertical\r\n\t        };\r\n\r\n\t        function render(tickPositions, tickOptions, skipUnit) {\r\n\t            var count = tickPositions.length;\r\n\t            var step = Math.max(1, tickOptions.step);\r\n\r\n\t            if (tickOptions.visible) {\r\n\t                for (var i = tickOptions.skip; i < count; i += step) {\r\n\t                    if (defined(skipUnit) && (i % skipUnit === 0)) {\r\n\t                        continue;\r\n\t                    }\r\n\r\n\t                    tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\r\n\t                    tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\r\n\t                    tickLineOptions.position = tickPositions[i];\r\n\r\n\t                    lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        render(this.getMajorTickPositions(), options.majorTicks);\r\n\t        render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\r\n\t    },\r\n\r\n\t    createLine: function() {\r\n\t        var options = this.options;\r\n\t        var line = options.line;\r\n\t        var lineBox = this.lineBox();\r\n\r\n\t        if (line.width > 0 && line.visible) {\r\n\t            var path = new Path({\r\n\t                stroke: {\r\n\t                    width: line.width,\r\n\t                    color: line.color,\r\n\t                    dashType: line.dashType\r\n\t                }\r\n\r\n\t                /* TODO\r\n\t                zIndex: line.zIndex,\r\n\t                */\r\n\t            });\r\n\r\n\t            path.moveTo(lineBox.x1, lineBox.y1)\r\n\t                .lineTo(lineBox.x2, lineBox.y2);\r\n\r\n\t            if (options._alignLines) {\r\n\t                alignPathToPixel(path);\r\n\t            }\r\n\r\n\t            var group = this._lineGroup = new Group();\r\n\t            group.append(path);\r\n\r\n\t            this.visual.append(group);\r\n\t            this.createTicks(group);\r\n\t        }\r\n\t    },\r\n\r\n\t    getActualTickSize: function() {\r\n\t        var options = this.options;\r\n\t        var tickSize = 0;\r\n\r\n\t        if (options.majorTicks.visible && options.minorTicks.visible) {\r\n\t            tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\r\n\t        } else if (options.majorTicks.visible) {\r\n\t            tickSize = options.majorTicks.size;\r\n\t        } else if (options.minorTicks.visible) {\r\n\t            tickSize = options.minorTicks.size;\r\n\t        }\r\n\r\n\t        return tickSize;\r\n\t    },\r\n\r\n\t    createBackground: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var box = ref.box;\r\n\t        var background = options.background;\r\n\r\n\t        if (background) {\r\n\t            this._backgroundPath = Path.fromRect(box.toRect(), {\r\n\t                fill: {\r\n\t                    color: background\r\n\t                },\r\n\t                stroke: null\r\n\t            });\r\n\r\n\t            this.visual.append(this._backgroundPath);\r\n\t        }\r\n\t    },\r\n\r\n\t    createPlotBands: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var plotBands = options.plotBands || [];\r\n\t        var vertical = options.vertical;\r\n\t        var plotArea = this.plotArea;\r\n\r\n\t        if (plotBands.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var group = this._plotbandGroup = new Group({\r\n\t            zIndex: -1\r\n\t        });\r\n\r\n\t        var altAxis = grep(this.pane.axes, function (axis) { return axis.options.vertical !== this$1.options.vertical; })[0];\r\n\r\n\t        for (var idx = 0; idx < plotBands.length; idx++) {\r\n\t            var item = plotBands[idx];\r\n\t            var slotX = (void 0), slotY = (void 0);\r\n\r\n\t            if (vertical) {\r\n\t                slotX = (altAxis || plotArea.axisX).lineBox();\r\n\t                slotY = this$1.getSlot(item.from, item.to, true);\r\n\t            } else {\r\n\t                slotX = this$1.getSlot(item.from, item.to, true);\r\n\t                slotY = (altAxis || plotArea.axisY).lineBox();\r\n\t            }\r\n\r\n\t            if (slotX.width() !== 0 && slotY.height() !== 0) {\r\n\t                var bandRect = new Rect(\r\n\t                    [ slotX.x1, slotY.y1 ],\r\n\t                    [ slotX.width(), slotY.height() ]\r\n\t                );\r\n\r\n\t                var path = Path.fromRect(bandRect, {\r\n\t                    fill: {\r\n\t                        color: item.color,\r\n\t                        opacity: item.opacity\r\n\t                    },\r\n\t                    stroke: null\r\n\t                });\r\n\r\n\t                group.append(path);\r\n\t            }\r\n\t        }\r\n\r\n\t        this.appendVisual(group);\r\n\t    },\r\n\r\n\t    createGridLines: function(altAxis) {\r\n\t        var options = this.options;\r\n\t        var minorGridLines = options.minorGridLines;\r\n\t        var majorGridLines = options.majorGridLines;\r\n\t        var minorUnit = options.minorUnit;\r\n\t        var vertical = options.vertical;\r\n\t        var axisLineVisible = altAxis.options.line.visible;\r\n\t        var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\r\n\t        var lineBox = altAxis.lineBox();\r\n\t        var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\r\n\t        var lineOptions = {\r\n\t            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\r\n\t            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\r\n\t            vertical: vertical\r\n\t        };\r\n\t        var majorTicks = [];\r\n\r\n\t        var container = this.gridLinesVisual();\r\n\r\n\t        function render(tickPositions, gridLine, skipUnit) {\r\n\t            var count = tickPositions.length;\r\n\t            var step = Math.max(1, gridLine.step);\r\n\r\n\t            if (gridLine.visible) {\r\n\t                for (var i = gridLine.skip; i < count; i += step) {\r\n\t                    var pos = round(tickPositions[i]);\r\n\t                    if (!inArray(pos, majorTicks)) {\r\n\t                        if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\r\n\t                            lineOptions.position = pos;\r\n\t                            container.append(createAxisGridLine(lineOptions, gridLine));\r\n\r\n\t                            majorTicks.push(pos);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        render(this.getMajorTickPositions(), majorGridLines);\r\n\t        render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\r\n\r\n\t        return container.children;\r\n\t    },\r\n\r\n\t    reflow: function(box) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var labels = ref.labels;\r\n\t        var title = ref.title;\r\n\t        var vertical = options.vertical;\r\n\t        var count = labels.length;\r\n\t        var sizeFn = vertical ? WIDTH : HEIGHT;\r\n\t        var titleSize = title ? title.box[sizeFn]() : 0;\r\n\t        var space = this.getActualTickSize() + options.margin + titleSize;\r\n\t        var rootBox = (this.getRoot() || {}).box || box;\r\n\t        var boxSize = rootBox[sizeFn]();\r\n\t        var maxLabelSize = 0;\r\n\r\n\t        for (var i = 0; i < count; i++) {\r\n\t            var labelSize = labels[i].box[sizeFn]();\r\n\t            if (labelSize + space <= boxSize) {\r\n\t                maxLabelSize = Math.max(maxLabelSize, labelSize);\r\n\t            }\r\n\t        }\r\n\r\n\t        if (vertical) {\r\n\t            this.box = new Box(\r\n\t                box.x1, box.y1,\r\n\t                box.x1 + maxLabelSize + space, box.y2\r\n\t            );\r\n\t        } else {\r\n\t            this.box = new Box(\r\n\t                box.x1, box.y1,\r\n\t                box.x2, box.y1 + maxLabelSize + space\r\n\t            );\r\n\t        }\r\n\r\n\t        this.arrangeTitle();\r\n\t        this.arrangeLabels();\r\n\t        this.arrangeNotes();\r\n\t    },\r\n\r\n\t    getLabelsTickPositions: function() {\r\n\t        return this.getMajorTickPositions();\r\n\t    },\r\n\r\n\t    labelTickIndex: function(label) {\r\n\t        return label.index;\r\n\t    },\r\n\r\n\t    arrangeLabels: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var labels = ref.labels;\r\n\t        var labelsBetweenTicks = !options.justified;\r\n\t        var vertical = options.vertical;\r\n\t        var lineBox = this.lineBox();\r\n\t        var mirror = options.labels.mirror;\r\n\t        var tickPositions = this.getLabelsTickPositions();\r\n\t        var labelOffset = this.getActualTickSize() + options.margin;\r\n\r\n\t        for (var idx = 0; idx < labels.length; idx++) {\r\n\t            var label = labels[idx];\r\n\t            var tickIx = this$1.labelTickIndex(label);\r\n\t            var labelSize = vertical ? label.box.height() : label.box.width();\r\n\t            var labelPos = tickPositions[tickIx] - (labelSize / 2);\r\n\t            var labelBox = (void 0), firstTickPosition = (void 0), nextTickPosition = (void 0);\r\n\r\n\t            if (vertical) {\r\n\t                if (labelsBetweenTicks) {\r\n\t                    firstTickPosition = tickPositions[tickIx];\r\n\t                    nextTickPosition = tickPositions[tickIx + 1];\r\n\r\n\t                    var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\r\n\t                    labelPos = middle - (labelSize / 2);\r\n\t                }\r\n\r\n\t                var labelX = lineBox.x2;\r\n\r\n\t                if (mirror) {\r\n\t                    labelX += labelOffset;\r\n\t                    label.options.rotationOrigin = LEFT;\r\n\t                } else {\r\n\t                    labelX -= labelOffset + label.box.width();\r\n\t                    label.options.rotationOrigin = RIGHT;\r\n\t                }\r\n\r\n\t                labelBox = label.box.move(labelX, labelPos);\r\n\t            } else {\r\n\t                if (labelsBetweenTicks) {\r\n\t                    firstTickPosition = tickPositions[tickIx];\r\n\t                    nextTickPosition = tickPositions[tickIx + 1];\r\n\t                } else {\r\n\t                    firstTickPosition = labelPos;\r\n\t                    nextTickPosition = labelPos + labelSize;\r\n\t                }\r\n\r\n\t                var labelY = lineBox.y1;\r\n\r\n\t                if (mirror) {\r\n\t                    labelY -= labelOffset + label.box.height();\r\n\t                    label.options.rotationOrigin = BOTTOM;\r\n\t                } else {\r\n\t                    labelY += labelOffset;\r\n\t                    label.options.rotationOrigin = TOP;\r\n\t                }\r\n\r\n\t                labelBox = new Box(firstTickPosition, labelY,\r\n\t                                nextTickPosition, labelY + label.box.height());\r\n\t            }\r\n\r\n\t            label.reflow(labelBox);\r\n\t        }\r\n\t    },\r\n\r\n\t    autoRotateLabels: function() {\r\n\t        if (this.options.autoRotateLabels && !this.options.vertical) {\r\n\t            var tickPositions = this.getMajorTickPositions();\r\n\t            var labels = this.labels;\r\n\t            var angle;\r\n\r\n\t            for (var idx = 0; idx < labels.length; idx++) {\r\n\t                var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\r\n\t                var labelBox = labels[idx].box;\r\n\r\n\t                if (labelBox.width() > width) {\r\n\t                    if (labelBox.height() > width) {\r\n\t                        angle = -90;\r\n\t                        break;\r\n\t                    }\r\n\t                    angle = -45;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (angle) {\r\n\t                for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\r\n\t                    labels[idx$1].options.rotation = angle;\r\n\t                    labels[idx$1].reflow(new Box());\r\n\t                }\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    arrangeTitle: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var title = ref.title;\r\n\t        var mirror = options.labels.mirror;\r\n\t        var vertical = options.vertical;\r\n\r\n\t        if (title) {\r\n\t            if (vertical) {\r\n\t                title.options.align = mirror ? RIGHT : LEFT;\r\n\t                title.options.vAlign = title.options.position;\r\n\t            } else {\r\n\t                title.options.align = title.options.position;\r\n\t                title.options.vAlign = mirror ? TOP : BOTTOM;\r\n\t            }\r\n\r\n\t            title.reflow(this.box);\r\n\t        }\r\n\t    },\r\n\r\n\t    arrangeNotes: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var idx = 0; idx < this.notes.length; idx++) {\r\n\t            var item = this$1.notes[idx];\r\n\t            var value = item.options.value;\r\n\t            var slot = (void 0);\r\n\r\n\t            if (defined(value)) {\r\n\t                if (this$1.shouldRenderNote(value)) {\r\n\t                    item.show();\r\n\t                } else {\r\n\t                    item.hide();\r\n\t                }\r\n\r\n\t                slot = this$1.noteSlot(value);\r\n\t            } else {\r\n\t                item.hide();\r\n\t            }\r\n\r\n\t            item.reflow(slot || this$1.lineBox());\r\n\t        }\r\n\t    },\r\n\r\n\t    noteSlot: function(value) {\r\n\t        return this.getSlot(value);\r\n\t    },\r\n\r\n\t    alignTo: function(secondAxis) {\r\n\t        var lineBox = secondAxis.lineBox();\r\n\t        var vertical = this.options.vertical;\r\n\t        var pos = vertical ? Y : X;\r\n\r\n\t        this.box.snapTo(lineBox, pos);\r\n\t        if (vertical) {\r\n\t            this.box.shrink(0, this.lineBox().height() - lineBox.height());\r\n\t        } else {\r\n\t            this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\r\n\t        }\r\n\t        this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\r\n\t        this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\r\n\t    },\r\n\r\n\t    axisLabelText: function(value, dataItem, options) {\r\n\t        var tmpl = getTemplate(options);\r\n\t        var text = value;\r\n\r\n\t        if (tmpl) {\r\n\t            text = tmpl({ value: value, dataItem: dataItem, format: options.format, culture: options.culture });\r\n\t        } else if (options.format) {\r\n\t            text = this.chartService.format.localeAuto(options.format, [ value ], options.culture);\r\n\t        }\r\n\r\n\t        return text;\r\n\t    },\r\n\r\n\t    slot: function(from , to, limit) {\r\n\t        var slot = this.getSlot(from, to, limit);\r\n\t        if (slot) {\r\n\t            return slot.toRect();\r\n\t        }\r\n\t    },\r\n\r\n\t    contentBox: function() {\r\n\t        var box = this.box.clone();\r\n\t        var labels = this.labels;\r\n\t        if (labels.length) {\r\n\t            if (labels[0].options.visible) {\r\n\t                box.wrap(labels[0].box);\r\n\t            }\r\n\t            var lastLabel = labels[labels.length - 1];\r\n\t            if (lastLabel.options.visible) {\r\n\t                box.wrap(lastLabel.box);\r\n\t            }\r\n\t        }\r\n\r\n\t        return box;\r\n\t    },\r\n\r\n\t    limitRange: function(from, to, min, max, offset) {\r\n\t        var options = this.options;\r\n\r\n\t        if ((from < min && offset < 0 && (!defined(options.min) || options.min <= min)) || (max < to && offset > 0 && (!defined(options.max) || max <= options.max))) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        if ((to < min && offset > 0) || (max < from && offset < 0)) {\r\n\t            return {\r\n\t                min: from,\r\n\t                max: to\r\n\t            };\r\n\t        }\r\n\r\n\t        var rangeSize = to - from;\r\n\t        var minValue = from;\r\n\t        var maxValue = to;\r\n\r\n\t        if (from < min) {\r\n\t            minValue = limitValue(from, min, max);\r\n\t            maxValue = limitValue(from + rangeSize, min + rangeSize, max);\r\n\t        } else if (to > max) {\r\n\t            maxValue = limitValue(to, min, max);\r\n\t            minValue = limitValue(to - rangeSize, min, max - rangeSize);\r\n\t        }\r\n\r\n\t        return {\r\n\t            min: minValue,\r\n\t            max: maxValue\r\n\t        };\r\n\t    },\r\n\r\n\t    valueRange: function() {\r\n\t        return {\r\n\t            min: this.seriesMin,\r\n\t            max: this.seriesMax\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(Axis, {\r\n\t    labels: {\r\n\t        visible: true,\r\n\t        rotation: 0,\r\n\t        mirror: false,\r\n\t        step: 1,\r\n\t        skip: 0\r\n\t    },\r\n\t    line: {\r\n\t        width: 1,\r\n\t        color: BLACK,\r\n\t        visible: true\r\n\t    },\r\n\t    title: {\r\n\t        visible: true,\r\n\t        position: CENTER\r\n\t    },\r\n\t    majorTicks: {\r\n\t        align: OUTSIDE,\r\n\t        size: 4,\r\n\t        skip: 0,\r\n\t        step: 1\r\n\t    },\r\n\t    minorTicks: {\r\n\t        align: OUTSIDE,\r\n\t        size: 3,\r\n\t        skip: 0,\r\n\t        step: 1\r\n\t    },\r\n\t    axisCrossingValue: 0,\r\n\t    majorTickType: OUTSIDE,\r\n\t    minorTickType: NONE,\r\n\t    majorGridLines: {\r\n\t        skip: 0,\r\n\t        step: 1\r\n\t    },\r\n\t    minorGridLines: {\r\n\t        visible: false,\r\n\t        width: 1,\r\n\t        color: BLACK,\r\n\t        skip: 0,\r\n\t        step: 1\r\n\t    },\r\n\t    // TODO: Move to line or labels options\r\n\t    margin: 5,\r\n\t    visible: true,\r\n\t    reverse: false,\r\n\t    justified: true,\r\n\t    notes: {\r\n\t        label: {\r\n\t            text: \"\"\r\n\t        }\r\n\t    },\r\n\r\n\t    _alignLines: true,\r\n\t    _deferLabels: false\r\n\t});\r\n\r\n\tvar MILLISECONDS = \"milliseconds\";\r\n\tvar SECONDS = \"seconds\";\r\n\tvar MINUTES = \"minutes\";\r\n\tvar HOURS = \"hours\";\r\n\tvar DAYS = \"days\";\r\n\tvar WEEKS = \"weeks\";\r\n\tvar MONTHS = \"months\";\r\n\tvar YEARS = \"years\";\r\n\r\n\tvar TIME_PER_MILLISECOND = 1;\r\n\tvar TIME_PER_SECOND = 1000;\r\n\tvar TIME_PER_MINUTE = 60 * TIME_PER_SECOND;\r\n\tvar TIME_PER_HOUR = 60 * TIME_PER_MINUTE;\r\n\tvar TIME_PER_DAY = 24 * TIME_PER_HOUR;\r\n\tvar TIME_PER_WEEK = 7 * TIME_PER_DAY;\r\n\tvar TIME_PER_MONTH = 31 * TIME_PER_DAY;\r\n\tvar TIME_PER_YEAR = 365 * TIME_PER_DAY;\r\n\tvar TIME_PER_UNIT = {\r\n\t    \"years\": TIME_PER_YEAR,\r\n\t    \"months\": TIME_PER_MONTH,\r\n\t    \"weeks\": TIME_PER_WEEK,\r\n\t    \"days\": TIME_PER_DAY,\r\n\t    \"hours\": TIME_PER_HOUR,\r\n\t    \"minutes\": TIME_PER_MINUTE,\r\n\t    \"seconds\": TIME_PER_SECOND,\r\n\t    \"milliseconds\": TIME_PER_MILLISECOND\r\n\t};\r\n\r\n\tfunction absoluteDateDiff(a, b) {\r\n\t    var diff = a.getTime() - b;\r\n\t    var offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();\r\n\r\n\t    return diff - (offsetDiff * TIME_PER_MINUTE);\r\n\t}\r\n\r\n\tfunction addTicks(date, ticks) {\r\n\t    return new Date(date.getTime() + ticks);\r\n\t}\r\n\r\n\tfunction toDate(value) {\r\n\t    var result;\r\n\r\n\t    if (value instanceof Date) {\r\n\t        result = value;\r\n\t    } else if (value) {\r\n\t        result = new Date(value);\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction startOfWeek(date, weekStartDay) {\r\n\t    if (weekStartDay === void 0) { weekStartDay = 0; }\r\n\r\n\t    var daysToSubtract = 0;\r\n\t    var day = date.getDay();\r\n\r\n\t    if (!isNaN(day)) {\r\n\t        while (day !== weekStartDay) {\r\n\t            if (day === 0) {\r\n\t                day = 6;\r\n\t            } else {\r\n\t                day--;\r\n\t            }\r\n\r\n\t            daysToSubtract++;\r\n\t        }\r\n\t    }\r\n\r\n\t    return addTicks(date, -daysToSubtract * TIME_PER_DAY);\r\n\t}\r\n\r\n\tfunction adjustDST(date, hours) {\r\n\t    if (hours === 0 && date.getHours() === 23) {\r\n\t        date.setHours(date.getHours() + 2);\r\n\t        return true;\r\n\t    }\r\n\r\n\t    return false;\r\n\t}\r\n\r\n\tfunction addHours(date, hours) {\r\n\t    var roundedDate = new Date(date);\r\n\r\n\t    roundedDate.setMinutes(0, 0, 0);\r\n\r\n\t    var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;\r\n\r\n\t    return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);\r\n\t}\r\n\r\n\tfunction addDuration(dateValue, value, unit, weekStartDay) {\r\n\t    var result = dateValue;\r\n\r\n\t    if (dateValue) {\r\n\t        var date = toDate(dateValue);\r\n\t        var hours = date.getHours();\r\n\r\n\t        if (unit === YEARS) {\r\n\t            result = new Date(date.getFullYear() + value, 0, 1);\r\n\t            adjustDST(result, 0);\r\n\t        } else if (unit === MONTHS) {\r\n\t            result = new Date(date.getFullYear(), date.getMonth() + value, 1);\r\n\t            adjustDST(result, hours);\r\n\t        } else if (unit === WEEKS) {\r\n\t            result = addDuration(startOfWeek(date, weekStartDay), value * 7, DAYS);\r\n\t            adjustDST(result, hours);\r\n\t        } else if (unit === DAYS) {\r\n\t            result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value);\r\n\t            adjustDST(result, hours);\r\n\t        } else if (unit === HOURS) {\r\n\t            result = addHours(date, value);\r\n\t        } else if (unit === MINUTES) {\r\n\t            result = addTicks(date, value * TIME_PER_MINUTE);\r\n\r\n\t            if (result.getSeconds() > 0) {\r\n\t                result.setSeconds(0);\r\n\t            }\r\n\t        } else if (unit === SECONDS) {\r\n\t            result = addTicks(date, value * TIME_PER_SECOND);\r\n\t        } else if (unit === MILLISECONDS) {\r\n\t            result = addTicks(date, value);\r\n\t        }\r\n\r\n\t        if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {\r\n\t            result.setMilliseconds(0);\r\n\t        }\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction floorDate(date, unit, weekStartDay) {\r\n\t    return addDuration(toDate(date), 0, unit, weekStartDay);\r\n\t}\r\n\r\n\tfunction ceilDate(dateValue, unit, weekStartDay) {\r\n\t    var date = toDate(dateValue);\r\n\r\n\t    if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {\r\n\t        return date;\r\n\t    }\r\n\r\n\t    return addDuration(date, 1, unit, weekStartDay);\r\n\t}\r\n\r\n\tfunction dateComparer(a, b) {\r\n\t    if (a && b) {\r\n\t        return a.getTime() - b.getTime();\r\n\t    }\r\n\r\n\t    return -1;\r\n\t}\r\n\r\n\tfunction dateDiff(a, b) {\r\n\t    return a.getTime() - b;\r\n\t}\r\n\r\n\tfunction toTime(value) {\r\n\t    if (isArray(value)) {\r\n\t        var result = [];\r\n\t        for (var idx = 0; idx < value.length; idx++) {\r\n\t            result.push(toTime(value[idx]));\r\n\t        }\r\n\r\n\t        return result;\r\n\t    } else if (value) {\r\n\t        return toDate(value).getTime();\r\n\t    }\r\n\t}\r\n\r\n\tfunction dateEquals(a, b) {\r\n\t    if (a && b) {\r\n\t        return toTime(a) === toTime(b);\r\n\t    }\r\n\r\n\t    return a === b;\r\n\t}\r\n\r\n\tfunction timeIndex(date, start, baseUnit) {\r\n\t    return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];\r\n\t}\r\n\r\n\tfunction dateIndex(value, start, baseUnit, baseUnitStep) {\r\n\t    var date = toDate(value);\r\n\t    var startDate = toDate(start);\r\n\t    var index;\r\n\r\n\t    if (baseUnit === MONTHS) {\r\n\t        index = (date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12) +\r\n\t            timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\r\n\t    } else if (baseUnit === YEARS) {\r\n\t        index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;\r\n\t    } else if (baseUnit === DAYS || baseUnit === WEEKS) {\r\n\t        index = timeIndex(date, startDate, baseUnit);\r\n\t    } else {\r\n\t        index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];\r\n\t    }\r\n\r\n\t    return index / baseUnitStep;\r\n\t}\r\n\r\n\tfunction duration(a, b, unit) {\r\n\t    var diff;\r\n\r\n\t    if (unit === YEARS) {\r\n\t        diff = b.getFullYear() - a.getFullYear();\r\n\t    } else if (unit === MONTHS) {\r\n\t        diff = duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();\r\n\t    } else if (unit === DAYS) {\r\n\t        diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);\r\n\t    } else {\r\n\t        diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit]);\r\n\t    }\r\n\r\n\t    return diff;\r\n\t}\r\n\r\n\tfunction lteDateIndex(date, sortedDates) {\r\n\t    var low = 0;\r\n\t    var high = sortedDates.length - 1;\r\n\t    var index;\r\n\r\n\t    while (low <= high) {\r\n\t        index = Math.floor((low + high) / 2);\r\n\t        var currentDate = sortedDates[index];\r\n\r\n\t        if (currentDate < date) {\r\n\t            low = index + 1;\r\n\t            continue;\r\n\t        }\r\n\r\n\t        if (currentDate > date) {\r\n\t            high = index - 1;\r\n\t            continue;\r\n\t        }\r\n\r\n\t        while (dateEquals(sortedDates[index - 1], date)) {\r\n\t            index--;\r\n\t        }\r\n\r\n\t        return index;\r\n\t    }\r\n\r\n\t    if (sortedDates[index] <= date) {\r\n\t        return index;\r\n\t    }\r\n\r\n\t    return index - 1;\r\n\t}\r\n\r\n\tfunction parseDate(intlService, date) {\r\n\t    var result;\r\n\t    if (isString(date)) {\r\n\t        result = intlService.parseDate(date) || toDate(date);\r\n\t    } else {\r\n\t        result = toDate(date);\r\n\t    }\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction parseDates(intlService, dates) {\r\n\t    if (isArray(dates)) {\r\n\t        var result = [];\r\n\t        for (var idx = 0; idx < dates.length; idx++) {\r\n\t            result.push(parseDate(intlService, dates[idx]));\r\n\t        }\r\n\r\n\t        return result;\r\n\t    }\r\n\r\n\t    return parseDate(intlService, dates);\r\n\t}\r\n\r\n\tvar MIN_CATEGORY_POINTS_RANGE = 0.01;\r\n\r\n\tfunction indexOf(value, arr) {\r\n\t    if (value instanceof Date) {\r\n\t        var length = arr.length;\r\n\t        for (var idx = 0; idx < length; idx++) {\r\n\t            if (dateEquals(arr[idx], value)) {\r\n\t                return idx;\r\n\t            }\r\n\t        }\r\n\r\n\t        return -1;\r\n\t    }\r\n\r\n\t    return arr.indexOf(value);\r\n\t}\r\n\r\n\tvar CategoryAxis = Axis.extend({\r\n\t    init: function(options, chartService) {\r\n\t        Axis.fn.init.call(this, options, chartService);\r\n\r\n\t        this._ticks = {};\r\n\t        this._initCategories(this.options);\r\n\t    },\r\n\r\n\t    _initCategories: function(options) {\r\n\t        var categories = (options.categories || []).slice(0);\r\n\t        var definedMin = defined(options.min);\r\n\t        var definedMax = defined(options.max);\r\n\t        options.categories = categories;\r\n\r\n\t        if ((definedMin || definedMax) && categories.length) {\r\n\t            options.srcCategories = options.categories;\r\n\t            var min = definedMin ? Math.floor(options.min) : 0;\r\n\t            var max;\r\n\r\n\t            if (definedMax) {\r\n\t                max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\r\n\t            } else {\r\n\t                max = categories.length;\r\n\t            }\r\n\r\n\t            options.categories = options.categories.slice(min, max);\r\n\t        }\r\n\t    },\r\n\r\n\t    rangeIndices: function() {\r\n\t        var options = this.options;\r\n\t        var length = options.categories.length || 1;\r\n\t        var min = isNumber(options.min) ? options.min % 1 : 0;\r\n\t        var max;\r\n\r\n\t        if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\r\n\t            max = length - (1 - options.max % 1);\r\n\t        } else {\r\n\t            max = length - (options.justified ? 1 : 0);\r\n\t        }\r\n\r\n\t        return {\r\n\t            min: min,\r\n\t            max: max\r\n\t        };\r\n\t    },\r\n\r\n\t    totalRangeIndices: function(limit) {\r\n\t        var options = this.options;\r\n\t        var min = isNumber(options.min) ? options.min : 0;\r\n\t        var max;\r\n\r\n\t        if (isNumber(options.max)) {\r\n\t            max = options.max;\r\n\t        } else if (isNumber(options.min)) {\r\n\t            max = min + options.categories.length;\r\n\t        } else {\r\n\t            max = ((options.srcCategories || options.categories).length - (options.justified ? 1 : 0) || 1);\r\n\t        }\r\n\r\n\t        if (limit) {\r\n\t            var totalRange = this.totalRange();\r\n\t            min = limitValue(min, 0, totalRange.max);\r\n\t            max = limitValue(max, 0, totalRange.max);\r\n\t        }\r\n\r\n\t        return {\r\n\t            min: min,\r\n\t            max: max\r\n\t        };\r\n\t    },\r\n\r\n\t    range: function() {\r\n\t        var options = this.options;\r\n\t        return { min: isNumber(options.min) ? options.min : 0, max: isNumber(options.max) ? options.max : options.categories.length };\r\n\t    },\r\n\r\n\t    totalRange: function() {\r\n\t        var options = this.options;\r\n\t        return { min: 0, max: Math.max(this._seriesMax || 0, (options.srcCategories || options.categories).length) - (options.justified ? 1 : 0) };\r\n\t    },\r\n\r\n\t    getScale: function() {\r\n\t        var ref = this.rangeIndices();\r\n\t        var min = ref.min;\r\n\t        var max = ref.max;\r\n\t        var lineBox = this.lineBox();\r\n\t        var size = this.options.vertical ? lineBox.height() : lineBox.width();\r\n\t        var scale = size / ((max - min) || 1);\r\n\r\n\t        return scale * (this.options.reverse ? -1 : 1);\r\n\t    },\r\n\r\n\t    getTickPositions: function(stepSize) {\r\n\t        var ref = this.options;\r\n\t        var vertical = ref.vertical;\r\n\t        var reverse = ref.reverse;\r\n\t        var ref$1 = this.rangeIndices();\r\n\t        var min = ref$1.min;\r\n\t        var max = ref$1.max;\r\n\t        var lineBox = this.lineBox();\r\n\t        var scale = this.getScale();\r\n\t        var pos = lineBox[(vertical ? Y : X) + (reverse ? 2 : 1)];\r\n\t        var positions = [];\r\n\r\n\t        var current = min % 1 !== 0 ? Math.floor(min / 1) + stepSize : min;\r\n\r\n\t        while (current <= max) {\r\n\t            positions.push(pos + round(scale * (current - min), COORD_PRECISION));\r\n\t            current += stepSize;\r\n\t        }\r\n\r\n\t        return positions;\r\n\t    },\r\n\r\n\t    getLabelsTickPositions: function() {\r\n\t        var tickPositions = this.getMajorTickPositions().slice(0);\r\n\t        var range = this.rangeIndices();\r\n\t        var scale = this.getScale();\r\n\t        var box = this.lineBox();\r\n\t        var options = this.options;\r\n\t        var axis = options.vertical ? Y : X;\r\n\t        var start = options.reverse ? 2 : 1;\r\n\t        var end = options.reverse ? 1 : 2;\r\n\r\n\t        if (range.min % 1 !== 0) {\r\n\t            tickPositions.unshift(box[axis + start] - scale * (range.min % 1));\r\n\t        }\r\n\r\n\t        if (range.max % 1 !== 0) {\r\n\t            tickPositions.push(box[axis + end] + scale * (1 - range.max % 1));\r\n\t        }\r\n\r\n\t        return tickPositions;\r\n\t    },\r\n\r\n\t    labelTickIndex: function(label) {\r\n\t        var range = this.rangeIndices();\r\n\t        var index = label.index;\r\n\r\n\t        if (range.min > 0) {\r\n\t            index = index - Math.floor(range.min);\r\n\t        }\r\n\r\n\t        return index;\r\n\t    },\r\n\r\n\t    arrangeLabels: function() {\r\n\t        Axis.fn.arrangeLabels.call(this);\r\n\t        this.hideOutOfRangeLabels();\r\n\t    },\r\n\r\n\t    hideOutOfRangeLabels: function() {\r\n\t        var ref = this;\r\n\t        var box = ref.box;\r\n\t        var labels = ref.labels;\r\n\r\n\t        if (labels.length) {\r\n\t            var valueAxis = this.options.vertical ? Y : X;\r\n\t            var start = box[valueAxis + 1];\r\n\t            var end = box[valueAxis + 2];\r\n\t            var firstLabel = labels[0];\r\n\t            var lastLabel = last(labels);\r\n\r\n\t            if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\r\n\t                firstLabel.options.visible = false;\r\n\t            }\r\n\t            if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\r\n\t                lastLabel.options.visible = false;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    getMajorTickPositions: function() {\r\n\t        return this.getTicks().majorTicks;\r\n\t    },\r\n\r\n\t    getMinorTickPositions: function() {\r\n\t        return this.getTicks().minorTicks;\r\n\t    },\r\n\r\n\t    getTicks: function() {\r\n\t        var ref = this.options;\r\n\t        var reverse = ref.reverse;\r\n\t        var justified = ref.justified;\r\n\t        var cache = this._ticks;\r\n\t        var range = this.rangeIndices();\r\n\t        var lineBox = this.lineBox();\r\n\t        var hash = lineBox.getHash() + range.min + \",\" + range.max + reverse + justified;\r\n\r\n\t        if (cache._hash !== hash) {\r\n\t            cache._hash = hash;\r\n\t            cache.majorTicks = this.getTickPositions(1);\r\n\t            cache.minorTicks = this.getTickPositions(0.5);\r\n\t        }\r\n\r\n\t        return cache;\r\n\t    },\r\n\r\n\t    getSlot: function(from, to, limit) {\r\n\t        var options = this.options;\r\n\t        var reverse = options.reverse;\r\n\t        var justified = options.justified;\r\n\t        var vertical = options.vertical;\r\n\t        var ref = this.rangeIndices();\r\n\t        var min = ref.min;\r\n\t        var valueAxis = vertical ? Y : X;\r\n\t        var lineBox = this.lineBox();\r\n\t        var scale = this.getScale();\r\n\t        var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\r\n\t        var slotBox = lineBox.clone();\r\n\t        var singleSlot = !defined(to);\r\n\r\n\t        var start = valueOrDefault(from, 0);\r\n\t        var end = valueOrDefault(to, start);\r\n\t        end = Math.max(end - 1, start);\r\n\r\n\t        // Fixes transient bug caused by iOS 6.0 JIT\r\n\t        // (one can never be too sure)\r\n\t        end = Math.max(start, end);\r\n\r\n\t        var p1 = lineStart + (start - min) * scale;\r\n\t        var p2 = lineStart + (end + 1 - min) * scale;\r\n\r\n\t        if (singleSlot && justified) {\r\n\t            p2 = p1;\r\n\t        }\r\n\r\n\t        if (limit) {\r\n\t            p1 = limitValue(p1, lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\r\n\t            p2 = limitValue(p2, lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\r\n\t        }\r\n\r\n\t        slotBox[valueAxis + 1] = reverse ? p2 : p1;\r\n\t        slotBox[valueAxis + 2] = reverse ? p1 : p2;\r\n\r\n\t        return slotBox;\r\n\t    },\r\n\r\n\t    limitSlot: function(slot) {\r\n\t        var vertical = this.options.vertical;\r\n\t        var valueAxis = vertical ? Y : X;\r\n\t        var lineBox = this.lineBox();\r\n\t        var limittedSlot = slot.clone();\r\n\r\n\t        limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\r\n\t        limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\r\n\r\n\t        return limittedSlot;\r\n\t    },\r\n\r\n\t    slot: function(from, to, limit) {\r\n\t        var start = from;\r\n\t        var end = to;\r\n\r\n\t        if (typeof start === \"string\") {\r\n\t            start = this.categoryIndex(start);\r\n\t        }\r\n\r\n\t        if (typeof end === \"string\") {\r\n\t            end = this.categoryIndex(end);\r\n\t        }\r\n\r\n\t        return Axis.fn.slot.call(this, start, end, limit);\r\n\t    },\r\n\r\n\t    pointCategoryIndex: function(point) {\r\n\t        var ref = this.options;\r\n\t        var reverse = ref.reverse;\r\n\t        var justified = ref.justified;\r\n\t        var vertical = ref.vertical;\r\n\t        var valueAxis = vertical ? Y : X;\r\n\t        var lineBox = this.lineBox();\r\n\t        var range = this.rangeIndices();\r\n\t        var startValue = reverse ? range.max : range.min;\r\n\t        var scale = this.getScale();\r\n\t        var lineStart = lineBox[valueAxis + 1];\r\n\t        var lineEnd = lineBox[valueAxis + 2];\r\n\t        var pos = point[valueAxis];\r\n\r\n\t        if (pos < lineStart || pos > lineEnd) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        var value = startValue + (pos - lineStart) / scale;\r\n\t        var diff = value % 1;\r\n\r\n\t        if (justified) {\r\n\t            value = Math.round(value);\r\n\t        } else if (diff === 0 && value > 0) {\r\n\t            value--;\r\n\t        }\r\n\r\n\t        return Math.floor(value);\r\n\t    },\r\n\r\n\t    getCategory: function(point) {\r\n\t        var index = this.pointCategoryIndex(point);\r\n\r\n\t        if (index === null) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        return this.options.categories[index];\r\n\t    },\r\n\r\n\t    categoryIndex: function(value) {\r\n\t        var options = this.options;\r\n\t        var index = indexOf(value, options.srcCategories || options.categories);\r\n\r\n\t        return index - Math.floor(options.min || 0);\r\n\t    },\r\n\r\n\t    translateRange: function(delta) {\r\n\t        var options = this.options;\r\n\t        var lineBox = this.lineBox();\r\n\t        var size = options.vertical ? lineBox.height() : lineBox.width();\r\n\t        var range = options.categories.length;\r\n\t        var scale = size / range;\r\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\r\n\r\n\t        return {\r\n\t            min: offset,\r\n\t            max: range + offset\r\n\t        };\r\n\t    },\r\n\r\n\t    zoomRange: function(rate) {\r\n\t        var rangeIndices = this.totalRangeIndices();\r\n\t        var ref = this.totalRange();\r\n\t        var totalMin = ref.min;\r\n\t        var totalMax = ref.max;\r\n\t        var min = limitValue(rangeIndices.min + rate, totalMin, totalMax);\r\n\t        var max = limitValue(rangeIndices.max - rate, totalMin, totalMax);\r\n\r\n\t        if (max - min > 0) {\r\n\t            return {\r\n\t                min: min,\r\n\t                max: max\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    scaleRange: function(scale) {\r\n\t        var range = this.options.categories.length;\r\n\t        var delta = scale * range;\r\n\r\n\t        return {\r\n\t            min: -delta,\r\n\t            max: range + delta\r\n\t        };\r\n\t    },\r\n\r\n\t    labelsCount: function() {\r\n\t        var labelsRange = this.labelsRange();\r\n\r\n\t        return labelsRange.max - labelsRange.min;\r\n\t    },\r\n\r\n\t    labelsRange: function() {\r\n\t        var options = this.options;\r\n\t        var justified = options.justified;\r\n\t        var labelOptions = options.labels;\r\n\t        var ref = this.totalRangeIndices(true);\r\n\t        var min = ref.min;\r\n\t        var max = ref.max;\r\n\t        var start = Math.floor(min);\r\n\r\n\t        if (!justified) {\r\n\t            min = Math.floor(min);\r\n\t            max = Math.ceil(max);\r\n\t        } else {\r\n\t            min = Math.ceil(min);\r\n\t            max = Math.floor(max);\r\n\t        }\r\n\r\n\t        var skip;\r\n\r\n\t        if (min > labelOptions.skip) {\r\n\t            skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\r\n\t        } else {\r\n\t            skip = labelOptions.skip;\r\n\t        }\r\n\r\n\t        return {\r\n\t            min: skip - start,\r\n\t            max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\r\n\t        };\r\n\t    },\r\n\r\n\t    createAxisLabel: function(index, labelOptions) {\r\n\t        var options = this.options;\r\n\t        var dataItem = options.dataItems ? options.dataItems[index] : null;\r\n\t        var category = valueOrDefault(options.categories[index], \"\");\r\n\t        var text = this.axisLabelText(category, dataItem, labelOptions);\r\n\r\n\t        return new AxisLabel(category, text, index, dataItem, labelOptions);\r\n\t    },\r\n\r\n\t    shouldRenderNote: function(value) {\r\n\t        var range = this.totalRangeIndices();\r\n\r\n\t        return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\r\n\t    },\r\n\r\n\t    noteSlot: function(value) {\r\n\t        var options = this.options;\r\n\t        var index = value - Math.floor(options.min || 0);\r\n\t        return this.getSlot(index);\r\n\t    },\r\n\r\n\t    arrangeNotes: function() {\r\n\t        Axis.fn.arrangeNotes.call(this);\r\n\t        this.hideOutOfRangeNotes();\r\n\t    },\r\n\r\n\t    hideOutOfRangeNotes: function() {\r\n\t        var ref = this;\r\n\t        var notes = ref.notes;\r\n\t        var box = ref.box;\r\n\t        if (notes && notes.length) {\r\n\t            var valueAxis = this.options.vertical ? Y : X;\r\n\t            var start = box[valueAxis + 1];\r\n\t            var end = box[valueAxis + 2];\r\n\r\n\t            for (var idx = 0; idx < notes.length; idx++) {\r\n\t                var note = notes[idx];\r\n\t                if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\r\n\t                    note.hide();\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    pan: function(delta) {\r\n\t        var range = this.totalRangeIndices(true);\r\n\t        var scale = this.getScale();\r\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\r\n\t        var totalRange = this.totalRange();\r\n\t        var min = range.min + offset;\r\n\t        var max = range.max + offset;\r\n\r\n\t        return this.limitRange(min, max, 0, totalRange.max, offset);\r\n\t    },\r\n\r\n\t    pointsRange: function(start, end) {\r\n\t        var ref = this.options;\r\n\t        var reverse = ref.reverse;\r\n\t        var vertical = ref.vertical;\r\n\t        var valueAxis = vertical ? Y : X;\r\n\t        var lineBox = this.lineBox();\r\n\t        var range = this.totalRangeIndices(true);\r\n\t        var scale = this.getScale();\r\n\t        var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\r\n\r\n\t        var diffStart = start[valueAxis] - lineStart;\r\n\t        var diffEnd = end[valueAxis] - lineStart;\r\n\r\n\t        var min = range.min + diffStart / scale;\r\n\t        var max = range.min + diffEnd / scale;\r\n\t        var rangeMin = Math.min(min, max);\r\n\t        var rangeMax = Math.max(min, max);\r\n\r\n\t        if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\r\n\t            return {\r\n\t                min: rangeMin,\r\n\t                max: rangeMax\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    valueRange: function() {\r\n\t        return this.range();\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(CategoryAxis, {\r\n\t    type: \"category\",\r\n\t    categories: [],\r\n\t    vertical: false,\r\n\t    majorGridLines: {\r\n\t        visible: false,\r\n\t        width: 1,\r\n\t        color: BLACK\r\n\t    },\r\n\t    labels: {\r\n\t        zIndex: 1\r\n\t    },\r\n\t    justified: false,\r\n\t    _deferLabels: true\r\n\t});\r\n\r\n\tvar COORDINATE_LIMIT = 300000;\r\n\r\n\tvar DateLabelFormats = {\r\n\t    milliseconds: \"HH:mm:ss.fff\",\r\n\t    seconds: \"HH:mm:ss\",\r\n\t    minutes: \"HH:mm\",\r\n\t    hours: \"HH:mm\",\r\n\t    days: \"M/d\",\r\n\t    weeks: \"M/d\",\r\n\t    months: \"MMM 'yy\",\r\n\t    years: \"yyyy\"\r\n\t};\r\n\r\n\tvar ZERO_THRESHOLD = 0.2;\r\n\r\n\tvar AUTO = \"auto\";\r\n\tvar BASE_UNITS = [\r\n\t    MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS\r\n\t];\r\n\tvar FIT = \"fit\";\r\n\r\n\tvar DateCategoryAxis = CategoryAxis.extend({\r\n\t    init: function(axisOptions, chartService) {\r\n\t        CategoryAxis.fn.init.call(this, axisOptions, chartService);\r\n\r\n\t        var intlService = chartService.intl;\r\n\t        var options = this.options;\r\n\r\n\t        options = deepExtend({\r\n\t            roundToBaseUnit: true\r\n\t        }, options, {\r\n\t            categories: parseDates(intlService, options.categories),\r\n\t            min: parseDate(intlService, options.min),\r\n\t            max: parseDate(intlService, options.max)\r\n\t        });\r\n\r\n\t        options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\r\n\t        options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\r\n\r\n\t        if (options.categories && options.categories.length > 0) {\r\n\t            var baseUnit = (options.baseUnit || \"\").toLowerCase();\r\n\t            var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\r\n\r\n\t            if (useDefault) {\r\n\t                options.baseUnit = this.defaultBaseUnit(options);\r\n\t            }\r\n\r\n\t            if (baseUnit === FIT || options.baseUnitStep === AUTO) {\r\n\t                this.autoBaseUnit(options);\r\n\t            }\r\n\r\n\t            this._groupsStart = addDuration(options.categories[0], 0, options.baseUnit, options.weekStartDay);\r\n\r\n\t            this.groupCategories(options);\r\n\t        } else {\r\n\t            options.baseUnit = options.baseUnit || DAYS;\r\n\t        }\r\n\r\n\t        this.options = options;\r\n\t    },\r\n\r\n\t    _initCategories: function() {},\r\n\r\n\t    shouldRenderNote: function(value) {\r\n\t        var range = this.range();\r\n\t        var categories = this.options.categories || [];\r\n\r\n\t        return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\r\n\t    },\r\n\r\n\t    parseNoteValue: function(value) {\r\n\t        return parseDate(this.chartService.intl, value);\r\n\t    },\r\n\r\n\t    noteSlot: function(value) {\r\n\t        return this.getSlot(value);\r\n\t    },\r\n\r\n\t    translateRange: function(delta) {\r\n\t        var options = this.options;\r\n\t        var baseUnit = options.baseUnit;\r\n\t        var weekStartDay = options.weekStartDay;\r\n\t        var vertical = options.vertical;\r\n\t        var lineBox = this.lineBox();\r\n\t        var size = vertical ? lineBox.height() : lineBox.width();\r\n\t        var range = this.range();\r\n\t        var scale = size / (range.max - range.min);\r\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\r\n\r\n\t        if (range.min && range.max) {\r\n\t            var from = addTicks(options.min || range.min, offset);\r\n\t            var to = addTicks(options.max || range.max, offset);\r\n\r\n\t            range = {\r\n\t                min: addDuration(from, 0, baseUnit, weekStartDay),\r\n\t                max: addDuration(to, 0, baseUnit, weekStartDay)\r\n\t            };\r\n\t        }\r\n\r\n\t        return range;\r\n\t    },\r\n\r\n\t    scaleRange: function(delta) {\r\n\t        var rounds = Math.abs(delta);\r\n\t        var result = this.range();\r\n\t        var from = result.min;\r\n\t        var to = result.max;\r\n\r\n\t        if (from && to) {\r\n\t            while (rounds--) {\r\n\t                var range = dateDiff(from, to);\r\n\t                var step = Math.round(range * 0.1);\r\n\t                if (delta < 0) {\r\n\t                    from = addTicks(from, step);\r\n\t                    to = addTicks(to, -step);\r\n\t                } else {\r\n\t                    from = addTicks(from, -step);\r\n\t                    to = addTicks(to, step);\r\n\t                }\r\n\t            }\r\n\r\n\t            result = { min: from, max: to };\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    defaultBaseUnit: function(options) {\r\n\t        var categories = options.categories;\r\n\t        var count = defined(categories) ? categories.length : 0;\r\n\t        var minDiff = MAX_VALUE;\r\n\t        var lastCategory, unit;\r\n\r\n\t        for (var categoryIx = 0; categoryIx < count; categoryIx++) {\r\n\t            var category = categories[categoryIx];\r\n\r\n\t            if (category && lastCategory) {\r\n\t                var diff = absoluteDateDiff(category, lastCategory);\r\n\t                if (diff > 0) {\r\n\t                    minDiff = Math.min(minDiff, diff);\r\n\r\n\t                    if (minDiff >= TIME_PER_YEAR) {\r\n\t                        unit = YEARS;\r\n\t                    } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\r\n\t                        unit = MONTHS;\r\n\t                    } else if (minDiff >= TIME_PER_WEEK) {\r\n\t                        unit = WEEKS;\r\n\t                    } else if (minDiff >= TIME_PER_DAY) {\r\n\t                        unit = DAYS;\r\n\t                    } else if (minDiff >= TIME_PER_HOUR) {\r\n\t                        unit = HOURS;\r\n\t                    } else if (minDiff >= TIME_PER_MINUTE) {\r\n\t                        unit = MINUTES;\r\n\t                    } else {\r\n\t                        unit = SECONDS;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            lastCategory = category;\r\n\t        }\r\n\r\n\t        return unit || DAYS;\r\n\t    },\r\n\r\n\t    _categoryRange: function(categories) {\r\n\t        var range = categories._range;\r\n\t        if (!range) {\r\n\t            range = categories._range = sparseArrayLimits(categories);\r\n\t        }\r\n\r\n\t        return range;\r\n\t    },\r\n\r\n\t    totalRange: function() {\r\n\t        return {\r\n\t            min: 0,\r\n\t            max: this.options.categories.length\r\n\t        };\r\n\t    },\r\n\r\n\t    rangeIndices: function() {\r\n\t        var options = this.options;\r\n\t        var categories = options.categories;\r\n\t        var baseUnit = options.baseUnit;\r\n\t        var baseUnitStep = options.baseUnitStep || 1;\r\n\t        var categoryLimits = this.categoriesRange();\r\n\t        var min = toDate(options.min || categoryLimits.min);\r\n\t        var max = toDate(options.max || categoryLimits.max);\r\n\t        var minIdx = 0, maxIdx = 0;\r\n\r\n\t        if (categories.length) {\r\n\t            minIdx = dateIndex(min, categories[0], baseUnit, baseUnitStep);\r\n\t            maxIdx = dateIndex(max, categories[0], baseUnit, baseUnitStep);\r\n\r\n\t            if (options.roundToBaseUnit) {\r\n\t                minIdx = Math.floor(minIdx);\r\n\t                maxIdx = options.justified ? Math.floor(maxIdx) : Math.ceil(maxIdx);\r\n\t            }\r\n\t        }\r\n\r\n\t        return { min: minIdx, max: maxIdx };\r\n\t    },\r\n\r\n\t    labelsRange: function() {\r\n\t        var options = this.options;\r\n\t        var labelOptions = options.labels;\r\n\t        var range = this.rangeIndices();\r\n\t        var min = Math.floor(range.min);\r\n\t        var max = Math.ceil(range.max);\r\n\r\n\t        return {\r\n\t            min: min + labelOptions.skip,\r\n\t            max: options.categories.length ? max + (options.justified ? 1 : 0) : 0\r\n\t        };\r\n\t    },\r\n\r\n\t    categoriesRange: function() {\r\n\t        var options = this.options;\r\n\t        var range = this._categoryRange(options.srcCategories || options.categories);\r\n\r\n\t        var max = toDate(range.max);\r\n\t        if (!options.justified && dateEquals(max, this._roundToTotalStep(max, options, false))) {\r\n\t            max = this._roundToTotalStep(max, options, true, true);\r\n\t        }\r\n\t        return {\r\n\t            min: toDate(range.min),\r\n\t            max: max\r\n\t        };\r\n\t    },\r\n\r\n\t    currentRange: function() {\r\n\t        var options = this.options;\r\n\t        var round$$1 = options.roundToBaseUnit !== false;\r\n\t        var totalRange = this.categoriesRange();\r\n\t        var min = options.min;\r\n\t        var max = options.max;\r\n\r\n\t        if (!min) {\r\n\t            min = round$$1 ? this._roundToTotalStep(totalRange.min, options, false) : totalRange.min;\r\n\t        }\r\n\r\n\t        if (!max) {\r\n\t            max = round$$1 ? this._roundToTotalStep(totalRange.max, options, !options.justified) : totalRange.max;\r\n\t        }\r\n\r\n\t        return {\r\n\t            min: min,\r\n\t            max: max\r\n\t        };\r\n\t    },\r\n\r\n\t    datesRange: function() {\r\n\t        var range = this._categoryRange(this.options.srcCategories || this.options.categories);\r\n\t        return {\r\n\t            min: toDate(range.min),\r\n\t            max: toDate(range.max)\r\n\t        };\r\n\t    },\r\n\r\n\t    pan: function(delta) {\r\n\t        var options = this.options;\r\n\t        var lineBox = this.lineBox();\r\n\t        var size = options.vertical ? lineBox.height() : lineBox.width();\r\n\t        var ref = this.currentRange();\r\n\t        var min = ref.min;\r\n\t        var max = ref.max;\r\n\t        var totalLimits = this.totalLimits();\r\n\t        var scale = size / (max - min);\r\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\r\n\t        var from = addTicks(min, offset);\r\n\t        var to = addTicks(max, offset);\r\n\r\n\t        var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\r\n\r\n\t        if (panRange) {\r\n\t            panRange.min = toDate(panRange.min);\r\n\t            panRange.max = toDate(panRange.max);\r\n\t            panRange.baseUnit = options.baseUnit;\r\n\t            panRange.baseUnitStep = options.baseUnitStep || 1;\r\n\t            panRange.userSetBaseUnit = options.userSetBaseUnit;\r\n\t            panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\r\n\r\n\t            return panRange;\r\n\t        }\r\n\t    },\r\n\r\n\t    pointsRange: function(start, end) {\r\n\t        var pointsRange = CategoryAxis.fn.pointsRange.call(this, start, end);\r\n\t        var datesRange = this.currentRange();\r\n\t        var indicesRange = this.rangeIndices();\r\n\t        var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\r\n\t        var options = this.options;\r\n\r\n\t        var min = addTicks(datesRange.min, pointsRange.min * scale);\r\n\t        var max = addTicks(datesRange.min, pointsRange.max * scale);\r\n\r\n\t        return {\r\n\t            min: min,\r\n\t            max: max,\r\n\t            baseUnit: options.userSetBaseUnit,\r\n\t            baseUnitStep: options.userSetBaseUnitStep\r\n\t        };\r\n\t    },\r\n\r\n\t    zoomRange: function(delta) {\r\n\t        var options = this.options;\r\n\t        var totalLimits = this.totalLimits();\r\n\t        var weekStartDay = options.weekStartDay;\r\n\t        var baseUnit = options.baseUnit;\r\n\t        var baseUnitStep = options.baseUnitStep || 1;\r\n\t        var ref = this.currentRange();\r\n\t        var rangeMin = ref.min;\r\n\t        var rangeMax = ref.max;\r\n\t        var min = addDuration(rangeMin, delta * baseUnitStep, baseUnit, weekStartDay);\r\n\t        var max = addDuration(rangeMax, -delta * baseUnitStep, baseUnit, weekStartDay);\r\n\r\n\t        if (options.userSetBaseUnit === FIT) {\r\n\t            var autoBaseUnitSteps = options.autoBaseUnitSteps;\r\n\t            var maxDateGroups = options.maxDateGroups;\r\n\r\n\t            var maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\r\n\t            var rangeDiff = dateDiff(rangeMax, rangeMin);\r\n\t            var diff = dateDiff(max, min);\r\n\t            var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\r\n\t            var autoBaseUnitStep, ticks;\r\n\r\n\t            if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\r\n\t                baseUnit = BASE_UNITS[baseUnitIndex - 1];\r\n\t                autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\r\n\t                ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\r\n\t                min = addTicks(rangeMin, ticks);\r\n\t                max = addTicks(rangeMax, -ticks);\r\n\r\n\t            } else if (diff > maxDiff && baseUnit !== YEARS) {\r\n\t                var stepIndex = 0;\r\n\r\n\t                do {\r\n\t                    baseUnitIndex++;\r\n\t                    baseUnit = BASE_UNITS[baseUnitIndex];\r\n\t                    stepIndex = 0;\r\n\t                    ticks = 2 * TIME_PER_UNIT[baseUnit];\r\n\t                    do {\r\n\t                        autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\r\n\t                        stepIndex++;\r\n\t                    } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\r\n\t                } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\r\n\r\n\t                ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\r\n\t                if (ticks > 0) {\r\n\t                    min = addTicks(rangeMin, -ticks);\r\n\t                    max = addTicks(rangeMax, ticks);\r\n\t                    min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\r\n\t                    max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        min = toDate(limitValue(min, totalLimits.min, totalLimits.max));\r\n\t        max = toDate(limitValue(max, totalLimits.min, totalLimits.max));\r\n\r\n\t        if (min && max && dateDiff(max, min) > 0) {\r\n\t            return {\r\n\t                min: min,\r\n\t                max: max,\r\n\t                baseUnit: options.userSetBaseUnit,\r\n\t                baseUnitStep: options.userSetBaseUnitStep\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    totalLimits: function() {\r\n\t        var options = this.options;\r\n\t        var datesRange = this.datesRange();\r\n\r\n\t        var min = this._roundToTotalStep(toDate(datesRange.min), options, false);\r\n\t        var max = datesRange.max;\r\n\r\n\t        if (!options.justified) {\r\n\t            max = this._roundToTotalStep(max, options, true, dateEquals(max, this._roundToTotalStep(max, options, false)));\r\n\t        }\r\n\r\n\t        return {\r\n\t            min: min,\r\n\t            max: max\r\n\t        };\r\n\t    },\r\n\r\n\t    range: function(rangeOptions) {\r\n\t        var options = rangeOptions || this.options;\r\n\r\n\t        var categories = options.categories;\r\n\t        var autoUnit = options.baseUnit === FIT;\r\n\t        var baseUnit = autoUnit ? BASE_UNITS[0] : options.baseUnit;\r\n\t        var baseUnitStep = options.baseUnitStep || 1;\r\n\t        var stepOptions = {\r\n\t            baseUnit: baseUnit,\r\n\t            baseUnitStep: baseUnitStep,\r\n\t            weekStartDay: options.weekStartDay\r\n\t        };\r\n\t        var categoryLimits = this._categoryRange(categories);\r\n\t        var min = toDate(options.min || categoryLimits.min);\r\n\t        var max = toDate(options.max || categoryLimits.max);\r\n\r\n\t        return {\r\n\t            min: this._roundToTotalStep(min, stepOptions, false),\r\n\t            max: this._roundToTotalStep(max, stepOptions, true, true)\r\n\t        };\r\n\t    },\r\n\r\n\t    autoBaseUnit: function(options) {\r\n\t        var categoryLimits = this._categoryRange(options.categories);\r\n\t        var span = toDate(options.max || categoryLimits.max) - toDate(options.min || categoryLimits.min);\r\n\t        var maxDateGroups = options.maxDateGroups || this.options.maxDateGroups;\r\n\t        var autoUnit = options.baseUnit === FIT;\r\n\t        var autoUnitIx = 0;\r\n\t        var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\r\n\t        var units = span / TIME_PER_UNIT[baseUnit];\r\n\t        var totalUnits = units;\r\n\t        var autoBaseUnitSteps = deepExtend(\r\n\t            {}, this.options.autoBaseUnitSteps, options.autoBaseUnitSteps\r\n\t        );\r\n\t        var unitSteps, step, nextStep;\r\n\r\n\t        while (!step || units >= maxDateGroups) {\r\n\t            unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\r\n\t            nextStep = unitSteps.shift();\r\n\r\n\t            if (nextStep) {\r\n\t                step = nextStep;\r\n\t                units = totalUnits / step;\r\n\t            } else if (baseUnit === last(BASE_UNITS)) {\r\n\t                step = Math.ceil(totalUnits / maxDateGroups);\r\n\t                break;\r\n\t            } else if (autoUnit) {\r\n\t                baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\r\n\t                totalUnits = span / TIME_PER_UNIT[baseUnit];\r\n\t                unitSteps = null;\r\n\t            } else {\r\n\t                if (units > maxDateGroups) {\r\n\t                    step = Math.ceil(totalUnits / maxDateGroups);\r\n\t                }\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        options.baseUnitStep = step;\r\n\t        options.baseUnit = baseUnit;\r\n\t    },\r\n\r\n\t    groupCategories: function(options) {\r\n\t        var categories = options.categories;\r\n\t        var baseUnit = options.baseUnit;\r\n\t        var baseUnitStep = options.baseUnitStep || 1;\r\n\t        var maxCategory = toDate(sparseArrayLimits(categories).max);\r\n\t        var ref = this.range(options);\r\n\t        var min = ref.min;\r\n\t        var max = ref.max;\r\n\t        var groups = [];\r\n\t        var nextDate;\r\n\r\n\t        for (var date = min; date < max; date = nextDate) {\r\n\t            groups.push(date);\r\n\r\n\t            nextDate = addDuration(date, baseUnitStep, baseUnit, options.weekStartDay);\r\n\t            if (nextDate > maxCategory && !options.max) {\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        options.srcCategories = categories;\r\n\t        options.categories = groups;\r\n\t    },\r\n\r\n\t    _roundToTotalStep: function(value, axisOptions, upper, roundToNext) {\r\n\t        var options = axisOptions || this.options;\r\n\t        var baseUnit = options.baseUnit;\r\n\t        var baseUnitStep = options.baseUnitStep || 1;\r\n\t        var start = this._groupsStart;\r\n\r\n\t        if (start) {\r\n\t            var step = dateIndex(value, start, baseUnit, baseUnitStep);\r\n\t            var roundedStep = upper ? Math.ceil(step) : Math.floor(step);\r\n\t            if (roundToNext) {\r\n\t                roundedStep++;\r\n\t            }\r\n\t            return addDuration(start, roundedStep * baseUnitStep, baseUnit, options.weekStartDay);\r\n\t        }\r\n\r\n\t        return addDuration(value, upper ? baseUnitStep : 0, baseUnit, options.weekStartDay);\r\n\t    },\r\n\r\n\t    createAxisLabel: function(index, labelOptions) {\r\n\t        var options = this.options;\r\n\t        var dataItem = options.dataItems ? options.dataItems[index] : null;\r\n\t        var date = options.categories[index];\r\n\t        var baseUnit = options.baseUnit;\r\n\t        var unitFormat = labelOptions.dateFormats[baseUnit];\r\n\t        var visible = true;\r\n\r\n\t        if (options.justified) {\r\n\t            var roundedDate = floorDate(date, baseUnit, options.weekStartDay);\r\n\t            visible = dateEquals(roundedDate, date);\r\n\t        } else if (!options.roundToBaseUnit) {\r\n\t            visible = !dateEquals(this.range().max, date);\r\n\t        }\r\n\r\n\t        if (visible) {\r\n\t            labelOptions.format = labelOptions.format || unitFormat;\r\n\t            var text = this.axisLabelText(date, dataItem, labelOptions);\r\n\t            if (text) {\r\n\t                return new AxisLabel(date, text, index, dataItem, labelOptions);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    categoryIndex: function(value) {\r\n\t        var options = this.options;\r\n\t        var categories = options.categories;\r\n\t        var index = -1;\r\n\r\n\t        if (categories.length) {\r\n\t            index = Math.floor(dateIndex(toDate(value), categories[0], options.baseUnit, options.baseUnitStep || 1));\r\n\t        }\r\n\r\n\t        return index;\r\n\t    },\r\n\r\n\t    getSlot: function(a, b, limit) {\r\n\t        var start = a;\r\n\t        var end = b;\r\n\r\n\t        if (typeof start === OBJECT) {\r\n\t            start = this.categoryIndex(start);\r\n\t        }\r\n\r\n\t        if (typeof end === OBJECT) {\r\n\t            end = this.categoryIndex(end);\r\n\t        }\r\n\r\n\t        return CategoryAxis.fn.getSlot.call(this, start, end, limit);\r\n\t    },\r\n\r\n\t    valueRange: function() {\r\n\t        var options = this.options;\r\n\t        var range = this._categoryRange(options.srcCategories || options.categories);\r\n\r\n\t        return {\r\n\t            min: toDate(range.min),\r\n\t            max: toDate(range.max)\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(DateCategoryAxis, {\r\n\t    type: DATE,\r\n\t    labels: {\r\n\t        dateFormats: DateLabelFormats\r\n\t    },\r\n\t    autoBaseUnitSteps: {\r\n\t        milliseconds: [ 1, 10, 100 ],\r\n\t        seconds: [ 1, 2, 5, 15, 30 ],\r\n\t        minutes: [ 1, 2, 5, 15, 30 ],\r\n\t        hours: [ 1, 2, 3 ],\r\n\t        days: [ 1, 2, 3 ],\r\n\t        weeks: [ 1, 2 ],\r\n\t        months: [ 1, 2, 3, 6 ],\r\n\t        years: [ 1, 2, 3, 5, 10, 25, 50 ]\r\n\t    },\r\n\t    maxDateGroups: 10\r\n\t});\r\n\r\n\tfunction autoMajorUnit(min, max) {\r\n\t    var diff = round(max - min, DEFAULT_PRECISION - 1);\r\n\r\n\t    if (diff === 0) {\r\n\t        if (max === 0) {\r\n\t            return 0.1;\r\n\t        }\r\n\r\n\t        diff = Math.abs(max);\r\n\t    }\r\n\r\n\t    var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));\r\n\t    var relativeValue = round((diff / scale), DEFAULT_PRECISION);\r\n\t    var scaleMultiplier = 1;\r\n\r\n\t    if (relativeValue < 1.904762) {\r\n\t        scaleMultiplier = 0.2;\r\n\t    } else if (relativeValue < 4.761904) {\r\n\t        scaleMultiplier = 0.5;\r\n\t    } else if (relativeValue < 9.523809) {\r\n\t        scaleMultiplier = 1;\r\n\t    } else {\r\n\t        scaleMultiplier = 2;\r\n\t    }\r\n\r\n\t    return round(scale * scaleMultiplier, DEFAULT_PRECISION);\r\n\t}\r\n\r\n\tfunction autoAxisMin(min, max, narrow) {\r\n\t    if (!min && !max) {\r\n\t        return 0;\r\n\t    }\r\n\r\n\t    var axisMin;\r\n\r\n\t    if (min >= 0 && max >= 0) {\r\n\t        var minValue = min === max ? 0 : min;\r\n\r\n\t        var diff = (max - minValue) / max;\r\n\t        if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\r\n\t            return 0;\r\n\t        }\r\n\r\n\t        axisMin = Math.max(0, minValue - ((max - minValue) / 2));\r\n\t    } else {\r\n\t        axisMin = min;\r\n\t    }\r\n\r\n\t    return axisMin;\r\n\t}\r\n\r\n\tfunction autoAxisMax(min, max, narrow) {\r\n\t    if (!min && !max) {\r\n\t        return 1;\r\n\t    }\r\n\r\n\t    var axisMax;\r\n\r\n\t    if (min <= 0 && max <= 0) {\r\n\t        var maxValue = min === max ? 0 : max;\r\n\r\n\t        var diff = Math.abs((maxValue - min) / maxValue);\r\n\t        if (narrow === false || (!narrow && diff > ZERO_THRESHOLD)) {\r\n\t            return 0;\r\n\t        }\r\n\r\n\t        axisMax = Math.min(0, maxValue - ((min - maxValue) / 2));\r\n\t    } else {\r\n\t        axisMax = max;\r\n\t    }\r\n\r\n\t    return axisMax;\r\n\t}\r\n\r\n\tfunction floor(value, step) {\r\n\t    return round(Math.floor(value / step) * step, DEFAULT_PRECISION);\r\n\t}\r\n\r\n\tfunction ceil(value, step) {\r\n\t    return round(Math.ceil(value / step) * step, DEFAULT_PRECISION);\r\n\t}\r\n\r\n\tfunction limitCoordinate(value) {\r\n\t    return Math.max(Math.min(value, COORDINATE_LIMIT), -COORDINATE_LIMIT);\r\n\t}\r\n\r\n\tvar MIN_VALUE_RANGE = Math.pow(10, -DEFAULT_PRECISION + 1);\r\n\r\n\tvar NumericAxis = Axis.extend({\r\n\t    init: function(seriesMin, seriesMax, options, chartService) {\r\n\t        var autoOptions = autoAxisOptions(seriesMin, seriesMax, options);\r\n\t        var totalOptions = totalAxisOptions(autoOptions, options);\r\n\r\n\t        Axis.fn.init.call(this, axisOptions(autoOptions, options), chartService);\r\n\r\n\t        this.totalMin = totalOptions.min;\r\n\t        this.totalMax = totalOptions.max;\r\n\t        this.totalMajorUnit = totalOptions.majorUnit;\r\n\t        this.seriesMin = seriesMin;\r\n\t        this.seriesMax = seriesMax;\r\n\t    },\r\n\r\n\t    startValue: function() {\r\n\t        return 0;\r\n\t    },\r\n\r\n\t    range: function() {\r\n\t        var options = this.options;\r\n\t        return { min: options.min, max: options.max };\r\n\t    },\r\n\r\n\t    getDivisions: function(stepValue) {\r\n\t        if (stepValue === 0) {\r\n\t            return 1;\r\n\t        }\r\n\r\n\t        var options = this.options;\r\n\t        var range = options.max - options.min;\r\n\r\n\t        return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;\r\n\t    },\r\n\r\n\t    getTickPositions: function(unit, skipUnit) {\r\n\t        var options = this.options;\r\n\t        var vertical = options.vertical;\r\n\t        var reverse = options.reverse;\r\n\t        var lineBox = this.lineBox();\r\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\r\n\t        var range = options.max - options.min;\r\n\t        var scale = lineSize / range;\r\n\t        var step = unit * scale;\r\n\t        var divisions = this.getDivisions(unit);\r\n\t        var dir = (vertical ? -1 : 1) * (reverse ? -1 : 1);\r\n\t        var startEdge = dir === 1 ? 1 : 2;\r\n\t        var positions = [];\r\n\t        var pos = lineBox[(vertical ? Y : X) + startEdge];\r\n\t        var skipStep = 0;\r\n\r\n\t        if (skipUnit) {\r\n\t            skipStep = skipUnit / unit;\r\n\t        }\r\n\r\n\t        for (var idx = 0; idx < divisions; idx++) {\r\n\t            if (idx % skipStep !== 0) {\r\n\t                positions.push(round(pos, COORD_PRECISION));\r\n\t            }\r\n\r\n\t            pos = pos + step * dir;\r\n\t        }\r\n\r\n\t        return positions;\r\n\t    },\r\n\r\n\t    getMajorTickPositions: function() {\r\n\t        return this.getTickPositions(this.options.majorUnit);\r\n\t    },\r\n\r\n\t    getMinorTickPositions: function() {\r\n\t        return this.getTickPositions(this.options.minorUnit);\r\n\t    },\r\n\r\n\t    getSlot: function(a, b, limit) {\r\n\t        if (limit === void 0) { limit = false; }\r\n\r\n\t        var options = this.options;\r\n\t        var vertical = options.vertical;\r\n\t        var reverse = options.reverse;\r\n\t        var valueAxis = vertical ? Y : X;\r\n\t        var lineBox = this.lineBox();\r\n\t        var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\r\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\r\n\t        var dir = reverse ? -1 : 1;\r\n\t        var step = dir * (lineSize / (options.max - options.min));\r\n\t        var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\r\n\r\n\t        var start = a;\r\n\t        var end = b;\r\n\r\n\t        if (!defined(start)) {\r\n\t            start = end || 0;\r\n\t        }\r\n\r\n\t        if (!defined(end)) {\r\n\t            end = start || 0;\r\n\t        }\r\n\r\n\t        if (limit) {\r\n\t            start = Math.max(Math.min(start, options.max), options.min);\r\n\t            end = Math.max(Math.min(end, options.max), options.min);\r\n\t        }\r\n\r\n\t        var p1, p2;\r\n\r\n\t        if (vertical) {\r\n\t            p1 = options.max - Math.max(start, end);\r\n\t            p2 = options.max - Math.min(start, end);\r\n\t        } else {\r\n\t            p1 = Math.min(start, end) - options.min;\r\n\t            p2 = Math.max(start, end) - options.min;\r\n\t        }\r\n\r\n\t        slotBox[valueAxis + 1] = limitCoordinate(lineStart + step * (reverse ? p2 : p1));\r\n\t        slotBox[valueAxis + 2] = limitCoordinate(lineStart + step * (reverse ? p1 : p2));\r\n\r\n\t        return slotBox;\r\n\t    },\r\n\r\n\t    getValue: function(point) {\r\n\t        var options = this.options;\r\n\t        var vertical = options.vertical;\r\n\t        var reverse = options.reverse;\r\n\t        var max = Number(options.max);\r\n\t        var min = Number(options.min);\r\n\t        var valueAxis = vertical ? Y : X;\r\n\t        var lineBox = this.lineBox();\r\n\t        var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\r\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\r\n\t        var dir = reverse ? -1 : 1;\r\n\t        var offset = dir * (point[valueAxis] - lineStart);\r\n\t        var step = (max - min) / lineSize;\r\n\t        var valueOffset = offset * step;\r\n\r\n\t        if (offset < 0 || offset > lineSize) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        var value = vertical ?\r\n\t                max - valueOffset :\r\n\t                min + valueOffset;\r\n\r\n\t        return round(value, DEFAULT_PRECISION);\r\n\t    },\r\n\r\n\t    translateRange: function(delta) {\r\n\t        var options = this.options;\r\n\t        var vertical = options.vertical;\r\n\t        var reverse = options.reverse;\r\n\t        var max = options.max;\r\n\t        var min = options.min;\r\n\t        var lineBox = this.lineBox();\r\n\t        var size = vertical ? lineBox.height() : lineBox.width();\r\n\t        var range = max - min;\r\n\t        var scale = size / range;\r\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\r\n\r\n\t        if ((vertical || reverse) && !(vertical && reverse )) {\r\n\t            offset = -offset;\r\n\t        }\r\n\r\n\t        return {\r\n\t            min: min + offset,\r\n\t            max: max + offset\r\n\t        };\r\n\t    },\r\n\r\n\t    scaleRange: function(delta) {\r\n\t        var options = this.options;\r\n\t        var offset = -delta * options.majorUnit;\r\n\r\n\t        return {\r\n\t            min: options.min - offset,\r\n\t            max: options.max + offset\r\n\t        };\r\n\t    },\r\n\r\n\t    labelsCount: function() {\r\n\t        return this.getDivisions(this.options.majorUnit);\r\n\t    },\r\n\r\n\t    createAxisLabel: function(index, labelOptions) {\r\n\t        var options = this.options;\r\n\t        var value = round(options.min + (index * options.majorUnit), DEFAULT_PRECISION);\r\n\t        var text = this.axisLabelText(value, null, labelOptions);\r\n\r\n\t        return new AxisLabel(value, text, index, null, labelOptions);\r\n\t    },\r\n\r\n\t    shouldRenderNote: function(value) {\r\n\t        var range = this.range();\r\n\t        return range.min <= value && value <= range.max;\r\n\t    },\r\n\r\n\t    pan: function(delta) {\r\n\t        var range = this.translateRange(delta);\r\n\t        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax);\r\n\t    },\r\n\r\n\t    pointsRange: function(start, end) {\r\n\t        var startValue = this.getValue(start);\r\n\t        var endValue = this.getValue(end);\r\n\t        var min = Math.min(startValue, endValue);\r\n\t        var max = Math.max(startValue, endValue);\r\n\r\n\t        if (this.isValidRange(min, max)) {\r\n\t            return {\r\n\t                min: min,\r\n\t                max: max\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    zoomRange: function(delta) {\r\n\t        var ref = this;\r\n\t        var totalMin = ref.totalMin;\r\n\t        var totalMax = ref.totalMax;\r\n\t        var newRange = this.scaleRange(delta);\r\n\t        var min = limitValue(newRange.min, totalMin, totalMax);\r\n\t        var max = limitValue(newRange.max, totalMin, totalMax);\r\n\r\n\t        if (this.isValidRange(min, max)) {\r\n\t            return {\r\n\t                min: min,\r\n\t                max: max\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    isValidRange: function(min, max) {\r\n\t        return max - min > MIN_VALUE_RANGE;\r\n\t    }\r\n\t});\r\n\r\n\tfunction autoAxisOptions(seriesMin, seriesMax, options) {\r\n\t    var narrowRange = options.narrowRange;\r\n\r\n\t    var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);\r\n\t    var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);\r\n\r\n\t    var majorUnit = autoMajorUnit(autoMin, autoMax);\r\n\t    var autoOptions = {\r\n\t        majorUnit: majorUnit\r\n\t    };\r\n\r\n\t    if (options.roundToMajorUnit !== false) {\r\n\t        if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {\r\n\t            autoMin -= majorUnit;\r\n\t        }\r\n\r\n\t        if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {\r\n\t            autoMax += majorUnit;\r\n\t        }\r\n\t    }\r\n\r\n\t    autoOptions.min = floor(autoMin, majorUnit);\r\n\t    autoOptions.max = ceil(autoMax, majorUnit);\r\n\r\n\t    return autoOptions;\r\n\t}\r\n\r\n\tfunction totalAxisOptions(autoOptions, options) {\r\n\t    return {\r\n\t        min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,\r\n\t        max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,\r\n\t        majorUnit: autoOptions.majorUnit\r\n\t    };\r\n\t}\r\n\r\n\tfunction axisOptions(autoOptions, userOptions) {\r\n\t    var options = userOptions;\r\n\t    var userSetMin, userSetMax;\r\n\r\n\t    if (userOptions) {\r\n\t        userSetMin = defined(userOptions.min);\r\n\t        userSetMax = defined(userOptions.max);\r\n\r\n\t        var userSetLimits = userSetMin || userSetMax;\r\n\r\n\t        if (userSetLimits) {\r\n\t            if (userOptions.min === userOptions.max) {\r\n\t                if (userOptions.min > 0) {\r\n\t                    userOptions.min = 0;\r\n\t                } else {\r\n\t                    userOptions.max = 1;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (userOptions.majorUnit) {\r\n\t            autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);\r\n\t            autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);\r\n\t        } else if (userSetLimits) {\r\n\t            options = deepExtend(autoOptions, userOptions);\r\n\r\n\t            // Determine an auto major unit after min/max have been set\r\n\t            autoOptions.majorUnit = autoMajorUnit(options.min, options.max);\r\n\t        }\r\n\t    }\r\n\r\n\t    autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;\r\n\r\n\t    var result = deepExtend(autoOptions, options);\r\n\t    if (result.min >= result.max) {\r\n\t        if (userSetMin && !userSetMax) {\r\n\t            result.max = result.min + result.majorUnit;\r\n\t        } else if (!userSetMin && userSetMax) {\r\n\t            result.min = result.max - result.majorUnit;\r\n\t        }\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction remainderClose(value, divisor, ratio) {\r\n\t    var remainder = round(Math.abs(value % divisor), DEFAULT_PRECISION);\r\n\t    var threshold = divisor * (1 - ratio);\r\n\r\n\t    return remainder === 0 || remainder > threshold;\r\n\t}\r\n\r\n\tsetDefaultOptions(NumericAxis, {\r\n\t    type: \"numeric\",\r\n\t    min: 0,\r\n\t    max: 1,\r\n\t    vertical: true,\r\n\t    majorGridLines: {\r\n\t        visible: true,\r\n\t        width: 1,\r\n\t        color: BLACK\r\n\t    },\r\n\t    labels: {\r\n\t        format: \"#.####################\"\r\n\t    },\r\n\t    zIndex: 1\r\n\t});\r\n\r\n\tvar DateValueAxis = Axis.extend({\r\n\t    init: function(seriesMin, seriesMax, axisOptions, chartService) {\r\n\t        var min = toDate(seriesMin);\r\n\t        var max = toDate(seriesMax);\r\n\r\n\t        var intlService = chartService.intl;\r\n\t        var options = axisOptions || {};\r\n\t        options = deepExtend(options || {}, {\r\n\t            min: parseDate(intlService, options.min),\r\n\t            max: parseDate(intlService, options.max),\r\n\t            axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue)\r\n\t        });\r\n\t        options = applyDefaults(min, max, options);\r\n\r\n\t        Axis.fn.init.call(this, options, chartService);\r\n\r\n\t        this.seriesMin = min;\r\n\t        this.seriesMax = max;\r\n\t        this.totalMin = toTime(floorDate(toTime(min) - 1, options.baseUnit));\r\n\t        this.totalMax = toTime(ceilDate(toTime(max) + 1, options.baseUnit));\r\n\t    },\r\n\r\n\t    range: function() {\r\n\t        var options = this.options;\r\n\t        return { min: options.min, max: options.max };\r\n\t    },\r\n\r\n\t    getDivisions: function(stepValue) {\r\n\t        var options = this.options;\r\n\r\n\t        return Math.floor(\r\n\t            duration(options.min, options.max, options.baseUnit) / stepValue + 1\r\n\t        );\r\n\t    },\r\n\r\n\t    getTickPositions: function(step) {\r\n\t        var options = this.options;\r\n\t        var vertical = options.vertical;\r\n\t        var lineBox = this.lineBox();\r\n\t        var dir = (vertical ? -1 : 1) * (options.reverse ? -1 : 1);\r\n\t        var startEdge = dir === 1 ? 1 : 2;\r\n\t        var start = lineBox[(vertical ? Y : X) + startEdge];\r\n\t        var divisions = this.getDivisions(step);\r\n\t        var timeRange = dateDiff(options.max, options.min);\r\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\r\n\t        var scale = lineSize / timeRange;\r\n\r\n\t        var positions = [ start ];\r\n\t        for (var i = 1; i < divisions; i++) {\r\n\t            var date = addDuration(options.min, i * step, options.baseUnit);\r\n\t            var pos = start + dateDiff(date, options.min) * scale * dir;\r\n\r\n\t            positions.push(round(pos, COORD_PRECISION));\r\n\t        }\r\n\r\n\t        return positions;\r\n\t    },\r\n\r\n\t    getMajorTickPositions: function() {\r\n\t        return this.getTickPositions(this.options.majorUnit);\r\n\t    },\r\n\r\n\t    getMinorTickPositions: function() {\r\n\t        return this.getTickPositions(this.options.minorUnit);\r\n\t    },\r\n\r\n\t    getSlot: function(a, b, limit) {\r\n\t        return NumericAxis.prototype.getSlot.call(\r\n\t            this, toDate(a), toDate(b), limit\r\n\t        );\r\n\t    },\r\n\r\n\t    getValue: function(point) {\r\n\t        var value = NumericAxis.prototype.getValue.call(this, point);\r\n\r\n\t        return value !== null ? toDate(value) : null;\r\n\t    },\r\n\r\n\t    labelsCount: function() {\r\n\t        return this.getDivisions(this.options.majorUnit);\r\n\t    },\r\n\r\n\t    createAxisLabel: function(index, labelOptions) {\r\n\t        var options = this.options;\r\n\t        var offset = index * options.majorUnit;\r\n\t        var date = options.min;\r\n\r\n\t        if (offset > 0) {\r\n\t            date = addDuration(date, offset, options.baseUnit);\r\n\t        }\r\n\r\n\t        var unitFormat = labelOptions.dateFormats[options.baseUnit];\r\n\t        labelOptions.format = labelOptions.format || unitFormat;\r\n\r\n\t        var text = this.axisLabelText(date, null, labelOptions);\r\n\t        return new AxisLabel(date, text, index, null, labelOptions);\r\n\t    },\r\n\r\n\t    translateRange: function(delta, exact) {\r\n\t        var options = this.options;\r\n\t        var baseUnit = options.baseUnit;\r\n\t        var weekStartDay = options.weekStartDay;\r\n\t        var lineBox = this.lineBox();\r\n\t        var size = options.vertical ? lineBox.height() : lineBox.width();\r\n\t        var range = this.range();\r\n\t        var scale = size / dateDiff(range.max, range.min);\r\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\r\n\t        var from = addTicks(options.min, offset);\r\n\t        var to = addTicks(options.max, offset);\r\n\r\n\t        if (!exact) {\r\n\t            from = addDuration(from, 0, baseUnit, weekStartDay);\r\n\t            to = addDuration(to, 0, baseUnit, weekStartDay);\r\n\t        }\r\n\r\n\t        return {\r\n\t            min: from,\r\n\t            max: to\r\n\t        };\r\n\t    },\r\n\r\n\t    scaleRange: function(delta) {\r\n\t        var ref = this.options;\r\n\t        var from = ref.min;\r\n\t        var to = ref.max;\r\n\t        var rounds = Math.abs(delta);\r\n\r\n\t        while (rounds--) {\r\n\t            var range = dateDiff(from, to);\r\n\t            var step = Math.round(range * 0.1);\r\n\t            if (delta < 0) {\r\n\t                from = addTicks(from, step);\r\n\t                to = addTicks(to, -step);\r\n\t            } else {\r\n\t                from = addTicks(from, -step);\r\n\t                to = addTicks(to, step);\r\n\t            }\r\n\t        }\r\n\r\n\t        return { min: from, max: to };\r\n\t    },\r\n\r\n\t    shouldRenderNote: function(value) {\r\n\t        var range = this.range();\r\n\r\n\t        return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0;\r\n\t    },\r\n\r\n\t    pan: function(delta) {\r\n\t        var range = this.translateRange(delta, true);\r\n\t        var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax);\r\n\r\n\t        if (limittedRange) {\r\n\t            return {\r\n\t                min: toDate(limittedRange.min),\r\n\t                max: toDate(limittedRange.max)\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    pointsRange: function(start, end) {\r\n\t        var startValue = this.getValue(start);\r\n\t        var endValue = this.getValue(end);\r\n\t        var min = Math.min(startValue, endValue);\r\n\t        var max = Math.max(startValue, endValue);\r\n\r\n\t        return {\r\n\t            min: toDate(min),\r\n\t            max: toDate(max)\r\n\t        };\r\n\t    },\r\n\r\n\t    zoomRange: function(delta) {\r\n\t        var range = this.scaleRange(delta);\r\n\t        var min = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));\r\n\t        var max = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));\r\n\r\n\t        return {\r\n\t            min: min,\r\n\t            max: max\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tfunction timeUnits(delta) {\r\n\t    var unit = HOURS;\r\n\r\n\t    if (delta >= TIME_PER_YEAR) {\r\n\t        unit = YEARS;\r\n\t    } else if (delta >= TIME_PER_MONTH) {\r\n\t        unit = MONTHS;\r\n\t    } else if (delta >= TIME_PER_WEEK) {\r\n\t        unit = WEEKS;\r\n\t    } else if (delta >= TIME_PER_DAY) {\r\n\t        unit = DAYS;\r\n\t    }\r\n\r\n\t    return unit;\r\n\t}\r\n\r\n\tfunction applyDefaults(seriesMin, seriesMax, options) {\r\n\t    var min = options.min || seriesMin;\r\n\t    var max = options.max || seriesMax;\r\n\t    var baseUnit = options.baseUnit || (max && min ? timeUnits(absoluteDateDiff(max, min)) : HOURS);\r\n\t    var baseUnitTime = TIME_PER_UNIT[baseUnit];\r\n\t    var autoMin = floorDate(toTime(min) - 1, baseUnit) || toDate(max);\r\n\t    var autoMax = ceilDate(toTime(max) + 1, baseUnit);\r\n\t    var userMajorUnit = options.majorUnit ? options.majorUnit : undefined;\r\n\t    var majorUnit = userMajorUnit || ceil(\r\n\t                        autoMajorUnit(autoMin.getTime(), autoMax.getTime()),\r\n\t                        baseUnitTime\r\n\t                    ) / baseUnitTime;\r\n\t    var actualUnits = duration(autoMin, autoMax, baseUnit);\r\n\t    var totalUnits = ceil(actualUnits, majorUnit);\r\n\t    var unitsToAdd = totalUnits - actualUnits;\r\n\t    var head = Math.floor(unitsToAdd / 2);\r\n\t    var tail = unitsToAdd - head;\r\n\r\n\t    if (!options.baseUnit) {\r\n\t        delete options.baseUnit;\r\n\t    }\r\n\r\n\t    options.baseUnit = options.baseUnit || baseUnit;\r\n\t    options.min = options.min || addDuration(autoMin, -head, baseUnit);\r\n\t    options.max = options.max || addDuration(autoMax, tail, baseUnit);\r\n\t    options.minorUnit = options.minorUnit || majorUnit / 5;\r\n\t    options.majorUnit = majorUnit;\r\n\r\n\t    return options;\r\n\t}\r\n\r\n\tsetDefaultOptions(DateValueAxis, {\r\n\t    type: DATE,\r\n\t    majorGridLines: {\r\n\t        visible: true,\r\n\t        width: 1,\r\n\t        color: BLACK\r\n\t    },\r\n\t    labels: {\r\n\t        dateFormats: DateLabelFormats\r\n\t    }\r\n\t});\r\n\r\n\tvar DEFAULT_MAJOR_UNIT = 10;\r\n\r\n\tvar LogarithmicAxis = Axis.extend({\r\n\t    init: function(seriesMin, seriesMax, options, chartService) {\r\n\r\n\t        var axisOptions = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);\r\n\t        var base = axisOptions.majorUnit;\r\n\t        var autoMax = autoAxisMax$1(seriesMax, base);\r\n\t        var autoMin = autoAxisMin$1(seriesMin, seriesMax, axisOptions);\r\n\t        var range = initRange(autoMin, autoMax, axisOptions, options);\r\n\r\n\t        axisOptions.max = range.max;\r\n\t        axisOptions.min = range.min;\r\n\t        axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\r\n\r\n\t        Axis.fn.init.call(this, axisOptions, chartService);\r\n\r\n\t        this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\r\n\t        this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\r\n\t        this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\r\n\t        this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\r\n\t        this.seriesMin = seriesMin;\r\n\t        this.seriesMax = seriesMax;\r\n\r\n\t        this.createLabels();\r\n\t    },\r\n\r\n\t    startValue: function() {\r\n\t        return this.options.min;\r\n\t    },\r\n\r\n\t    getSlot: function(a, b, limit) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var logMin = ref.logMin;\r\n\t        var logMax = ref.logMax;\r\n\t        var reverse = options.reverse;\r\n\t        var vertical = options.vertical;\r\n\t        var base = options.majorUnit;\r\n\t        var valueAxis = vertical ? Y : X;\r\n\t        var lineBox = this.lineBox();\r\n\t        var lineStart = lineBox[valueAxis + (reverse ? 2 : 1)];\r\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\r\n\t        var dir = reverse ? -1 : 1;\r\n\t        var step = dir * (lineSize / (logMax - logMin));\r\n\t        var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\r\n\t        var start = a;\r\n\t        var end = b;\r\n\r\n\t        if (!defined(start)) {\r\n\t            start = end || 1;\r\n\t        }\r\n\r\n\t        if (!defined(end)) {\r\n\t            end = start || 1;\r\n\t        }\r\n\r\n\t        if (start <= 0 || end <= 0) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        if (limit) {\r\n\t            start = Math.max(Math.min(start, options.max), options.min);\r\n\t            end = Math.max(Math.min(end, options.max), options.min);\r\n\t        }\r\n\r\n\t        start = log(start, base);\r\n\t        end = log(end, base);\r\n\r\n\t        var p1, p2;\r\n\r\n\t        if (vertical) {\r\n\t            p1 = logMax - Math.max(start, end);\r\n\t            p2 = logMax - Math.min(start, end);\r\n\t        } else {\r\n\t            p1 = Math.min(start, end) - logMin;\r\n\t            p2 = Math.max(start, end) - logMin;\r\n\t        }\r\n\r\n\t        slotBox[valueAxis + 1] = limitCoordinate(lineStart + step * (reverse ? p2 : p1));\r\n\t        slotBox[valueAxis + 2] = limitCoordinate(lineStart + step * (reverse ? p1 : p2));\r\n\r\n\t        return slotBox;\r\n\t    },\r\n\r\n\t    getValue: function(point) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var logMin = ref.logMin;\r\n\t        var logMax = ref.logMax;\r\n\t        var reverse = options.reverse;\r\n\t        var vertical = options.vertical;\r\n\t        var base = options.majorUnit;\r\n\t        var lineBox = this.lineBox();\r\n\t        var dir = vertical === reverse ? 1 : -1;\r\n\t        var startEdge = dir === 1 ? 1 : 2;\r\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\r\n\t        var step = ((logMax - logMin) / lineSize);\r\n\t        var valueAxis = vertical ? Y : X;\r\n\t        var lineStart = lineBox[valueAxis + startEdge];\r\n\t        var offset = dir * (point[valueAxis] - lineStart);\r\n\t        var valueOffset = offset * step;\r\n\r\n\t        if (offset < 0 || offset > lineSize) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        var value = logMin + valueOffset;\r\n\r\n\t        return round(Math.pow(base, value), DEFAULT_PRECISION);\r\n\t    },\r\n\r\n\t    range: function() {\r\n\t        var options = this.options;\r\n\t        return { min: options.min, max: options.max };\r\n\t    },\r\n\r\n\t    scaleRange: function(delta) {\r\n\t        var base = this.options.majorUnit;\r\n\t        var offset = -delta;\r\n\r\n\t        return {\r\n\t            min: Math.pow(base, this.logMin - offset),\r\n\t            max: Math.pow(base, this.logMax + offset)\r\n\t        };\r\n\t    },\r\n\r\n\t    translateRange: function(delta) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var logMin = ref.logMin;\r\n\t        var logMax = ref.logMax;\r\n\t        var reverse = options.reverse;\r\n\t        var vertical = options.vertical;\r\n\t        var base = options.majorUnit;\r\n\t        var lineBox = this.lineBox();\r\n\t        var size = vertical ? lineBox.height() : lineBox.width();\r\n\t        var scale = size / (logMax - logMin);\r\n\t        var offset = round(delta / scale, DEFAULT_PRECISION);\r\n\r\n\t        if ((vertical || reverse) && !(vertical && reverse )) {\r\n\t            offset = -offset;\r\n\t        }\r\n\r\n\t        return {\r\n\t            min: Math.pow(base, logMin + offset),\r\n\t            max: Math.pow(base, logMax + offset)\r\n\t        };\r\n\t    },\r\n\r\n\t    labelsCount: function() {\r\n\t        var floorMax = Math.floor(this.logMax);\r\n\t        var count = Math.floor(floorMax - this.logMin) + 1;\r\n\r\n\t        return count;\r\n\t    },\r\n\r\n\t    getMajorTickPositions: function() {\r\n\t        var ticks = [];\r\n\r\n\t        this.traverseMajorTicksPositions(function (position) {\r\n\t            ticks.push(position);\r\n\t        }, { step: 1, skip: 0 });\r\n\r\n\t        return ticks;\r\n\t    },\r\n\r\n\t    createTicks: function(lineGroup) {\r\n\t        var options = this.options;\r\n\t        var majorTicks = options.majorTicks;\r\n\t        var minorTicks = options.minorTicks;\r\n\t        var vertical = options.vertical;\r\n\t        var mirror = options.labels.mirror;\r\n\t        var lineBox = this.lineBox();\r\n\t        var ticks = [];\r\n\t        var tickLineOptions = {\r\n\t            // TODO\r\n\t            // _alignLines: options._alignLines,\r\n\t            vertical: vertical\r\n\t        };\r\n\r\n\t        function render(tickPosition, tickOptions) {\r\n\t            tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\r\n\t            tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\r\n\t            tickLineOptions.position = tickPosition;\r\n\r\n\t            lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\r\n\t        }\r\n\r\n\t        if (majorTicks.visible) {\r\n\t            this.traverseMajorTicksPositions(render, majorTicks);\r\n\t        }\r\n\r\n\t        if (minorTicks.visible) {\r\n\t            this.traverseMinorTicksPositions(render, minorTicks);\r\n\t        }\r\n\r\n\t        return ticks;\r\n\t    },\r\n\r\n\t    createGridLines: function(altAxis) {\r\n\t        var options = this.options;\r\n\t        var minorGridLines = options.minorGridLines;\r\n\t        var majorGridLines = options.majorGridLines;\r\n\t        var vertical = options.vertical;\r\n\t        var lineBox = altAxis.lineBox();\r\n\t        var lineOptions = {\r\n\t            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\r\n\t            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\r\n\t            vertical: vertical\r\n\t        };\r\n\t        var majorTicks = [];\r\n\r\n\t        var container = this.gridLinesVisual();\r\n\t        function render(tickPosition, gridLine) {\r\n\t            if (!inArray(tickPosition, majorTicks)) {\r\n\t                lineOptions.position = tickPosition;\r\n\t                container.append(createAxisGridLine(lineOptions, gridLine));\r\n\r\n\t                majorTicks.push(tickPosition);\r\n\t            }\r\n\t        }\r\n\r\n\t        if (majorGridLines.visible) {\r\n\t            this.traverseMajorTicksPositions(render, majorGridLines);\r\n\t        }\r\n\r\n\t        if (minorGridLines.visible) {\r\n\t            this.traverseMinorTicksPositions(render, minorGridLines);\r\n\t        }\r\n\r\n\t        return container.children;\r\n\t    },\r\n\r\n\t    traverseMajorTicksPositions: function(callback, tickOptions) {\r\n\t        var ref = this._lineOptions();\r\n\t        var lineStart = ref.lineStart;\r\n\t        var step = ref.step;\r\n\t        var ref$1 = this;\r\n\t        var logMin = ref$1.logMin;\r\n\t        var logMax = ref$1.logMax;\r\n\r\n\t        for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\r\n\t            var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\r\n\t            callback(position, tickOptions);\r\n\t        }\r\n\t    },\r\n\r\n\t    traverseMinorTicksPositions: function(callback, tickOptions) {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this.options;\r\n\t        var min = ref.min;\r\n\t        var max = ref.max;\r\n\t        var minorUnit = ref.minorUnit;\r\n\t        var base = ref.majorUnit;\r\n\t        var ref$1 = this._lineOptions();\r\n\t        var lineStart = ref$1.lineStart;\r\n\t        var step = ref$1.step;\r\n\t        var ref$2 = this;\r\n\t        var logMin = ref$2.logMin;\r\n\t        var logMax = ref$2.logMax;\r\n\t        var start = Math.floor(logMin);\r\n\r\n\t        for (var power = start; power < logMax; power++) {\r\n\t            var minorOptions = this$1._minorIntervalOptions(power);\r\n\t            for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\r\n\t                var value = minorOptions.value + idx * minorOptions.minorStep;\r\n\t                if (value > max) {\r\n\t                    break;\r\n\t                }\r\n\t                if (value >= min) {\r\n\t                    var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\r\n\t                    callback(position, tickOptions);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createAxisLabel: function(index, labelOptions) {\r\n\t        var power = Math.ceil(this.logMin + index);\r\n\t        var value = Math.pow(this.options.majorUnit, power);\r\n\t        var text = this.axisLabelText(value, null, labelOptions);\r\n\r\n\t        return new AxisLabel(value, text, index, null, labelOptions);\r\n\t    },\r\n\r\n\t    shouldRenderNote: function(value) {\r\n\t        var range = this.range();\r\n\t        return range.min <= value && value <= range.max;\r\n\t    },\r\n\r\n\t    pan: function(delta) {\r\n\t        var range = this.translateRange(delta);\r\n\t        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, -delta);\r\n\t    },\r\n\r\n\t    pointsRange: function(start, end) {\r\n\t        var startValue = this.getValue(start);\r\n\t        var endValue = this.getValue(end);\r\n\t        var min = Math.min(startValue, endValue);\r\n\t        var max = Math.max(startValue, endValue);\r\n\r\n\t        return {\r\n\t            min: min,\r\n\t            max: max\r\n\t        };\r\n\t    },\r\n\r\n\t    zoomRange: function(delta) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var totalMin = ref.totalMin;\r\n\t        var totalMax = ref.totalMax;\r\n\t        var newRange = this.scaleRange(delta);\r\n\t        var min = limitValue(newRange.min, totalMin, totalMax);\r\n\t        var max = limitValue(newRange.max, totalMin, totalMax);\r\n\t        var base = options.majorUnit;\r\n\t        var acceptOptionsRange = max > min && options.min && options.max && (round(log(options.max, base) - log(options.min, base), DEFAULT_PRECISION) < 1);\r\n\t        var acceptNewRange = !(options.min === totalMin && options.max === totalMax) && round(log(max, base) - log(min, base), DEFAULT_PRECISION) >= 1;\r\n\r\n\t        if (acceptOptionsRange || acceptNewRange) {\r\n\t            return {\r\n\t                min: min,\r\n\t                max: max\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    _minorIntervalOptions: function(power) {\r\n\t        var ref = this.options;\r\n\t        var minorUnit = ref.minorUnit;\r\n\t        var base = ref.majorUnit;\r\n\t        var value = Math.pow(base, power);\r\n\t        var nextValue = Math.pow(base, power + 1);\r\n\t        var difference = nextValue - value;\r\n\t        var minorStep = difference / minorUnit;\r\n\r\n\t        return {\r\n\t            value: value,\r\n\t            minorStep: minorStep\r\n\t        };\r\n\t    },\r\n\r\n\t    _lineOptions: function() {\r\n\t        var ref = this.options;\r\n\t        var reverse = ref.reverse;\r\n\t        var vertical = ref.vertical;\r\n\t        var valueAxis = vertical ? Y : X;\r\n\t        var lineBox = this.lineBox();\r\n\t        var dir = vertical === reverse ? 1 : -1;\r\n\t        var startEdge = dir === 1 ? 1 : 2;\r\n\t        var lineSize = vertical ? lineBox.height() : lineBox.width();\r\n\t        var step = dir * (lineSize / (this.logMax - this.logMin));\r\n\t        var lineStart = lineBox[valueAxis + startEdge];\r\n\r\n\t        return {\r\n\t            step: step,\r\n\t            lineStart: lineStart,\r\n\t            lineBox: lineBox\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tfunction initRange(autoMin, autoMax, axisOptions, options) {\r\n\t    var min = axisOptions.min;\r\n\t    var max = axisOptions.max;\r\n\r\n\t    if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\r\n\t        throwNegativeValuesError();\r\n\t    }\r\n\r\n\t    if (!defined(options.max)) {\r\n\t        max = autoMax;\r\n\t    } else if (options.max <= 0) {\r\n\t        throwNegativeValuesError();\r\n\t    }\r\n\r\n\t    if (!defined(options.min)) {\r\n\t        min = autoMin;\r\n\t    } else if (options.min <= 0) {\r\n\t        throwNegativeValuesError();\r\n\t    }\r\n\r\n\t    return {\r\n\t        min: min,\r\n\t        max: max\r\n\t    };\r\n\t}\r\n\r\n\tfunction autoAxisMin$1(min, max, options) {\r\n\t    var base = options.majorUnit;\r\n\t    var autoMin = min;\r\n\t    if (min <= 0) {\r\n\t        autoMin = max <= 1 ? Math.pow(base, -2) : 1;\r\n\t    } else if (!options.narrowRange) {\r\n\t        autoMin = Math.pow(base, Math.floor(log(min, base)));\r\n\t    }\r\n\t    return autoMin;\r\n\t}\r\n\r\n\tfunction autoAxisMax$1(max, base) {\r\n\t    var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\r\n\t    var autoMax;\r\n\t    if (max <= 0) {\r\n\t        autoMax = base;\r\n\t    } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\r\n\t        autoMax = Math.pow(base, log(max, base) + 0.2);\r\n\t    } else {\r\n\t        autoMax = Math.pow(base, Math.ceil(log(max, base)));\r\n\t    }\r\n\r\n\t    return autoMax;\r\n\t}\r\n\r\n\tfunction throwNegativeValuesError() {\r\n\t    throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\r\n\t}\r\n\r\n\tfunction log(y, x) {\r\n\t    return Math.log(y) / Math.log(x);\r\n\t}\r\n\r\n\tsetDefaultOptions(LogarithmicAxis, {\r\n\t    type: \"log\",\r\n\t    majorUnit: DEFAULT_MAJOR_UNIT,\r\n\t    minorUnit: 1,\r\n\t    axisCrossingValue: 1,\r\n\t    vertical: true,\r\n\t    majorGridLines: {\r\n\t        visible: true,\r\n\t        width: 1,\r\n\t        color: BLACK\r\n\t    },\r\n\t    zIndex: 1,\r\n\t    _deferLabels: true\r\n\t});\r\n\r\n\tvar GridLinesMixin = {\r\n\t    createGridLines: function(altAxis) {\r\n\t        var options = this.options;\r\n\t        var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);\r\n\t        var gridLines = [];\r\n\t        var skipMajor = false;\r\n\t        var majorAngles, minorAngles;\r\n\r\n\t        if (options.majorGridLines.visible) {\r\n\t            majorAngles = this.majorGridLineAngles(altAxis);\r\n\t            skipMajor = true;\r\n\r\n\t            gridLines = this.renderMajorGridLines(\r\n\t                majorAngles, radius, options.majorGridLines\r\n\t            );\r\n\t        }\r\n\r\n\t        if (options.minorGridLines.visible) {\r\n\t            minorAngles = this.minorGridLineAngles(altAxis, skipMajor);\r\n\r\n\t            append(gridLines, this.renderMinorGridLines(\r\n\t                minorAngles, radius, options.minorGridLines, altAxis, skipMajor\r\n\t            ));\r\n\t        }\r\n\r\n\t        return gridLines;\r\n\t    },\r\n\r\n\t    renderMajorGridLines: function(angles, radius, options) {\r\n\t        return this.renderGridLines(angles, radius, options);\r\n\t    },\r\n\r\n\t    renderMinorGridLines: function(angles, radius, options, altAxis, skipMajor) {\r\n\t        var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);\r\n\t        return this.renderGridLines(angles, radius, options, radiusCallback);\r\n\t    },\r\n\r\n\t    renderGridLines: function(angles, radius, options, radiusCallback) {\r\n\t        var style = {\r\n\t            stroke: {\r\n\t                width: options.width,\r\n\t                color: options.color,\r\n\t                dashType: options.dashType\r\n\t            }\r\n\t        };\r\n\r\n\t        var center = this.box.center();\r\n\t        var circle = new Circle([ center.x, center.y ], radius);\r\n\t        var container = this.gridLinesVisual();\r\n\r\n\t        for (var i = 0; i < angles.length; i++) {\r\n\t            var line = new Path(style);\r\n\t            if (radiusCallback) {\r\n\t                circle.radius = radiusCallback(angles[i]);\r\n\t            }\r\n\r\n\t            line.moveTo(circle.center)\r\n\t                .lineTo(circle.pointAt(angles[i] + 180));\r\n\r\n\t            container.append(line);\r\n\t        }\r\n\r\n\t        return container.children;\r\n\t    },\r\n\r\n\t    gridLineAngles: function(altAxis, size, skip, step, skipAngles) {\r\n\t        var this$1 = this;\r\n\r\n\t        var divs = this.intervals(size, skip, step, skipAngles);\r\n\t        var options = altAxis.options;\r\n\t        var altAxisVisible = options.visible && (options.line || {}).visible !== false;\r\n\r\n\t        return map(divs, function (d) {\r\n\t            var alpha = this$1.intervalAngle(d);\r\n\r\n\t            if (!altAxisVisible || alpha !== 90) {\r\n\t                return alpha;\r\n\t            }\r\n\t        });\r\n\t    }\r\n\t};\r\n\r\n\tvar RadarCategoryAxis = CategoryAxis.extend({\r\n\t    range: function() {\r\n\t        return { min: 0, max: this.options.categories.length };\r\n\t    },\r\n\r\n\t    reflow: function(box) {\r\n\t        this.box = box;\r\n\t        this.reflowLabels();\r\n\t    },\r\n\r\n\t    lineBox: function() {\r\n\t        return this.box;\r\n\t    },\r\n\r\n\t    reflowLabels: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var labels = ref.labels;\r\n\t        var labelOptions = ref.options.labels;\r\n\t        var skip = labelOptions.skip || 0;\r\n\t        var step = labelOptions.step || 1;\r\n\t        var measureBox = new Box();\r\n\r\n\t        for (var i = 0; i < labels.length; i++) {\r\n\t            labels[i].reflow(measureBox);\r\n\t            var labelBox = labels[i].box;\r\n\r\n\t            labels[i].reflow(this$1.getSlot(skip + i * step).adjacentBox(\r\n\t                0, labelBox.width(), labelBox.height()\r\n\t            ));\r\n\t        }\r\n\t    },\r\n\r\n\t    intervals: function(size, skipOption, stepOption, skipAngles) {\r\n\t        if (skipAngles === void 0) { skipAngles = false; }\r\n\r\n\t        var options = this.options;\r\n\t        var categories = options.categories.length;\r\n\t        var divCount = categories / size || 1;\r\n\t        var divAngle = 360 / divCount;\r\n\t        var skip = skipOption || 0;\r\n\t        var step = stepOption || 1;\r\n\t        var divs = [];\r\n\t        var angle = 0;\r\n\r\n\t        for (var i = skip; i < divCount; i += step) {\r\n\t            if (options.reverse) {\r\n\t                angle = 360 - i * divAngle;\r\n\t            } else {\r\n\t                angle = i * divAngle;\r\n\t            }\r\n\r\n\t            angle = round(angle, COORD_PRECISION) % 360;\r\n\r\n\t            if (!(skipAngles && inArray(angle, skipAngles))) {\r\n\t                divs.push(angle);\r\n\t            }\r\n\t        }\r\n\r\n\t        return divs;\r\n\t    },\r\n\r\n\t    majorIntervals: function() {\r\n\t        return this.intervals(1);\r\n\t    },\r\n\r\n\t    minorIntervals: function() {\r\n\t        return this.intervals(0.5);\r\n\t    },\r\n\r\n\t    intervalAngle: function(interval) {\r\n\t        return (360 + interval + this.options.startAngle) % 360;\r\n\t    },\r\n\r\n\t    majorAngles: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        return map(this.majorIntervals(), function (interval) { return this$1.intervalAngle(interval); });\r\n\t    },\r\n\r\n\t    createLine: function() {\r\n\t        return [];\r\n\t    },\r\n\r\n\t    majorGridLineAngles: function(altAxis) {\r\n\t        var majorGridLines = this.options.majorGridLines;\r\n\t        return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);\r\n\t    },\r\n\r\n\t    minorGridLineAngles: function(altAxis, skipMajor) {\r\n\t        var ref = this.options;\r\n\t        var minorGridLines = ref.minorGridLines;\r\n\t        var majorGridLines = ref.majorGridLines;\r\n\t        var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;\r\n\r\n\t        return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\r\n\t    },\r\n\r\n\t    radiusCallback: function(radius, altAxis, skipMajor) {\r\n\t        if (altAxis.options.type !== ARC) {\r\n\t            var minorAngle = rad(360 / (this.options.categories.length * 2));\r\n\t            var minorRadius = Math.cos(minorAngle) * radius;\r\n\t            var majorAngles = this.majorAngles();\r\n\r\n\t            var radiusCallback = function(angle) {\r\n\t                if (!skipMajor && inArray(angle, majorAngles)) {\r\n\t                    return radius;\r\n\t                }\r\n\r\n\t                return minorRadius;\r\n\t            };\r\n\t            return radiusCallback;\r\n\t        }\r\n\t    },\r\n\r\n\t    createPlotBands: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var plotBands = this.options.plotBands || [];\r\n\r\n\t        var group = this._plotbandGroup = new Group({\r\n\t            zIndex: -1\r\n\t        });\r\n\r\n\t        for (var i = 0; i < plotBands.length; i++) {\r\n\t            var band = plotBands[i];\r\n\t            var slot = this$1.plotBandSlot(band);\r\n\t            var singleSlot = this$1.getSlot(band.from);\r\n\r\n\t            var head = band.from - Math.floor(band.from);\r\n\t            slot.startAngle += head * singleSlot.angle;\r\n\r\n\t            var tail = Math.ceil(band.to) - band.to;\r\n\t            slot.angle -= (tail + head) * singleSlot.angle;\r\n\r\n\t            var ring = ShapeBuilder.current.createRing(slot, {\r\n\t                fill: {\r\n\t                    color: band.color,\r\n\t                    opacity: band.opacity\r\n\t                },\r\n\t                stroke: {\r\n\t                    opacity: band.opacity\r\n\t                }\r\n\t            });\r\n\t            group.append(ring);\r\n\t        }\r\n\r\n\t        this.appendVisual(group);\r\n\t    },\r\n\r\n\t    plotBandSlot: function(band) {\r\n\t        return this.getSlot(band.from, band.to - 1);\r\n\t    },\r\n\r\n\t    getSlot: function(from, to) {\r\n\t        var options = this.options;\r\n\t        var justified = options.justified;\r\n\t        var box = this.box;\r\n\t        var divs = this.majorAngles();\r\n\t        var totalDivs = divs.length;\r\n\t        var slotAngle = 360 / totalDivs;\r\n\t        var fromValue = from;\r\n\r\n\t        if (options.reverse && !justified) {\r\n\t            fromValue = (fromValue + 1) % totalDivs;\r\n\t        }\r\n\r\n\t        fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);\r\n\t        var slotStart = divs[fromValue];\r\n\r\n\t        if (justified) {\r\n\t            slotStart = slotStart - slotAngle / 2;\r\n\r\n\t            if (slotStart < 0) {\r\n\t                slotStart += 360;\r\n\t            }\r\n\t        }\r\n\r\n\t        var toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);\r\n\t        var slots = toValue - fromValue + 1;\r\n\t        var angle = slotAngle * slots;\r\n\r\n\t        return new Ring(box.center(), 0, box.height() / 2, slotStart, angle);\r\n\t    },\r\n\r\n\t    slot: function(from, to) {\r\n\t        var slot = this.getSlot(from, to);\r\n\t        var startAngle = slot.startAngle + 180;\r\n\t        var endAngle = startAngle + slot.angle;\r\n\r\n\t        return new geometry.Arc([ slot.center.x, slot.center.y ], {\r\n\t            startAngle: startAngle,\r\n\t            endAngle: endAngle,\r\n\t            radiusX: slot.radius,\r\n\t            radiusY: slot.radius\r\n\t        });\r\n\t    },\r\n\r\n\t    pointCategoryIndex: function(point) {\r\n\t        var this$1 = this;\r\n\r\n\t        var length = this.options.categories.length;\r\n\t        var index = null;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var slot = this$1.getSlot(i);\r\n\t            if (slot.containsPoint(point)) {\r\n\t                index = i;\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        return index;\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(RadarCategoryAxis, {\r\n\t    startAngle: 90,\r\n\t    labels: {\r\n\t        margin: getSpacing(10)\r\n\t    },\r\n\t    majorGridLines: {\r\n\t        visible: true\r\n\t    },\r\n\t    justified: true\r\n\t});\r\n\tdeepExtend(RadarCategoryAxis.prototype, GridLinesMixin);\r\n\r\n\tvar PolarAxis = Axis.extend({\r\n\t    init: function(options, chartService) {\r\n\t        Axis.fn.init.call(this, options, chartService);\r\n\r\n\t        var instanceOptions = this.options;\r\n\r\n\t        instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;\r\n\t    },\r\n\r\n\t    getDivisions: function(stepValue) {\r\n\t        return NumericAxis.prototype.getDivisions.call(this, stepValue) - 1;\r\n\t    },\r\n\r\n\t    reflow: function(box) {\r\n\t        this.box = box;\r\n\t        this.reflowLabels();\r\n\t    },\r\n\r\n\t    reflowLabels: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var labels = ref.labels;\r\n\t        var labelOptions = ref.options.labels;\r\n\t        var skip = labelOptions.skip || 0;\r\n\t        var step = labelOptions.step || 1;\r\n\r\n\t        var measureBox = new Box();\r\n\t        var divs = this.intervals(options.majorUnit, skip, step);\r\n\r\n\t        for (var i = 0; i < labels.length; i++) {\r\n\t            labels[i].reflow(measureBox);\r\n\t            var labelBox = labels[i].box;\r\n\r\n\t            labels[i].reflow(this$1.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));\r\n\t        }\r\n\t    },\r\n\r\n\t    lineBox: function() {\r\n\t        return this.box;\r\n\t    },\r\n\r\n\t    intervals: function(size, skipOption, stepOption, skipAngles) {\r\n\t        if (skipAngles === void 0) { skipAngles = false; }\r\n\r\n\t        var min = this.options.min;\r\n\t        var divisions = this.getDivisions(size);\r\n\t        var divs = [];\r\n\t        var skip = skipOption || 0;\r\n\t        var step = stepOption || 1;\r\n\r\n\t        for (var i = skip; i < divisions; i += step) {\r\n\t            var current = (360 + min + i * size) % 360;\r\n\t            if (!(skipAngles && inArray(current, skipAngles))) {\r\n\t                divs.push(current);\r\n\t            }\r\n\t        }\r\n\r\n\t        return divs;\r\n\t    },\r\n\r\n\t    majorIntervals: function() {\r\n\t        return this.intervals(this.options.majorUnit);\r\n\t    },\r\n\r\n\t    minorIntervals: function() {\r\n\t        return this.intervals(this.options.minorUnit);\r\n\t    },\r\n\r\n\t    intervalAngle: function(i) {\r\n\t        return (540 - i - this.options.startAngle) % 360;\r\n\t    },\r\n\r\n\t    createLine: function() {\r\n\t        return [];\r\n\t    },\r\n\r\n\t    majorGridLineAngles: function(altAxis) {\r\n\t        var majorGridLines = this.options.majorGridLines;\r\n\t        return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);\r\n\t    },\r\n\r\n\t    minorGridLineAngles: function(altAxis, skipMajor) {\r\n\t        var options = this.options;\r\n\t        var minorGridLines = options.minorGridLines;\r\n\t        var majorGridLines = options.majorGridLines;\r\n\t        var majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;\r\n\r\n\t        return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);\r\n\t    },\r\n\r\n\t    plotBandSlot: function(band) {\r\n\t        return this.getSlot(band.from, band.to);\r\n\t    },\r\n\r\n\t    getSlot: function(a, b) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var box = ref.box;\r\n\t        var startAngle = options.startAngle;\r\n\t        var start = limitValue(a, options.min, options.max);\r\n\t        var end = limitValue(b || start, start, options.max);\r\n\r\n\t        if (options.reverse) {\r\n\t            start *= -1;\r\n\t            end *= -1;\r\n\t        }\r\n\r\n\t        start = (540 - start - startAngle) % 360;\r\n\t        end = (540 - end - startAngle) % 360;\r\n\r\n\t        if (end < start) {\r\n\t            var tmp = start;\r\n\t            start = end;\r\n\t            end = tmp;\r\n\t        }\r\n\r\n\t        return new Ring(box.center(), 0, box.height() / 2, start, end - start);\r\n\t    },\r\n\r\n\t    slot: function(from, to) {\r\n\t        if (to === void 0) { to = from; }\r\n\r\n\t        var options = this.options;\r\n\t        var start = 360 - options.startAngle;\r\n\t        var slot = this.getSlot(from, to);\r\n\t        var min = Math.min(from, to);\r\n\t        var max = Math.max(from, to);\r\n\t        var startAngle, endAngle;\r\n\r\n\t        if (options.reverse) {\r\n\t            startAngle = min;\r\n\t            endAngle = max;\r\n\t        } else {\r\n\t            startAngle = 360 - max;\r\n\t            endAngle = 360 - min;\r\n\t        }\r\n\r\n\t        startAngle = (startAngle + start) % 360;\r\n\t        endAngle = (endAngle + start) % 360;\r\n\r\n\t        return new geometry.Arc([ slot.center.x, slot.center.y ], {\r\n\t            startAngle: startAngle,\r\n\t            endAngle: endAngle,\r\n\t            radiusX: slot.radius,\r\n\t            radiusY: slot.radius\r\n\t        });\r\n\t    },\r\n\r\n\t    getValue: function(point) {\r\n\t        var options = this.options;\r\n\t        var center = this.box.center();\r\n\t        var dx = point.x - center.x;\r\n\t        var dy = point.y - center.y;\r\n\t        var theta = Math.round(deg(Math.atan2(dy, dx)));\r\n\t        var start = options.startAngle;\r\n\r\n\t        if (!options.reverse) {\r\n\t            theta *= -1;\r\n\t            start *= -1;\r\n\t        }\r\n\r\n\t        return (theta + start + 360) % 360;\r\n\t    },\r\n\r\n\t    valueRange: function() {\r\n\t        return {\r\n\t            min: 0,\r\n\t            max: Math.PI * 2\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(PolarAxis, {\r\n\t    type: \"polar\",\r\n\t    startAngle: 0,\r\n\t    reverse: false,\r\n\t    majorUnit: 60,\r\n\t    min: 0,\r\n\t    max: 360,\r\n\t    labels: {\r\n\t        margin: getSpacing(10)\r\n\t    },\r\n\t    majorGridLines: {\r\n\t        color: BLACK,\r\n\t        visible: true,\r\n\t        width: 1\r\n\t    },\r\n\t    minorGridLines: {\r\n\t        color: \"#aaa\"\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(PolarAxis.prototype, GridLinesMixin, {\r\n\t    createPlotBands: RadarCategoryAxis.prototype.createPlotBands,\r\n\t    majorAngles: RadarCategoryAxis.prototype.majorAngles,\r\n\t    range: NumericAxis.prototype.range,\r\n\t    labelsCount: NumericAxis.prototype.labelsCount,\r\n\t    createAxisLabel: NumericAxis.prototype.createAxisLabel\r\n\t});\r\n\r\n\tvar RadarNumericAxisMixin = {\r\n\t    options: {\r\n\t        majorGridLines: {\r\n\t            visible: true\r\n\t        }\r\n\t    },\r\n\r\n\t    createPlotBands: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this.options;\r\n\t        var type = ref.majorGridLines.type;\r\n\t        var plotBands = ref.plotBands; if (plotBands === void 0) { plotBands = []; }\r\n\t        var altAxis = this.plotArea.polarAxis;\r\n\t        var majorAngles = altAxis.majorAngles();\r\n\t        var center = altAxis.box.center();\r\n\t        var group = this._plotbandGroup = new Group({\r\n\t            zIndex: -1\r\n\t        });\r\n\r\n\t        for (var i = 0; i < plotBands.length; i++) {\r\n\t            var band = plotBands[i];\r\n\t            var bandStyle = {\r\n\t                fill: {\r\n\t                    color: band.color,\r\n\t                    opacity: band.opacity\r\n\t                },\r\n\t                stroke: {\r\n\t                    opacity: band.opacity\r\n\t                }\r\n\t            };\r\n\r\n\t            var slot = this$1.getSlot(band.from, band.to, true);\r\n\t            var ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\r\n\r\n\t            var shape = (void 0);\r\n\t            if (type === ARC) {\r\n\t                shape = ShapeBuilder.current.createRing(ring, bandStyle);\r\n\t            } else {\r\n\t                shape = Path.fromPoints(this$1.plotBandPoints(ring, majorAngles), bandStyle).close();\r\n\t            }\r\n\r\n\t            group.append(shape);\r\n\t        }\r\n\r\n\t        this.appendVisual(group);\r\n\t    },\r\n\r\n\t    plotBandPoints: function(ring, angles) {\r\n\t        var innerPoints = [];\r\n\t        var outerPoints = [];\r\n\t        var center = [ ring.center.x, ring.center.y ];\r\n\t        var innerCircle = new Circle(center, ring.innerRadius);\r\n\t        var outerCircle = new Circle(center, ring.radius);\r\n\r\n\t        for (var i = 0; i < angles.length; i++) {\r\n\t            innerPoints.push(innerCircle.pointAt(angles[i] + 180));\r\n\t            outerPoints.push(outerCircle.pointAt(angles[i] + 180));\r\n\t        }\r\n\r\n\t        innerPoints.reverse();\r\n\t        innerPoints.push(innerPoints[0]);\r\n\t        outerPoints.push(outerPoints[0]);\r\n\r\n\t        return outerPoints.concat(innerPoints);\r\n\t    },\r\n\r\n\t    createGridLines: function(altAxis) {\r\n\t        var options = this.options;\r\n\t        var majorTicks = this.radarMajorGridLinePositions();\r\n\t        var majorAngles = altAxis.majorAngles();\r\n\t        var center = altAxis.box.center();\r\n\t        var gridLines = [];\r\n\r\n\t        if (options.majorGridLines.visible) {\r\n\t            gridLines = this.renderGridLines(\r\n\t                center, majorTicks, majorAngles, options.majorGridLines\r\n\t            );\r\n\t        }\r\n\r\n\t        if (options.minorGridLines.visible) {\r\n\t            var minorTicks = this.radarMinorGridLinePositions();\r\n\t            append(gridLines, this.renderGridLines(\r\n\t                center, minorTicks, majorAngles, options.minorGridLines\r\n\t            ));\r\n\t        }\r\n\r\n\t        return gridLines;\r\n\t    },\r\n\r\n\t    renderGridLines: function(center, ticks, angles, options) {\r\n\t        var style = {\r\n\t            stroke: {\r\n\t                width: options.width,\r\n\t                color: options.color,\r\n\t                dashType: options.dashType\r\n\t            }\r\n\t        };\r\n\t        var skip = options.skip; if (skip === void 0) { skip = 0; }\r\n\t        var step = options.step; if (step === void 0) { step = 0; }\r\n\t        var container = this.gridLinesVisual();\r\n\r\n\t        for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {\r\n\t            var tickRadius = center.y - ticks[tickIx];\r\n\t            if (tickRadius > 0) {\r\n\t                var circle = new Circle([ center.x, center.y ], tickRadius);\r\n\t                if (options.type === ARC) {\r\n\t                    container.append(new drawing.Circle(circle, style));\r\n\t                } else {\r\n\t                    var line = new Path(style);\r\n\t                    for (var angleIx = 0; angleIx < angles.length; angleIx++) {\r\n\t                        line.lineTo(circle.pointAt(angles[angleIx] + 180));\r\n\t                    }\r\n\r\n\t                    line.close();\r\n\t                    container.append(line);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return container.children;\r\n\t    },\r\n\r\n\t    getValue: function(point) {\r\n\t        var lineBox = this.lineBox();\r\n\t        var altAxis = this.plotArea.polarAxis;\r\n\t        var majorAngles = altAxis.majorAngles();\r\n\t        var center = altAxis.box.center();\r\n\t        var radius = point.distanceTo(center);\r\n\t        var distance = radius;\r\n\r\n\t        if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\r\n\t            var dx = point.x - center.x;\r\n\t            var dy = point.y - center.y;\r\n\t            var theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\r\n\r\n\t            majorAngles.sort(function(a, b) {\r\n\t                return angularDistance(a, theta) - angularDistance(b, theta);\r\n\t            });\r\n\r\n\t            // Solve triangle (center, point, axis X) using one side (radius) and two angles.\r\n\t            // Angles are derived from triangle (center, point, gridline X)\r\n\t            var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\r\n\t            var alpha = angularDistance(theta, majorAngles[0]);\r\n\t            var gamma = 90 - midAngle;\r\n\t            var beta = 180 - alpha - gamma;\r\n\r\n\t            distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\r\n\t        }\r\n\r\n\t        return this.axisType().prototype.getValue.call(\r\n\t            this, new Point(lineBox.x1, lineBox.y2 - distance)\r\n\t        );\r\n\t    }\r\n\t};\r\n\r\n\tfunction angularDistance(a, b) {\r\n\t    return 180 - Math.abs(Math.abs(a - b) - 180);\r\n\t}\r\n\r\n\tvar RadarNumericAxis = NumericAxis.extend({\r\n\t    radarMajorGridLinePositions: function() {\r\n\t        return this.getTickPositions(this.options.majorUnit);\r\n\t    },\r\n\r\n\t    radarMinorGridLinePositions: function() {\r\n\t        var options = this.options;\r\n\t        var minorSkipStep = 0;\r\n\r\n\t        if (options.majorGridLines.visible) {\r\n\t            minorSkipStep = options.majorUnit;\r\n\t        }\r\n\t        return this.getTickPositions(options.minorUnit, minorSkipStep);\r\n\t    },\r\n\r\n\t    axisType: function() {\r\n\t        return NumericAxis;\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(RadarNumericAxis.prototype, RadarNumericAxisMixin);\r\n\r\n\tvar RadarLogarithmicAxis = LogarithmicAxis.extend({\r\n\t    radarMajorGridLinePositions: function() {\r\n\t        var positions = [];\r\n\r\n\t        this.traverseMajorTicksPositions(function(position) {\r\n\t            positions.push(position);\r\n\t        }, this.options.majorGridLines);\r\n\r\n\t        return positions;\r\n\t    },\r\n\r\n\t    radarMinorGridLinePositions: function() {\r\n\t        var positions = [];\r\n\r\n\t        this.traverseMinorTicksPositions(function(position) {\r\n\t            positions.push(position);\r\n\t        }, this.options.minorGridLines);\r\n\r\n\t        return positions;\r\n\t    },\r\n\r\n\t    axisType: function() {\r\n\t        return LogarithmicAxis;\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(RadarLogarithmicAxis.prototype, RadarNumericAxisMixin);\r\n\r\n\tvar WEIGHT = 0.333;\r\n\tvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\r\n\r\n\tvar CurveProcessor = Class.extend({\r\n\t    init: function(closed) {\r\n\r\n\t        this.closed = closed;\r\n\t    },\r\n\r\n\t    process: function(dataPoints) {\r\n\t        var this$1 = this;\r\n\r\n\t        var points = dataPoints.slice(0);\r\n\t        var segments = [];\r\n\t        var closed = this.closed;\r\n\t        var length = points.length;\r\n\r\n\t        if (length > 2) {\r\n\t            this.removeDuplicates(0, points);\r\n\t            length = points.length;\r\n\t        }\r\n\r\n\t        if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\r\n\t            return segments;\r\n\t        }\r\n\r\n\t        var p0 = points[0];\r\n\t        var p1 = points[1];\r\n\t        var p2 = points[2];\r\n\r\n\t        segments.push(new Segment(p0));\r\n\r\n\t        while (p0.equals(points[length - 1])) {\r\n\t            closed = true;\r\n\t            points.pop();\r\n\t            length--;\r\n\t        }\r\n\r\n\t        if (length === 2) {\r\n\t            var tangent = this.tangent(p0,p1, X, Y);\r\n\r\n\t            last(segments).controlOut(\r\n\t                this.firstControlPoint(tangent, p0, p1, X, Y)\r\n\t            );\r\n\r\n\t            segments.push(new Segment(\r\n\t                p1,\r\n\t                this.secondControlPoint(tangent, p0, p1, X, Y)\r\n\t            ));\r\n\r\n\t            return segments;\r\n\t        }\r\n\r\n\t        var initialControlPoint, lastControlPoint;\r\n\r\n\t        if (closed) {\r\n\t            p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\r\n\t            var controlPoints = this.controlPoints(p0, p1, p2);\r\n\t            initialControlPoint = controlPoints[1];\r\n\t            lastControlPoint = controlPoints[0];\r\n\t        } else {\r\n\t            var tangent$1 = this.tangent(p0, p1, X,Y);\r\n\t            initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);\r\n\t        }\r\n\r\n\t        var cp0 = initialControlPoint;\r\n\t        for (var idx = 0; idx <= length - 3; idx++) {\r\n\t            this$1.removeDuplicates(idx, points);\r\n\t            length = points.length;\r\n\t            if (idx + 3 <= length) {\r\n\t                p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\r\n\t                var controlPoints$1 = this$1.controlPoints(p0,p1,p2);\r\n\r\n\t                last(segments).controlOut(cp0);\r\n\t                cp0 = controlPoints$1[1];\r\n\r\n\t                var cp1 = controlPoints$1[0];\r\n\t                segments.push(new Segment(p1, cp1));\r\n\t            }\r\n\t        }\r\n\r\n\t        if (closed) {\r\n\t            p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\r\n\t            var controlPoints$2 = this.controlPoints(p0, p1, p2);\r\n\r\n\t            last(segments).controlOut(cp0);\r\n\t            segments.push(new Segment(\r\n\t                p1,\r\n\t                controlPoints$2[0]\r\n\t            ));\r\n\r\n\t            last(segments).controlOut(controlPoints$2[1]);\r\n\t            segments.push(new Segment(\r\n\t                p2,\r\n\t                lastControlPoint\r\n\t            ));\r\n\t        } else {\r\n\t            var tangent$2 = this.tangent(p1, p2, X, Y);\r\n\r\n\t            last(segments).controlOut(cp0);\r\n\t            segments.push(new Segment(\r\n\t                p2,\r\n\t                this.secondControlPoint(tangent$2, p1, p2, X, Y)\r\n\t            ));\r\n\t        }\r\n\r\n\t        return segments;\r\n\t    },\r\n\r\n\t    removeDuplicates: function(idx, points) {\r\n\t        while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\r\n\t            points.splice(idx + 1, 1);\r\n\t        }\r\n\t    },\r\n\r\n\t    invertAxis: function(p0, p1, p2) {\r\n\t        var invertAxis = false;\r\n\r\n\t        if (p0.x === p1.x) {\r\n\t            invertAxis = true;\r\n\t        } else if (p1.x === p2.x) {\r\n\t            if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\r\n\t                invertAxis = true;\r\n\t            }\r\n\t        } else {\r\n\t            var fn = this.lineFunction(p0,p1);\r\n\t            var y2 = this.calculateFunction(fn, p2.x);\r\n\t            if (!(p0.y <= p1.y && p2.y <= y2) &&\r\n\t                !(p1.y <= p0.y && p2.y >= y2)) {\r\n\t                invertAxis = true;\r\n\t            }\r\n\t        }\r\n\r\n\t        return invertAxis;\r\n\t    },\r\n\r\n\t    isLine: function(p0, p1, p2) {\r\n\t        var fn = this.lineFunction(p0, p1);\r\n\t        var y2 = this.calculateFunction(fn, p2.x);\r\n\r\n\t        return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\r\n\t    },\r\n\r\n\t    lineFunction: function(p1, p2) {\r\n\t        var a = (p2.y - p1.y) / (p2.x - p1.x);\r\n\t        var b = p1.y - a * p1.x;\r\n\r\n\t        return [ b, a ];\r\n\t    },\r\n\r\n\t    controlPoints: function(p0, p1, p2) {\r\n\t        var xField = X;\r\n\t        var yField = Y;\r\n\t        var restrict = false;\r\n\t        var switchOrientation = false;\r\n\t        var tangent;\r\n\r\n\t        if (this.isLine(p0, p1, p2)) {\r\n\t            tangent = this.tangent(p0, p1, X, Y);\r\n\t        } else {\r\n\t            var monotonic = {\r\n\t                x: this.isMonotonicByField(p0, p1, p2, X),\r\n\t                y: this.isMonotonicByField(p0, p1, p2, Y)\r\n\t            };\r\n\r\n\t            if (monotonic.x && monotonic.y) {\r\n\t                tangent = this.tangent(p0, p2, X, Y);\r\n\t                restrict = true;\r\n\t            } else {\r\n\t                if (this.invertAxis(p0, p1, p2)) {\r\n\t                    xField = Y;\r\n\t                    yField = X;\r\n\t                }\r\n\r\n\t                if (monotonic[xField]) {\r\n\t                    tangent = 0;\r\n\t                } else {\r\n\t                    var sign;\r\n\t                    if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\r\n\t                        (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\r\n\t                        sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\r\n\t                    } else {\r\n\t                        sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\r\n\t                    }\r\n\r\n\t                    tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\r\n\t                    switchOrientation = true;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        var secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\r\n\r\n\t        if (switchOrientation) {\r\n\t            var oldXField = xField;\r\n\t            xField = yField;\r\n\t            yField = oldXField;\r\n\t        }\r\n\r\n\t        var firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\r\n\r\n\t        if (restrict) {\r\n\t            this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\r\n\t            this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\r\n\t        }\r\n\r\n\t        return [ secondControlPoint, firstControlPoint ];\r\n\t    },\r\n\r\n\t    restrictControlPoint: function(p1, p2, cp, tangent) {\r\n\t        if (p1.y < p2.y) {\r\n\t            if (p2.y < cp.y) {\r\n\t                cp.x = p1.x + (p2.y - p1.y) / tangent;\r\n\t                cp.y = p2.y;\r\n\t            } else if (cp.y < p1.y) {\r\n\t                cp.x = p2.x - (p2.y - p1.y) / tangent;\r\n\t                cp.y = p1.y;\r\n\t            }\r\n\t        } else {\r\n\t            if (cp.y < p2.y) {\r\n\t                cp.x = p1.x - (p1.y - p2.y) / tangent;\r\n\t                cp.y = p2.y;\r\n\t            } else if (p1.y < cp.y) {\r\n\t                cp.x = p2.x + (p1.y - p2.y) / tangent;\r\n\t                cp.y = p1.y;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    tangent: function(p0, p1, xField, yField) {\r\n\t        var x = p1[xField] - p0[xField];\r\n\t        var y = p1[yField] - p0[yField];\r\n\t        var tangent;\r\n\r\n\t        if (x === 0) {\r\n\t            tangent = 0;\r\n\t        } else {\r\n\t            tangent = y / x;\r\n\t        }\r\n\r\n\t        return tangent;\r\n\t    },\r\n\r\n\t    isMonotonicByField: function(p0, p1, p2, field) {\r\n\t        return (p2[field] > p1[field] && p1[field] > p0[field]) ||\r\n\t                    (p2[field] < p1[field] && p1[field] < p0[field]);\r\n\t    },\r\n\r\n\t    firstControlPoint: function(tangent, p0, p3, xField, yField) {\r\n\t        var t1 = p0[xField];\r\n\t        var t2 = p3[xField];\r\n\t        var distance = (t2 - t1) * WEIGHT;\r\n\r\n\t        return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\r\n\t    },\r\n\r\n\t    secondControlPoint: function(tangent, p0, p3, xField, yField) {\r\n\t        var t1 = p0[xField];\r\n\t        var t2 = p3[xField];\r\n\t        var distance = (t2 - t1) * WEIGHT;\r\n\r\n\t        return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\r\n\t    },\r\n\r\n\t    point: function(xValue, yValue, xField, yField) {\r\n\t        var controlPoint = new geometry.Point();\r\n\t        controlPoint[xField] = xValue;\r\n\t        controlPoint[yField] = yValue;\r\n\r\n\t        return controlPoint;\r\n\t    },\r\n\r\n\t    calculateFunction: function(fn, x) {\r\n\t        var length = fn.length;\r\n\t        var result = 0;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            result += Math.pow(x,i) * fn[i];\r\n\t        }\r\n\t        return result;\r\n\t    }\r\n\t});\r\n\r\n\tfunction numberSign(value) {\r\n\t    return value <= 0 ? -1 : 1;\r\n\t}\r\n\r\n\tdataviz.Gradients = GRADIENTS;\r\n\r\n\tkendo.deepExtend(kendo.dataviz, {\r\n\t    constants: constants,\r\n\t    services: services,\r\n\t    autoMajorUnit: autoMajorUnit,\r\n\t    Point: Point,\r\n\t    Box: Box,\r\n\t    Ring: Ring,\r\n\t    Sector: Sector,\r\n\t    ShapeBuilder: ShapeBuilder,\r\n\t    ShapeElement: ShapeElement,\r\n\t    ChartElement: ChartElement,\r\n\t    BoxElement: BoxElement,\r\n\t    RootElement: RootElement,\r\n\t    FloatElement: FloatElement,\r\n\t    Text: Text,\r\n\t    TextBox: TextBox,\r\n\t    Title: Title,\r\n\t    AxisLabel: AxisLabel,\r\n\t    Axis: Axis,\r\n\t    Note: Note,\r\n\t    CategoryAxis: CategoryAxis,\r\n\t    DateCategoryAxis: DateCategoryAxis,\r\n\t    DateValueAxis: DateValueAxis,\r\n\t    NumericAxis: NumericAxis,\r\n\t    LogarithmicAxis: LogarithmicAxis,\r\n\t    PolarAxis: PolarAxis,\r\n\t    RadarCategoryAxis: RadarCategoryAxis,\r\n\t    RadarNumericAxis: RadarNumericAxis,\r\n\t    RadarLogarithmicAxis: RadarLogarithmicAxis,\r\n\t    CurveProcessor: CurveProcessor,\r\n\t    rectToBox: rectToBox,\r\n\t    addClass: addClass,\r\n\t    removeClass: removeClass,\r\n\t    alignPathToPixel: alignPathToPixel,\r\n\t    clockwise: clockwise,\r\n\t    convertableToNumber: convertableToNumber,\r\n\t    deepExtend: deepExtend,\r\n\t    elementStyles: elementStyles,\r\n\t    getSpacing: getSpacing,\r\n\t    getTemplate: getTemplate,\r\n\t    getter: __common_getter_js,\r\n\t    grep: grep,\r\n\t    hasClasses: hasClasses,\r\n\t    inArray: inArray,\r\n\t    interpolateValue: interpolateValue,\r\n\t    InstanceObserver: InstanceObserver,\r\n\t    isArray: isArray,\r\n\t    isFunction: isFunction,\r\n\t    isNumber: isNumber,\r\n\t    isObject: isObject,\r\n\t    isString: isString,\r\n\t    map: map,\r\n\t    mousewheelDelta: mousewheelDelta,\r\n\t    FontLoader: FontLoader,\r\n\t    setDefaultOptions: setDefaultOptions,\r\n\t    sparseArrayLimits: sparseArrayLimits,\r\n\t    styleValue: styleValue,\r\n\t    append: append,\r\n\t    bindEvents: bindEvents,\r\n\t    Class: Class,\r\n\t    defined: defined,\r\n\t    deg: deg,\r\n\t    elementOffset: elementOffset,\r\n\t    elementSize: elementSize,\r\n\t    eventElement: eventElement,\r\n\t    eventCoordinates: eventCoordinates,\r\n\t    last: last,\r\n\t    limitValue: limitValue,\r\n\t    logToConsole: kendo.logToConsole,\r\n\t    objectKey: objectKey,\r\n\t    rad: rad,\r\n\t    round: round,\r\n\t    unbindEvents: unbindEvents,\r\n\t    valueOrDefault: valueOrDefault,\r\n\t    absoluteDateDiff: absoluteDateDiff,\r\n\t    addDuration: addDuration,\r\n\t    addTicks: addTicks,\r\n\t    ceilDate: ceilDate,\r\n\t    dateComparer: dateComparer,\r\n\t    dateDiff: dateDiff,\r\n\t    dateEquals: dateEquals,\r\n\t    dateIndex: dateIndex,\r\n\t    duration: duration,\r\n\t    floorDate: floorDate,\r\n\t    lteDateIndex: lteDateIndex,\r\n\t    startOfWeek: startOfWeek,\r\n\t    toDate: toDate,\r\n\t    parseDate: parseDate,\r\n\t    parseDates: parseDates,\r\n\t    toTime: toTime\r\n\t});\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/dataviz/core/kendo-core.js\n// module id = 469\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1089);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1041:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo.dataviz.core\");\n\n/***/ }),\n\n/***/ 1089:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n\t        __webpack_require__(1041),\r\n\t        __webpack_require__(1090),\r\n\t        __webpack_require__(1091),\r\n\t        __webpack_require__(1092)\r\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"dataviz.themes\",\r\n\t    name: \"Themes\",\r\n\t    description: \"Built-in themes for the DataViz widgets\",\r\n\t    category: \"dataviz\",\r\n\t    depends: [ \"dataviz.core\" ],\r\n\t    hidden: true\r\n\t};\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ }),\n\n/***/ 1090:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./dataviz/themes/chart-base-theme\");\n\n/***/ }),\n\n/***/ 1091:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./dataviz/themes/auto-theme\");\n\n/***/ }),\n\n/***/ 1092:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./dataviz/themes/themes\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.dataviz.themes.js\n// module id = 470\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(906);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 850:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.dataviz.core\");\n\n/***/ }),\n\n/***/ 906:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t     !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(850) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function () {\r\n\r\n\twindow.kendo.dataviz = window.kendo.dataviz || {};\r\n\r\n\tvar BAR_GAP = 1.5;\r\n\tvar BAR_SPACING = 0.4;\r\n\tvar BLACK = '#000';\r\n\tvar SANS = 'Arial, Helvetica, sans-serif';\r\n\tvar SANS11 = \"11px \" + SANS;\r\n\tvar SANS12 = '12px ' + SANS;\r\n\tvar SANS16 = '16px ' + SANS;\r\n\tvar TRANSPARENT = 'transparent';\r\n\tvar WHITE = '#fff';\r\n\r\n\tvar notes = function () { return ({\r\n\t    icon: {\r\n\t        border: {\r\n\t            width: 1\r\n\t        }\r\n\t    },\r\n\t    label: {\r\n\t        font: SANS12,\r\n\t        padding: 3\r\n\t    },\r\n\t    line: {\r\n\t        length: 10,\r\n\t        width: 2\r\n\t    },\r\n\t    visible: true\r\n\t}); };\r\n\r\n\tvar axisDefaults = function () { return ({\r\n\t    labels: {\r\n\t        font: SANS12\r\n\t    },\r\n\t    notes: notes(),\r\n\t    title: {\r\n\t        font: SANS16,\r\n\t        margin: 5\r\n\t    }\r\n\t}); };\r\n\r\n\tvar areaSeries = function () { return ({\r\n\t    highlight: {\r\n\t        markers: {\r\n\t            border: {}\r\n\t        }\r\n\t    },\r\n\t    line: {\r\n\t        opacity: 1,\r\n\t        width: 0\r\n\t    },\r\n\t    markers: {\r\n\t        size: 6,\r\n\t        visible: false\r\n\t    },\r\n\t    opacity: 0.4\r\n\t}); };\r\n\r\n\tvar rangeAreaSeries = function () { return ({\r\n\t    highlight: {\r\n\t        markers: {\r\n\t            border: {}\r\n\t        }\r\n\t    },\r\n\t    line: {\r\n\t        opacity: 1,\r\n\t        width: 0\r\n\t    },\r\n\t    markers: {\r\n\t        size: 6,\r\n\t        visible: false\r\n\t    },\r\n\t    opacity: 0.4\r\n\t}); };\r\n\r\n\tvar barSeries = function () { return ({\r\n\t    gap: BAR_GAP,\r\n\t    spacing: BAR_SPACING\r\n\t}); };\r\n\r\n\tvar boxPlotSeries = function () { return ({\r\n\t    outliersField: \"\",\r\n\t    meanField: \"\",\r\n\t    border: {\r\n\t        _brightness: 0.8,\r\n\t        width: 1\r\n\t    },\r\n\t    downColor: WHITE,\r\n\t    gap: 1,\r\n\t    highlight: {\r\n\t        border: {\r\n\t            opacity: 1,\r\n\t            width: 2\r\n\t        },\r\n\t        whiskers: {\r\n\t            width: 3\r\n\t        },\r\n\t        mean: {\r\n\t            width: 2\r\n\t        },\r\n\t        median: {\r\n\t            width: 2\r\n\t        }\r\n\t    },\r\n\t    mean: {\r\n\t        width: 2\r\n\t    },\r\n\t    median: {\r\n\t        width: 2\r\n\t    },\r\n\t    spacing: 0.3,\r\n\t    whiskers: {\r\n\t        width: 2\r\n\t    }\r\n\t}); };\r\n\r\n\tvar bubbleSeries = function () { return ({\r\n\t    border: {\r\n\t        width: 0\r\n\t    },\r\n\t    labels: {\r\n\t        background: TRANSPARENT\r\n\t    },\r\n\t    opacity: 0.6\r\n\t}); };\r\n\r\n\tvar bulletSeries = function () { return ({\r\n\t    gap: BAR_GAP,\r\n\t    spacing: BAR_SPACING,\r\n\t    target: {\r\n\t        color: \"#ff0000\"\r\n\t    }\r\n\t}); };\r\n\r\n\tvar candlestickSeries = function () { return ({\r\n\t    border: {\r\n\t        _brightness: 0.8,\r\n\t        width: 1\r\n\t    },\r\n\t    downColor: WHITE,\r\n\t    gap: 1,\r\n\t    highlight: {\r\n\t        border: {\r\n\t            opacity: 1,\r\n\t            width: 2\r\n\t        },\r\n\t        line: {\r\n\t            width: 2\r\n\t        }\r\n\t    },\r\n\t    line: {\r\n\t        color: BLACK,\r\n\t        width: 1\r\n\t    },\r\n\t    spacing: 0.3\r\n\t}); };\r\n\r\n\tvar columnSeries = function () { return ({\r\n\t    gap: BAR_GAP,\r\n\t    spacing: BAR_SPACING\r\n\t}); };\r\n\r\n\tvar donutSeries = function () { return ({\r\n\t    margin: 1\r\n\t}); };\r\n\r\n\tvar lineSeries = function () { return ({\r\n\t    width: 2\r\n\t}); };\r\n\r\n\tvar ohlcSeries = function () { return ({\r\n\t    gap: 1,\r\n\t    highlight: {\r\n\t        line: {\r\n\t            opacity: 1,\r\n\t            width: 3\r\n\t        }\r\n\t    },\r\n\t    line: {\r\n\t        width: 1\r\n\t    },\r\n\t    spacing: 0.3\r\n\t}); };\r\n\r\n\tvar radarAreaSeries = function () { return ({\r\n\t    line: {\r\n\t        opacity: 1,\r\n\t        width: 0\r\n\t    },\r\n\t    markers: {\r\n\t        size: 6,\r\n\t        visible: false\r\n\t    },\r\n\t    opacity: 0.5\r\n\t}); };\r\n\r\n\tvar radarLineSeries = function () { return ({\r\n\t    markers: {\r\n\t        visible: false\r\n\t    },\r\n\t    width: 2\r\n\t}); };\r\n\r\n\tvar rangeBarSeries = function () { return ({\r\n\t    gap: BAR_GAP,\r\n\t    spacing: BAR_SPACING\r\n\t}); };\r\n\r\n\tvar rangeColumnSeries = function () { return ({\r\n\t    gap: BAR_GAP,\r\n\t    spacing: BAR_SPACING\r\n\t}); };\r\n\r\n\tvar scatterLineSeries = function () { return ({\r\n\t    width: 1\r\n\t}); };\r\n\r\n\tvar waterfallSeries = function () { return ({\r\n\t    gap: 0.5,\r\n\t    line: {\r\n\t        color: BLACK,\r\n\t        width: 1\r\n\t    },\r\n\t    spacing: BAR_SPACING\r\n\t}); };\r\n\r\n\tvar pieSeries = function () { return ({\r\n\t    labels: {\r\n\t        background: '',\r\n\t        color: '',\r\n\t        padding: {\r\n\t            top: 5,\r\n\t            bottom: 5,\r\n\t            left: 7,\r\n\t            right: 7\r\n\t        }\r\n\t    }\r\n\t}); };\r\n\r\n\tvar funnelSeries = function () { return ({\r\n\t    labels: {\r\n\t        background: '',\r\n\t        color: '',\r\n\t        padding: {\r\n\t            top: 5,\r\n\t            bottom: 5,\r\n\t            left: 7,\r\n\t            right: 7\r\n\t        }\r\n\t    }\r\n\t}); };\r\n\r\n\tvar seriesDefaults = function (options) { return ({\r\n\t    visible: true,\r\n\t    labels: {\r\n\t        font: SANS11\r\n\t    },\r\n\t    overlay: options.gradients ? {} : {\r\n\t        gradient: \"none\"\r\n\t    },\r\n\t    area: areaSeries(),\r\n\t    rangeArea: rangeAreaSeries(),\r\n\t    verticalRangeArea: rangeAreaSeries(),\r\n\t    bar: barSeries(),\r\n\t    boxPlot: boxPlotSeries(),\r\n\t    bubble: bubbleSeries(),\r\n\t    bullet: bulletSeries(),\r\n\t    candlestick: candlestickSeries(),\r\n\t    column: columnSeries(),\r\n\t    pie: pieSeries(),\r\n\t    donut: donutSeries(),\r\n\t    funnel: funnelSeries(),\r\n\t    horizontalWaterfall: waterfallSeries(),\r\n\t    line: lineSeries(),\r\n\t    notes: notes(),\r\n\t    ohlc: ohlcSeries(),\r\n\t    radarArea: radarAreaSeries(),\r\n\t    radarLine: radarLineSeries(),\r\n\t    polarArea: radarAreaSeries(),\r\n\t    polarLine: radarLineSeries(),\r\n\t    rangeBar: rangeBarSeries(),\r\n\t    rangeColumn: rangeColumnSeries(),\r\n\t    scatterLine: scatterLineSeries(),\r\n\t    verticalArea: areaSeries(),\r\n\t    verticalBoxPlot: boxPlotSeries(),\r\n\t    verticalBullet: bulletSeries(),\r\n\t    verticalLine: lineSeries(),\r\n\t    waterfall: waterfallSeries()\r\n\t}); };\r\n\r\n\tvar title = function () { return ({\r\n\t    font: SANS16\r\n\t}); };\r\n\r\n\tvar legend = function () { return ({\r\n\t    labels: {\r\n\t        font: SANS12\r\n\t    }\r\n\t}); };\r\n\r\n\tvar baseTheme = function (options) {\r\n\t    if (options === void 0) { options = {}; }\r\n\r\n\t    return ({\r\n\t    axisDefaults: axisDefaults(),\r\n\t    categoryAxis: {\r\n\t        majorGridLines: {\r\n\t            visible: true\r\n\t        }\r\n\t    },\r\n\t    navigator: {\r\n\t        pane: {\r\n\t            height: 90,\r\n\t            margin: {\r\n\t                top: 10\r\n\t            }\r\n\t        }\r\n\t    },\r\n\t    seriesDefaults: seriesDefaults(options),\r\n\t    title: title(),\r\n\t    legend: legend()\r\n\t});\r\n\t};\r\n\r\n\tkendo.deepExtend(kendo.dataviz, {\r\n\t    chartBaseTheme: baseTheme\r\n\t});\r\n\r\n\t})();\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/dataviz/themes/chart-base-theme.js\n// module id = 471\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(854);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 850:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.dataviz.core\");\n\n/***/ }),\n\n/***/ 852:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.drawing\");\n\n/***/ }),\n\n/***/ 854:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n\t        __webpack_require__(855),\r\n\t        __webpack_require__(856),\r\n\t        __webpack_require__(852),\r\n\t        __webpack_require__(850)\r\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function ($) {\r\n\r\n\twindow.kendo.dataviz = window.kendo.dataviz || {};\r\n\tvar dataviz = kendo.dataviz;\r\n\tvar Class = dataviz.Class;\r\n\tvar isNumber = dataviz.isNumber;\r\n\tvar datavizConstants = dataviz.constants;\r\n\tvar MAX_VALUE = datavizConstants.MAX_VALUE;\r\n\tvar MIN_VALUE = datavizConstants.MIN_VALUE;\r\n\tvar VALUE = datavizConstants.VALUE;\r\n\tvar CENTER = datavizConstants.CENTER;\r\n\tvar TOP = datavizConstants.TOP;\r\n\tvar BOTTOM = datavizConstants.BOTTOM;\r\n\tvar LEFT = datavizConstants.LEFT;\r\n\tvar WHITE = datavizConstants.WHITE;\r\n\tvar CIRCLE = datavizConstants.CIRCLE;\r\n\tvar X = datavizConstants.X;\r\n\tvar Y = datavizConstants.Y;\r\n\tvar RIGHT = datavizConstants.RIGHT;\r\n\tvar BLACK = datavizConstants.BLACK;\r\n\tvar DATE = datavizConstants.DATE;\r\n\tvar DEFAULT_PRECISION = datavizConstants.DEFAULT_PRECISION;\r\n\tvar ARC = datavizConstants.ARC;\r\n\tvar defined = dataviz.defined;\r\n\tvar getter = dataviz.getter;\r\n\tvar isArray = dataviz.isArray;\r\n\tvar ChartElement = dataviz.ChartElement;\r\n\tvar Point = dataviz.Point;\r\n\tvar Box = dataviz.Box;\r\n\tvar alignPathToPixel = dataviz.alignPathToPixel;\r\n\tvar setDefaultOptions = dataviz.setDefaultOptions;\r\n\tvar inArray = dataviz.inArray;\r\n\tvar isFunction = dataviz.isFunction;\r\n\tvar valueOrDefault = dataviz.valueOrDefault;\r\n\tvar isObject = dataviz.isObject;\r\n\tvar deepExtend = dataviz.deepExtend;\r\n\tvar last = dataviz.last;\r\n\tvar eventElement = dataviz.eventElement;\r\n\tvar getTemplate = dataviz.getTemplate;\r\n\tvar TextBox = dataviz.TextBox;\r\n\tvar ShapeElement = dataviz.ShapeElement;\r\n\tvar getSpacing = dataviz.getSpacing;\r\n\tvar CurveProcessor = dataviz.CurveProcessor;\r\n\tvar append = dataviz.append;\r\n\tvar isString = dataviz.isString;\r\n\tvar parseDate = dataviz.parseDate;\r\n\tvar styleValue = dataviz.styleValue;\r\n\tvar CategoryAxis = dataviz.CategoryAxis;\r\n\tvar BoxElement = dataviz.BoxElement;\r\n\tvar round = dataviz.round;\r\n\tvar grep = dataviz.grep;\r\n\tvar DateCategoryAxis = dataviz.DateCategoryAxis;\r\n\tvar elementStyles = dataviz.elementStyles;\r\n\tvar hasClasses = dataviz.hasClasses;\r\n\tvar bindEvents = dataviz.bindEvents;\r\n\tvar services = dataviz.services;\r\n\tvar unbindEvents = dataviz.unbindEvents;\r\n\tvar limitValue = dataviz.limitValue;\r\n\tvar support = kendo.support;\r\n\tvar drawing = kendo.drawing;\r\n\tvar Path = drawing.Path;\r\n\tvar Animation = drawing.Animation;\r\n\tvar AnimationFactory = drawing.AnimationFactory;\r\n\tvar Group = drawing.Group;\r\n\tvar Color = kendo.Color;\r\n\tvar geometry = kendo.geometry;\r\n\tvar GeometryPoint = geometry.Point;\r\n\tvar transform = geometry.transform;\r\n\r\n\tvar ChartAxis = Class.extend({\r\n\t    init: function(axis) {\r\n\r\n\t        this._axis = axis;\r\n\t        this.options = axis.options;\r\n\t    },\r\n\r\n\t    value: function(point) {\r\n\t        var axis = this._axis;\r\n\t        var value = axis.getCategory ? axis.getCategory(point) : axis.getValue(point);\r\n\r\n\t        return value;\r\n\t    },\r\n\r\n\t    slot: function(from, to, limit) {\r\n\t        if (limit === void 0) { limit = true; }\r\n\r\n\t        return this._axis.slot(from, to, limit);\r\n\t    },\r\n\r\n\t    range: function() {\r\n\t        return this._axis.range();\r\n\t    },\r\n\r\n\t    valueRange: function() {\r\n\t        return this._axis.valueRange();\r\n\t    }\r\n\t});\r\n\r\n\tvar ChartPane = kendo.Class.extend({\r\n\t    init: function(pane) {\r\n\t        this.visual = pane.visual;\r\n\t        this.chartsVisual = pane.chartContainer.visual;\r\n\t    }\r\n\t});\r\n\r\n\tvar ChartPlotArea = Class.extend({\r\n\t    init: function(plotArea) {\r\n\r\n\t        this._plotArea = plotArea;\r\n\t        this.visual = plotArea.visual;\r\n\t        this.backgroundVisual = plotArea._bgVisual;\r\n\t    }\r\n\t});\r\n\r\n\tfunction countNumbers(values) {\r\n\t    var length = values.length;\r\n\t    var count = 0;\r\n\r\n\t    for (var i = 0; i < length; i++) {\r\n\t        var num = values[i];\r\n\t        if (isNumber(num)) {\r\n\t            count++;\r\n\t        }\r\n\t    }\r\n\r\n\t    return count;\r\n\t}\r\n\r\n\tvar Aggregates = {\r\n\t    min: function(values) {\r\n\t        var length = values.length;\r\n\t        var min = MAX_VALUE;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var value = values[i];\r\n\t            if (isNumber(value)) {\r\n\t                min = Math.min(min, value);\r\n\t            }\r\n\t        }\r\n\r\n\t        return min === MAX_VALUE ? values[0] : min;\r\n\t    },\r\n\r\n\t    max: function(values) {\r\n\t        var length = values.length;\r\n\t        var max = MIN_VALUE;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var value = values[i];\r\n\t            if (isNumber(value)) {\r\n\t                max = Math.max(max, value);\r\n\t            }\r\n\t        }\r\n\r\n\t        return max === MIN_VALUE ? values[0] : max;\r\n\t    },\r\n\r\n\t    sum: function(values) {\r\n\t        var length = values.length;\r\n\t        var sum = 0;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var value = values[i];\r\n\t            if (isNumber(value)) {\r\n\t                sum += value;\r\n\t            }\r\n\t        }\r\n\r\n\t        return sum;\r\n\t    },\r\n\r\n\t    sumOrNull: function(values) {\r\n\t        var result = null;\r\n\r\n\t        if (countNumbers(values)) {\r\n\t            result = Aggregates.sum(values);\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    count: function(values) {\r\n\t        var length = values.length;\r\n\t        var count = 0;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var value = values[i];\r\n\t            if (value !== null && defined(value)) {\r\n\t                count++;\r\n\t            }\r\n\t        }\r\n\r\n\t        return count;\r\n\t    },\r\n\r\n\t    avg: function(values) {\r\n\t        var count = countNumbers(values);\r\n\t        var result = values[0];\r\n\r\n\t        if (count > 0) {\r\n\t            result = Aggregates.sum(values) / count;\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    first: function(values) {\r\n\t        var length = values.length;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var value = values[i];\r\n\t            if (value !== null && defined(value)) {\r\n\t                return value;\r\n\t            }\r\n\t        }\r\n\r\n\t        return values[0];\r\n\t    }\r\n\t};\r\n\r\n\tfunction getField(field, row) {\r\n\t    if (row === null) {\r\n\t        return row;\r\n\t    }\r\n\r\n\t    var get = getter(field, true);\r\n\t    return get(row);\r\n\t}\r\n\r\n\tvar SeriesBinder = Class.extend({\r\n\t    init: function() {\r\n\r\n\t        this._valueFields = {};\r\n\t        this._otherFields = {};\r\n\t        this._nullValue = {};\r\n\t        this._undefinedValue = {};\r\n\t    },\r\n\r\n\t    register: function(seriesTypes, valueFields, otherFields) {\r\n\t        var this$1 = this;\r\n\t        if (valueFields === void 0) { valueFields = [ VALUE ]; }\r\n\t        if (otherFields === void 0) { otherFields = {}; }\r\n\r\n\t        for (var i = 0; i < seriesTypes.length; i++) {\r\n\t            var type = seriesTypes[i];\r\n\r\n\t            this$1._valueFields[type] = valueFields;\r\n\t            this$1._otherFields[type] = otherFields;\r\n\t            this$1._nullValue[type] = this$1._makeValue(valueFields, null);\r\n\t            this$1._undefinedValue[type] = this$1._makeValue(valueFields, undefined);\r\n\t        }\r\n\t    },\r\n\r\n\t    canonicalFields: function(series) {\r\n\t        return this.valueFields(series).concat(this.otherFields(series));\r\n\t    },\r\n\r\n\t    valueFields: function(series) {\r\n\t        return this._valueFields[series.type] || [ VALUE ];\r\n\t    },\r\n\r\n\t    otherFields: function(series) {\r\n\t        return this._otherFields[series.type] || [ VALUE ];\r\n\t    },\r\n\r\n\t    bindPoint: function(series, pointIx, item) {\r\n\t        var data = series.data;\r\n\t        var pointData = defined(item) ? item : data[pointIx];\r\n\t        var result = { valueFields: { value: pointData } };\r\n\t        var valueFields = this.valueFields(series);\r\n\t        var otherFields = this._otherFields[series.type];\r\n\t        var fields, value;\r\n\r\n\t        if (pointData === null) {\r\n\t            value = this._nullValue[series.type];\r\n\t        } else if (!defined(pointData)) {\r\n\t            value = this._undefinedValue[series.type];\r\n\t        } else if (Array.isArray(pointData)) {\r\n\t            var fieldData = pointData.slice(valueFields.length);\r\n\t            value = this._bindFromArray(pointData, valueFields);\r\n\t            fields = this._bindFromArray(fieldData, otherFields);\r\n\t        } else if (typeof pointData === \"object\") {\r\n\t            var srcValueFields = this.sourceFields(series, valueFields);\r\n\t            var srcPointFields = this.sourceFields(series, otherFields);\r\n\r\n\t            value = this._bindFromObject(pointData, valueFields, srcValueFields);\r\n\t            fields = this._bindFromObject(pointData, otherFields, srcPointFields);\r\n\t        }\r\n\r\n\t        if (defined(value)) {\r\n\t            if (valueFields.length === 1) {\r\n\t                result.valueFields.value = value[valueFields[0]];\r\n\t            } else {\r\n\t                result.valueFields = value;\r\n\t            }\r\n\t        }\r\n\r\n\t        result.fields = fields || {};\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    _makeValue: function(fields, initialValue) {\r\n\t        var value = {};\r\n\t        var length = fields.length;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var fieldName = fields[i];\r\n\t            value[fieldName] = initialValue;\r\n\t        }\r\n\r\n\t        return value;\r\n\t    },\r\n\r\n\t    _bindFromArray: function(array, fields) {\r\n\t        var value = {};\r\n\r\n\t        if (fields) {\r\n\t            var length = Math.min(fields.length, array.length);\r\n\r\n\t            for (var i = 0; i < length; i++) {\r\n\t                value[fields[i]] = array[i];\r\n\t            }\r\n\t        }\r\n\r\n\t        return value;\r\n\t    },\r\n\r\n\t    _bindFromObject: function(object, fields, srcFields) {\r\n\t        if (srcFields === void 0) { srcFields = fields; }\r\n\r\n\t        var value = {};\r\n\r\n\t        if (fields) {\r\n\t            var length = fields.length;\r\n\r\n\t            for (var i = 0; i < length; i++) {\r\n\t                var fieldName = fields[i];\r\n\t                var srcFieldName = srcFields[i];\r\n\t                value[fieldName] = getField(srcFieldName, object);\r\n\t            }\r\n\t        }\r\n\r\n\t        return value;\r\n\t    },\r\n\r\n\t    sourceFields: function(series, canonicalFields) {\r\n\t        var sourceFields = [];\r\n\r\n\t        if (canonicalFields) {\r\n\t            var length = canonicalFields.length;\r\n\r\n\t            for (var i = 0; i < length; i++) {\r\n\t                var fieldName = canonicalFields[i];\r\n\t                var sourceFieldName = fieldName === VALUE ? \"field\" : fieldName + \"Field\";\r\n\r\n\t                sourceFields.push(series[sourceFieldName] || fieldName);\r\n\t            }\r\n\t        }\r\n\r\n\t        return sourceFields;\r\n\t    }\r\n\t});\r\n\r\n\tSeriesBinder.current = new SeriesBinder();\r\n\r\n\tvar STD_ERR = \"stderr\";\r\n\tvar STD_DEV = \"stddev\";\r\n\tvar percentRegex = /percent(?:\\w*)\\((\\d+)\\)/;\r\n\tvar standardDeviationRegex = new RegExp(\"^\" + STD_DEV + \"(?:\\\\((\\\\d+(?:\\\\.\\\\d+)?)\\\\))?$\");\r\n\r\n\tvar ErrorRangeCalculator = Class.extend({\r\n\t    init: function(errorValue, series, field) {\r\n\r\n\t        this.initGlobalRanges(errorValue, series, field);\r\n\t    },\r\n\r\n\t    initGlobalRanges: function(errorValue, series, field) {\r\n\t        var data = series.data;\r\n\t        var deviationMatch = standardDeviationRegex.exec(errorValue);\r\n\r\n\t        if (deviationMatch) {\r\n\t            this.valueGetter = this.createValueGetter(series, field);\r\n\r\n\t            var average = this.getAverage(data);\r\n\t            var deviation = this.getStandardDeviation(data, average, false);\r\n\t            var multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;\r\n\t            var errorRange = { low: average.value - deviation * multiple, high: average.value + deviation * multiple };\r\n\r\n\t            this.globalRange = function() {\r\n\t                return errorRange;\r\n\t            };\r\n\t        } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {\r\n\t            this.valueGetter = this.createValueGetter(series, field);\r\n\t            var standardError = this.getStandardError(data, this.getAverage(data));\r\n\r\n\t            this.globalRange = function(value) {\r\n\t                return { low: value - standardError, high: value + standardError };\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    createValueGetter: function(series, field) {\r\n\t        var data = series.data;\r\n\t        var binder = SeriesBinder.current;\r\n\t        var valueFields = binder.valueFields(series);\r\n\t        var item = defined(data[0]) ? data[0] : {};\r\n\t        var valueGetter;\r\n\r\n\t        if (isArray(item)) {\r\n\t            var index = field ? valueFields.indexOf(field) : 0;\r\n\t            valueGetter = getter(\"[\" + index + \"]\");\r\n\t        } else if (isNumber(item)) {\r\n\t            valueGetter = getter();\r\n\t        } else if (typeof item === datavizConstants.OBJECT) {\r\n\t            var srcValueFields = binder.sourceFields(series, valueFields);\r\n\t            valueGetter = getter(srcValueFields[valueFields.indexOf(field)]);\r\n\t        }\r\n\r\n\t        return valueGetter;\r\n\t    },\r\n\r\n\t    getErrorRange: function(pointValue, errorValue) {\r\n\t        var low, high, value;\r\n\r\n\t        if (!defined(errorValue)) {\r\n\t            return null;\r\n\t        }\r\n\r\n\t        if (this.globalRange) {\r\n\t            return this.globalRange(pointValue);\r\n\t        }\r\n\r\n\t        if (isArray(errorValue)) {\r\n\t            low = pointValue - errorValue[0];\r\n\t            high = pointValue + errorValue[1];\r\n\t        } else if (isNumber(value = parseFloat(errorValue))) {\r\n\t            low = pointValue - value;\r\n\t            high = pointValue + value;\r\n\t        } else if ((value = percentRegex.exec(errorValue))) {\r\n\t            var percentValue = pointValue * (parseFloat(value[1]) / 100);\r\n\t            low = pointValue - Math.abs(percentValue);\r\n\t            high = pointValue + Math.abs(percentValue);\r\n\t        } else {\r\n\t            throw new Error(\"Invalid ErrorBar value: \" + errorValue);\r\n\t        }\r\n\r\n\t        return { low: low, high: high };\r\n\t    },\r\n\r\n\t    getStandardError: function(data, average) {\r\n\t        return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);\r\n\t    },\r\n\r\n\t    getStandardDeviation: function(data, average, isSample) {\r\n\t        var this$1 = this;\r\n\r\n\t        var length = data.length;\r\n\t        var total = isSample ? average.count - 1 : average.count;\r\n\t        var squareDifferenceSum = 0;\r\n\r\n\t        for (var idx = 0; idx < length; idx++) {\r\n\t            var value = this$1.valueGetter(data[idx]);\r\n\t            if (isNumber(value)) {\r\n\t                squareDifferenceSum += Math.pow(value - average.value, 2);\r\n\t            }\r\n\t        }\r\n\r\n\t        return Math.sqrt(squareDifferenceSum / total);\r\n\t    },\r\n\r\n\t    getAverage: function(data) {\r\n\t        var this$1 = this;\r\n\r\n\t        var length = data.length;\r\n\t        var sum = 0;\r\n\t        var count = 0;\r\n\r\n\t        for (var idx = 0; idx < length; idx++) {\r\n\t            var value = this$1.valueGetter(data[idx]);\r\n\t            if (isNumber(value)) {\r\n\t                sum += value;\r\n\t                count++;\r\n\t            }\r\n\t        }\r\n\r\n\t        return {\r\n\t            value: sum / count,\r\n\t            count: count\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tvar browser = support.browser || {};\r\n\r\n\tvar INITIAL_ANIMATION_DURATION = 600;\r\n\tvar FADEIN = \"fadeIn\";\r\n\r\n\tvar GLASS = \"glass\";\r\n\tvar BORDER_BRIGHTNESS = 0.8;\r\n\tvar TOOLTIP_OFFSET = 5;\r\n\tvar START_SCALE = browser.msie ? 0.001 : 0;\r\n\tvar ERROR_LOW_FIELD = \"errorLow\";\r\n\tvar ERROR_HIGH_FIELD = \"errorHigh\";\r\n\tvar X_ERROR_LOW_FIELD = \"xErrorLow\";\r\n\tvar X_ERROR_HIGH_FIELD = \"xErrorHigh\";\r\n\tvar Y_ERROR_LOW_FIELD = \"yErrorLow\";\r\n\tvar Y_ERROR_HIGH_FIELD = \"yErrorHigh\";\r\n\tvar LINE_MARKER_SIZE = 8;\r\n\tvar ZERO = \"zero\";\r\n\tvar INTERPOLATE = \"interpolate\";\r\n\tvar GAP = \"gap\";\r\n\tvar ABOVE = \"above\";\r\n\tvar BELOW = \"below\";\r\n\r\n\tvar SMOOTH = \"smooth\";\r\n\tvar STEP = \"step\";\r\n\r\n\tvar AREA = \"area\";\r\n\tvar BAR = \"bar\";\r\n\tvar BOX_PLOT = \"boxPlot\";\r\n\tvar BUBBLE = \"bubble\";\r\n\tvar BULLET = \"bullet\";\r\n\tvar CANDLESTICK = \"candlestick\";\r\n\tvar COLUMN = \"column\";\r\n\tvar DONUT = \"donut\";\r\n\tvar FUNNEL = \"funnel\";\r\n\tvar HORIZONTAL_WATERFALL = \"horizontalWaterfall\";\r\n\tvar LINE = \"line\";\r\n\tvar OHLC = \"ohlc\";\r\n\tvar PIE = \"pie\";\r\n\tvar POLAR_AREA = \"polarArea\";\r\n\tvar POLAR_LINE = \"polarLine\";\r\n\tvar POLAR_SCATTER = \"polarScatter\";\r\n\tvar RADAR_AREA = \"radarArea\";\r\n\tvar RADAR_COLUMN = \"radarColumn\";\r\n\tvar RADAR_LINE = \"radarLine\";\r\n\tvar RANGE_AREA = \"rangeArea\";\r\n\tvar RANGE_BAR = \"rangeBar\";\r\n\tvar RANGE_COLUMN = \"rangeColumn\";\r\n\tvar SCATTER = \"scatter\";\r\n\tvar SCATTER_LINE = \"scatterLine\";\r\n\tvar VERTICAL_AREA = \"verticalArea\";\r\n\tvar VERTICAL_BOX_PLOT = \"verticalBoxPlot\";\r\n\tvar VERTICAL_BULLET = \"verticalBullet\";\r\n\tvar VERTICAL_LINE = \"verticalLine\";\r\n\tvar VERTICAL_RANGE_AREA = \"verticalRangeArea\";\r\n\tvar WATERFALL = \"waterfall\";\r\n\tvar EQUALLY_SPACED_SERIES = [\r\n\t    BAR, COLUMN, OHLC, CANDLESTICK, BOX_PLOT, VERTICAL_BOX_PLOT,\r\n\t    BULLET, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL\r\n\t];\r\n\r\n\tvar LEGEND_ITEM_CLICK = \"legendItemClick\";\r\n\tvar LEGEND_ITEM_HOVER = \"legendItemHover\";\r\n\tvar SERIES_CLICK = \"seriesClick\";\r\n\tvar SERIES_HOVER = \"seriesHover\";\r\n\tvar PLOT_AREA_CLICK = \"plotAreaClick\";\r\n\tvar PLOT_AREA_HOVER = \"plotAreaHover\";\r\n\tvar DRAG = \"drag\";\r\n\tvar DRAG_END = \"dragEnd\";\r\n\tvar DRAG_START = \"dragStart\";\r\n\tvar ZOOM_START = \"zoomStart\";\r\n\tvar ZOOM = \"zoom\";\r\n\tvar ZOOM_END = \"zoomEnd\";\r\n\tvar SELECT_START = \"selectStart\";\r\n\tvar SELECT = \"select\";\r\n\tvar SELECT_END = \"selectEnd\";\r\n\tvar RENDER = \"render\";\r\n\tvar SHOW_TOOLTIP = \"showTooltip\";\r\n\tvar HIDE_TOOLTIP = \"hideTooltip\";\r\n\r\n\tvar LOGARITHMIC = \"log\";\r\n\tvar CATEGORY = \"category\";\r\n\r\n\tvar INSIDE_END = \"insideEnd\";\r\n\tvar INSIDE_BASE = \"insideBase\";\r\n\tvar OUTSIDE_END = \"outsideEnd\";\r\n\r\n\tvar MOUSEWHEEL = \"DOMMouseScroll mousewheel\";\r\n\tvar MOUSEWHEEL_DELAY = 150;\r\n\r\n\tvar constants = {\r\n\t\tINITIAL_ANIMATION_DURATION: INITIAL_ANIMATION_DURATION,\r\n\t\tFADEIN: FADEIN,\r\n\t\tLEGEND_ITEM_CLICK: LEGEND_ITEM_CLICK,\r\n\t\tLEGEND_ITEM_HOVER: LEGEND_ITEM_HOVER,\r\n\t\tSERIES_CLICK: SERIES_CLICK,\r\n\t\tSERIES_HOVER: SERIES_HOVER,\r\n\t\tGLASS: GLASS,\r\n\t\tBORDER_BRIGHTNESS: BORDER_BRIGHTNESS,\r\n\t\tTOOLTIP_OFFSET: TOOLTIP_OFFSET,\r\n\t\tSTART_SCALE: START_SCALE,\r\n\t\tERROR_LOW_FIELD: ERROR_LOW_FIELD,\r\n\t\tERROR_HIGH_FIELD: ERROR_HIGH_FIELD,\r\n\t\tX_ERROR_LOW_FIELD: X_ERROR_LOW_FIELD,\r\n\t\tX_ERROR_HIGH_FIELD: X_ERROR_HIGH_FIELD,\r\n\t\tY_ERROR_LOW_FIELD: Y_ERROR_LOW_FIELD,\r\n\t\tY_ERROR_HIGH_FIELD: Y_ERROR_HIGH_FIELD,\r\n\t\tLINE_MARKER_SIZE: LINE_MARKER_SIZE,\r\n\t\tINTERPOLATE: INTERPOLATE,\r\n\t\tZERO: ZERO,\r\n\t\tSMOOTH: SMOOTH,\r\n\t\tSTEP: STEP,\r\n\t\tCATEGORY: CATEGORY,\r\n\t\tFUNNEL: FUNNEL,\r\n\t\tBAR: BAR,\r\n\t\tCANDLESTICK: CANDLESTICK,\r\n\t\tPIE: PIE,\r\n\t\tCOLUMN: COLUMN,\r\n\t\tAREA: AREA,\r\n\t\tVERTICAL_BULLET: VERTICAL_BULLET,\r\n\t\tBOX_PLOT: BOX_PLOT,\r\n\t\tOHLC: OHLC,\r\n\t\tWATERFALL: WATERFALL,\r\n\t\tLINE: LINE,\r\n\t\tBULLET: BULLET,\r\n\t\tVERTICAL_LINE: VERTICAL_LINE,\r\n\t\tVERTICAL_AREA: VERTICAL_AREA,\r\n\t\tRANGE_AREA: RANGE_AREA,\r\n\t\tVERTICAL_RANGE_AREA: VERTICAL_RANGE_AREA,\r\n\t\tRANGE_COLUMN: RANGE_COLUMN,\r\n\t\tVERTICAL_BOX_PLOT: VERTICAL_BOX_PLOT,\r\n\t\tRANGE_BAR: RANGE_BAR,\r\n\t\tHORIZONTAL_WATERFALL: HORIZONTAL_WATERFALL,\r\n\t\tSCATTER: SCATTER,\r\n\t\tSCATTER_LINE: SCATTER_LINE,\r\n\t\tBUBBLE: BUBBLE,\r\n\t\tRADAR_AREA: RADAR_AREA,\r\n\t\tRADAR_LINE: RADAR_LINE,\r\n\t\tRADAR_COLUMN: RADAR_COLUMN,\r\n\t\tPOLAR_LINE: POLAR_LINE,\r\n\t\tPOLAR_AREA: POLAR_AREA,\r\n\t\tPOLAR_SCATTER: POLAR_SCATTER,\r\n\t\tRENDER: RENDER,\r\n\t\tPLOT_AREA_CLICK: PLOT_AREA_CLICK,\r\n\t\tPLOT_AREA_HOVER: PLOT_AREA_HOVER,\r\n\t\tLOGARITHMIC: LOGARITHMIC,\r\n\t\tDRAG: DRAG,\r\n\t\tDRAG_START: DRAG_START,\r\n\t\tDRAG_END: DRAG_END,\r\n\t\tZOOM_START: ZOOM_START,\r\n\t\tZOOM: ZOOM,\r\n\t\tZOOM_END: ZOOM_END,\r\n\t\tSELECT_START: SELECT_START,\r\n\t\tSELECT: SELECT,\r\n\t\tSELECT_END: SELECT_END,\r\n\t\tGAP: GAP,\r\n\t\tDONUT: DONUT,\r\n\t\tINSIDE_END: INSIDE_END,\r\n\t\tINSIDE_BASE: INSIDE_BASE,\r\n\t\tOUTSIDE_END: OUTSIDE_END,\r\n\t\tMOUSEWHEEL: MOUSEWHEEL,\r\n\t\tMOUSEWHEEL_DELAY: MOUSEWHEEL_DELAY,\r\n\t\tSHOW_TOOLTIP: SHOW_TOOLTIP,\r\n\t\tHIDE_TOOLTIP: HIDE_TOOLTIP,\r\n\t\tEQUALLY_SPACED_SERIES: EQUALLY_SPACED_SERIES,\r\n\t\tABOVE: ABOVE,\r\n\t\tBELOW: BELOW\r\n\t};\r\n\r\n\tvar DEFAULT_ERROR_BAR_WIDTH = 4;\r\n\r\n\tvar ErrorBarBase = ChartElement.extend({\r\n\t    init: function(low, high, isVertical, chart, series, options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.low = low;\r\n\t        this.high = high;\r\n\t        this.isVertical = isVertical;\r\n\t        this.chart = chart;\r\n\t        this.series = series;\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var endCaps = this.options.endCaps;\r\n\t        var isVertical = this.isVertical;\r\n\t        var axis = this.getAxis();\r\n\t        var valueBox = axis.getSlot(this.low, this.high);\r\n\t        var centerBox = targetBox.center();\r\n\t        var capsWidth = this.getCapsWidth(targetBox, isVertical);\r\n\t        var capValue = isVertical ? centerBox.x : centerBox.y;\r\n\t        var capStart = capValue - capsWidth;\r\n\t        var capEnd = capValue + capsWidth;\r\n\t        var linePoints;\r\n\r\n\t        if (isVertical) {\r\n\t            linePoints = [\r\n\t                new Point(centerBox.x, valueBox.y1),\r\n\t                new Point(centerBox.x, valueBox.y2)\r\n\t            ];\r\n\t            if (endCaps) {\r\n\t                linePoints.push(new Point(capStart, valueBox.y1),\r\n\t                    new Point(capEnd, valueBox.y1),\r\n\t                    new Point(capStart, valueBox.y2),\r\n\t                    new Point(capEnd, valueBox.y2));\r\n\t            }\r\n\t            this.box = new Box(capStart, valueBox.y1, capEnd, valueBox.y2);\r\n\t        } else {\r\n\t            linePoints = [\r\n\t                new Point(valueBox.x1, centerBox.y),\r\n\t                new Point(valueBox.x2, centerBox.y)\r\n\t            ];\r\n\t            if (endCaps) {\r\n\t                linePoints.push(new Point(valueBox.x1, capStart),\r\n\t                    new Point(valueBox.x1, capEnd),\r\n\t                    new Point(valueBox.x2, capStart),\r\n\t                    new Point(valueBox.x2, capEnd));\r\n\t            }\r\n\t            this.box = new Box(valueBox.x1, capStart, valueBox.x2, capEnd);\r\n\t        }\r\n\r\n\t        this.linePoints = linePoints;\r\n\t    },\r\n\r\n\t    getCapsWidth: function(box, isVertical) {\r\n\t        var boxSize = isVertical ? box.width() : box.height();\r\n\t        var capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;\r\n\r\n\t        return capsWidth;\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var visual = options.visual;\r\n\r\n\t        if (visual) {\r\n\t            this.visual = visual({\r\n\t                low: this.low,\r\n\t                high: this.high,\r\n\t                rect: this.box.toRect(),\r\n\t                sender: this.getSender(),\r\n\t                options: {\r\n\t                    endCaps: options.endCaps,\r\n\t                    color: options.color,\r\n\t                    line: options.line\r\n\t                },\r\n\t                createVisual: function () {\r\n\t                    this$1.createDefaultVisual();\r\n\t                    var defaultVisual = this$1.visual;\r\n\t                    delete this$1.visual;\r\n\t                    return defaultVisual;\r\n\t                }\r\n\t            });\r\n\t        } else {\r\n\t            this.createDefaultVisual();\r\n\t        }\r\n\t    },\r\n\r\n\t    createDefaultVisual: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var linePoints = ref.linePoints;\r\n\t        var lineOptions = {\r\n\t            stroke: {\r\n\t                color: options.color,\r\n\t                width: options.line.width,\r\n\t                dashType: options.line.dashType\r\n\t            }\r\n\t        };\r\n\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\r\n\t        for (var idx = 0; idx < linePoints.length; idx += 2) {\r\n\t            var line = new Path(lineOptions)\r\n\t                .moveTo(linePoints[idx].x, linePoints[idx].y)\r\n\t                .lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);\r\n\r\n\t            alignPathToPixel(line);\r\n\t            this$1.visual.append(line);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(ErrorBarBase, {\r\n\t    animation: {\r\n\t        type: FADEIN,\r\n\t        delay: INITIAL_ANIMATION_DURATION\r\n\t    },\r\n\t    endCaps: true,\r\n\t    line: {\r\n\t        width: 2\r\n\t    },\r\n\t    zIndex: 1\r\n\t});\r\n\r\n\tvar CategoricalErrorBar = ErrorBarBase.extend({\r\n\t    getAxis: function() {\r\n\t        var axis = this.chart.seriesValueAxis(this.series);\r\n\r\n\t        return axis;\r\n\t    }\r\n\t});\r\n\r\n\tvar MAX_EXPAND_DEPTH = 5;\r\n\r\n\tfunction evalOptions(options, context, state, dryRun) {\r\n\t    if (state === void 0) { state = {}; }\r\n\t    if (dryRun === void 0) { dryRun = false; }\r\n\r\n\t    var defaults = state.defaults = state.defaults || {};\r\n\t    var depth = state.depth = state.depth || 0;\r\n\t    var needsEval = false;\r\n\r\n\t    state.excluded = state.excluded || [];\r\n\r\n\t    if (depth > MAX_EXPAND_DEPTH) {\r\n\t        return null;\r\n\t    }\r\n\r\n\t    for (var property in options) {\r\n\t        if (!inArray(property, state.excluded) && options.hasOwnProperty(property)) {\r\n\t            var propValue = options[property];\r\n\t            if (isFunction(propValue)) {\r\n\t                needsEval = true;\r\n\t                if (!dryRun) {\r\n\t                    options[property] = valueOrDefault(propValue(context), defaults[property]);\r\n\t                }\r\n\t            } else if (isObject(propValue)) {\r\n\t                if (!dryRun) {\r\n\t                    state.defaults = defaults[property];\r\n\t                }\r\n\t                state.depth++;\r\n\t                needsEval = evalOptions(propValue, context, state, dryRun) || needsEval;\r\n\t                state.depth--;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    return needsEval;\r\n\t}\r\n\r\n\tfunction categoriesCount(series) {\r\n\t    var seriesCount = series.length;\r\n\t    var categories = 0;\r\n\r\n\t    for (var i = 0; i < seriesCount; i++) {\r\n\t        categories = Math.max(categories, series[i].data.length);\r\n\t    }\r\n\r\n\t    return categories;\r\n\t}\r\n\r\n\tvar CategoricalChart = ChartElement.extend({\r\n\t    init: function(plotArea, options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.plotArea = plotArea;\r\n\t        this.chartService = plotArea.chartService;\r\n\t        this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);\r\n\r\n\t        // Value axis ranges grouped by axis name, e.g.:\r\n\t        // primary: { min: 0, max: 1 }\r\n\t        this.valueAxisRanges = {};\r\n\r\n\t        this.points = [];\r\n\t        this.categoryPoints = [];\r\n\t        this.seriesPoints = [];\r\n\t        this.seriesOptions = [];\r\n\t        this._evalSeries = [];\r\n\r\n\t        this.render();\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        this.traverseDataPoints(this.addValue.bind(this));\r\n\t    },\r\n\r\n\t    pointOptions: function(series, seriesIx) {\r\n\t        var options = this.seriesOptions[seriesIx];\r\n\t        if (!options) {\r\n\t            var defaults = this.pointType().prototype.defaults;\r\n\t            this.seriesOptions[seriesIx] = options = deepExtend({ }, defaults, {\r\n\t                vertical: !this.options.invertAxes\r\n\t            }, series);\r\n\t        }\r\n\r\n\t        return options;\r\n\t    },\r\n\r\n\t    plotValue: function(point) {\r\n\t        if (!point) {\r\n\t            return 0;\r\n\t        }\r\n\r\n\t        if (this.options.isStacked100 && isNumber(point.value)) {\r\n\t            var categoryIx = point.categoryIx;\r\n\t            var categoryPoints = this.categoryPoints[categoryIx];\r\n\t            var otherValues = [];\r\n\t            var categorySum = 0;\r\n\r\n\t            for (var i = 0; i < categoryPoints.length; i++) {\r\n\t                var other = categoryPoints[i];\r\n\t                if (other) {\r\n\t                    var stack = point.series.stack;\r\n\t                    var otherStack = other.series.stack;\r\n\r\n\t                    if ((stack && otherStack) && stack.group !== otherStack.group) {\r\n\t                        continue;\r\n\t                    }\r\n\r\n\t                    if (isNumber(other.value)) {\r\n\t                        categorySum += Math.abs(other.value);\r\n\t                        otherValues.push(Math.abs(other.value));\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            if (categorySum > 0) {\r\n\t                return point.value / categorySum;\r\n\t            }\r\n\t        }\r\n\r\n\t        return point.value;\r\n\t    },\r\n\r\n\t    plotRange: function(point, startValue) {\r\n\t        var this$1 = this;\r\n\t        if (startValue === void 0) { startValue = 0; }\r\n\r\n\t        var categoryPoints = this.categoryPoints[point.categoryIx];\r\n\r\n\t        if (this.options.isStacked) {\r\n\t            var plotValue = this.plotValue(point);\r\n\t            var positive = plotValue >= 0;\r\n\t            var prevValue = startValue;\r\n\t            var isStackedBar = false;\r\n\r\n\t            for (var i = 0; i < categoryPoints.length; i++) {\r\n\t                var other = categoryPoints[i];\r\n\r\n\t                if (point === other) {\r\n\t                    break;\r\n\t                }\r\n\r\n\t                var stack = point.series.stack;\r\n\t                var otherStack = other.series.stack;\r\n\t                if (stack && otherStack) {\r\n\t                    if (typeof stack === datavizConstants.STRING && stack !== otherStack) {\r\n\t                        continue;\r\n\t                    }\r\n\r\n\t                    if (stack.group && stack.group !== otherStack.group) {\r\n\t                        continue;\r\n\t                    }\r\n\t                }\r\n\r\n\t                var otherValue = this$1.plotValue(other);\r\n\t                if ((otherValue >= 0 && positive) ||\r\n\t                    (otherValue < 0 && !positive)) {\r\n\t                    prevValue += otherValue;\r\n\t                    plotValue += otherValue;\r\n\t                    isStackedBar = true;\r\n\r\n\t                    if (this$1.options.isStacked100) {\r\n\t                        plotValue = Math.min(plotValue, 1);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            if (isStackedBar) {\r\n\t                prevValue -= startValue;\r\n\t            }\r\n\r\n\t            return [ prevValue, plotValue ];\r\n\t        }\r\n\r\n\t        var series = point.series;\r\n\t        var valueAxis = this.seriesValueAxis(series);\r\n\t        var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\r\n\r\n\t        return [ axisCrossingValue, dataviz.convertableToNumber(point.value) ? point.value : axisCrossingValue ];\r\n\t    },\r\n\r\n\t    stackLimits: function(axisName, stackName) {\r\n\t        var this$1 = this;\r\n\r\n\t        var min = MAX_VALUE;\r\n\t        var max = MIN_VALUE;\r\n\r\n\t        for (var i = 0; i < this.categoryPoints.length; i++) {\r\n\t            var categoryPoints = this$1.categoryPoints[i];\r\n\t            if (!categoryPoints) {\r\n\t                continue;\r\n\t            }\r\n\r\n\t            for (var pIx = 0; pIx < categoryPoints.length; pIx++) {\r\n\t                var point = categoryPoints[pIx];\r\n\t                if (point) {\r\n\t                    if (point.series.stack === stackName || point.series.axis === axisName) {\r\n\t                        var to = this$1.plotRange(point, 0)[1];\r\n\t                        if (defined(to) && isFinite(to)) {\r\n\t                            max = Math.max(max, to);\r\n\t                            min = Math.min(min, to);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return { min: min, max: max };\r\n\t    },\r\n\r\n\t    updateStackRange: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this.options;\r\n\t        var isStacked = ref.isStacked;\r\n\t        var chartSeries = ref.series;\r\n\t        var limitsCache = {};\r\n\r\n\t        if (isStacked) {\r\n\t            for (var i = 0; i < chartSeries.length; i++) {\r\n\t                var series = chartSeries[i];\r\n\t                var axisName = series.axis;\r\n\t                var key = axisName + series.stack;\r\n\r\n\t                var limits = limitsCache[key];\r\n\t                if (!limits) {\r\n\t                    limits = this$1.stackLimits(axisName, series.stack);\r\n\r\n\t                    var errorTotals = this$1.errorTotals;\r\n\t                    if (errorTotals) {\r\n\t                        if (errorTotals.negative.length) {\r\n\t                            limits.min = Math.min(limits.min, dataviz.sparseArrayLimits(errorTotals.negative).min);\r\n\t                        }\r\n\t                        if (errorTotals.positive.length) {\r\n\t                            limits.max = Math.max(limits.max, dataviz.sparseArrayLimits(errorTotals.positive).max);\r\n\t                        }\r\n\t                    }\r\n\r\n\t                    if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\r\n\t                        limitsCache[key] = limits;\r\n\t                    } else {\r\n\t                        limits = null;\r\n\t                    }\r\n\t                }\r\n\r\n\t                if (limits) {\r\n\t                    this$1.valueAxisRanges[axisName] = limits;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    addErrorBar: function(point, data, categoryIx) {\r\n\t        var value = point.value;\r\n\t        var series = point.series;\r\n\t        var seriesIx = point.seriesIx;\r\n\t        var errorBars = point.options.errorBars;\r\n\t        var lowValue = data.fields[ERROR_LOW_FIELD];\r\n\t        var highValue = data.fields[ERROR_HIGH_FIELD];\r\n\t        var errorRange;\r\n\r\n\t        if (isNumber(lowValue) && isNumber(highValue)) {\r\n\t            errorRange = { low: lowValue, high: highValue };\r\n\t        } else if (errorBars && defined(errorBars.value)) {\r\n\t            this.seriesErrorRanges = this.seriesErrorRanges || [];\r\n\t            this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] ||\r\n\t                new ErrorRangeCalculator(errorBars.value, series, VALUE);\r\n\r\n\t            errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\r\n\t        }\r\n\r\n\t        if (errorRange) {\r\n\t            point.low = errorRange.low;\r\n\t            point.high = errorRange.high;\r\n\t            this.addPointErrorBar(point, categoryIx);\r\n\t        }\r\n\t    },\r\n\r\n\t    addPointErrorBar: function(point, categoryIx) {\r\n\t        var isVertical = !this.options.invertAxes;\r\n\t        var options = point.options.errorBars;\r\n\t        var series = point.series;\r\n\t        var low = point.low;\r\n\t        var high = point.high;\r\n\r\n\t        if (this.options.isStacked) {\r\n\t            var stackedErrorRange = this.stackedErrorRange(point, categoryIx);\r\n\t            low = stackedErrorRange.low;\r\n\t            high = stackedErrorRange.high;\r\n\t        } else {\r\n\t            var fields = { categoryIx: categoryIx, series: series };\r\n\t            this.updateRange({ value: low }, fields);\r\n\t            this.updateRange({ value: high }, fields);\r\n\t        }\r\n\r\n\t        var errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\r\n\t        point.errorBars = [ errorBar ];\r\n\t        point.append(errorBar);\r\n\t    },\r\n\r\n\t    stackedErrorRange: function(point, categoryIx) {\r\n\t        var plotValue = this.plotRange(point, 0)[1] - point.value;\r\n\t        var low = point.low + plotValue;\r\n\t        var high = point.high + plotValue;\r\n\r\n\t        this.errorTotals = this.errorTotals || { positive: [], negative: [] };\r\n\r\n\t        if (low < 0) {\r\n\t            this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\r\n\t        }\r\n\r\n\t        if (high > 0) {\r\n\t            this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\r\n\t        }\r\n\r\n\t        return { low: low, high: high };\r\n\t    },\r\n\r\n\t    addValue: function(data, fields) {\r\n\t        var categoryIx = fields.categoryIx;\r\n\t        var series = fields.series;\r\n\t        var seriesIx = fields.seriesIx;\r\n\r\n\t        var categoryPoints = this.categoryPoints[categoryIx];\r\n\t        if (!categoryPoints) {\r\n\t            this.categoryPoints[categoryIx] = categoryPoints = [];\r\n\t        }\r\n\r\n\t        var seriesPoints = this.seriesPoints[seriesIx];\r\n\t        if (!seriesPoints) {\r\n\t            this.seriesPoints[seriesIx] = seriesPoints = [];\r\n\t        }\r\n\r\n\t        var point = this.createPoint(data, fields);\r\n\t        if (point) {\r\n\t            $.extend(point, fields);\r\n\r\n\t            point.owner = this;\r\n\t            point.noteText = data.fields.noteText;\r\n\t            if (!defined(point.dataItem)) {\r\n\t                point.dataItem = series.data[categoryIx];\r\n\t            }\r\n\t            this.addErrorBar(point, data, categoryIx);\r\n\t        }\r\n\r\n\t        this.points.push(point);\r\n\t        seriesPoints.push(point);\r\n\t        categoryPoints.push(point);\r\n\r\n\t        this.updateRange(data.valueFields, fields);\r\n\t    },\r\n\r\n\t    evalPointOptions: function(options, value, category, categoryIx, series, seriesIx) {\r\n\t        var state = { defaults: series._defaults, excluded: [ \"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\" ] };\r\n\r\n\t        var doEval = this._evalSeries[seriesIx];\r\n\t        if (!defined(doEval)) {\r\n\t            this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\r\n\t        }\r\n\r\n\t        var pointOptions = options;\r\n\t        if (doEval) {\r\n\t            pointOptions = deepExtend({}, pointOptions);\r\n\t            evalOptions(pointOptions, {\r\n\t                value: value,\r\n\t                category: category,\r\n\t                index: categoryIx,\r\n\t                series: series,\r\n\t                dataItem: series.data[categoryIx]\r\n\t            }, state);\r\n\t        }\r\n\r\n\t        return pointOptions;\r\n\t    },\r\n\r\n\t    updateRange: function(data, fields) {\r\n\t        var axisName = fields.series.axis;\r\n\t        var value = data.value;\r\n\t        var axisRange = this.valueAxisRanges[axisName];\r\n\r\n\t        if (isFinite(value) && value !== null) {\r\n\t            axisRange = this.valueAxisRanges[axisName] =\r\n\t                axisRange || { min: MAX_VALUE, max: MIN_VALUE };\r\n\r\n\t            axisRange.min = Math.min(axisRange.min, value);\r\n\t            axisRange.max = Math.max(axisRange.max, value);\r\n\t        }\r\n\t    },\r\n\r\n\t    seriesValueAxis: function(series) {\r\n\t        var plotArea = this.plotArea;\r\n\t        var axisName = series.axis;\r\n\t        var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\r\n\r\n\t        if (!axis) {\r\n\t            throw new Error(\"Unable to locate value axis with name \" + axisName);\r\n\t        }\r\n\r\n\t        return axis;\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var this$1 = this;\r\n\r\n\t        var categorySlots = this.categorySlots = [];\r\n\t        var chartPoints = this.points;\r\n\t        var categoryAxis = this.categoryAxis;\r\n\t        var pointIx = 0;\r\n\r\n\t        this.traverseDataPoints(function (data, fields) {\r\n\t            var categoryIx = fields.categoryIx;\r\n\t            var currentSeries = fields.series;\r\n\r\n\t            var valueAxis = this$1.seriesValueAxis(currentSeries);\r\n\t            var point = chartPoints[pointIx++];\r\n\r\n\t            var categorySlot = categorySlots[categoryIx];\r\n\t            if (!categorySlot) {\r\n\t                categorySlots[categoryIx] = categorySlot =\r\n\t                    this$1.categorySlot(categoryAxis, categoryIx, valueAxis);\r\n\t            }\r\n\r\n\t            if (point) {\r\n\t                var plotRange = this$1.plotRange(point, valueAxis.startValue());\r\n\t                var valueSlot = this$1.valueSlot(valueAxis, plotRange);\r\n\t                if (valueSlot) {\r\n\t                    var pointSlot = this$1.pointSlot(categorySlot, valueSlot);\r\n\r\n\t                    point.aboveAxis = this$1.aboveAxis(point, valueAxis);\r\n\t                    point.stackValue = plotRange[1];\r\n\r\n\t                    if (this$1.options.isStacked100) {\r\n\t                        point.percentage = this$1.plotValue(point);\r\n\t                    }\r\n\r\n\t                    this$1.reflowPoint(point, pointSlot);\r\n\t                } else {\r\n\t                    point.visible = false;\r\n\t                }\r\n\t            }\r\n\t        });\r\n\r\n\t        this.reflowCategories(categorySlots);\r\n\t        if (!this.options.clip && this.options.limitPoints && this.points.length) {\r\n\t            this.limitPoints();\r\n\t        }\r\n\r\n\t        this.box = targetBox;\r\n\t    },\r\n\r\n\t    valueSlot: function(valueAxis, plotRange) {\r\n\t        return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\r\n\t    },\r\n\r\n\t    limitPoints: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var categoryPoints = this.categoryPoints;\r\n\t        var points = categoryPoints[0].concat(last(categoryPoints));\r\n\t        for (var idx = 0; idx < points.length; idx++) {\r\n\t            if (points[idx]) {\r\n\t                this$1.limitPoint(points[idx]);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    limitPoint: function(point) {\r\n\t        var limittedSlot = this.categoryAxis.limitSlot(point.box);\r\n\t        if (!limittedSlot.equals(point.box)) {\r\n\t            point.reflow(limittedSlot);\r\n\t        }\r\n\t    },\r\n\r\n\t    aboveAxis: function(point, valueAxis) {\r\n\t        var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\r\n\t        var value = point.value;\r\n\r\n\t        return valueAxis.options.reverse ?\r\n\t            value < axisCrossingValue : value >= axisCrossingValue;\r\n\t    },\r\n\r\n\t    categoryAxisCrossingValue: function(valueAxis) {\r\n\t        var categoryAxis = this.categoryAxis;\r\n\t        var options = valueAxis.options;\r\n\t        var crossingValues = [].concat(\r\n\t            options.axisCrossingValues || options.axisCrossingValue\r\n\t        );\r\n\r\n\t        return crossingValues[categoryAxis.axisIndex || 0] || 0;\r\n\t    },\r\n\r\n\t    reflowPoint: function(point, pointSlot) {\r\n\t        point.reflow(pointSlot);\r\n\t    },\r\n\r\n\t    reflowCategories: function() { },\r\n\r\n\t    pointSlot: function(categorySlot, valueSlot) {\r\n\t        var options = this.options;\r\n\t        var invertAxes = options.invertAxes;\r\n\t        var slotX = invertAxes ? valueSlot : categorySlot;\r\n\t        var slotY = invertAxes ? categorySlot : valueSlot;\r\n\r\n\t        return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\r\n\t    },\r\n\r\n\t    categorySlot: function(categoryAxis, categoryIx) {\r\n\t        return categoryAxis.getSlot(categoryIx);\r\n\t    },\r\n\r\n\t    traverseDataPoints: function(callback) {\r\n\t        var this$1 = this;\r\n\r\n\t        var series = this.options.series;\r\n\t        var categories = this.categoryAxis.options.categories || [];\r\n\t        var count = categoriesCount(series);\r\n\t        var seriesCount = series.length;\r\n\r\n\t        for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\r\n\t            this$1._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\r\n\t        }\r\n\r\n\t        for (var categoryIx = 0; categoryIx < count; categoryIx++) {\r\n\t            for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {\r\n\t                var currentSeries = series[seriesIx$1];\r\n\t                var currentCategory = categories[categoryIx];\r\n\t                var pointData = this$1._bindPoint(currentSeries, seriesIx$1, categoryIx);\r\n\r\n\t                callback(pointData, {\r\n\t                    category: currentCategory,\r\n\t                    categoryIx: categoryIx,\r\n\t                    series: currentSeries,\r\n\t                    seriesIx: seriesIx$1\r\n\t                });\r\n\t            }\r\n\t        }\r\n\r\n\t        for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {\r\n\t            this$1._outOfRangeCallback(series[seriesIx$2], \"_outOfRangeMaxPoint\", seriesIx$2, callback);\r\n\t        }\r\n\t    },\r\n\r\n\t    _outOfRangeCallback: function(series, field, seriesIx, callback) {\r\n\t        var outOfRangePoint = series[field];\r\n\t        if (outOfRangePoint) {\r\n\t            var categoryIx = outOfRangePoint.categoryIx;\r\n\t            var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);\r\n\r\n\t            callback(pointData, {\r\n\t                category: outOfRangePoint.category,\r\n\t                categoryIx: categoryIx,\r\n\t                series: series,\r\n\t                seriesIx: seriesIx,\r\n\t                dataItem: outOfRangePoint.item\r\n\t            });\r\n\t        }\r\n\t    },\r\n\r\n\t    _bindPoint: function(series, seriesIx, categoryIx, item) {\r\n\t        if (!this._bindCache) {\r\n\t            this._bindCache = [];\r\n\t        }\r\n\r\n\t        var bindCache = this._bindCache[seriesIx];\r\n\t        if (!bindCache) {\r\n\t            bindCache = this._bindCache[seriesIx] = [];\r\n\t        }\r\n\r\n\t        var data = bindCache[categoryIx];\r\n\t        if (!data) {\r\n\t            data = bindCache[categoryIx] = SeriesBinder.current.bindPoint(series, categoryIx, item);\r\n\t        }\r\n\r\n\t        return data;\r\n\t    },\r\n\r\n\t    formatPointValue: function(point, format) {\r\n\t        if (point.value === null) {\r\n\t            return \"\";\r\n\t        }\r\n\r\n\t        return this.chartService.format.auto(format, point.value);\r\n\t    },\r\n\r\n\t    pointValue: function(data) {\r\n\t        return data.valueFields.value;\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(CategoricalChart, {\r\n\t    series: [],\r\n\t    invertAxes: false,\r\n\t    isStacked: false,\r\n\t    clip: true,\r\n\t    limitPoints: true\r\n\t});\r\n\r\n\tvar PointEventsMixin = {\r\n\t    click: function(chart, e) {\r\n\t        return chart.trigger(\r\n\t            SERIES_CLICK,\r\n\t            this.eventArgs(e)\r\n\t        );\r\n\t    },\r\n\r\n\t    hover: function(chart, e) {\r\n\t        return chart.trigger(\r\n\t            SERIES_HOVER,\r\n\t            this.eventArgs(e)\r\n\t        );\r\n\t    },\r\n\r\n\t    eventArgs: function(e) {\r\n\t        return {\r\n\t            value: this.value,\r\n\t            percentage: this.percentage,\r\n\t            stackValue: this.stackValue,\r\n\t            category: this.category,\r\n\t            series: this.series,\r\n\t            dataItem: this.dataItem,\r\n\t            runningTotal: this.runningTotal,\r\n\t            total: this.total,\r\n\t            element: eventElement(e),\r\n\t            originalEvent: e,\r\n\t            point: this\r\n\t        };\r\n\t    }\r\n\t};\r\n\r\n\tvar NoteMixin = {\r\n\t    createNote: function() {\r\n\t        var options = this.options.notes;\r\n\t        var text = this.noteText || options.label.text;\r\n\r\n\t        if (options.visible !== false && defined(text) && text !== null) {\r\n\t            this.note = new dataviz.Note({\r\n\t                value: this.value,\r\n\t                text: text,\r\n\t                dataItem: this.dataItem,\r\n\t                category: this.category,\r\n\t                series: this.series\r\n\t            }, this.options.notes, this.owner.chartService);\r\n\r\n\t            this.append(this.note);\r\n\t        }\r\n\t    }\r\n\t};\r\n\r\n\tvar LinePoint = ChartElement.extend({\r\n\t    init: function(value, options) {\r\n\t        ChartElement.fn.init.call(this);\r\n\r\n\t        this.value = value;\r\n\t        this.options = options;\r\n\t        this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\r\n\t        this.tooltipTracking = true;\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        var ref = this.options;\r\n\t        var markers = ref.markers;\r\n\t        var labels = ref.labels;\r\n\r\n\t        if (this._rendered) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        this._rendered = true;\r\n\r\n\t        if (markers.visible && markers.size) {\r\n\t            this.marker = this.createMarker();\r\n\t            this.append(this.marker);\r\n\t        }\r\n\r\n\t        if (labels.visible) {\r\n\t            var labelTemplate = getTemplate(labels);\r\n\t            var labelText = this.value;\r\n\t            if (labelTemplate) {\r\n\t                labelText = labelTemplate({\r\n\t                    dataItem: this.dataItem,\r\n\t                    category: this.category,\r\n\t                    value: this.value,\r\n\t                    percentage: this.percentage,\r\n\t                    stackValue: this.stackValue,\r\n\t                    series: this.series\r\n\t                });\r\n\t            } else if (labels.format) {\r\n\t                labelText = this.formatValue(labels.format);\r\n\t            }\r\n\t            this.label = new TextBox(labelText,\r\n\t                deepExtend({\r\n\t                    align: CENTER,\r\n\t                    vAlign: CENTER,\r\n\t                    margin: {\r\n\t                        left: 5,\r\n\t                        right: 5\r\n\t                    },\r\n\t                    zIndex: valueOrDefault(labels.zIndex, this.series.zIndex)\r\n\t                }, labels)\r\n\t            );\r\n\t            this.append(this.label);\r\n\t        }\r\n\r\n\t        this.createNote();\r\n\r\n\t        if (this.errorBar) {\r\n\t            this.append(this.errorBar);\r\n\t        }\r\n\t    },\r\n\r\n\t    markerBorder: function() {\r\n\t        var options = this.options.markers;\r\n\t        var background = options.background;\r\n\t        var border = deepExtend({ color: this.color }, options.border);\r\n\r\n\t        if (!defined(border.color)) {\r\n\t            border.color = new Color(background).brightness(BORDER_BRIGHTNESS).toHex();\r\n\t        }\r\n\r\n\t        return border;\r\n\t    },\r\n\r\n\t    createVisual: function() {},\r\n\r\n\t    createMarker: function() {\r\n\t        var options = this.options.markers;\r\n\t        var marker = new ShapeElement({\r\n\t            type: options.type,\r\n\t            width: options.size,\r\n\t            height: options.size,\r\n\t            rotation: options.rotation,\r\n\t            background: options.background,\r\n\t            border: this.markerBorder(),\r\n\t            opacity: options.opacity,\r\n\t            zIndex: valueOrDefault(options.zIndex, this.series.zIndex),\r\n\t            animation: options.animation,\r\n\t            visual: options.visual\r\n\t        }, {\r\n\t            dataItem: this.dataItem,\r\n\t            value: this.value,\r\n\t            series: this.series,\r\n\t            category: this.category\r\n\t        });\r\n\r\n\t        return marker;\r\n\t    },\r\n\r\n\t    markerBox: function() {\r\n\t        if (!this.marker) {\r\n\t            this.marker = this.createMarker();\r\n\t            this.marker.reflow(this._childBox);\r\n\t        }\r\n\r\n\t        return this.marker.box;\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var aboveAxis = ref.aboveAxis;\r\n\t        var vertical = options.vertical;\r\n\r\n\t        this.render();\r\n\r\n\t        this.box = targetBox;\r\n\t        var childBox = targetBox.clone();\r\n\r\n\t        if (vertical) {\r\n\t            if (aboveAxis) {\r\n\t                childBox.y1 -= childBox.height();\r\n\t            } else {\r\n\t                childBox.y2 += childBox.height();\r\n\t            }\r\n\t        } else {\r\n\t            if (aboveAxis) {\r\n\t                childBox.x1 += childBox.width();\r\n\t            } else {\r\n\t                childBox.x2 -= childBox.width();\r\n\t            }\r\n\t        }\r\n\r\n\t        this._childBox = childBox;\r\n\t        if (this.marker) {\r\n\t            this.marker.reflow(childBox);\r\n\t        }\r\n\r\n\t        this.reflowLabel(childBox);\r\n\r\n\t        if (this.errorBars) {\r\n\t            for (var i = 0; i < this.errorBars.length; i++) {\r\n\t                this$1.errorBars[i].reflow(childBox);\r\n\t            }\r\n\t        }\r\n\r\n\t        if (this.note) {\r\n\t            var noteTargetBox = this.markerBox();\r\n\r\n\t            if (!(options.markers.visible && options.markers.size)) {\r\n\t                var center = noteTargetBox.center();\r\n\t                noteTargetBox = new Box(center.x, center.y, center.x, center.y);\r\n\t            }\r\n\r\n\t            this.note.reflow(noteTargetBox);\r\n\t        }\r\n\t    },\r\n\r\n\t    reflowLabel: function(box) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var label = ref.label;\r\n\t        var anchor = options.labels.position;\r\n\r\n\t        if (label) {\r\n\t            anchor = anchor === ABOVE ? TOP : anchor;\r\n\t            anchor = anchor === BELOW ? BOTTOM : anchor;\r\n\r\n\t            label.reflow(box);\r\n\t            label.box.alignTo(this.markerBox(), anchor);\r\n\t            label.reflow(label.box);\r\n\t        }\r\n\t    },\r\n\r\n\t    createHighlight: function() {\r\n\t        var markers = this.options.highlight.markers;\r\n\t        var defaultColor = this.markerBorder().color;\r\n\t        var options = this.options.markers;\r\n\t        var size = options.size + (options.border.width || 0) + (markers.border.width || 0);\r\n\r\n\t        var shadow = new ShapeElement({\r\n\t            type: options.type,\r\n\t            width: size,\r\n\t            height: size,\r\n\t            rotation: options.rotation,\r\n\t            background: markers.color || defaultColor,\r\n\t            border: {\r\n\t                color: markers.border.color,\r\n\t                width: markers.border.width,\r\n\t                opacity: valueOrDefault(markers.border.opacity, 1)\r\n\t            },\r\n\t            opacity: valueOrDefault(markers.opacity, 1)\r\n\t        });\r\n\t        shadow.reflow(this._childBox);\r\n\r\n\t        return shadow.getElement();\r\n\t    },\r\n\r\n\t    highlightVisual: function() {\r\n\t        return (this.marker || {}).visual;\r\n\t    },\r\n\r\n\t    highlightVisualArgs: function() {\r\n\t        var marker = this.marker;\r\n\t        var visual, rect;\r\n\r\n\t        if (marker) {\r\n\t            rect = marker.paddingBox.toRect();\r\n\t            visual = marker.visual;\r\n\t        } else {\r\n\t            var size = this.options.markers.size;\r\n\t            var halfSize = size / 2;\r\n\t            var center = this.box.center();\r\n\t            rect = new geometry.Rect([ center.x - halfSize, center.y - halfSize ], [ size, size ]);\r\n\t        }\r\n\r\n\t        return {\r\n\t            options: this.options,\r\n\t            rect: rect,\r\n\t            visual: visual\r\n\t        };\r\n\t    },\r\n\r\n\t    tooltipAnchor: function() {\r\n\t        var markerBox = this.markerBox();\r\n\t        var clipBox = this.owner.pane.clipBox();\r\n\t        var showTooltip = !clipBox || clipBox.overlaps(markerBox);\r\n\r\n\t        if (showTooltip) {\r\n\t            var x = markerBox.x2 + TOOLTIP_OFFSET;\r\n\t            var horizontalAlign = LEFT;\r\n\t            var y, verticalAlign;\r\n\r\n\t            if (this.aboveAxis) {\r\n\t                y = markerBox.y1;\r\n\t                verticalAlign = BOTTOM;\r\n\t            } else {\r\n\t                y = markerBox.y2;\r\n\t                verticalAlign = TOP;\r\n\t            }\r\n\r\n\t            return {\r\n\t                point: new Point(x, y),\r\n\t                align: {\r\n\t                    horizontal: horizontalAlign,\r\n\t                    vertical: verticalAlign\r\n\t                }\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    formatValue: function(format) {\r\n\t        return this.owner.formatPointValue(this, format);\r\n\t    },\r\n\r\n\t    overlapsBox: function(box) {\r\n\t        var markerBox = this.markerBox();\r\n\t        return markerBox.overlaps(box);\r\n\t    },\r\n\r\n\t    unclipElements: function() {\r\n\t        if (this.label) {\r\n\t            this.label.options.noclip = true;\r\n\t        }\r\n\r\n\t        if (this.note) {\r\n\t            this.note.options.noclip = true;\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tLinePoint.prototype.defaults = {\r\n\t    vertical: true,\r\n\t    markers: {\r\n\t        visible: true,\r\n\t        background: WHITE,\r\n\t        size: LINE_MARKER_SIZE,\r\n\t        type: CIRCLE,\r\n\t        border: {\r\n\t            width: 2\r\n\t        },\r\n\t        opacity: 1\r\n\t    },\r\n\t    labels: {\r\n\t        visible: false,\r\n\t        position: ABOVE,\r\n\t        margin: getSpacing(3),\r\n\t        padding: getSpacing(4),\r\n\t        animation: {\r\n\t            type: FADEIN,\r\n\t            delay: INITIAL_ANIMATION_DURATION\r\n\t        }\r\n\t    },\r\n\t    notes: {\r\n\t        label: {}\r\n\t    },\r\n\t    highlight: {\r\n\t        markers: {\r\n\t            border: {\r\n\t                color: \"#fff\",\r\n\t                width: 2\r\n\t            }\r\n\t        },\r\n\t        zIndex: datavizConstants.HIGHLIGHT_ZINDEX\r\n\t    },\r\n\t    errorBars: {\r\n\t        line: {\r\n\t            width: 1\r\n\t        }\r\n\t    }\r\n\t};\r\n\r\n\tdeepExtend(LinePoint.prototype, PointEventsMixin);\r\n\tdeepExtend(LinePoint.prototype, NoteMixin);\r\n\r\n\tvar LineSegment = ChartElement.extend({\r\n\t    init: function(linePoints, series, seriesIx) {\r\n\t        ChartElement.fn.init.call(this);\r\n\r\n\t        this.linePoints = linePoints;\r\n\t        this.series = series;\r\n\t        this.seriesIx = seriesIx;\r\n\t    },\r\n\r\n\t    points: function() {\r\n\t        return this.toGeometryPoints(this.linePoints);\r\n\t    },\r\n\r\n\t    toGeometryPoints: function(points) {\r\n\t        var result = [];\r\n\t        for (var i = 0, length = points.length; i < length; i++) {\r\n\t            if (points[i] && points[i].visible !== false) {\r\n\t                result.push(points[i]._childBox.toRect().center());\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var series = ref.series;\r\n\t        var color = series.color;\r\n\t        var defaults = series._defaults;\r\n\r\n\t        if (isFunction(color) && defaults) {\r\n\t            color = defaults.color;\r\n\t        }\r\n\r\n\t        var line = Path.fromPoints(this.points(), {\r\n\t            stroke: {\r\n\t                color: color,\r\n\t                width: series.width,\r\n\t                opacity: series.opacity,\r\n\t                dashType: series.dashType\r\n\t            },\r\n\t            zIndex: series.zIndex\r\n\t        });\r\n\r\n\t        if (options.closed) {\r\n\t            line.close();\r\n\t        }\r\n\r\n\t        this.visual = line;\r\n\t    },\r\n\r\n\t    aliasFor: function(e, coords) {\r\n\t        return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(LineSegment, {\r\n\t    closed: false\r\n\t});\r\n\r\n\tvar StepLineMixin = {\r\n\t    calculateStepPoints: function(points) {\r\n\t        var categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);\r\n\t        var ref = categoryAxis.options;\r\n\t        var justified = ref.justified;\r\n\t        var vertical = ref.vertical;\r\n\t        var reverse = ref.reverse;\r\n\r\n\t        var stepAxis = vertical ? X : Y;\r\n\t        var axis = vertical ? Y : X;\r\n\t        var stepDir = reverse ? 2 : 1;\r\n\t        var dir = stepDir;\r\n\r\n\t        var previousPoint = toGeometryPoint(points[0], stepAxis, stepDir, axis, dir);\r\n\t        var result = [ previousPoint ];\r\n\r\n\t        for (var idx = 1; idx < points.length; idx++) {\r\n\t            var point = toGeometryPoint(points[idx], stepAxis, stepDir, axis, dir);\r\n\r\n\t            if (previousPoint[stepAxis] !== point[stepAxis]) {\r\n\t                var stepPoint = new GeometryPoint();\r\n\t                stepPoint[stepAxis] = previousPoint[stepAxis];\r\n\t                stepPoint[axis] = point[axis];\r\n\r\n\t                result.push(stepPoint, point);\r\n\t            }\r\n\r\n\t            previousPoint = point;\r\n\t        }\r\n\r\n\t        if (!justified) {\r\n\t            result.push(toGeometryPoint(last(points), stepAxis, stepDir, axis, reverse ? 1 : 2));\r\n\t        } else if (previousPoint !== last(result)) {\r\n\t            result.push(previousPoint);\r\n\t        }\r\n\r\n\t        return result;\r\n\r\n\t    }\r\n\t};\r\n\r\n\tfunction toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {\r\n\t    var box = lintPoint.box;\r\n\t    var result = new GeometryPoint();\r\n\r\n\t    result[stepAxis] = box[stepAxis + stepDir];\r\n\t    result[axis] = box[axis + dir];\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tvar StepLineSegment = LineSegment.extend({\r\n\t    points: function() {\r\n\t        return this.calculateStepPoints(this.linePoints);\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(StepLineSegment.prototype, StepLineMixin);\r\n\r\n\tvar SplineSegment = LineSegment.extend({\r\n\t    createVisual: function() {\r\n\t        var series = this.series;\r\n\t        var defaults = series._defaults;\r\n\t        var color = series.color;\r\n\r\n\t        if (isFunction(color) && defaults) {\r\n\t            color = defaults.color;\r\n\t        }\r\n\r\n\t        var curveProcessor = new CurveProcessor(this.options.closed);\r\n\t        var segments = curveProcessor.process(this.points());\r\n\t        var curve = new Path({\r\n\t            stroke: {\r\n\t                color: color,\r\n\t                width: series.width,\r\n\t                opacity: series.opacity,\r\n\t                dashType: series.dashType\r\n\t            },\r\n\t            zIndex: series.zIndex\r\n\t        });\r\n\r\n\t        curve.segments.push.apply(curve.segments, segments);\r\n\r\n\t        this.visual = curve;\r\n\t    }\r\n\t});\r\n\r\n\tvar LineChartMixin = {\r\n\t    renderSegments: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var seriesPoints = ref.seriesPoints;\r\n\t        var series = options.series;\r\n\t        var seriesCount = seriesPoints.length;\r\n\t        var lastSegment;\r\n\r\n\t        this._segments = [];\r\n\r\n\t        for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\r\n\t            var currentSeries = series[seriesIx];\r\n\t            var sortedPoints = this$1.sortPoints(seriesPoints[seriesIx]);\r\n\t            var pointCount = sortedPoints.length;\r\n\t            var linePoints = [];\r\n\r\n\t            for (var pointIx = 0; pointIx < pointCount; pointIx++) {\r\n\t                var point = sortedPoints[pointIx];\r\n\t                if (point) {\r\n\t                    linePoints.push(point);\r\n\t                } else if (this$1.seriesMissingValues(currentSeries) !== INTERPOLATE) {\r\n\t                    if (linePoints.length > 1) {\r\n\t                        lastSegment = this$1.createSegment(\r\n\t                            linePoints, currentSeries, seriesIx, lastSegment\r\n\t                        );\r\n\t                        this$1._addSegment(lastSegment);\r\n\t                    }\r\n\t                    linePoints = [];\r\n\t                }\r\n\t            }\r\n\r\n\t            if (linePoints.length > 1) {\r\n\t                lastSegment = this$1.createSegment(\r\n\t                    linePoints, currentSeries, seriesIx, lastSegment\r\n\t                );\r\n\t                this$1._addSegment(lastSegment);\r\n\t            }\r\n\t        }\r\n\r\n\t        this.children.unshift.apply(this.children, this._segments);\r\n\t    },\r\n\r\n\t    _addSegment: function(segment) {\r\n\t        this._segments.push(segment);\r\n\t        segment.parent = this;\r\n\t    },\r\n\r\n\t    sortPoints: function(points) {\r\n\t        return points;\r\n\t    },\r\n\r\n\t    seriesMissingValues: function(series) {\r\n\t        var missingValues = series.missingValues;\r\n\t        var assumeZero = !missingValues && this.options.isStacked;\r\n\r\n\t        return assumeZero ? ZERO : missingValues || INTERPOLATE;\r\n\t    },\r\n\r\n\t    getNearestPoint: function(x, y, seriesIx) {\r\n\t        var target = new Point(x, y);\r\n\t        var allPoints = this.seriesPoints[seriesIx];\r\n\t        var nearestPointDistance = MAX_VALUE;\r\n\t        var nearestPoint;\r\n\r\n\t        for (var i = 0; i < allPoints.length; i++) {\r\n\t            var point = allPoints[i];\r\n\r\n\t            if (point && defined(point.value) && point.value !== null && point.visible !== false) {\r\n\t                var pointBox = point.box;\r\n\t                var pointDistance = pointBox.center().distanceTo(target);\r\n\r\n\t                if (pointDistance < nearestPointDistance) {\r\n\t                    nearestPoint = point;\r\n\t                    nearestPointDistance = pointDistance;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return nearestPoint;\r\n\t    }\r\n\t};\r\n\r\n\tvar ClipAnimation = Animation.extend({\r\n\t    setup: function() {\r\n\t        this._setEnd(this.options.box.x1);\r\n\t    },\r\n\r\n\t    step: function(pos) {\r\n\t        var box = this.options.box;\r\n\t        this._setEnd(dataviz.interpolateValue(box.x1, box.x2, pos));\r\n\t    },\r\n\r\n\t    _setEnd: function(x) {\r\n\t        var element = this.element;\r\n\t        var segments = element.segments;\r\n\t        var topRight = segments[1].anchor();\r\n\t        var bottomRight = segments[2].anchor();\r\n\r\n\t        element.suspend();\r\n\t        topRight.setX(x);\r\n\t        element.resume();\r\n\t        bottomRight.setX(x);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(ClipAnimation, {\r\n\t    duration: INITIAL_ANIMATION_DURATION\r\n\t});\r\n\r\n\tAnimationFactory.current.register(\"clip\", ClipAnimation);\r\n\r\n\tfunction anyHasZIndex(elements) {\r\n\t    for (var idx = 0; idx < elements.length; idx++) {\r\n\t        if (defined(elements[idx].zIndex)) {\r\n\t            return true;\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tvar ClipAnimationMixin = {\r\n\t    createAnimation: function() {\r\n\t        var root = this.getRoot();\r\n\t        if (root && (root.options || {}).transitions !== false) {\r\n\t            var box = root.box;\r\n\t            var clipPath = Path.fromRect(box.toRect());\r\n\t            this.visual.clip(clipPath);\r\n\t            this.animation = new ClipAnimation(clipPath, {\r\n\t                box: box\r\n\t            });\r\n\t            if (anyHasZIndex(this.options.series)) {\r\n\t                this._setChildrenAnimation(clipPath);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _setChildrenAnimation: function(clipPath) {\r\n\t        var points = this.animationPoints();\r\n\r\n\t        for (var idx = 0; idx < points.length; idx++) {\r\n\t            var point = points[idx];\r\n\t            if (point && point.visual && defined(point.visual.options.zIndex)) {\r\n\t                point.visual.clip(clipPath);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t};\r\n\r\n\tvar LineChart = CategoricalChart.extend({\r\n\t    render: function() {\r\n\r\n\t        CategoricalChart.fn.render.call(this);\r\n\r\n\t        this.updateStackRange();\r\n\t        this.renderSegments();\r\n\t    },\r\n\r\n\t    pointType: function() {\r\n\t        return LinePoint;\r\n\t    },\r\n\r\n\t    createPoint: function(data, fields) {\r\n\t        var categoryIx = fields.categoryIx;\r\n\t        var category = fields.category;\r\n\t        var series = fields.series;\r\n\t        var seriesIx = fields.seriesIx;\r\n\t        var missingValues = this.seriesMissingValues(series);\r\n\t        var value = data.valueFields.value;\r\n\r\n\t        if (!defined(value) || value === null) {\r\n\t            if (missingValues === ZERO) {\r\n\t                value = 0;\r\n\t            } else {\r\n\t                return null;\r\n\t            }\r\n\t        }\r\n\r\n\t        var pointOptions = this.pointOptions(series, seriesIx);\r\n\t        pointOptions = this.evalPointOptions(\r\n\t            pointOptions, value, category, categoryIx, series, seriesIx\r\n\t        );\r\n\r\n\t        var color = data.fields.color || series.color;\r\n\t        if (isFunction(series.color)) {\r\n\t            color = pointOptions.color;\r\n\t        }\r\n\r\n\t        var point = new LinePoint(value, pointOptions);\r\n\t        point.color = color;\r\n\r\n\t        this.append(point);\r\n\r\n\t        return point;\r\n\t    },\r\n\r\n\t    plotRange: function(point) {\r\n\t        var this$1 = this;\r\n\r\n\t        var plotValue = this.plotValue(point);\r\n\r\n\t        if (this.options.isStacked) {\r\n\t            var categoryIx = point.categoryIx;\r\n\t            var categoryPoints = this.categoryPoints[categoryIx];\r\n\r\n\t            for (var i = 0; i < categoryPoints.length; i++) {\r\n\t                var other = categoryPoints[i];\r\n\r\n\t                if (point === other) {\r\n\t                    break;\r\n\t                }\r\n\r\n\t                plotValue += this$1.plotValue(other);\r\n\r\n\t                if (this$1.options.isStacked100) {\r\n\t                    plotValue = Math.min(plotValue, 1);\r\n\t                }\r\n\t            }\r\n\r\n\t        }\r\n\r\n\t        return [ plotValue, plotValue ];\r\n\t    },\r\n\r\n\t    createSegment: function(linePoints, currentSeries, seriesIx) {\r\n\t        var style = currentSeries.style;\r\n\t        var pointType;\r\n\r\n\t        if (style === STEP) {\r\n\t            pointType = StepLineSegment;\r\n\t        } else if (style === SMOOTH) {\r\n\t            pointType = SplineSegment;\r\n\t        } else {\r\n\t            pointType = LineSegment;\r\n\t        }\r\n\r\n\t        return new pointType(linePoints, currentSeries, seriesIx);\r\n\t    },\r\n\r\n\t    animationPoints: function() {\r\n\t        var points = this.points;\r\n\t        var result = [];\r\n\t        for (var idx = 0; idx < points.length; idx++) {\r\n\t            result.push((points[idx] || {}).marker);\r\n\t        }\r\n\t        return result.concat(this._segments);\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(LineChart.prototype, LineChartMixin, ClipAnimationMixin);\r\n\r\n\tvar AreaSegment = LineSegment.extend({\r\n\t    init: function(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {\r\n\t        LineSegment.fn.init.call(this, linePoints, currentSeries, seriesIx);\r\n\r\n\t        this.prevSegment = prevSegment;\r\n\t        this.stackPoints = stackPoints;\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        var series = this.series;\r\n\t        var defaults = series._defaults;\r\n\t        var lineOptions = series.line || {};\r\n\t        var color = series.color;\r\n\r\n\t        if (isFunction(color) && defaults) {\r\n\t            color = defaults.color;\r\n\t        }\r\n\r\n\t        this.visual = new Group({\r\n\t            zIndex: series.zIndex\r\n\t        });\r\n\r\n\t        this.createFill({\r\n\t            fill: {\r\n\t                color: color,\r\n\t                opacity: series.opacity\r\n\t            },\r\n\t            stroke: null\r\n\t        });\r\n\r\n\t        if (lineOptions.width > 0 && lineOptions.visible !== false) {\r\n\t            this.createStroke({\r\n\t                stroke: deepExtend({\r\n\t                    color: color,\r\n\t                    opacity: series.opacity,\r\n\t                    lineCap: \"butt\"\r\n\t                }, lineOptions)\r\n\t            });\r\n\t        }\r\n\t    },\r\n\r\n\t    strokeSegments: function() {\r\n\t        var segments = this._strokeSegments;\r\n\r\n\t        if (!segments) {\r\n\t            segments = this._strokeSegments = this.createStrokeSegments();\r\n\t        }\r\n\r\n\t        return segments;\r\n\t    },\r\n\r\n\t    createStrokeSegments: function() {\r\n\t        return this.segmentsFromPoints(this.points());\r\n\t    },\r\n\r\n\t    stackSegments: function() {\r\n\t        if (this.prevSegment) {\r\n\t            return this.prevSegment.createStackSegments(this.stackPoints);\r\n\t        }\r\n\r\n\t        return this.createStackSegments(this.stackPoints);\r\n\t    },\r\n\r\n\t    createStackSegments: function(stackPoints) {\r\n\t        return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();\r\n\t    },\r\n\r\n\t    segmentsFromPoints: function(points) {\r\n\t        return points.map(function (point) { return new geometry.Segment(point); });\r\n\t    },\r\n\r\n\t    createStroke: function(style) {\r\n\t        var stroke = new Path(style);\r\n\t        stroke.segments.push.apply(stroke.segments, this.strokeSegments());\r\n\r\n\t        this.visual.append(stroke);\r\n\t    },\r\n\r\n\t    hasStackSegment: function() {\r\n\t        return this.prevSegment || (this.stackPoints && this.stackPoints.length);\r\n\t    },\r\n\r\n\t    createFill: function(style) {\r\n\t        var strokeSegments = this.strokeSegments();\r\n\t        var fillSegments = strokeSegments.slice(0);\r\n\t        var hasStackSegments = this.hasStackSegment();\r\n\r\n\t        if (hasStackSegments) {\r\n\t            var stackSegments = this.stackSegments();\r\n\r\n\t            append(fillSegments, stackSegments);\r\n\t        }\r\n\r\n\t        var fill = new Path(style);\r\n\t        fill.segments.push.apply(fill.segments, fillSegments);\r\n\r\n\t        if (!hasStackSegments && strokeSegments.length > 1) {\r\n\t            this.fillToAxes(fill);\r\n\t        }\r\n\r\n\t        this.visual.append(fill);\r\n\t    },\r\n\r\n\t    fillToAxes: function(fillPath) {\r\n\t        var chart = this.parent;\r\n\t        var invertAxes = chart.options.invertAxes;\r\n\t        var valueAxis = chart.seriesValueAxis(this.series);\r\n\t        var crossingValue = chart.categoryAxisCrossingValue(valueAxis);\r\n\t        var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);\r\n\t        var segments = this.strokeSegments();\r\n\t        var firstPoint = segments[0].anchor();\r\n\t        var lastPoint = last(segments).anchor();\r\n\t        var end = invertAxes ? endSlot.x1 : endSlot.y1;\r\n\r\n\t        if (invertAxes) {\r\n\t            fillPath.lineTo(end, lastPoint.y)\r\n\t                    .lineTo(end, firstPoint.y);\r\n\t        } else {\r\n\t            fillPath.lineTo(lastPoint.x, end)\r\n\t                    .lineTo(firstPoint.x, end);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar StepAreaSegment = AreaSegment.extend({\r\n\t    createStrokeSegments: function() {\r\n\t        return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));\r\n\t    },\r\n\r\n\t    createStackSegments: function(stackPoints) {\r\n\t        return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(StepAreaSegment.prototype, StepLineMixin);\r\n\r\n\tvar SplineAreaSegment = AreaSegment.extend({\r\n\t    createStrokeSegments: function() {\r\n\t        var curveProcessor = new CurveProcessor(this.options.closed);\r\n\t        var linePoints = this.points();\r\n\r\n\t        return curveProcessor.process(linePoints);\r\n\t    },\r\n\r\n\t    createStackSegments: function() {\r\n\t        var strokeSegments = this.strokeSegments();\r\n\t        var stackSegments = [];\r\n\t        for (var idx = strokeSegments.length - 1; idx >= 0; idx--) {\r\n\t            var segment = strokeSegments[idx];\r\n\t            stackSegments.push(new geometry.Segment(\r\n\t                segment.anchor(),\r\n\t                segment.controlOut(),\r\n\t                segment.controlIn()\r\n\t            ));\r\n\t        }\r\n\r\n\t        return stackSegments;\r\n\t    }\r\n\t});\r\n\r\n\tvar AreaChart = LineChart.extend({\r\n\t    createSegment: function(linePoints, currentSeries, seriesIx, prevSegment) {\r\n\t        var isStacked = this.options.isStacked;\r\n\t        var style = (currentSeries.line || {}).style;\r\n\t        var previousSegment;\r\n\r\n\t        var stackPoints;\r\n\t        if (isStacked && seriesIx > 0 && prevSegment) {\r\n\t            var missingValues = this.seriesMissingValues(currentSeries);\r\n\t            if (missingValues !== \"gap\") {\r\n\t                stackPoints = prevSegment.linePoints;\r\n\t                previousSegment = prevSegment;\r\n\t            } else {\r\n\t                stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\r\n\t            }\r\n\t        }\r\n\r\n\t        var pointType;\r\n\t        if (style === STEP) {\r\n\t            pointType = StepAreaSegment;\r\n\t        } else if (style === SMOOTH) {\r\n\t            pointType = SplineAreaSegment;\r\n\t        } else {\r\n\t            pointType = AreaSegment;\r\n\t        }\r\n\r\n\t        return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var this$1 = this;\r\n\r\n\t        LineChart.fn.reflow.call(this, targetBox);\r\n\r\n\t        var stackPoints = this._stackPoints;\r\n\t        if (stackPoints) {\r\n\t            for (var idx = 0; idx < stackPoints.length; idx++) {\r\n\t                var stackPoint = stackPoints[idx];\r\n\t                var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);\r\n\t                stackPoint.reflow(pointSlot);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _gapStackPoints: function(linePoints, seriesIx, style) {\r\n\t        var this$1 = this;\r\n\r\n\t        var seriesPoints = this.seriesPoints;\r\n\t        var startIdx = linePoints[0].categoryIx;\r\n\t        var length = linePoints.length;\r\n\t        if (startIdx < 0) {\r\n\t            startIdx = 0;\r\n\t            length--;\r\n\t        }\r\n\r\n\t        var endIdx = startIdx + length;\r\n\t        var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\r\n\t        var stackPoints = [];\r\n\r\n\t        this._stackPoints = this._stackPoints || [];\r\n\t        for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\r\n\t            var pointIx = categoryIx + pointOffset;\r\n\t            var currentSeriesIx = seriesIx;\r\n\t            var point = (void 0);\r\n\r\n\t            do {\r\n\t                currentSeriesIx--;\r\n\t                point = seriesPoints[currentSeriesIx][pointIx];\r\n\t            } while (currentSeriesIx > 0 && !point);\r\n\r\n\t            if (point) {\r\n\t                if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\r\n\t                    stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\r\n\t                }\r\n\r\n\t                stackPoints.push(point);\r\n\r\n\t                if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\r\n\t                    stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\r\n\t                }\r\n\t            } else {\r\n\t                var gapStackPoint = this$1._createGapStackPoint(categoryIx);\r\n\t                this$1._stackPoints.push(gapStackPoint);\r\n\t                stackPoints.push(gapStackPoint);\r\n\t            }\r\n\t        }\r\n\r\n\t        return stackPoints;\r\n\t    },\r\n\r\n\t    _previousSegmentPoint: function(categoryIx, pointIx, segmentIx, seriesIdx) {\r\n\t        var seriesPoints = this.seriesPoints;\r\n\t        var index = seriesIdx;\r\n\t        var point;\r\n\r\n\t        while (index > 0 && !point) {\r\n\t            index--;\r\n\t            point = seriesPoints[index][segmentIx];\r\n\t        }\r\n\r\n\t        if (!point) {\r\n\t            point = this._createGapStackPoint(categoryIx);\r\n\t            this._stackPoints.push(point);\r\n\t        } else {\r\n\t            point = seriesPoints[index][pointIx];\r\n\t        }\r\n\r\n\t        return point;\r\n\t    },\r\n\r\n\t    _createGapStackPoint: function(categoryIx) {\r\n\t        var options = this.pointOptions({}, 0);\r\n\t        var point = new LinePoint(0, options);\r\n\t        point.categoryIx = categoryIx;\r\n\t        point.series = {};\r\n\r\n\t        return point;\r\n\t    },\r\n\r\n\t    seriesMissingValues: function(series) {\r\n\t        return series.missingValues || ZERO;\r\n\t    }\r\n\t});\r\n\r\n\tvar AxisGroupRangeTracker = Class.extend({\r\n\t    init: function() {\r\n\r\n\t        this.axisRanges = {};\r\n\t    },\r\n\r\n\t    update: function(chartAxisRanges) {\r\n\t        var axisRanges = this.axisRanges;\r\n\r\n\t        for (var axisName in chartAxisRanges) {\r\n\t            var chartRange = chartAxisRanges[axisName];\r\n\t            var range = axisRanges[axisName];\r\n\t            axisRanges[axisName] = range = range || { min: MAX_VALUE, max: MIN_VALUE };\r\n\r\n\t            range.min = Math.min(range.min, chartRange.min);\r\n\t            range.max = Math.max(range.max, chartRange.max);\r\n\t        }\r\n\t    },\r\n\r\n\t    reset: function(axisName) {\r\n\t        this.axisRanges[axisName] = undefined;\r\n\t    },\r\n\r\n\t    query: function(axisName) {\r\n\t        return this.axisRanges[axisName];\r\n\t    }\r\n\t});\r\n\r\n\tvar BarLabel = ChartElement.extend({\r\n\t    init: function(content, options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.textBox = new TextBox(content, this.options);\r\n\t        this.append(this.textBox);\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        this.textBox.options.noclip = this.options.noclip;\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var options = this.options;\r\n\t        var vertical = options.vertical;\r\n\t        var aboveAxis = options.aboveAxis;\r\n\t        var text = this.children[0];\r\n\t        var textOptions = text.options;\r\n\t        var box = text.box;\r\n\t        var padding = text.options.padding;\r\n\t        var labelBox = targetBox;\r\n\r\n\t        textOptions.align = vertical ? CENTER : LEFT;\r\n\t        textOptions.vAlign = vertical ? TOP : CENTER;\r\n\r\n\t        if (options.position === INSIDE_END) {\r\n\t            if (vertical) {\r\n\t                textOptions.vAlign = TOP;\r\n\r\n\t                if (!aboveAxis && box.height() < targetBox.height()) {\r\n\t                    textOptions.vAlign = BOTTOM;\r\n\t                }\r\n\t            } else {\r\n\t                textOptions.align = aboveAxis ? RIGHT : LEFT;\r\n\t            }\r\n\t        } else if (options.position === CENTER) {\r\n\t            textOptions.vAlign = CENTER;\r\n\t            textOptions.align = CENTER;\r\n\t        } else if (options.position === INSIDE_BASE) {\r\n\t            if (vertical) {\r\n\t                textOptions.vAlign = aboveAxis ? BOTTOM : TOP;\r\n\t            } else {\r\n\t                textOptions.align = aboveAxis ? LEFT : RIGHT;\r\n\t            }\r\n\t        } else if (options.position === OUTSIDE_END) {\r\n\t            if (vertical) {\r\n\t                if (aboveAxis) {\r\n\t                    labelBox = new Box(\r\n\t                        targetBox.x1, targetBox.y1 - box.height(),\r\n\t                        targetBox.x2, targetBox.y1\r\n\t                    );\r\n\t                } else {\r\n\t                    labelBox = new Box(\r\n\t                        targetBox.x1, targetBox.y2,\r\n\t                        targetBox.x2, targetBox.y2 + box.height()\r\n\t                    );\r\n\t                }\r\n\t            } else {\r\n\t                textOptions.align = CENTER;\r\n\t                if (aboveAxis) {\r\n\t                    labelBox = new Box(\r\n\t                        targetBox.x2, targetBox.y1,\r\n\t                        targetBox.x2 + box.width(), targetBox.y2\r\n\t                    );\r\n\t                } else {\r\n\t                    labelBox = new Box(\r\n\t                        targetBox.x1 - box.width(), targetBox.y1,\r\n\t                        targetBox.x1, targetBox.y2\r\n\t                    );\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (!options.rotation) {\r\n\t            if (vertical) {\r\n\t                padding.left = padding.right =\r\n\t                    (labelBox.width() - text.contentBox.width()) / 2;\r\n\t            } else {\r\n\t                padding.top = padding.bottom =\r\n\t                    (labelBox.height() - text.contentBox.height()) / 2;\r\n\t            }\r\n\t        }\r\n\r\n\t        text.reflow(labelBox);\r\n\t    },\r\n\r\n\t    alignToClipBox: function(clipBox) {\r\n\t        var vertical = this.options.vertical;\r\n\t        var field = vertical ? Y : X;\r\n\t        var start = field + \"1\";\r\n\t        var end = field + \"2\";\r\n\t        var text = this.children[0];\r\n\t        var parentBox = this.parent.box;\r\n\r\n\t        if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {\r\n\t            var targetBox = text.paddingBox.clone();\r\n\t            targetBox[start] = Math.max(parentBox[start], clipBox[start]);\r\n\t            targetBox[end] = Math.min(parentBox[end], clipBox[end]);\r\n\r\n\t            this.reflow(targetBox);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(BarLabel, {\r\n\t    position: OUTSIDE_END,\r\n\t    margin: getSpacing(3),\r\n\t    padding: getSpacing(4),\r\n\t    color: BLACK,\r\n\t    background: \"\",\r\n\t    border: {\r\n\t        width: 1,\r\n\t        color: \"\"\r\n\t    },\r\n\t    aboveAxis: true,\r\n\t    vertical: false,\r\n\t    animation: {\r\n\t        type: FADEIN,\r\n\t        delay: INITIAL_ANIMATION_DURATION\r\n\t    },\r\n\t    zIndex: 2\r\n\t});\r\n\r\n\tfunction hasGradientOverlay(options) {\r\n\t    var overlay = options.overlay;\r\n\r\n\t    return overlay && overlay.gradient && overlay.gradient !== \"none\";\r\n\t}\r\n\r\n\tvar BAR_ALIGN_MIN_WIDTH = 6;\r\n\r\n\tvar Bar = ChartElement.extend({\r\n\t    init: function(value, options) {\r\n\t        ChartElement.fn.init.call(this);\r\n\r\n\t        this.options = options;\r\n\t        this.color = options.color || WHITE;\r\n\t        this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\r\n\t        this.value = value;\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        if (this._rendered) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        this._rendered = true;\r\n\r\n\t        this.createLabel();\r\n\t        this.createNote();\r\n\r\n\t        if (this.errorBar) {\r\n\t            this.append(this.errorBar);\r\n\t        }\r\n\t    },\r\n\r\n\t    createLabel: function() {\r\n\t        var options = this.options;\r\n\t        var labels = options.labels;\r\n\r\n\t        if (labels.visible) {\r\n\t            var labelTemplate = getTemplate(labels);\r\n\t            var labelText;\r\n\r\n\t            if (labelTemplate) {\r\n\t                labelText = labelTemplate({\r\n\t                    dataItem: this.dataItem,\r\n\t                    category: this.category,\r\n\t                    value: this.value,\r\n\t                    percentage: this.percentage,\r\n\t                    stackValue: this.stackValue,\r\n\t                    runningTotal: this.runningTotal,\r\n\t                    total: this.total,\r\n\t                    series: this.series\r\n\t                });\r\n\t            } else {\r\n\t                labelText = this.formatValue(labels.format);\r\n\t            }\r\n\r\n\t            this.label = new BarLabel(labelText,\r\n\t                    deepExtend({\r\n\t                        vertical: options.vertical\r\n\t                    },\r\n\t                    labels\r\n\t                ));\r\n\t            this.append(this.label);\r\n\t        }\r\n\t    },\r\n\r\n\t    formatValue: function(format) {\r\n\t        return this.owner.formatPointValue(this, format);\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var this$1 = this;\r\n\r\n\t        this.render();\r\n\r\n\t        var label = this.label;\r\n\r\n\t        this.box = targetBox;\r\n\r\n\t        if (label) {\r\n\t            label.options.aboveAxis = this.aboveAxis;\r\n\t            label.reflow(targetBox);\r\n\t        }\r\n\r\n\t        if (this.note) {\r\n\t            this.note.reflow(targetBox);\r\n\t        }\r\n\r\n\t        if (this.errorBars) {\r\n\t            for (var i = 0; i < this.errorBars.length; i++) {\r\n\t                this$1.errorBars[i].reflow(targetBox);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var box = ref.box;\r\n\t        var options = ref.options;\r\n\t        var customVisual = options.visual;\r\n\r\n\t        if (this.visible !== false) {\r\n\t            ChartElement.fn.createVisual.call(this);\r\n\r\n\t            if (customVisual) {\r\n\t                var visual = this.rectVisual = customVisual({\r\n\t                    category: this.category,\r\n\t                    dataItem: this.dataItem,\r\n\t                    value: this.value,\r\n\t                    sender: this.getSender(),\r\n\t                    series: this.series,\r\n\t                    percentage: this.percentage,\r\n\t                    stackValue: this.stackValue,\r\n\t                    runningTotal: this.runningTotal,\r\n\t                    total: this.total,\r\n\t                    rect: box.toRect(),\r\n\t                    createVisual: function () {\r\n\t                        var group = new Group();\r\n\t                        this$1.createRect(group);\r\n\t                        return group;\r\n\t                    },\r\n\t                    options: options\r\n\t                });\r\n\r\n\t                if (visual) {\r\n\t                    this.visual.append(visual);\r\n\t                }\r\n\t            } else if (box.width() > 0 && box.height() > 0) {\r\n\t                this.createRect(this.visual);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createRect: function(visual) {\r\n\t        var options = this.options;\r\n\t        var border = options.border;\r\n\t        var strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;\r\n\t        var rect = this.box.toRect();\r\n\r\n\t        rect.size.width = Math.round(rect.size.width);\r\n\r\n\t        var path = this.rectVisual = Path.fromRect(rect, {\r\n\t            fill: {\r\n\t                color: this.color,\r\n\t                opacity: options.opacity\r\n\t            },\r\n\t            stroke: {\r\n\t                color: this.getBorderColor(),\r\n\t                width: border.width,\r\n\t                opacity: strokeOpacity,\r\n\t                dashType: border.dashType\r\n\t            }\r\n\t        });\r\n\r\n\t        var width = this.box.width();\r\n\t        var height = this.box.height();\r\n\r\n\t        var size = options.vertical ? width : height;\r\n\r\n\t        if (size > BAR_ALIGN_MIN_WIDTH) {\r\n\t            alignPathToPixel(path);\r\n\r\n\t            // Fixes lineJoin issue in firefox when the joined lines are parallel\r\n\t            if (width < 1 || height < 1) {\r\n\t                path.options.stroke.lineJoin = \"round\";\r\n\t            }\r\n\t        }\r\n\r\n\t        visual.append(path);\r\n\r\n\t        if (hasGradientOverlay(options)) {\r\n\t            var overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({\r\n\t                end: !options.vertical ? [ 0, 1 ] : undefined\r\n\t            }, options.overlay));\r\n\r\n\t            visual.append(overlay);\r\n\t        }\r\n\t    },\r\n\r\n\t    createHighlight: function(style) {\r\n\t        var highlight = Path.fromRect(this.box.toRect(), style);\r\n\r\n\t        return alignPathToPixel(highlight);\r\n\t    },\r\n\r\n\t    highlightVisual: function() {\r\n\t        return this.rectVisual;\r\n\t    },\r\n\r\n\t    highlightVisualArgs: function() {\r\n\t        return {\r\n\t            options: this.options,\r\n\t            rect: this.box.toRect(),\r\n\t            visual: this.rectVisual\r\n\t        };\r\n\t    },\r\n\r\n\t    getBorderColor: function() {\r\n\t        var color = this.color;\r\n\t        var border = this.options.border;\r\n\t        var brightness = border._brightness || BORDER_BRIGHTNESS;\r\n\t        var borderColor = border.color;\r\n\r\n\t        if (!defined(borderColor)) {\r\n\t            borderColor = new Color(color).brightness(brightness).toHex();\r\n\t        }\r\n\r\n\t        return borderColor;\r\n\t    },\r\n\r\n\t    tooltipAnchor: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var box = ref.box;\r\n\t        var aboveAxis = ref.aboveAxis;\r\n\t        var clipBox = this.owner.pane.clipBox() || box;\r\n\t        var horizontalAlign = LEFT;\r\n\t        var verticalAlign = TOP;\r\n\t        var x, y;\r\n\r\n\t        if (options.vertical) {\r\n\t            x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;\r\n\t            if (aboveAxis) {\r\n\t                y = Math.max(box.y1, clipBox.y1);\r\n\t            } else {\r\n\t                y = Math.min(box.y2, clipBox.y2);\r\n\t                verticalAlign = BOTTOM;\r\n\t            }\r\n\t        } else {\r\n\t            var x1 = Math.max(box.x1, clipBox.x1);\r\n\t            var x2 = Math.min(box.x2, clipBox.x2);\r\n\r\n\t            if (options.isStacked) {\r\n\t                verticalAlign = BOTTOM;\r\n\t                if (aboveAxis) {\r\n\t                    horizontalAlign = RIGHT;\r\n\t                    x = x2;\r\n\t                } else {\r\n\t                    x = x1;\r\n\t                }\r\n\t                y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;\r\n\t            } else {\r\n\t                if (aboveAxis) {\r\n\t                    x = x2 + TOOLTIP_OFFSET;\r\n\t                } else {\r\n\t                    x = x1 - TOOLTIP_OFFSET;\r\n\t                    horizontalAlign = RIGHT;\r\n\t                }\r\n\t                y = Math.max(box.y1, clipBox.y1);\r\n\t            }\r\n\t        }\r\n\r\n\t        return {\r\n\t            point: new Point(x, y),\r\n\t            align: {\r\n\t                horizontal: horizontalAlign,\r\n\t                vertical: verticalAlign\r\n\t            }\r\n\t        };\r\n\t    },\r\n\r\n\t    overlapsBox: function(box) {\r\n\t        return this.box.overlaps(box);\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(Bar.prototype, PointEventsMixin);\r\n\tdeepExtend(Bar.prototype, NoteMixin);\r\n\r\n\tBar.prototype.defaults = {\r\n\t    border: {\r\n\t        width: 1\r\n\t    },\r\n\t    vertical: true,\r\n\t    overlay: {\r\n\t        gradient: \"glass\"\r\n\t    },\r\n\t    labels: {\r\n\t        visible: false,\r\n\t        format: \"{0}\"\r\n\t    },\r\n\t    opacity: 1,\r\n\t    notes: {\r\n\t        label: {}\r\n\t    }\r\n\t};\r\n\r\n\tfunction forEach(elements, callback) {\r\n\t    elements.forEach(callback);\r\n\t}\r\n\r\n\tfunction forEachReverse(elements, callback) {\r\n\t    var length = elements.length;\r\n\r\n\t    for (var idx = length - 1; idx >= 0; idx--) {\r\n\t        callback(elements[idx], idx - length - 1);\r\n\t    }\r\n\t}\r\n\r\n\tvar ClusterLayout = ChartElement.extend({\r\n\t    init: function(options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.forEach = options.rtl ? forEachReverse : forEach;\r\n\t    },\r\n\r\n\t    reflow: function(box) {\r\n\t        var ref = this.options;\r\n\t        var vertical = ref.vertical;\r\n\t        var gap = ref.gap;\r\n\t        var spacing = ref.spacing;\r\n\t        var children = this.children;\r\n\t        var count = children.length;\r\n\t        var axis = vertical ? Y : X;\r\n\t        var slots = count + gap + (spacing * (count - 1));\r\n\t        var slotSize = (vertical ? box.height() : box.width()) / slots;\r\n\t        var position = box[axis + 1] + slotSize * (gap / 2);\r\n\r\n\t        this.forEach(children, function (child, idx) {\r\n\t            var childBox = (child.box || box).clone();\r\n\r\n\t            childBox[axis + 1] = position;\r\n\t            childBox[axis + 2] = position + slotSize;\r\n\r\n\t            child.reflow(childBox);\r\n\t            if (idx < count - 1) {\r\n\t                position += (slotSize * spacing);\r\n\t            }\r\n\r\n\t            position += slotSize;\r\n\t        });\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(ClusterLayout, {\r\n\t    vertical: false,\r\n\t    gap: 0,\r\n\t    spacing: 0\r\n\t});\r\n\r\n\tvar StackWrap = ChartElement.extend({\r\n\t    reflow: function(targetBox) {\r\n\t        var this$1 = this;\r\n\r\n\t        var positionAxis = this.options.vertical ? X : Y;\r\n\t        var children = this.children;\r\n\t        var childrenCount = children.length;\r\n\t        var box = this.box = new Box();\r\n\r\n\t        for (var i = 0; i < childrenCount; i++) {\r\n\t            var currentChild = children[i];\r\n\r\n\t            if (currentChild.visible !== false) {\r\n\t                var childBox = currentChild.box.clone();\r\n\t                childBox.snapTo(targetBox, positionAxis);\r\n\r\n\t                if (i === 0) {\r\n\t                    box = this$1.box = childBox.clone();\r\n\t                }\r\n\r\n\t                currentChild.reflow(childBox);\r\n\t                box.wrap(childBox);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(StackWrap, {\r\n\t    vertical: true\r\n\t});\r\n\r\n\tvar BarChart = CategoricalChart.extend({\r\n\t    render: function() {\r\n\t        CategoricalChart.fn.render.call(this);\r\n\t        this.updateStackRange();\r\n\t    },\r\n\r\n\t    pointType: function() {\r\n\t        return Bar;\r\n\t    },\r\n\r\n\t    clusterType: function() {\r\n\t        return ClusterLayout;\r\n\t    },\r\n\r\n\t    stackType: function() {\r\n\t        return StackWrap;\r\n\t    },\r\n\r\n\t    stackLimits: function(axisName, stackName) {\r\n\t        var limits = CategoricalChart.fn.stackLimits.call(this, axisName, stackName);\r\n\r\n\t        return limits;\r\n\t    },\r\n\r\n\t    createPoint: function(data, fields) {\r\n\t        var categoryIx = fields.categoryIx;\r\n\t        var category = fields.category;\r\n\t        var series = fields.series;\r\n\t        var seriesIx = fields.seriesIx;\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var children = ref.children;\r\n\t        var isStacked = options.isStacked;\r\n\t        var value = this.pointValue(data);\r\n\t        var pointOptions = this.pointOptions(series, seriesIx);\r\n\r\n\t        var labelOptions = pointOptions.labels;\r\n\t        if (isStacked) {\r\n\t            if (labelOptions.position === OUTSIDE_END) {\r\n\t                labelOptions.position = INSIDE_END;\r\n\t            }\r\n\t        }\r\n\r\n\t        pointOptions.isStacked = isStacked;\r\n\r\n\t        var color = data.fields.color || series.color;\r\n\t        if (value < 0 && pointOptions.negativeColor) {\r\n\t            color = pointOptions.negativeColor;\r\n\t        }\r\n\r\n\t        pointOptions = this.evalPointOptions(\r\n\t            pointOptions, value, category, categoryIx, series, seriesIx\r\n\t        );\r\n\r\n\t        if (isFunction(series.color)) {\r\n\t            color = pointOptions.color;\r\n\t        }\r\n\r\n\t        var pointType = this.pointType();\r\n\t        var point = new pointType(value, pointOptions);\r\n\t        point.color = color;\r\n\r\n\t        var cluster = children[categoryIx];\r\n\t        if (!cluster) {\r\n\t            var clusterType = this.clusterType();\r\n\t            cluster = new clusterType({\r\n\t                vertical: options.invertAxes,\r\n\t                gap: options.gap,\r\n\t                spacing: options.spacing,\r\n\t                rtl: !options.invertAxes && (this.chartService || {}).rtl\r\n\t            });\r\n\t            this.append(cluster);\r\n\t        }\r\n\r\n\t        if (isStacked) {\r\n\t            var stackWrap = this.getStackWrap(series, cluster);\r\n\t            stackWrap.append(point);\r\n\t        } else {\r\n\t            cluster.append(point);\r\n\t        }\r\n\r\n\t        return point;\r\n\t    },\r\n\r\n\t    getStackWrap: function(series, cluster) {\r\n\t        var stack = series.stack;\r\n\t        var stackGroup = stack ? stack.group || stack : stack;\r\n\t        var wraps = cluster.children;\r\n\t        var stackWrap;\r\n\r\n\t        if (typeof stackGroup === datavizConstants.STRING) {\r\n\t            for (var i = 0; i < wraps.length; i++) {\r\n\t                if (wraps[i]._stackGroup === stackGroup) {\r\n\t                    stackWrap = wraps[i];\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t        } else {\r\n\t            stackWrap = wraps[0];\r\n\t        }\r\n\r\n\t        if (!stackWrap) {\r\n\t            var stackType = this.stackType();\r\n\t            stackWrap = new stackType({\r\n\t                vertical: !this.options.invertAxes\r\n\t            });\r\n\t            stackWrap._stackGroup = stackGroup;\r\n\t            cluster.append(stackWrap);\r\n\t        }\r\n\r\n\t        return stackWrap;\r\n\t    },\r\n\r\n\t    categorySlot: function(categoryAxis, categoryIx, valueAxis) {\r\n\t        var options = this.options;\r\n\t        var categorySlot = categoryAxis.getSlot(categoryIx);\r\n\t        var startValue = valueAxis.startValue();\r\n\r\n\t        if (options.isStacked) {\r\n\t            var zeroSlot = valueAxis.getSlot(startValue, startValue, true);\r\n\t            var stackAxis = options.invertAxes ? X : Y;\r\n\t            categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];\r\n\t        }\r\n\r\n\t        return categorySlot;\r\n\t    },\r\n\r\n\t    reflowCategories: function(categorySlots) {\r\n\t        var children = this.children;\r\n\t        var childrenLength = children.length;\r\n\r\n\t        for (var i = 0; i < childrenLength; i++) {\r\n\t            children[i].reflow(categorySlots[i]);\r\n\t        }\r\n\t    },\r\n\r\n\t    createAnimation: function() {\r\n\t        this._setAnimationOptions();\r\n\t        CategoricalChart.fn.createAnimation.call(this);\r\n\r\n\t        if (anyHasZIndex(this.options.series)) {\r\n\t            this._setChildrenAnimation();\r\n\t        }\r\n\t    },\r\n\r\n\t    _setChildrenAnimation: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var points = this.points;\r\n\r\n\t        for (var idx = 0; idx < points.length; idx++) {\r\n\t            var point = points[idx];\r\n\t            var pointVisual = point.visual;\r\n\t            if (pointVisual && defined(pointVisual.options.zIndex)) {\r\n\t                point.options.animation = this$1.options.animation;\r\n\t                point.createAnimation();\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _setAnimationOptions: function() {\r\n\t        var options = this.options;\r\n\t        var animation = options.animation || {};\r\n\t        var origin;\r\n\r\n\t        if (options.isStacked) {\r\n\t            var valueAxis = this.seriesValueAxis(options.series[0]);\r\n\t            origin = valueAxis.getSlot(valueAxis.startValue());\r\n\t        } else {\r\n\t            origin = this.categoryAxis.getSlot(0);\r\n\t        }\r\n\r\n\t        animation.origin = new GeometryPoint(origin.x1, origin.y1);\r\n\t        animation.vertical = !options.invertAxes;\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(BarChart, {\r\n\t    animation: {\r\n\t        type: BAR\r\n\t    }\r\n\t});\r\n\r\n\tvar Candlestick = ChartElement.extend({\r\n\t    init: function(value, options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\t        this.value = value;\r\n\t    },\r\n\r\n\t    reflow: function(box) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var value = ref.value;\r\n\t        var chart = ref.owner;\r\n\t        var valueAxis = chart.seriesValueAxis(options);\r\n\t        var ocSlot = valueAxis.getSlot(value.open, value.close);\r\n\t        var lhSlot = valueAxis.getSlot(value.low, value.high);\r\n\r\n\t        ocSlot.x1 = lhSlot.x1 = box.x1;\r\n\t        ocSlot.x2 = lhSlot.x2 = box.x2;\r\n\r\n\t        this.realBody = ocSlot;\r\n\r\n\t        var mid = lhSlot.center().x;\r\n\t        var points = [];\r\n\r\n\t        points.push([ [ mid, lhSlot.y1 ], [ mid, ocSlot.y1 ] ]);\r\n\t        points.push([ [ mid, ocSlot.y2 ], [ mid, lhSlot.y2 ] ]);\r\n\r\n\t        this.lines = points;\r\n\r\n\t        this.box = lhSlot.clone().wrap(ocSlot);\r\n\r\n\t        if (!this._rendered) {\r\n\t            this._rendered = true;\r\n\t            this.createNote();\r\n\t        }\r\n\r\n\t        this.reflowNote();\r\n\t    },\r\n\r\n\t    reflowNote: function() {\r\n\t        if (this.note) {\r\n\t            this.note.reflow(this.box);\r\n\t        }\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\t        this._mainVisual = this.mainVisual(this.options);\r\n\t        this.visual.append(\r\n\t            this._mainVisual\r\n\t        );\r\n\r\n\t        this.createOverlay();\r\n\t    },\r\n\r\n\t    mainVisual: function(options) {\r\n\t        var group = new Group();\r\n\r\n\t        this.createBody(group, options);\r\n\t        this.createLines(group, options);\r\n\r\n\t        return group;\r\n\t    },\r\n\r\n\t    createBody: function(container, options) {\r\n\t        var body = Path.fromRect(this.realBody.toRect(), {\r\n\t            fill: {\r\n\t                color: this.color,\r\n\t                opacity: options.opacity\r\n\t            },\r\n\t            stroke: null\r\n\t        });\r\n\r\n\t        if (options.border.width > 0) {\r\n\t            body.options.set(\"stroke\", {\r\n\t                color: this.getBorderColor(),\r\n\t                width: options.border.width,\r\n\t                dashType: options.border.dashType,\r\n\t                opacity: valueOrDefault(options.border.opacity, options.opacity)\r\n\t            });\r\n\t        }\r\n\r\n\t        alignPathToPixel(body);\r\n\t        container.append(body);\r\n\r\n\t        if (hasGradientOverlay(options)) {\r\n\t            container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({\r\n\t                end: !options.vertical ? [ 0, 1 ] : undefined\r\n\t            }, options.overlay)));\r\n\t        }\r\n\t    },\r\n\r\n\t    createLines: function(container, options) {\r\n\t        this.drawLines(container, options, this.lines, options.line);\r\n\t    },\r\n\r\n\t    drawLines: function(container, options, lines, lineOptions) {\r\n\t        if (!lines) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var lineStyle = {\r\n\t            stroke: {\r\n\t                color: lineOptions.color || this.color,\r\n\t                opacity: valueOrDefault(lineOptions.opacity, options.opacity),\r\n\t                width: lineOptions.width,\r\n\t                dashType: lineOptions.dashType,\r\n\t                lineCap: \"butt\"\r\n\t            }\r\n\t        };\r\n\r\n\t        for (var i = 0; i < lines.length; i++) {\r\n\t            var line = Path.fromPoints(lines[i], lineStyle);\r\n\t            alignPathToPixel(line);\r\n\t            container.append(line);\r\n\t        }\r\n\t    },\r\n\r\n\t    getBorderColor: function() {\r\n\t        var border = this.options.border;\r\n\t        var borderColor = border.color;\r\n\r\n\t        if (!defined(borderColor)) {\r\n\t            borderColor = new Color(this.color).brightness(border._brightness).toHex();\r\n\t        }\r\n\r\n\t        return borderColor;\r\n\t    },\r\n\r\n\t    createOverlay: function() {\r\n\t        var overlay = Path.fromRect(this.box.toRect(), {\r\n\t            fill: {\r\n\t                color: WHITE,\r\n\t                opacity: 0\r\n\t            },\r\n\t            stroke: null\r\n\t        });\r\n\r\n\t        this.visual.append(overlay);\r\n\t    },\r\n\r\n\t    createHighlight: function() {\r\n\t        var highlight = this.options.highlight;\r\n\t        var normalColor = this.color;\r\n\r\n\t        this.color = highlight.color || this.color;\r\n\t        var overlay = this.mainVisual(\r\n\t            deepExtend({}, this.options, {\r\n\t                line: {\r\n\t                    color: this.getBorderColor()\r\n\t                }\r\n\t            }, highlight)\r\n\t        );\r\n\t        this.color = normalColor;\r\n\r\n\t        return overlay;\r\n\t    },\r\n\r\n\t    highlightVisual: function() {\r\n\t        return this._mainVisual;\r\n\t    },\r\n\r\n\t    highlightVisualArgs: function() {\r\n\t        return {\r\n\t            options: this.options,\r\n\t            rect: this.box.toRect(),\r\n\t            visual: this._mainVisual\r\n\t        };\r\n\t    },\r\n\r\n\t    tooltipAnchor: function() {\r\n\t        var box = this.box;\r\n\t        var clipBox = this.owner.pane.clipBox() || box;\r\n\r\n\t        return {\r\n\t            point: new Point(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),\r\n\t            align: {\r\n\t                horizontal: LEFT,\r\n\t                vertical: TOP\r\n\t            }\r\n\t        };\r\n\t    },\r\n\r\n\t    formatValue: function(format) {\r\n\t        return this.owner.formatPointValue(this, format);\r\n\t    },\r\n\r\n\t    overlapsBox: function(box) {\r\n\t        return this.box.overlaps(box);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(Candlestick, {\r\n\t    vertical: true,\r\n\t    border: {\r\n\t        _brightness: 0.8\r\n\t    },\r\n\t    line: {\r\n\t        width: 2\r\n\t    },\r\n\t    overlay: {\r\n\t        gradient: \"glass\"\r\n\t    },\r\n\t    tooltip: {\r\n\t        format: \"<table>\" +\r\n\t                    \"<tr><th colspan='2'>{4:d}</th></tr>\" +\r\n\t                    \"<tr><td>Open:</td><td>{0:C}</td></tr>\" +\r\n\t                    \"<tr><td>High:</td><td>{1:C}</td></tr>\" +\r\n\t                    \"<tr><td>Low:</td><td>{2:C}</td></tr>\" +\r\n\t                    \"<tr><td>Close:</td><td>{3:C}</td></tr>\" +\r\n\t                \"</table>\"\r\n\t    },\r\n\t    highlight: {\r\n\t        opacity: 1,\r\n\t        border: {\r\n\t            width: 1,\r\n\t            opacity: 1\r\n\t        },\r\n\t        line: {\r\n\t            width: 1,\r\n\t            opacity: 1\r\n\t        }\r\n\t    },\r\n\t    notes: {\r\n\t        visible: true,\r\n\t        label: {}\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(Candlestick.prototype, PointEventsMixin);\r\n\tdeepExtend(Candlestick.prototype, NoteMixin);\r\n\r\n\tfunction areNumbers(values) {\r\n\t    return countNumbers(values) === values.length;\r\n\t}\r\n\r\n\tvar CandlestickChart = CategoricalChart.extend({\r\n\t    reflowCategories: function(categorySlots) {\r\n\t        var children = this.children;\r\n\t        var childrenLength = children.length;\r\n\r\n\t        for (var i = 0; i < childrenLength; i++) {\r\n\t            children[i].reflow(categorySlots[i]);\r\n\t        }\r\n\t    },\r\n\r\n\t    addValue: function(data, fields) {\r\n\t        var categoryIx = fields.categoryIx;\r\n\t        var category = fields.category;\r\n\t        var series = fields.series;\r\n\t        var seriesIx = fields.seriesIx;\r\n\t        var ref = this;\r\n\t        var children = ref.children;\r\n\t        var options = ref.options;\r\n\t        var value = data.valueFields;\r\n\t        var valueParts = this.splitValue(value);\r\n\t        var hasValue = areNumbers(valueParts);\r\n\t        var dataItem = series.data[categoryIx];\r\n\t        var categoryPoints = this.categoryPoints[categoryIx];\r\n\t        var point;\r\n\r\n\t        if (!categoryPoints) {\r\n\t            this.categoryPoints[categoryIx] = categoryPoints = [];\r\n\t        }\r\n\r\n\t        if (hasValue) {\r\n\t            point = this.createPoint(data, fields);\r\n\t        }\r\n\r\n\t        var cluster = children[categoryIx];\r\n\t        if (!cluster) {\r\n\t            cluster = new ClusterLayout({\r\n\t                vertical: options.invertAxes,\r\n\t                gap: options.gap,\r\n\t                spacing: options.spacing,\r\n\t                rtl: !options.invertAxes && (this.chartService || {}).rtl\r\n\t            });\r\n\t            this.append(cluster);\r\n\t        }\r\n\r\n\t        if (point) {\r\n\t            this.updateRange(value, fields);\r\n\r\n\t            cluster.append(point);\r\n\r\n\t            point.categoryIx = categoryIx;\r\n\t            point.category = category;\r\n\t            point.series = series;\r\n\t            point.seriesIx = seriesIx;\r\n\t            point.owner = this;\r\n\t            point.dataItem = dataItem;\r\n\t            point.noteText = data.fields.noteText;\r\n\t        }\r\n\r\n\t        this.points.push(point);\r\n\t        categoryPoints.push(point);\r\n\t    },\r\n\r\n\t    pointType: function() {\r\n\t        return Candlestick;\r\n\t    },\r\n\r\n\t    createPoint: function(data, fields) {\r\n\t        var categoryIx = fields.categoryIx;\r\n\t        var category = fields.category;\r\n\t        var series = fields.series;\r\n\t        var seriesIx = fields.seriesIx;\r\n\t        var pointType = this.pointType();\r\n\t        var value = data.valueFields;\r\n\t        var pointOptions = deepExtend({}, series);\r\n\t        var color = data.fields.color || series.color;\r\n\r\n\t        pointOptions = this.evalPointOptions(\r\n\t            pointOptions, value, category, categoryIx, series, seriesIx\r\n\t        );\r\n\r\n\t        if (series.type === CANDLESTICK) {\r\n\t            if (value.open > value.close) {\r\n\t                color = data.fields.downColor || series.downColor || series.color;\r\n\t            }\r\n\t        }\r\n\r\n\t        if (isFunction(series.color)) {\r\n\t            color = pointOptions.color;\r\n\t        }\r\n\r\n\t        pointOptions.vertical = !this.options.invertAxes;\r\n\r\n\t        var point = new pointType(value, pointOptions);\r\n\t        point.color = color;\r\n\r\n\t        return point;\r\n\t    },\r\n\r\n\t    splitValue: function(value) {\r\n\t        return [ value.low, value.open, value.close, value.high ];\r\n\t    },\r\n\r\n\t    updateRange: function(value, fields) {\r\n\t        var axisName = fields.series.axis;\r\n\t        var parts = this.splitValue(value);\r\n\t        var axisRange = this.valueAxisRanges[axisName];\r\n\r\n\t        axisRange = this.valueAxisRanges[axisName] =\r\n\t            axisRange || { min: MAX_VALUE, max: MIN_VALUE };\r\n\r\n\t        axisRange = this.valueAxisRanges[axisName] = {\r\n\t            min: Math.min.apply(Math, parts.concat([ axisRange.min ])),\r\n\t            max: Math.max.apply(Math, parts.concat([ axisRange.max ]))\r\n\t        };\r\n\t    },\r\n\r\n\t    formatPointValue: function(point, format) {\r\n\t        var value = point.value;\r\n\r\n\t        return this.chartService.format.auto(format,\r\n\t            value.open, value.high,\r\n\t            value.low, value.close, point.category\r\n\t        );\r\n\t    },\r\n\r\n\t    animationPoints: function() {\r\n\t        return this.points;\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(CandlestickChart.prototype, ClipAnimationMixin);\r\n\r\n\tvar BoxPlot = Candlestick.extend({\r\n\t    init: function(value, options) {\r\n\t        Candlestick.fn.init.call(this, value, options);\r\n\r\n\t        this.createNote();\r\n\t    },\r\n\r\n\t    reflow: function(box) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var value = ref.value;\r\n\t        var chart = ref.owner;\r\n\t        var valueAxis = chart.seriesValueAxis(options);\r\n\t        var whiskerSlot, boxSlot;\r\n\r\n\t        this.boxSlot = boxSlot = valueAxis.getSlot(value.q1, value.q3);\r\n\t        this.realBody = boxSlot;\r\n\t        this.reflowBoxSlot(box);\r\n\r\n\t        this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value.lower, value.upper);\r\n\t        this.reflowWhiskerSlot(box);\r\n\r\n\t        var medianSlot = valueAxis.getSlot(value.median);\r\n\r\n\t        if (value.mean) {\r\n\t            var meanSlot = valueAxis.getSlot(value.mean);\r\n\t            this.meanPoints = this.calcMeanPoints(box, meanSlot);\r\n\t        }\r\n\r\n\t        this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);\r\n\t        this.medianPoints = this.calcMedianPoints(box, medianSlot);\r\n\r\n\t        this.box = whiskerSlot.clone().wrap(boxSlot);\r\n\t        this.reflowNote();\r\n\t    },\r\n\r\n\t    reflowBoxSlot: function(box) {\r\n\t        this.boxSlot.x1 = box.x1;\r\n\t        this.boxSlot.x2 = box.x2;\r\n\t    },\r\n\r\n\t    reflowWhiskerSlot: function(box) {\r\n\t        this.whiskerSlot.x1 = box.x1;\r\n\t        this.whiskerSlot.x2 = box.x2;\r\n\t    },\r\n\r\n\t    calcMeanPoints: function(box, meanSlot) {\r\n\t        return [\r\n\t            [ [ box.x1, meanSlot.y1 ], [ box.x2, meanSlot.y1 ] ]\r\n\t        ];\r\n\t    },\r\n\r\n\t    calcWhiskerPoints: function(boxSlot, whiskerSlot) {\r\n\t        var mid = whiskerSlot.center().x;\r\n\t        return [ [\r\n\t            [ mid - 5, whiskerSlot.y1 ], [ mid + 5, whiskerSlot.y1 ],\r\n\t            [ mid, whiskerSlot.y1 ], [ mid, boxSlot.y1 ]\r\n\t        ], [\r\n\t            [ mid - 5, whiskerSlot.y2 ], [ mid + 5, whiskerSlot.y2 ],\r\n\t            [ mid, whiskerSlot.y2 ], [ mid, boxSlot.y2 ]\r\n\t        ] ];\r\n\t    },\r\n\r\n\t    calcMedianPoints: function(box, medianSlot) {\r\n\t        return [\r\n\t            [ [ box.x1, medianSlot.y1 ], [ box.x2, medianSlot.y1 ] ]\r\n\t        ];\r\n\t    },\r\n\r\n\t    renderOutliers: function(options) {\r\n\t        var this$1 = this;\r\n\r\n\t        var value = this.value;\r\n\t        var outliers = value.outliers || [];\r\n\t        var outerFence = Math.abs(value.q3 - value.q1) * 3;\r\n\t        var elements = [];\r\n\t        var markers = options.markers || {};\r\n\r\n\t        for (var i = 0; i < outliers.length; i++) {\r\n\t            var outlierValue = outliers[i];\r\n\t            if (outlierValue < value.q3 + outerFence && outlierValue > value.q1 - outerFence) {\r\n\t                markers = options.outliers;\r\n\t            } else {\r\n\t                markers = options.extremes;\r\n\t            }\r\n\t            var markersBorder = deepExtend({}, markers.border);\r\n\r\n\t            if (!defined(markersBorder.color)) {\r\n\t                if (defined(this$1.color)) {\r\n\t                    markersBorder.color = this$1.color;\r\n\t                } else {\r\n\t                    markersBorder.color =\r\n\t                        new Color(markers.background).brightness(BORDER_BRIGHTNESS).toHex();\r\n\t                }\r\n\t            }\r\n\r\n\t            var shape = new ShapeElement({\r\n\t                type: markers.type,\r\n\t                width: markers.size,\r\n\t                height: markers.size,\r\n\t                rotation: markers.rotation,\r\n\t                background: markers.background,\r\n\t                border: markersBorder,\r\n\t                opacity: markers.opacity\r\n\t            });\r\n\r\n\t            shape.value = outlierValue;\r\n\r\n\t            elements.push(shape);\r\n\t        }\r\n\r\n\t        this.reflowOutliers(elements);\r\n\t        return elements;\r\n\t    },\r\n\r\n\t    reflowOutliers: function(outliers) {\r\n\t        var this$1 = this;\r\n\r\n\t        var valueAxis = this.owner.seriesValueAxis(this.options);\r\n\t        var center = this.box.center();\r\n\r\n\t        for (var i = 0; i < outliers.length; i++) {\r\n\t            var outlierValue = outliers[i].value;\r\n\t            var markerBox = valueAxis.getSlot(outlierValue);\r\n\r\n\t            if (this$1.options.vertical) {\r\n\t                markerBox.move(center.x);\r\n\t            } else {\r\n\t                markerBox.move(undefined, center.y);\r\n\t            }\r\n\r\n\t            this$1.box = this$1.box.wrap(markerBox);\r\n\t            outliers[i].reflow(markerBox);\r\n\t        }\r\n\t    },\r\n\r\n\t    mainVisual: function(options) {\r\n\t        var group = Candlestick.fn.mainVisual.call(this, options);\r\n\t        var outliers = this.renderOutliers(options);\r\n\r\n\t        for (var i = 0; i < outliers.length; i++) {\r\n\t            var element = outliers[i].getElement();\r\n\t            if (element) {\r\n\t                group.append(element);\r\n\t            }\r\n\t        }\r\n\r\n\t        return group;\r\n\t    },\r\n\r\n\t    createLines: function(container, options) {\r\n\t        this.drawLines(container, options, this.whiskerPoints, options.whiskers);\r\n\t        this.drawLines(container, options, this.medianPoints, options.median);\r\n\t        this.drawLines(container, options, this.meanPoints, options.mean);\r\n\t    },\r\n\r\n\t    getBorderColor: function() {\r\n\t        if (this.color) {\r\n\t            return this.color;\r\n\t        }\r\n\r\n\t        return Candlestick.fn.getBorderColor.call(this);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(BoxPlot, {\r\n\t    border: {\r\n\t        _brightness: 0.8\r\n\t    },\r\n\t    line: {\r\n\t        width: 2\r\n\t    },\r\n\t    median: {\r\n\t        color: \"#f6f6f6\"\r\n\t    },\r\n\t    mean: {\r\n\t        width: 2,\r\n\t        dashType: \"dash\",\r\n\t        color: \"#f6f6f6\"\r\n\t    },\r\n\t    overlay: {\r\n\t        gradient: \"glass\"\r\n\t    },\r\n\t    tooltip: {\r\n\t        format: \"<table>\" +\r\n\t                    \"<tr><th colspan='2'>{6:d}</th></tr>\" +\r\n\t                    \"<tr><td>Lower:</td><td>{0:C}</td></tr>\" +\r\n\t                    \"<tr><td>Q1:</td><td>{1:C}</td></tr>\" +\r\n\t                    \"<tr><td>Median:</td><td>{2:C}</td></tr>\" +\r\n\t                    \"<tr><td>Mean:</td><td>{5:C}</td></tr>\" +\r\n\t                    \"<tr><td>Q3:</td><td>{3:C}</td></tr>\" +\r\n\t                    \"<tr><td>Upper:</td><td>{4:C}</td></tr>\" +\r\n\t                \"</table>\"\r\n\t    },\r\n\t    highlight: {\r\n\t        opacity: 1,\r\n\t        border: {\r\n\t            width: 1,\r\n\t            opacity: 1\r\n\t        },\r\n\t        line: {\r\n\t            width: 1,\r\n\t            opacity: 1\r\n\t        }\r\n\t    },\r\n\t    notes: {\r\n\t        visible: true,\r\n\t        label: {}\r\n\t    },\r\n\t    outliers: {\r\n\t        visible: true,\r\n\t        size: LINE_MARKER_SIZE,\r\n\t        type: datavizConstants.CROSS,\r\n\t        background: WHITE,\r\n\t        border: {\r\n\t            width: 2,\r\n\t            opacity: 1\r\n\t        },\r\n\t        opacity: 0\r\n\t    },\r\n\t    extremes: {\r\n\t        visible: true,\r\n\t        size: LINE_MARKER_SIZE,\r\n\t        type: CIRCLE,\r\n\t        background: WHITE,\r\n\t        border: {\r\n\t            width: 2,\r\n\t            opacity: 1\r\n\t        },\r\n\t        opacity: 0\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(BoxPlot.prototype, PointEventsMixin);\r\n\r\n\tvar VerticalBoxPlot = BoxPlot.extend({\r\n\t    reflowBoxSlot: function(box) {\r\n\t        this.boxSlot.y1 = box.y1;\r\n\t        this.boxSlot.y2 = box.y2;\r\n\t    },\r\n\r\n\t    reflowWhiskerSlot: function(box) {\r\n\t        this.whiskerSlot.y1 = box.y1;\r\n\t        this.whiskerSlot.y2 = box.y2;\r\n\t    },\r\n\r\n\t    calcMeanPoints: function(box, meanSlot) {\r\n\t        return [\r\n\t            [ [ meanSlot.x1, box.y1 ], [ meanSlot.x1, box.y2 ] ]\r\n\t        ];\r\n\t    },\r\n\r\n\t    calcWhiskerPoints: function(boxSlot, whiskerSlot) {\r\n\t        var mid = whiskerSlot.center().y;\r\n\t        return [ [\r\n\t            [ whiskerSlot.x1, mid - 5 ], [ whiskerSlot.x1, mid + 5 ],\r\n\t            [ whiskerSlot.x1, mid ], [ boxSlot.x1, mid ]\r\n\t        ], [\r\n\t            [ whiskerSlot.x2, mid - 5 ], [ whiskerSlot.x2, mid + 5 ],\r\n\t            [ whiskerSlot.x2, mid ], [ boxSlot.x2, mid ]\r\n\t        ] ];\r\n\t    },\r\n\r\n\t    calcMedianPoints: function(box, medianSlot) {\r\n\t        return [\r\n\t            [ [ medianSlot.x1, box.y1 ], [ medianSlot.x1, box.y2 ] ]\r\n\t        ];\r\n\t    }\r\n\t});\r\n\r\n\tvar BoxPlotChart = CandlestickChart.extend({\r\n\t    addValue: function(data, fields) {\r\n\t        var categoryIx = fields.categoryIx;\r\n\t        var category = fields.category;\r\n\t        var series = fields.series;\r\n\t        var seriesIx = fields.seriesIx;\r\n\t        var ref = this;\r\n\t        var children = ref.children;\r\n\t        var options = ref.options;\r\n\t        var value = data.valueFields;\r\n\t        var valueParts = this.splitValue(value);\r\n\t        var hasValue = areNumbers(valueParts);\r\n\t        var dataItem = series.data[categoryIx];\r\n\t        var categoryPoints = this.categoryPoints[categoryIx];\r\n\t        var point;\r\n\r\n\t        if (!categoryPoints) {\r\n\t            this.categoryPoints[categoryIx] = categoryPoints = [];\r\n\t        }\r\n\r\n\t        if (hasValue) {\r\n\t            point = this.createPoint(data, fields);\r\n\t        }\r\n\r\n\t        var cluster = children[categoryIx];\r\n\t        if (!cluster) {\r\n\t            cluster = new ClusterLayout({\r\n\t                vertical: options.invertAxes,\r\n\t                gap: options.gap,\r\n\t                spacing: options.spacing,\r\n\t                rtl: !options.invertAxes && (this.chartService || {}).rtl\r\n\t            });\r\n\t            this.append(cluster);\r\n\t        }\r\n\r\n\t        if (point) {\r\n\t            this.updateRange(value, fields);\r\n\r\n\t            cluster.append(point);\r\n\r\n\t            point.categoryIx = categoryIx;\r\n\t            point.category = category;\r\n\t            point.series = series;\r\n\t            point.seriesIx = seriesIx;\r\n\t            point.owner = this;\r\n\t            point.dataItem = dataItem;\r\n\t        }\r\n\r\n\t        this.points.push(point);\r\n\t        categoryPoints.push(point);\r\n\t    },\r\n\r\n\t    pointType: function() {\r\n\t        if (this.options.invertAxes) {\r\n\t            return VerticalBoxPlot;\r\n\t        }\r\n\r\n\t        return BoxPlot;\r\n\t    },\r\n\r\n\t    splitValue: function(value) {\r\n\t        return [\r\n\t            value.lower, value.q1, value.median,\r\n\t            value.q3, value.upper\r\n\t        ];\r\n\t    },\r\n\r\n\t    updateRange: function(value, fields) {\r\n\t        var axisName = fields.series.axis;\r\n\t        var axisRange = this.valueAxisRanges[axisName];\r\n\t        var parts = this.splitValue(value).concat(this.filterOutliers(value.outliers));\r\n\r\n\t        if (defined(value.mean)) {\r\n\t            parts = parts.concat(value.mean);\r\n\t        }\r\n\r\n\t        axisRange = this.valueAxisRanges[axisName] =\r\n\t            axisRange || { min: MAX_VALUE, max: MIN_VALUE };\r\n\r\n\t        axisRange = this.valueAxisRanges[axisName] = {\r\n\t            min: Math.min.apply(Math, parts.concat([ axisRange.min ])),\r\n\t            max: Math.max.apply(Math, parts.concat([ axisRange.max ]))\r\n\t        };\r\n\t    },\r\n\r\n\t    formatPointValue: function(point, format) {\r\n\t        var value = point.value;\r\n\r\n\t        return this.chartService.format.auto(format,\r\n\t            value.lower, value.q1, value.median,\r\n\t            value.q3, value.upper, value.mean, point.category\r\n\t        );\r\n\t    },\r\n\r\n\t    filterOutliers: function(items) {\r\n\t        var length = (items || []).length;\r\n\t        var result = [];\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var item = items[i];\r\n\t            if (defined(item) && item !== null) {\r\n\t                result.push(item);\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    }\r\n\t});\r\n\r\n\tvar ScatterErrorBar = ErrorBarBase.extend({\r\n\t    getAxis: function() {\r\n\t        var axes = this.chart.seriesAxes(this.series);\r\n\t        var axis = this.isVertical ? axes.y : axes.x;\r\n\r\n\t        return axis;\r\n\t    }\r\n\t});\r\n\r\n\tfunction hasValue(value) {\r\n\t    return defined(value) && value !== null;\r\n\t}\r\n\r\n\tvar ScatterChart = ChartElement.extend({\r\n\t    init: function(plotArea, options) {\r\n\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.plotArea = plotArea;\r\n\t        this.chartService = plotArea.chartService;\r\n\t        this._initFields();\r\n\r\n\t        this.render();\r\n\t    },\r\n\r\n\t    _initFields: function() {\r\n\t        // X and Y axis ranges grouped by name, e.g.:\r\n\t        // primary: { min: 0, max: 1 }\r\n\t        this.xAxisRanges = {};\r\n\t        this.yAxisRanges = {};\r\n\r\n\t        this.points = [];\r\n\t        this.seriesPoints = [];\r\n\t        this.seriesOptions = [];\r\n\t        this._evalSeries = [];\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        this.traverseDataPoints(this.addValue.bind(this));\r\n\t    },\r\n\r\n\t    addErrorBar: function(point, field, fields) {\r\n\t        var value = point.value[field];\r\n\t        var valueErrorField = field + \"Value\";\r\n\t        var lowField = field + \"ErrorLow\";\r\n\t        var highField = field + \"ErrorHigh\";\r\n\t        var seriesIx = fields.seriesIx;\r\n\t        var series = fields.series;\r\n\t        var errorBars = point.options.errorBars;\r\n\t        var lowValue = fields[lowField];\r\n\t        var highValue = fields[highField];\r\n\r\n\t        if (isNumber(value)) {\r\n\t            var errorRange;\r\n\t            if (isNumber(lowValue) && isNumber(highValue)) {\r\n\t                errorRange = { low: lowValue, high: highValue };\r\n\t            }\r\n\r\n\t            if (errorBars && defined(errorBars[valueErrorField])) {\r\n\t                this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };\r\n\t                this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] ||\r\n\t                    new ErrorRangeCalculator(errorBars[valueErrorField], series, field);\r\n\r\n\t                errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);\r\n\t            }\r\n\r\n\t            if (errorRange) {\r\n\t                this.addPointErrorBar(errorRange, point, field);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    addPointErrorBar: function(errorRange, point, field) {\r\n\t        var low = errorRange.low;\r\n\t        var high = errorRange.high;\r\n\t        var series = point.series;\r\n\t        var options = point.options.errorBars;\r\n\t        var isVertical = field === Y;\r\n\t        var item = {};\r\n\r\n\t        point[field + \"Low\"] = low;\r\n\t        point[field + \"High\"] = high;\r\n\r\n\t        point.errorBars = point.errorBars || [];\r\n\t        var errorBar = new ScatterErrorBar(low, high, isVertical, this, series, options);\r\n\t        point.errorBars.push(errorBar);\r\n\t        point.append(errorBar);\r\n\r\n\t        item[field] = low;\r\n\t        this.updateRange(item, series);\r\n\t        item[field] = high;\r\n\t        this.updateRange(item, series);\r\n\t    },\r\n\r\n\t    addValue: function(value, fields) {\r\n\t        var x = value.x;\r\n\t        var y = value.y;\r\n\t        var seriesIx = fields.seriesIx;\r\n\t        var series = this.options.series[seriesIx];\r\n\t        var missingValues = this.seriesMissingValues(series);\r\n\t        var seriesPoints = this.seriesPoints[seriesIx];\r\n\r\n\t        var pointValue = value;\r\n\t        if (!(hasValue(x) && hasValue(y))) {\r\n\t            pointValue = this.createMissingValue(pointValue, missingValues);\r\n\t        }\r\n\r\n\t        var point;\r\n\t        if (pointValue) {\r\n\t            point = this.createPoint(pointValue, fields);\r\n\t            if (point) {\r\n\t                $.extend(point, fields);\r\n\t                this.addErrorBar(point, X, fields);\r\n\t                this.addErrorBar(point, Y, fields);\r\n\t            }\r\n\t            this.updateRange(pointValue, fields.series);\r\n\t        }\r\n\r\n\t        this.points.push(point);\r\n\t        seriesPoints.push(point);\r\n\t    },\r\n\r\n\t    seriesMissingValues: function(series) {\r\n\t        return series.missingValues;\r\n\t    },\r\n\r\n\t    createMissingValue: function() {},\r\n\r\n\t    updateRange: function(value, series) {\r\n\t        var intlService = this.chartService.intl;\r\n\t        var xAxisName = series.xAxis;\r\n\t        var yAxisName = series.yAxis;\r\n\t        var x = value.x;\r\n\t        var y = value.y;\r\n\t        var xAxisRange = this.xAxisRanges[xAxisName];\r\n\t        var yAxisRange = this.yAxisRanges[yAxisName];\r\n\r\n\t        if (hasValue(x)) {\r\n\t            xAxisRange = this.xAxisRanges[xAxisName] =\r\n\t                xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };\r\n\r\n\t            if (isString(x)) {\r\n\t                x = parseDate(intlService, x);\r\n\t            }\r\n\r\n\t            xAxisRange.min = Math.min(xAxisRange.min, x);\r\n\t            xAxisRange.max = Math.max(xAxisRange.max, x);\r\n\t        }\r\n\r\n\t        if (hasValue(y)) {\r\n\t            yAxisRange = this.yAxisRanges[yAxisName] =\r\n\t                yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };\r\n\r\n\t            if (isString(y)) {\r\n\t                y = parseDate(intlService, y);\r\n\t            }\r\n\r\n\t            yAxisRange.min = Math.min(yAxisRange.min, y);\r\n\t            yAxisRange.max = Math.max(yAxisRange.max, y);\r\n\t        }\r\n\t    },\r\n\r\n\t    evalPointOptions: function(options, value, fields) {\r\n\t        var series = fields.series;\r\n\t        var seriesIx = fields.seriesIx;\r\n\t        var state = { defaults: series._defaults, excluded: [ \"data\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\" ] };\r\n\r\n\t        var doEval = this._evalSeries[seriesIx];\r\n\t        if (!defined(doEval)) {\r\n\t            this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\r\n\t        }\r\n\r\n\t        var pointOptions = options;\r\n\t        if (doEval) {\r\n\t            pointOptions = deepExtend({}, options);\r\n\t            evalOptions(pointOptions, {\r\n\t                value: value,\r\n\t                series: series,\r\n\t                dataItem: fields.dataItem\r\n\t            }, state);\r\n\t        }\r\n\r\n\t        return pointOptions;\r\n\t    },\r\n\r\n\t    pointType: function() {\r\n\t        return LinePoint;\r\n\t    },\r\n\r\n\t    pointOptions: function(series, seriesIx) {\r\n\t        var options = this.seriesOptions[seriesIx];\r\n\t        if (!options) {\r\n\t            var defaults = this.pointType().prototype.defaults;\r\n\t            this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\r\n\t                markers: {\r\n\t                    opacity: series.opacity\r\n\t                },\r\n\t                tooltip: {\r\n\t                    format: this.options.tooltip.format\r\n\t                },\r\n\t                labels: {\r\n\t                    format: this.options.labels.format\r\n\t                }\r\n\t            }, series);\r\n\t        }\r\n\r\n\t        return options;\r\n\t    },\r\n\r\n\t    createPoint: function(value, fields) {\r\n\t        var series = fields.series;\r\n\t        var pointOptions = this.pointOptions(series, fields.seriesIx);\r\n\t        var color = fields.color || series.color;\r\n\r\n\t        pointOptions = this.evalPointOptions(pointOptions, value, fields);\r\n\r\n\t        if (isFunction(series.color)) {\r\n\t            color = pointOptions.color;\r\n\t        }\r\n\r\n\t        var point = new LinePoint(value, pointOptions);\r\n\t        point.color = color;\r\n\r\n\t        this.append(point);\r\n\r\n\t        return point;\r\n\t    },\r\n\r\n\t    seriesAxes: function(series) {\r\n\t        var xAxisName = series.xAxis;\r\n\t        var yAxisName = series.yAxis;\r\n\t        var plotArea = this.plotArea;\r\n\t        var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\r\n\t        var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\r\n\r\n\t        if (!xAxis) {\r\n\t            throw new Error(\"Unable to locate X axis with name \" + xAxisName);\r\n\t        }\r\n\r\n\t        if (!yAxis) {\r\n\t            throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\r\n\t        }\r\n\r\n\t        return {\r\n\t            x: xAxis,\r\n\t            y: yAxis\r\n\t        };\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var this$1 = this;\r\n\r\n\t        var chartPoints = this.points;\r\n\t        var limit = !this.options.clip;\r\n\t        var pointIx = 0;\r\n\r\n\t        this.traverseDataPoints(function (value, fields) {\r\n\t            var point = chartPoints[pointIx++];\r\n\t            var seriesAxes = this$1.seriesAxes(fields.series);\r\n\t            var slotX = seriesAxes.x.getSlot(value.x, value.x, limit);\r\n\t            var slotY = seriesAxes.y.getSlot(value.y, value.y, limit);\r\n\r\n\t            if (point) {\r\n\t                if (slotX && slotY) {\r\n\t                    var pointSlot = this$1.pointSlot(slotX, slotY);\r\n\t                    point.reflow(pointSlot);\r\n\t                } else {\r\n\t                    point.visible = false;\r\n\t                }\r\n\t            }\r\n\t        });\r\n\r\n\t        this.box = targetBox;\r\n\t    },\r\n\r\n\t    pointSlot: function(slotX, slotY) {\r\n\t        return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\r\n\t    },\r\n\r\n\t    traverseDataPoints: function(callback) {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var series = ref.options.series;\r\n\t        var seriesPoints = ref.seriesPoints;\r\n\r\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\r\n\t            var currentSeries = series[seriesIx];\r\n\t            var currentSeriesPoints = seriesPoints[seriesIx];\r\n\t            if (!currentSeriesPoints) {\r\n\t                seriesPoints[seriesIx] = [];\r\n\t            }\r\n\r\n\t            for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\r\n\t                var ref$1 = this$1._bindPoint(currentSeries, seriesIx, pointIx);\r\n\t                var value = ref$1.valueFields;\r\n\t                var fields = ref$1.fields;\r\n\r\n\t                callback(value, deepExtend({\r\n\t                    pointIx: pointIx,\r\n\t                    series: currentSeries,\r\n\t                    seriesIx: seriesIx,\r\n\t                    dataItem: currentSeries.data[pointIx],\r\n\t                    owner: this$1\r\n\t                }, fields));\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    formatPointValue: function(point, format) {\r\n\t        var value = point.value;\r\n\t        return this.chartService.format.auto(format, value.x, value.y);\r\n\t    },\r\n\r\n\t    animationPoints: function() {\r\n\t        var points = this.points;\r\n\t        var result = [];\r\n\t        for (var idx = 0; idx < points.length; idx++) {\r\n\t            result.push((points[idx] || {}).marker);\r\n\t        }\r\n\t        return result;\r\n\t    }\r\n\t});\r\n\tsetDefaultOptions(ScatterChart, {\r\n\t    series: [],\r\n\t    tooltip: {\r\n\t        format: \"{0}, {1}\"\r\n\t    },\r\n\t    labels: {\r\n\t        format: \"{0}, {1}\"\r\n\t    },\r\n\t    clip: true\r\n\t});\r\n\tdeepExtend(ScatterChart.prototype, ClipAnimationMixin, {\r\n\t    _bindPoint: CategoricalChart.prototype._bindPoint\r\n\t});\r\n\r\n\tvar Bubble = LinePoint.extend({\r\n\t    init: function(value, options) {\r\n\t        LinePoint.fn.init.call(this, value, options);\r\n\r\n\t        this.category = value.category;\r\n\t    },\r\n\r\n\t    createHighlight: function() {\r\n\t        var highlight = this.options.highlight;\r\n\t        var border = highlight.border;\r\n\t        var markers = this.options.markers;\r\n\t        var center = this.box.center();\r\n\t        var radius = (markers.size + markers.border.width + border.width) / 2;\r\n\t        var highlightGroup = new Group();\r\n\t        var shadow = new drawing.Circle(new geometry.Circle([ center.x, center.y + radius / 5 + border.width / 2 ], radius + border.width / 2), {\r\n\t            stroke: {\r\n\t                color: 'none'\r\n\t            },\r\n\t            fill: this.createGradient({\r\n\t                gradient: 'bubbleShadow',\r\n\t                color: markers.background,\r\n\t                stops: [ {\r\n\t                    offset: 0,\r\n\t                    color: markers.background,\r\n\t                    opacity: 0.3\r\n\t                }, {\r\n\t                    offset: 1,\r\n\t                    color: markers.background,\r\n\t                    opacity: 0\r\n\t                } ]\r\n\t            })\r\n\t        });\r\n\t        var overlay = new drawing.Circle(new geometry.Circle([ center.x, center.y ], radius), {\r\n\t            stroke: {\r\n\t                color: border.color ||\r\n\t                    new Color(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),\r\n\t                width: border.width,\r\n\t                opacity: border.opacity\r\n\t            },\r\n\t            fill: {\r\n\t                color: markers.background,\r\n\t                opacity: highlight.opacity\r\n\t            }\r\n\t        });\r\n\r\n\t        highlightGroup.append(shadow, overlay);\r\n\r\n\t        return highlightGroup;\r\n\t    }\r\n\t});\r\n\r\n\tBubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {\r\n\t    labels: {\r\n\t        position: CENTER\r\n\t    },\r\n\t    highlight: {\r\n\t        opacity: 1,\r\n\t        border: {\r\n\t            color: \"#fff\",\r\n\t            width: 2,\r\n\t            opacity: 1\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tBubble.prototype.defaults.highlight.zIndex = undefined;\r\n\r\n\tvar BubbleChart = ScatterChart.extend({\r\n\t    _initFields: function() {\r\n\t        this._maxSize = MIN_VALUE;\r\n\t        ScatterChart.fn._initFields.call(this);\r\n\t    },\r\n\r\n\t    addValue: function(value, fields) {\r\n\t        if (value.size !== null && (value.size > 0 || (value.size < 0 && fields.series.negativeValues.visible))) {\r\n\t            this._maxSize = Math.max(this._maxSize, Math.abs(value.size));\r\n\t            ScatterChart.fn.addValue.call(this, value, fields);\r\n\t        } else {\r\n\t            this.points.push(null);\r\n\t            this.seriesPoints[fields.seriesIx].push(null);\r\n\t        }\r\n\t    },\r\n\r\n\t    reflow: function(box) {\r\n\t        this.updateBubblesSize(box);\r\n\t        ScatterChart.fn.reflow.call(this, box);\r\n\t    },\r\n\r\n\t    pointType: function() {\r\n\t        return Bubble;\r\n\t    },\r\n\r\n\t    createPoint: function(value, fields) {\r\n\t        var series = fields.series;\r\n\t        var pointsCount = series.data.length;\r\n\t        var delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);\r\n\t        var animationOptions = {\r\n\t            delay: delay,\r\n\t            duration: INITIAL_ANIMATION_DURATION - delay,\r\n\t            type: BUBBLE\r\n\t        };\r\n\r\n\t        var color = fields.color || series.color;\r\n\t        if (value.size < 0 && series.negativeValues.visible) {\r\n\t            color = valueOrDefault(\r\n\t                series.negativeValues.color, color\r\n\t            );\r\n\t        }\r\n\r\n\t        var pointOptions = deepExtend({\r\n\t            labels: {\r\n\t                animation: {\r\n\t                    delay: delay,\r\n\t                    duration: INITIAL_ANIMATION_DURATION - delay\r\n\t                }\r\n\t            }\r\n\t        }, this.pointOptions(series, fields.seriesIx), {\r\n\t            markers: {\r\n\t                type: CIRCLE,\r\n\t                border: series.border,\r\n\t                opacity: series.opacity,\r\n\t                animation: animationOptions\r\n\t            }\r\n\t        });\r\n\r\n\t        pointOptions = this.evalPointOptions(pointOptions, value, fields);\r\n\t        if (isFunction(series.color)) {\r\n\t            color = pointOptions.color;\r\n\t        }\r\n\r\n\t        pointOptions.markers.background = color;\r\n\r\n\t        var point = new Bubble(value, pointOptions);\r\n\t        point.color = color;\r\n\r\n\t        this.append(point);\r\n\r\n\t        return point;\r\n\t    },\r\n\r\n\t    updateBubblesSize: function(box) {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var series = ref.options.series;\r\n\t        var boxSize = Math.min(box.width(), box.height());\r\n\r\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\r\n\t            var currentSeries = series[seriesIx];\r\n\t            var seriesPoints = this$1.seriesPoints[seriesIx];\r\n\t            var minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);\r\n\t            var maxSize = currentSeries.maxSize || boxSize * 0.2;\r\n\t            var minR = minSize / 2;\r\n\t            var maxR = maxSize / 2;\r\n\t            var minArea = Math.PI * minR * minR;\r\n\t            var maxArea = Math.PI * maxR * maxR;\r\n\t            var areaRange = maxArea - minArea;\r\n\t            var areaRatio = areaRange / this$1._maxSize;\r\n\r\n\t            for (var pointIx = 0; pointIx < seriesPoints.length; pointIx++) {\r\n\t                var point = seriesPoints[pointIx];\r\n\t                if (point) {\r\n\t                    var area = Math.abs(point.value.size) * areaRatio;\r\n\t                    var radius = Math.sqrt((minArea + area) / Math.PI);\r\n\t                    var baseZIndex = valueOrDefault(point.options.zIndex, 0);\r\n\t                    var zIndex = baseZIndex + (1 - radius / maxR);\r\n\r\n\t                    deepExtend(point.options, {\r\n\t                        zIndex: zIndex,\r\n\t                        markers: {\r\n\t                            size: radius * 2,\r\n\t                            zIndex: zIndex\r\n\t                        },\r\n\t                        labels: {\r\n\t                            zIndex: zIndex + 1\r\n\t                        }\r\n\t                    });\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    formatPointValue: function(point, format) {\r\n\t        var value = point.value;\r\n\t        return this.chartService.format.auto(format, value.x, value.y, value.size, point.category);\r\n\t    },\r\n\r\n\t    createAnimation: function() {},\r\n\r\n\t    createVisual: function() {}\r\n\t});\r\n\r\n\tsetDefaultOptions(BubbleChart, {\r\n\t    tooltip: {\r\n\t        format: \"{3}\"\r\n\t    },\r\n\t    labels: {\r\n\t        format: \"{3}\"\r\n\t    }\r\n\t});\r\n\r\n\tvar Target = ShapeElement.extend({\r\n\r\n\t});\r\n\r\n\tdeepExtend(Target.prototype, PointEventsMixin);\r\n\r\n\tvar Bullet = ChartElement.extend({\r\n\t    init: function(value, options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.aboveAxis = this.options.aboveAxis;\r\n\t        this.color = options.color || WHITE;\r\n\t        this.value = value;\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        var options = this.options;\r\n\r\n\t        if (!this._rendered) {\r\n\t            this._rendered = true;\r\n\r\n\t            if (defined(this.value.target)) {\r\n\t                this.target = new Target({\r\n\t                    type: options.target.shape,\r\n\t                    background: options.target.color || this.color,\r\n\t                    opacity: options.opacity,\r\n\t                    zIndex: options.zIndex,\r\n\t                    border: options.target.border,\r\n\t                    vAlign: TOP,\r\n\t                    align: RIGHT\r\n\t                });\r\n\r\n\t                this.target.value = this.value;\r\n\t                this.target.dataItem = this.dataItem;\r\n\t                this.target.series = this.series;\r\n\r\n\t                this.append(this.target);\r\n\t            }\r\n\r\n\t            this.createNote();\r\n\t        }\r\n\t    },\r\n\r\n\t    reflow: function(box) {\r\n\t        this.render();\r\n\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var target = ref.target;\r\n\t        var chart = ref.owner;\r\n\t        var invertAxes = options.invertAxes;\r\n\t        var valueAxis = chart.seriesValueAxis(this.options);\r\n\t        var categorySlot = chart.categorySlot(chart.categoryAxis, options.categoryIx, valueAxis);\r\n\t        var targetValueSlot = valueAxis.getSlot(this.value.target);\r\n\t        var targetSlotX = invertAxes ? targetValueSlot : categorySlot;\r\n\t        var targetSlotY = invertAxes ? categorySlot : targetValueSlot;\r\n\r\n\t        if (target) {\r\n\t            var targetSlot = new Box(\r\n\t                targetSlotX.x1, targetSlotY.y1,\r\n\t                targetSlotX.x2, targetSlotY.y2\r\n\t            );\r\n\t            target.options.height = invertAxes ? targetSlot.height() : options.target.line.width;\r\n\t            target.options.width = invertAxes ? options.target.line.width : targetSlot.width();\r\n\t            target.reflow(targetSlot);\r\n\t        }\r\n\r\n\t        if (this.note) {\r\n\t            this.note.reflow(box);\r\n\t        }\r\n\r\n\t        this.box = box;\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\r\n\t        var options = this.options;\r\n\t        var body = Path.fromRect(this.box.toRect(), {\r\n\t            fill: {\r\n\t                color: this.color,\r\n\t                opacity: options.opacity\r\n\t            },\r\n\t            stroke: null\r\n\t        });\r\n\r\n\t        if (options.border.width > 0) {\r\n\t            body.options.set(\"stroke\", {\r\n\t                color: options.border.color || this.color,\r\n\t                width: options.border.width,\r\n\t                dashType: options.border.dashType,\r\n\t                opacity: valueOrDefault(options.border.opacity, options.opacity)\r\n\t            });\r\n\t        }\r\n\r\n\t        this.bodyVisual = body;\r\n\r\n\t        alignPathToPixel(body);\r\n\t        this.visual.append(body);\r\n\t    },\r\n\r\n\t    createAnimation: function() {\r\n\t        if (this.bodyVisual) {\r\n\t            this.animation = Animation.create(\r\n\t                this.bodyVisual, this.options.animation\r\n\t            );\r\n\t        }\r\n\t    },\r\n\r\n\t    createHighlight: function(style) {\r\n\t        return Path.fromRect(this.box.toRect(), style);\r\n\t    },\r\n\r\n\t    highlightVisual: function() {\r\n\t        return this.bodyVisual;\r\n\t    },\r\n\r\n\t    highlightVisualArgs: function() {\r\n\t        return {\r\n\t            rect: this.box.toRect(),\r\n\t            visual: this.bodyVisual,\r\n\t            options: this.options\r\n\t        };\r\n\t    },\r\n\r\n\t    formatValue: function(format) {\r\n\t        return this.owner.formatPointValue(this, format);\r\n\t    }\r\n\t});\r\n\r\n\tBullet.prototype.tooltipAnchor = Bar.prototype.tooltipAnchor;\r\n\r\n\tsetDefaultOptions(Bullet, {\r\n\t    border: {\r\n\t        width: 1\r\n\t    },\r\n\t    vertical: false,\r\n\t    opacity: 1,\r\n\t    target: {\r\n\t        shape: \"\",\r\n\t        border: {\r\n\t            width: 0,\r\n\t            color: \"green\"\r\n\t        },\r\n\t        line: {\r\n\t            width: 2\r\n\t        }\r\n\t    },\r\n\t    tooltip: {\r\n\t        format: \"Current: {0}<br />Target: {1}\"\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(Bullet.prototype, PointEventsMixin);\r\n\tdeepExtend(Bullet.prototype, NoteMixin);\r\n\r\n\tvar BulletChart = CategoricalChart.extend({\r\n\t    init: function(plotArea, options) {\r\n\r\n\t        wrapData(options);\r\n\r\n\t        CategoricalChart.fn.init.call(this, plotArea, options);\r\n\t    },\r\n\r\n\t    reflowCategories: function(categorySlots) {\r\n\t        var children = this.children;\r\n\t        var childrenLength = children.length;\r\n\r\n\t        for (var i = 0; i < childrenLength; i++) {\r\n\t            children[i].reflow(categorySlots[i]);\r\n\t        }\r\n\t    },\r\n\r\n\t    plotRange: function(point) {\r\n\t        var series = point.series;\r\n\t        var valueAxis = this.seriesValueAxis(series);\r\n\t        var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\r\n\r\n\t        return [ axisCrossingValue, point.value.current || axisCrossingValue ];\r\n\t    },\r\n\r\n\t    createPoint: function(data, fields) {\r\n\t        var categoryIx = fields.categoryIx;\r\n\t        var category = fields.category;\r\n\t        var series = fields.series;\r\n\t        var seriesIx = fields.seriesIx;\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var children = ref.children;\r\n\t        var value = data.valueFields;\r\n\r\n\t        var bulletOptions = deepExtend({\r\n\t            vertical: !options.invertAxes,\r\n\t            overlay: series.overlay,\r\n\t            categoryIx: categoryIx,\r\n\t            invertAxes: options.invertAxes\r\n\t        }, series);\r\n\r\n\t        var color = data.fields.color || series.color;\r\n\t        bulletOptions = this.evalPointOptions(\r\n\t            bulletOptions, value, category, categoryIx, series, seriesIx\r\n\t        );\r\n\r\n\t        if (isFunction(series.color)) {\r\n\t            color = bulletOptions.color;\r\n\t        }\r\n\r\n\t        var bullet = new Bullet(value, bulletOptions);\r\n\t        bullet.color = color;\r\n\r\n\t        var cluster = children[categoryIx];\r\n\t        if (!cluster) {\r\n\t            cluster = new ClusterLayout({\r\n\t                vertical: options.invertAxes,\r\n\t                gap: options.gap,\r\n\t                spacing: options.spacing,\r\n\t                rtl: !options.invertAxes && (this.chartService || {}).rtl\r\n\t            });\r\n\t            this.append(cluster);\r\n\t        }\r\n\r\n\t        cluster.append(bullet);\r\n\r\n\t        return bullet;\r\n\t    },\r\n\r\n\t    updateRange: function(value, fields) {\r\n\t        var current = value.current;\r\n\t        var target = value.target;\r\n\t        var axisName = fields.series.axis;\r\n\t        var axisRange = this.valueAxisRanges[axisName];\r\n\r\n\t        if (defined(current) && !isNaN(current) && defined(target && !isNaN(target))) {\r\n\t            axisRange = this.valueAxisRanges[axisName] =\r\n\t                axisRange || { min: MAX_VALUE, max: MIN_VALUE };\r\n\r\n\t            axisRange.min = Math.min(axisRange.min, current, target);\r\n\t            axisRange.max = Math.max(axisRange.max, current, target);\r\n\t        }\r\n\t    },\r\n\r\n\t    formatPointValue: function(point, format) {\r\n\t        return this.chartService.format.auto(format, point.value.current, point.value.target);\r\n\t    },\r\n\r\n\t    pointValue: function(data) {\r\n\t        return data.valueFields.current;\r\n\t    },\r\n\r\n\t    aboveAxis: function(point) {\r\n\t        var value = point.value.current;\r\n\r\n\t        return value > 0;\r\n\t    },\r\n\r\n\t    createAnimation: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var points = this.points;\r\n\r\n\t        this._setAnimationOptions();\r\n\r\n\t        for (var idx = 0; idx < points.length; idx++) {\r\n\t            var point = points[idx];\r\n\t            point.options.animation = this$1.options.animation;\r\n\t            point.createAnimation();\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tBulletChart.prototype._setAnimationOptions = BarChart.prototype._setAnimationOptions;\r\n\r\n\tsetDefaultOptions(BulletChart, {\r\n\t    animation: {\r\n\t        type: BAR\r\n\t    }\r\n\t});\r\n\r\n\tfunction wrapData(options) {\r\n\t    var series = options.series;\r\n\r\n\t    for (var i = 0; i < series.length; i++) {\r\n\t        var seriesItem = series[i];\r\n\t        var data = seriesItem.data;\r\n\t        if (data && !isArray(data[0]) && !isObject(data[0])) {\r\n\t            seriesItem.data = [ data ];\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tvar BaseTooltip = Class.extend({\r\n\t    init: function(chartService, options) {\r\n\r\n\t        this.chartService = chartService;\r\n\t        this.options = deepExtend({}, this.options, options);\r\n\t    },\r\n\r\n\t    getStyle: function(options, point) {\r\n\t        var background = options.background;\r\n\t        var border = options.border.color;\r\n\r\n\t        if (point) {\r\n\t            var pointColor = point.color || point.options.color;\r\n\t            background = valueOrDefault(background, pointColor);\r\n\t            border = valueOrDefault(border, pointColor);\r\n\t        }\r\n\r\n\t        var padding = getSpacing(options.padding || {}, \"auto\");\r\n\r\n\t        return {\r\n\t            backgroundColor: background,\r\n\t            borderColor: border,\r\n\t            font: options.font,\r\n\t            color: options.color,\r\n\t            opacity: options.opacity,\r\n\t            borderWidth: styleValue(options.border.width),\r\n\t            paddingTop: styleValue(padding.top),\r\n\t            paddingBottom: styleValue(padding.bottom),\r\n\t            paddingLeft: styleValue(padding.left),\r\n\t            paddingRight: styleValue(padding.right)\r\n\t        };\r\n\t    },\r\n\r\n\t    show: function(options, tooltipOptions, point) {\r\n\t        options.format = tooltipOptions.format;\r\n\r\n\t        var style = this.getStyle(tooltipOptions, point);\r\n\t        options.style = style;\r\n\r\n\t        if (!defined(tooltipOptions.color) && new Color(style.backgroundColor).percBrightness() > 180) {\r\n\t            options.className = \"k-chart-tooltip-inverse\";\r\n\t        }\r\n\r\n\t        this.chartService.notify(SHOW_TOOLTIP, options);\r\n\t    },\r\n\r\n\t    hide: function() {\r\n\t        if (this.chartService) {\r\n\t            this.chartService.notify(HIDE_TOOLTIP);\r\n\t        }\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        delete this.chartService;\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(BaseTooltip, {\r\n\t    border: {\r\n\t        width: 1\r\n\t    },\r\n\t    opacity: 1\r\n\t});\r\n\r\n\tvar CrosshairTooltip = BaseTooltip.extend({\r\n\t    init: function(chartService, crosshair, options) {\r\n\t        BaseTooltip.fn.init.call(this, chartService, options);\r\n\r\n\t        this.crosshair = crosshair;\r\n\t        this.formatService = chartService.format;\r\n\t        this.initAxisName();\r\n\t    },\r\n\r\n\t    initAxisName: function() {\r\n\t        var axis = this.crosshair.axis;\r\n\t        var plotArea = axis.plotArea;\r\n\t        var name;\r\n\t        if (plotArea.categoryAxis) {\r\n\t            name = axis.getCategory ? \"categoryAxis\" : \"valueAxis\";\r\n\t        } else {\r\n\t            name = axis.options.vertical ? \"yAxis\" : \"xAxis\";\r\n\t        }\r\n\t        this.axisName = name;\r\n\t    },\r\n\r\n\t    showAt: function(point) {\r\n\t        var ref = this;\r\n\t        var axis = ref.crosshair.axis;\r\n\t        var options = ref.options;\r\n\t        var value = axis[options.stickyMode ? \"getCategory\" : \"getValue\"](point);\r\n\t        var formattedValue = value;\r\n\r\n\t        if (options.format) {\r\n\t            formattedValue = this.formatService.auto(options.format, value);\r\n\t        } else if (axis.options.type === DATE) {\r\n\t            formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value);\r\n\t        }\r\n\r\n\t        this.show({\r\n\t            point: point,\r\n\t            anchor: this.getAnchor(),\r\n\t            crosshair: this.crosshair,\r\n\t            value: formattedValue,\r\n\t            axisName: this.axisName,\r\n\t            axisIndex: this.crosshair.axis.axisIndex\r\n\t        }, this.options);\r\n\t    },\r\n\r\n\t    hide: function() {\r\n\t        this.chartService.notify(HIDE_TOOLTIP, {\r\n\t            crosshair: this.crosshair,\r\n\t            axisName: this.axisName,\r\n\t            axisIndex: this.crosshair.axis.axisIndex\r\n\t        });\r\n\t    },\r\n\r\n\t    getAnchor: function() {\r\n\t        var ref = this;\r\n\t        var crosshair = ref.crosshair;\r\n\t        var ref_options = ref.options;\r\n\t        var position = ref_options.position;\r\n\t        var padding = ref_options.padding;\r\n\t        var vertical = !crosshair.axis.options.vertical;\r\n\t        var lineBox = crosshair.line.bbox();\r\n\t        var horizontalAlign, verticalAlign, point;\r\n\r\n\t        if (vertical) {\r\n\t            horizontalAlign = CENTER;\r\n\t            if (position === BOTTOM) {\r\n\t                verticalAlign = TOP;\r\n\t                point = lineBox.bottomLeft().translate(0, padding);\r\n\t            } else {\r\n\t                verticalAlign = BOTTOM;\r\n\t                point = lineBox.topLeft().translate(0, -padding);\r\n\t            }\r\n\t        } else {\r\n\t            verticalAlign = CENTER;\r\n\t            if (position === LEFT) {\r\n\t                horizontalAlign = RIGHT;\r\n\t                point = lineBox.topLeft().translate(-padding, 0);\r\n\t            } else {\r\n\t                horizontalAlign = LEFT;\r\n\t                point = lineBox.topRight().translate(padding, 0);\r\n\t            }\r\n\t        }\r\n\r\n\t        return {\r\n\t            point: point,\r\n\t            align: {\r\n\t                horizontal: horizontalAlign,\r\n\t                vertical: verticalAlign\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(CrosshairTooltip, {\r\n\t    padding: 10\r\n\t});\r\n\r\n\tvar Crosshair = ChartElement.extend({\r\n\t    init: function(chartService, axis, options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.axis = axis;\r\n\t        this.stickyMode = axis instanceof CategoryAxis;\r\n\r\n\t        var tooltipOptions = this.options.tooltip;\r\n\r\n\t        if (tooltipOptions.visible) {\r\n\t            this.tooltip = new CrosshairTooltip(chartService, this,\r\n\t                deepExtend({}, tooltipOptions, { stickyMode: this.stickyMode })\r\n\t            );\r\n\t        }\r\n\t    },\r\n\r\n\t    showAt: function(point) {\r\n\t        this.point = point;\r\n\t        this.moveLine();\r\n\t        this.line.visible(true);\r\n\r\n\t        if (this.tooltip) {\r\n\t            this.tooltip.showAt(point);\r\n\t        }\r\n\t    },\r\n\r\n\t    hide: function() {\r\n\t        this.line.visible(false);\r\n\r\n\t        if (this.tooltip) {\r\n\t            this.tooltip.hide();\r\n\t        }\r\n\t    },\r\n\r\n\t    moveLine: function() {\r\n\t        var ref = this;\r\n\t        var axis = ref.axis;\r\n\t        var point = ref.point;\r\n\t        var vertical = axis.options.vertical;\r\n\t        var box = this.getBox();\r\n\t        var dim = vertical ? Y : X;\r\n\t        var lineStart = new GeometryPoint(box.x1, box.y1);\r\n\t        var lineEnd;\r\n\r\n\t        if (vertical) {\r\n\t            lineEnd = new GeometryPoint(box.x2, box.y1);\r\n\t        } else {\r\n\t            lineEnd = new GeometryPoint(box.x1, box.y2);\r\n\t        }\r\n\r\n\t        if (point) {\r\n\t            if (this.stickyMode) {\r\n\t                var slot = axis.getSlot(axis.pointCategoryIndex(point));\r\n\t                lineStart[dim] = lineEnd[dim] = slot.center()[dim];\r\n\t            } else {\r\n\t                lineStart[dim] = lineEnd[dim] = point[dim];\r\n\t            }\r\n\t        }\r\n\r\n\t        this.box = box;\r\n\r\n\t        this.line.moveTo(lineStart).lineTo(lineEnd);\r\n\t    },\r\n\r\n\t    getBox: function() {\r\n\t        var axis = this.axis;\r\n\t        var axes = axis.pane.axes;\r\n\t        var length = axes.length;\r\n\t        var vertical = axis.options.vertical;\r\n\t        var box = axis.lineBox().clone();\r\n\t        var dim = vertical ? X : Y;\r\n\t        var axisLineBox;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var currentAxis = axes[i];\r\n\t            if (currentAxis.options.vertical !== vertical) {\r\n\t                if (!axisLineBox) {\r\n\t                    axisLineBox = currentAxis.lineBox().clone();\r\n\t                } else {\r\n\t                    axisLineBox.wrap(currentAxis.lineBox());\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        box[dim + 1] = axisLineBox[dim + 1];\r\n\t        box[dim + 2] = axisLineBox[dim + 2];\r\n\r\n\t        return box;\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\r\n\t        var options = this.options;\r\n\t        this.line = new Path({\r\n\t            stroke: {\r\n\t                color: options.color,\r\n\t                width: options.width,\r\n\t                opacity: options.opacity,\r\n\t                dashType: options.dashType\r\n\t            },\r\n\t            visible: false\r\n\t        });\r\n\r\n\t        this.moveLine();\r\n\t        this.visual.append(this.line);\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        if (this.tooltip) {\r\n\t            this.tooltip.destroy();\r\n\t        }\r\n\r\n\t        ChartElement.fn.destroy.call(this);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(Crosshair, {\r\n\t    color: BLACK,\r\n\t    width: 2,\r\n\t    zIndex: -1,\r\n\t    tooltip: {\r\n\t        visible: false\r\n\t    }\r\n\t});\r\n\r\n\tvar ChartContainer = ChartElement.extend({\r\n\t    init: function(options, pane) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\t        this.pane = pane;\r\n\t    },\r\n\r\n\t    shouldClip: function() {\r\n\t        var children = this.children;\r\n\t        var length = children.length;\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            if (children[i].options.clip === true) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t        return false;\r\n\t    },\r\n\r\n\t    _clipBox: function() {\r\n\t        return this.pane.chartsBox();\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        this.visual = new Group({\r\n\t            zIndex: 0\r\n\t        });\r\n\r\n\t        if (this.shouldClip()) {\r\n\t            var clipBox = this.clipBox = this._clipBox();\r\n\t            var clipRect = clipBox.toRect();\r\n\t            var clipPath = Path.fromRect(clipRect);\r\n\r\n\t            this.visual.clip(clipPath);\r\n\t            this.unclipLabels();\r\n\t        }\r\n\t    },\r\n\r\n\t    stackRoot: function() {\r\n\t        return this;\r\n\t    },\r\n\r\n\t    unclipLabels: function() {\r\n\t        var ref = this;\r\n\t        var charts = ref.children;\r\n\t        var clipBox = ref.clipBox;\r\n\r\n\t        for (var i = 0; i < charts.length; i++) {\r\n\t            var points = charts[i].points || {};\r\n\t            var length = points.length;\r\n\r\n\t            for (var j = 0; j < length; j++) {\r\n\t                var point = points[j];\r\n\t                if (point && point.visible !== false && point.overlapsBox && point.overlapsBox(clipBox)) {\r\n\t                    if (point.unclipElements) {\r\n\t                        point.unclipElements();\r\n\t                    } else {\r\n\t                        var label = point.label;\r\n\t                        var note = point.note;\r\n\r\n\t                        if (label && label.options.visible) {\r\n\t                            if (label.alignToClipBox) {\r\n\t                                label.alignToClipBox(clipBox);\r\n\t                            }\r\n\t                            label.options.noclip = true;\r\n\t                        }\r\n\r\n\t                        if (note && note.options.visible) {\r\n\t                            note.options.noclip = true;\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        ChartElement.fn.destroy.call(this);\r\n\r\n\t        delete this.parent;\r\n\t    }\r\n\t});\r\n\r\n\tChartContainer.prototype.isStackRoot = true;\r\n\r\n\tvar Pane = BoxElement.extend({\r\n\t    init: function(options) {\r\n\t        BoxElement.fn.init.call(this, options);\r\n\r\n\t        this.id = paneID();\r\n\r\n\t        this.createTitle();\r\n\r\n\t        this.content = new ChartElement();\r\n\r\n\t        this.chartContainer = new ChartContainer({}, this);\r\n\t        this.append(this.content);\r\n\r\n\t        this.axes = [];\r\n\t        this.charts = [];\r\n\t    },\r\n\r\n\t    createTitle: function() {\r\n\t        var titleOptions = this.options.title;\r\n\t        if (isObject(titleOptions)) {\r\n\t            titleOptions = deepExtend({}, titleOptions, {\r\n\t                align: titleOptions.position,\r\n\t                position: TOP\r\n\t            });\r\n\t        }\r\n\r\n\t        this.title = dataviz.Title.buildTitle(titleOptions, this, Pane.prototype.options.title);\r\n\t    },\r\n\r\n\t    appendAxis: function(axis) {\r\n\t        this.content.append(axis);\r\n\t        this.axes.push(axis);\r\n\t        axis.pane = this;\r\n\t    },\r\n\r\n\t    appendChart: function(chart) {\r\n\t        if (this.chartContainer.parent !== this.content) {\r\n\t            this.content.append(this.chartContainer);\r\n\t        }\r\n\r\n\t        this.charts.push(chart);\r\n\t        this.chartContainer.append(chart);\r\n\t        chart.pane = this;\r\n\t    },\r\n\r\n\t    empty: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var plotArea = this.parent;\r\n\r\n\t        if (plotArea) {\r\n\t            for (var i = 0; i < this.axes.length; i++) {\r\n\t                plotArea.removeAxis(this$1.axes[i]);\r\n\t            }\r\n\r\n\t            for (var i$1 = 0; i$1 < this.charts.length; i$1++) {\r\n\t                plotArea.removeChart(this$1.charts[i$1]);\r\n\t            }\r\n\t        }\r\n\r\n\t        this.axes = [];\r\n\t        this.charts = [];\r\n\r\n\t        this.content.destroy();\r\n\t        this.content.children = [];\r\n\t        this.chartContainer.children = [];\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        // Content (such as charts) is rendered, but excluded from reflows\r\n\t        var content;\r\n\t        if (last(this.children) === this.content) {\r\n\t            content = this.children.pop();\r\n\t        }\r\n\r\n\t        BoxElement.fn.reflow.call(this, targetBox);\r\n\r\n\t        if (content) {\r\n\t            this.children.push(content);\r\n\t        }\r\n\r\n\t        if (this.title) {\r\n\t            this.contentBox.y1 += this.title.box.height();\r\n\t        }\r\n\t    },\r\n\r\n\t    visualStyle: function() {\r\n\t        var style = BoxElement.fn.visualStyle.call(this);\r\n\t        style.zIndex = -10;\r\n\r\n\t        return style;\r\n\t    },\r\n\r\n\t    renderComplete: function() {\r\n\t        if (this.options.visible) {\r\n\t            this.createGridLines();\r\n\t        }\r\n\t    },\r\n\r\n\t    stackRoot: function() {\r\n\t        return this;\r\n\t    },\r\n\r\n\t    clipRoot: function() {\r\n\t        return this;\r\n\t    },\r\n\r\n\t    createGridLines: function() {\r\n\t        var axes = this.axes;\r\n\t        var allAxes = axes.concat(this.parent.axes);\r\n\t        var vGridLines = [];\r\n\t        var hGridLines = [];\r\n\r\n\t        // TODO\r\n\t        // Is full combination really necessary?\r\n\t        for (var i = 0; i < axes.length; i++) {\r\n\t            var axis = axes[i];\r\n\t            var vertical = axis.options.vertical;\r\n\t            var gridLines = vertical ? vGridLines : hGridLines;\r\n\t            for (var j = 0; j < allAxes.length; j++) {\r\n\t                if (gridLines.length === 0) {\r\n\t                    var altAxis = allAxes[j];\r\n\t                    if (vertical !== altAxis.options.vertical) {\r\n\t                        append(gridLines, axis.createGridLines(altAxis));\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    refresh: function() {\r\n\t        this.visual.clear();\r\n\r\n\t        this.content.parent = null;\r\n\t        this.content.createGradient = this.createGradient.bind(this);\r\n\t        this.content.renderVisual();\r\n\t        this.content.parent = this;\r\n\r\n\t        if (this.title) {\r\n\t            this.visual.append(this.title.visual);\r\n\t        }\r\n\r\n\t        this.visual.append(this.content.visual);\r\n\r\n\t        this.renderComplete();\r\n\t    },\r\n\r\n\t    chartsBox: function() {\r\n\t        var axes = this.axes;\r\n\t        var length = axes.length;\r\n\t        var chartsBox = new Box();\r\n\r\n\t        for (var idx = 0; idx < length; idx++) {\r\n\t            var axis = axes[idx];\r\n\t            var axisValueField = axis.options.vertical ? Y : X;\r\n\t            var lineBox = axis.lineBox();\r\n\t            chartsBox[axisValueField + 1] = lineBox[axisValueField + 1];\r\n\t            chartsBox[axisValueField + 2] = lineBox[axisValueField + 2];\r\n\t        }\r\n\r\n\t        if (chartsBox.x2 === 0) {\r\n\t            var allAxes = this.parent.axes;\r\n\t            var length$1 = allAxes.length;\r\n\r\n\t            for (var idx$1 = 0; idx$1 < length$1; idx$1++) {\r\n\t                var axis$1 = allAxes[idx$1];\r\n\t                if (!axis$1.options.vertical) {\r\n\t                    var lineBox$1 = axis$1.lineBox();\r\n\t                    chartsBox.x1 = lineBox$1.x1;\r\n\t                    chartsBox.x2 = lineBox$1.x2;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t        return chartsBox;\r\n\t    },\r\n\r\n\t    clipBox: function() {\r\n\t        return this.chartContainer.clipBox;\r\n\t    }\r\n\t});\r\n\r\n\tvar ID = 1;\r\n\r\n\tfunction paneID() {\r\n\t    return \"pane\" + ID++;\r\n\t}\r\n\r\n\tPane.prototype.isStackRoot = true;\r\n\r\n\tsetDefaultOptions(Pane, {\r\n\t    zIndex: -1,\r\n\t    shrinkToFit: true,\r\n\t    title: {\r\n\t        align: LEFT\r\n\t    },\r\n\t    visible: true\r\n\t});\r\n\r\n\tfunction segmentVisible(series, fields, index) {\r\n\t    var visible = fields.visible;\r\n\t    if (defined(visible)) {\r\n\t        return visible;\r\n\t    }\r\n\r\n\t    var pointVisibility = series.pointVisibility;\r\n\t    if (pointVisibility) {\r\n\t        return pointVisibility[index];\r\n\t    }\r\n\t}\r\n\r\n\tfunction bindSegments(series) {\r\n\t    var data = series.data;\r\n\t    var points = [];\r\n\t    var sum = 0;\r\n\t    var count = 0;\r\n\r\n\t    for (var idx = 0; idx < data.length; idx++) {\r\n\t        var pointData = SeriesBinder.current.bindPoint(series, idx);\r\n\t        var value = pointData.valueFields.value;\r\n\r\n\t        if (isString(value)) {\r\n\t            value = parseFloat(value);\r\n\t        }\r\n\r\n\t        if (isNumber(value)) {\r\n\t            pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;\r\n\r\n\t            pointData.value = Math.abs(value);\r\n\t            points.push(pointData);\r\n\r\n\t            if (pointData.visible) {\r\n\t                sum += pointData.value;\r\n\t            }\r\n\r\n\t            if (value !== 0) {\r\n\t                count++;\r\n\t            }\r\n\t        } else {\r\n\t            points.push(null);\r\n\t        }\r\n\t    }\r\n\r\n\t    return {\r\n\t        total: sum,\r\n\t        points: points,\r\n\t        count: count\r\n\t    };\r\n\t}\r\n\r\n\tfunction equalsIgnoreCase(a, b) {\r\n\t    if (a && b) {\r\n\t        return a.toLowerCase() === b.toLowerCase();\r\n\t    }\r\n\r\n\t    return a === b;\r\n\t}\r\n\r\n\tfunction filterSeriesByType(series, types) {\r\n\t    var result = [];\r\n\r\n\t    var seriesTypes = [].concat(types);\r\n\t    for (var idx = 0; idx < series.length; idx++) {\r\n\t        var currentSeries = series[idx];\r\n\t        if (inArray(currentSeries.type, seriesTypes)) {\r\n\t            result.push(currentSeries);\r\n\t        }\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction getDateField(field, row, intlService) {\r\n\t    if (row === null) {\r\n\t        return row;\r\n\t    }\r\n\r\n\t    var key = \"_date_\" + field;\r\n\t    var value = row[key];\r\n\r\n\t    if (!value) {\r\n\t        value = parseDate(intlService, getter(field, true)(row));\r\n\t        row[key] = value;\r\n\t    }\r\n\r\n\t    return value;\r\n\t}\r\n\r\n\tfunction isDateAxis(axisOptions, sampleCategory) {\r\n\t    var type = axisOptions.type;\r\n\t    var dateCategory = sampleCategory instanceof Date;\r\n\r\n\t    return (!type && dateCategory) || equalsIgnoreCase(type, DATE);\r\n\t}\r\n\r\n\tfunction singleItemOrArray(array) {\r\n\t    return array.length === 1 ? array[0] : array;\r\n\t}\r\n\r\n\tvar PlotAreaBase = ChartElement.extend({\r\n\t    init: function(series, options, chartService) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.initFields(series, options);\r\n\t        this.series = series;\r\n\t        this.initSeries();\r\n\t        this.charts = [];\r\n\t        this.options.legend.items = [];\r\n\t        this.axes = [];\r\n\t        this.crosshairs = [];\r\n\t        this.chartService = chartService;\r\n\t        this.originalOptions = options;\r\n\r\n\t        this.createPanes();\r\n\t        this.render();\r\n\t        this.createCrosshairs();\r\n\t    },\r\n\r\n\t    initFields: function() { },\r\n\r\n\t    initSeries: function() {\r\n\t        var series = this.series;\r\n\r\n\t        for (var i = 0; i < series.length; i++) {\r\n\t            series[i].index = i;\r\n\t        }\r\n\t    },\r\n\r\n\t    createPanes: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var defaults = { title: { color: (this.options.title || {}).color } };\r\n\t        var panes = [];\r\n\t        var paneOptions = this.options.panes || [];\r\n\t        var panesLength = Math.max(paneOptions.length, 1);\r\n\r\n\t        function setTitle(options, defaults) {\r\n\t            if (isString(options.title)) {\r\n\t                options.title = {\r\n\t                    text: options.title\r\n\t                };\r\n\t            }\r\n\r\n\t            options.title = deepExtend({}, defaults.title, options.title);\r\n\t        }\r\n\r\n\t        for (var i = 0; i < panesLength; i++) {\r\n\t            var options = paneOptions[i] || {};\r\n\t            setTitle(options, defaults);\r\n\r\n\t            var currentPane = new Pane(options);\r\n\t            currentPane.paneIndex = i;\r\n\r\n\t            panes.push(currentPane);\r\n\t            this$1.append(currentPane);\r\n\t        }\r\n\r\n\t        this.panes = panes;\r\n\t    },\r\n\r\n\t    createCrosshairs: function(panes) {\r\n\t        var this$1 = this;\r\n\t        if (panes === void 0) { panes = this.panes; }\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            var pane = panes[i];\r\n\t            for (var j = 0; j < pane.axes.length; j++) {\r\n\t                var axis = pane.axes[j];\r\n\t                if (axis.options.crosshair && axis.options.crosshair.visible) {\r\n\t                    var currentCrosshair = new Crosshair(this$1.chartService, axis, axis.options.crosshair);\r\n\r\n\t                    this$1.crosshairs.push(currentCrosshair);\r\n\t                    pane.content.append(currentCrosshair);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    removeCrosshairs: function(pane) {\r\n\t        var crosshairs = this.crosshairs;\r\n\t        var axes = pane.axes;\r\n\r\n\t        for (var i = crosshairs.length - 1; i >= 0; i--) {\r\n\t            for (var j = 0; j < axes.length; j++) {\r\n\t                if (crosshairs[i].axis === axes[j]) {\r\n\t                    crosshairs.splice(i, 1);\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    hideCrosshairs: function() {\r\n\t        var crosshairs = this.crosshairs;\r\n\t        for (var idx = 0; idx < crosshairs.length; idx++) {\r\n\t            crosshairs[idx].hide();\r\n\t        }\r\n\t    },\r\n\r\n\t    findPane: function(name) {\r\n\t        var panes = this.panes;\r\n\t        var matchingPane;\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            if (panes[i].options.name === name) {\r\n\t                matchingPane = panes[i];\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        return matchingPane || panes[0];\r\n\t    },\r\n\r\n\t    findPointPane: function(point) {\r\n\t        var panes = this.panes;\r\n\t        var matchingPane;\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            if (panes[i].box.containsPoint(point)) {\r\n\t                matchingPane = panes[i];\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        return matchingPane;\r\n\t    },\r\n\r\n\t    appendAxis: function(axis) {\r\n\t        var pane = this.findPane(axis.options.pane);\r\n\r\n\t        pane.appendAxis(axis);\r\n\t        this.axes.push(axis);\r\n\t        axis.plotArea = this;\r\n\t    },\r\n\r\n\t    removeAxis: function(axisToRemove) {\r\n\t        var this$1 = this;\r\n\r\n\t        var filteredAxes = [];\r\n\r\n\t        for (var i = 0; i < this.axes.length; i++) {\r\n\t            var axis = this$1.axes[i];\r\n\t            if (axisToRemove !== axis) {\r\n\t                filteredAxes.push(axis);\r\n\t            } else {\r\n\t                axis.destroy();\r\n\t            }\r\n\t        }\r\n\r\n\t        this.axes = filteredAxes;\r\n\t    },\r\n\r\n\t    appendChart: function(chart, pane) {\r\n\t        this.charts.push(chart);\r\n\t        if (pane) {\r\n\t            pane.appendChart(chart);\r\n\t        } else {\r\n\t            this.append(chart);\r\n\t        }\r\n\t    },\r\n\r\n\t    removeChart: function(chartToRemove) {\r\n\t        var this$1 = this;\r\n\r\n\t        var filteredCharts = [];\r\n\r\n\t        for (var i = 0; i < this.charts.length; i++) {\r\n\t            var chart = this$1.charts[i];\r\n\t            if (chart !== chartToRemove) {\r\n\t                filteredCharts.push(chart);\r\n\t            } else {\r\n\t                chart.destroy();\r\n\t            }\r\n\t        }\r\n\r\n\t        this.charts = filteredCharts;\r\n\t    },\r\n\r\n\t    addToLegend: function(series) {\r\n\t        var count = series.length;\r\n\t        var legend = this.options.legend;\r\n\t        var labels = legend.labels || {};\r\n\t        var inactiveItems = legend.inactiveItems || {};\r\n\t        var inactiveItemsLabels = inactiveItems.labels || {};\r\n\t        var data = [];\r\n\r\n\t        for (var i = 0; i < count; i++) {\r\n\t            var currentSeries = series[i];\r\n\t            var seriesVisible = currentSeries.visible !== false;\r\n\t            if (currentSeries.visibleInLegend === false) {\r\n\t                continue;\r\n\t            }\r\n\r\n\t            var text = currentSeries.name;\r\n\t            var labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);\r\n\t            if (labelTemplate) {\r\n\t                text = labelTemplate({\r\n\t                    text: hasValue(text) ? text : \"\",\r\n\t                    series: currentSeries\r\n\t                });\r\n\t            }\r\n\r\n\t            var defaults = currentSeries._defaults;\r\n\t            var color = currentSeries.color;\r\n\t            if (isFunction(color) && defaults) {\r\n\t                color = defaults.color;\r\n\t            }\r\n\r\n\t            var itemLabelOptions = (void 0), markerColor = (void 0);\r\n\t            if (seriesVisible) {\r\n\t                itemLabelOptions = {};\r\n\t                markerColor = color;\r\n\t            } else {\r\n\t                itemLabelOptions = {\r\n\t                    color: inactiveItemsLabels.color,\r\n\t                    font: inactiveItemsLabels.font\r\n\t                };\r\n\t                markerColor = inactiveItems.markers.color;\r\n\t            }\r\n\r\n\t            if (hasValue(text) && text !== \"\") {\r\n\t                data.push({\r\n\t                    text: text,\r\n\t                    labels: itemLabelOptions,\r\n\t                    markerColor: markerColor,\r\n\t                    series: currentSeries,\r\n\t                    active: seriesVisible\r\n\t                });\r\n\t            }\r\n\t        }\r\n\r\n\t        append(legend.items, data);\r\n\t    },\r\n\r\n\t    groupAxes: function(panes) {\r\n\t        var xAxes = [];\r\n\t        var yAxes = [];\r\n\r\n\t        for (var paneIx = 0; paneIx < panes.length; paneIx++) {\r\n\t            var paneAxes = panes[paneIx].axes;\r\n\t            for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {\r\n\t                var axis = paneAxes[axisIx];\r\n\t                if (axis.options.vertical) {\r\n\t                    yAxes.push(axis);\r\n\t                } else {\r\n\t                    xAxes.push(axis);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };\r\n\t    },\r\n\r\n\t    groupSeriesByPane: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var series = this.series;\r\n\t        var seriesByPane = {};\r\n\r\n\t        for (var i = 0; i < series.length; i++) {\r\n\t            var currentSeries = series[i];\r\n\t            var pane = this$1.seriesPaneName(currentSeries);\r\n\r\n\t            if (seriesByPane[pane]) {\r\n\t                seriesByPane[pane].push(currentSeries);\r\n\t            } else {\r\n\t                seriesByPane[pane] = [ currentSeries ];\r\n\t            }\r\n\t        }\r\n\r\n\t        return seriesByPane;\r\n\t    },\r\n\r\n\t    filterVisibleSeries: function(series) {\r\n\t        var result = [];\r\n\r\n\t        for (var i = 0; i < series.length; i++) {\r\n\t            var currentSeries = series[i];\r\n\t            if (currentSeries.visible !== false) {\r\n\t                result.push(currentSeries);\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var options = this.options.plotArea;\r\n\t        var panes = this.panes;\r\n\t        var margin = getSpacing(options.margin);\r\n\r\n\t        this.box = targetBox.clone().unpad(margin);\r\n\t        this.reflowPanes();\r\n\r\n\t        this.reflowAxes(panes);\r\n\t        this.reflowCharts(panes);\r\n\t    },\r\n\r\n\t    redraw: function(panes) {\r\n\t        var this$1 = this;\r\n\r\n\t        var panesArray = [].concat(panes);\r\n\t        this.initSeries();\r\n\r\n\t        for (var i = 0; i < panesArray.length; i++) {\r\n\t            this$1.removeCrosshairs(panesArray[i]);\r\n\t            panesArray[i].empty();\r\n\t        }\r\n\r\n\t        this.render(panesArray);\r\n\t        this.reflowAxes(this.panes);\r\n\t        this.reflowCharts(panesArray);\r\n\r\n\t        this.createCrosshairs(panesArray);\r\n\r\n\t        for (var i$1 = 0; i$1 < panesArray.length; i$1++) {\r\n\t            panesArray[i$1].refresh();\r\n\t        }\r\n\t    },\r\n\r\n\t    axisCrossingValues: function(axis, crossingAxes) {\r\n\t        var options = axis.options;\r\n\t        var crossingValues = [].concat(\r\n\t            options.axisCrossingValues || options.axisCrossingValue\r\n\t        );\r\n\t        var valuesToAdd = crossingAxes.length - crossingValues.length;\r\n\t        var defaultValue = crossingValues[0] || 0;\r\n\r\n\t        for (var i = 0; i < valuesToAdd; i++) {\r\n\t            crossingValues.push(defaultValue);\r\n\t        }\r\n\r\n\t        return crossingValues;\r\n\t    },\r\n\r\n\t    alignAxisTo: function(axis, targetAxis, crossingValue, targetCrossingValue) {\r\n\t        var slot = axis.getSlot(crossingValue, crossingValue, true);\r\n\t        var slotEdge = axis.options.reverse ? 2 : 1;\r\n\t        var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);\r\n\t        var targetEdge = targetAxis.options.reverse ? 2 : 1;\r\n\t        var axisBox = axis.box.translate(\r\n\t            targetSlot[X + targetEdge] - slot[X + slotEdge],\r\n\t            targetSlot[Y + targetEdge] - slot[Y + slotEdge]\r\n\t        );\r\n\r\n\t        if (axis.pane !== targetAxis.pane) {\r\n\t            axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);\r\n\t        }\r\n\r\n\t        axis.reflow(axisBox);\r\n\t    },\r\n\r\n\t    alignAxes: function(xAxes, yAxes) {\r\n\t        var this$1 = this;\r\n\r\n\t        var xAnchor = xAxes[0];\r\n\t        var yAnchor = yAxes[0];\r\n\t        var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);\r\n\t        var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);\r\n\t        var leftAnchors = {};\r\n\t        var rightAnchors = {};\r\n\t        var topAnchors = {};\r\n\t        var bottomAnchors = {};\r\n\r\n\t        for (var i = 0; i < yAxes.length; i++) {\r\n\t            var axis = yAxes[i];\r\n\t            var pane = axis.pane;\r\n\t            var paneId = pane.id;\r\n\t            var visible = axis.options.visible !== false;\r\n\r\n\t            // Locate pane anchor, if any, and use its axisCrossingValues\r\n\t            var anchor = paneAnchor(xAxes, pane) || xAnchor;\r\n\t            var anchorCrossings = xAnchorCrossings;\r\n\r\n\t            if (anchor !== xAnchor) {\r\n\t                anchorCrossings = this$1.axisCrossingValues(anchor, yAxes);\r\n\t            }\r\n\r\n\t            this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\r\n\r\n\t            if (axis.options._overlap) {\r\n\t                continue;\r\n\t            }\r\n\r\n\t            if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {\r\n\t                // Push the axis to the left the previous y-axis so they don't overlap\r\n\t                if (leftAnchors[paneId]) {\r\n\t                    axis.reflow(axis.box\r\n\t                        .alignTo(leftAnchors[paneId].box, LEFT)\r\n\t                        .translate(-axis.options.margin, 0)\r\n\t                    );\r\n\t                }\r\n\r\n\t                if (visible) {\r\n\t                    leftAnchors[paneId] = axis;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {\r\n\t                // Flip the labels on the right if we're at the right end of the pane\r\n\t                if (!axis._mirrored) {\r\n\t                    axis.options.labels.mirror = !axis.options.labels.mirror;\r\n\t                    axis._mirrored = true;\r\n\t                }\r\n\t                this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\r\n\r\n\t                // Push the axis to the right the previous y-axis so they don't overlap\r\n\t                if (rightAnchors[paneId]) {\r\n\t                    axis.reflow(axis.box\r\n\t                        .alignTo(rightAnchors[paneId].box, RIGHT)\r\n\t                        .translate(axis.options.margin, 0)\r\n\t                    );\r\n\t                }\r\n\r\n\t                if (visible) {\r\n\t                    rightAnchors[paneId] = axis;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (i !== 0 && yAnchor.pane === axis.pane) {\r\n\t                axis.alignTo(yAnchor);\r\n\t                axis.reflow(axis.box);\r\n\t            }\r\n\t        }\r\n\r\n\t        for (var i$1 = 0; i$1 < xAxes.length; i$1++) {\r\n\t            var axis$1 = xAxes[i$1];\r\n\t            var pane$1 = axis$1.pane;\r\n\t            var paneId$1 = pane$1.id;\r\n\t            var visible$1 = axis$1.options.visible !== false;\r\n\r\n\t            // Locate pane anchor and use its axisCrossingValues\r\n\t            var anchor$1 = paneAnchor(yAxes, pane$1) || yAnchor;\r\n\t            var anchorCrossings$1 = yAnchorCrossings;\r\n\t            if (anchor$1 !== yAnchor) {\r\n\t                anchorCrossings$1 = this$1.axisCrossingValues(anchor$1, xAxes);\r\n\t            }\r\n\r\n\t            this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);\r\n\r\n\t            if (axis$1.options._overlap) {\r\n\t                continue;\r\n\t            }\r\n\r\n\t            if (round(axis$1.lineBox().y1) === round(anchor$1.lineBox().y1)) {\r\n\t                // Flip the labels on top if we're at the top of the pane\r\n\t                if (!axis$1._mirrored) {\r\n\t                    axis$1.options.labels.mirror = !axis$1.options.labels.mirror;\r\n\t                    axis$1._mirrored = true;\r\n\t                }\r\n\t                this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);\r\n\r\n\t                // Push the axis above the previous x-axis so they don't overlap\r\n\t                if (topAnchors[paneId$1]) {\r\n\t                    axis$1.reflow(axis$1.box\r\n\t                        .alignTo(topAnchors[paneId$1].box, TOP)\r\n\t                        .translate(0, -axis$1.options.margin)\r\n\t                    );\r\n\t                }\r\n\r\n\t                if (visible$1) {\r\n\t                    topAnchors[paneId$1] = axis$1;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (round(axis$1.lineBox().y2, datavizConstants.COORD_PRECISION) === round(anchor$1.lineBox().y2, datavizConstants.COORD_PRECISION)) {\r\n\t                // Push the axis below the previous x-axis so they don't overlap\r\n\t                if (bottomAnchors[paneId$1]) {\r\n\t                    axis$1.reflow(axis$1.box\r\n\t                        .alignTo(bottomAnchors[paneId$1].box, BOTTOM)\r\n\t                        .translate(0, axis$1.options.margin)\r\n\t                    );\r\n\t                }\r\n\r\n\t                if (visible$1) {\r\n\t                    bottomAnchors[paneId$1] = axis$1;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (i$1 !== 0) {\r\n\t                axis$1.alignTo(xAnchor);\r\n\t                axis$1.reflow(axis$1.box);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    shrinkAxisWidth: function(panes) {\r\n\t        var axes = this.groupAxes(panes).any;\r\n\t        var axisBox = axisGroupBox(axes);\r\n\t        var overflowX = 0;\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            var currentPane = panes[i];\r\n\r\n\t            if (currentPane.axes.length > 0) {\r\n\t                overflowX = Math.max(\r\n\t                    overflowX,\r\n\t                    axisBox.width() - currentPane.contentBox.width()\r\n\t                );\r\n\t            }\r\n\t        }\r\n\r\n\t        if (overflowX !== 0) {\r\n\t            for (var i$1 = 0; i$1 < axes.length; i$1++) {\r\n\t                var currentAxis = axes[i$1];\r\n\r\n\t                if (!currentAxis.options.vertical) {\r\n\t                    currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    shrinkAxisHeight: function(panes) {\r\n\t        var shrinked;\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            var currentPane = panes[i];\r\n\t            var axes = currentPane.axes;\r\n\t            var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());\r\n\r\n\t            if (overflowY !== 0) {\r\n\t                for (var j = 0; j < axes.length; j++) {\r\n\t                    var currentAxis = axes[j];\r\n\r\n\t                    if (currentAxis.options.vertical) {\r\n\t                        currentAxis.reflow(\r\n\t                            currentAxis.box.shrink(0, overflowY)\r\n\t                        );\r\n\t                    }\r\n\t                }\r\n\t                shrinked = true;\r\n\t            }\r\n\t        }\r\n\r\n\t        return shrinked;\r\n\t    },\r\n\r\n\t    fitAxes: function(panes) {\r\n\t        var axes = this.groupAxes(panes).any;\r\n\t        var offsetX = 0;\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            var currentPane = panes[i];\r\n\t            var paneAxes = currentPane.axes;\r\n\t            var paneBox = currentPane.contentBox;\r\n\r\n\t            if (paneAxes.length > 0) {\r\n\t                var axisBox = axisGroupBox(paneAxes);\r\n\t                // OffsetY is calculated and applied per pane\r\n\t                var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);\r\n\r\n\t                // OffsetX is calculated and applied globally\r\n\t                offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);\r\n\r\n\t                for (var j = 0; j < paneAxes.length; j++) {\r\n\t                    var currentAxis = paneAxes[j];\r\n\r\n\t                    currentAxis.reflow(\r\n\t                        currentAxis.box.translate(0, offsetY)\r\n\t                    );\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        for (var i$1 = 0; i$1 < axes.length; i$1++) {\r\n\t            var currentAxis$1 = axes[i$1];\r\n\r\n\t            currentAxis$1.reflow(\r\n\t                currentAxis$1.box.translate(offsetX, 0)\r\n\t            );\r\n\t        }\r\n\t    },\r\n\r\n\t    reflowAxes: function(panes) {\r\n\t        var this$1 = this;\r\n\r\n\t        var axes = this.groupAxes(panes);\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            this$1.reflowPaneAxes(panes[i]);\r\n\t        }\r\n\r\n\t        if (axes.x.length > 0 && axes.y.length > 0) {\r\n\t            this.alignAxes(axes.x, axes.y);\r\n\t            this.shrinkAxisWidth(panes);\r\n\r\n\t            this.autoRotateAxisLabels(axes);\r\n\r\n\t            this.alignAxes(axes.x, axes.y);\r\n\t            if (this.shrinkAxisWidth(panes)) {\r\n\t                this.alignAxes(axes.x, axes.y);\r\n\t            }\r\n\r\n\t            this.shrinkAxisHeight(panes);\r\n\t            this.alignAxes(axes.x, axes.y);\r\n\r\n\t            if (this.shrinkAxisHeight(panes)) {\r\n\t                this.alignAxes(axes.x, axes.y);\r\n\t            }\r\n\r\n\t            this.fitAxes(panes);\r\n\t        }\r\n\t    },\r\n\r\n\t    autoRotateAxisLabels: function(groupedAxes) {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var axes = ref.axes;\r\n\t        var panes = ref.panes;\r\n\t        var rotated;\r\n\r\n\t        for (var idx = 0; idx < axes.length; idx++) {\r\n\t            var axis = axes[idx];\r\n\t            if (axis.autoRotateLabels()) {\r\n\t                rotated = true;\r\n\t            }\r\n\t        }\r\n\r\n\t        if (rotated) {\r\n\t            for (var idx$1 = 0; idx$1 < panes.length; idx$1++) {\r\n\t                this$1.reflowPaneAxes(panes[idx$1]);\r\n\t            }\r\n\r\n\t            if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {\r\n\t                this.alignAxes(groupedAxes.x, groupedAxes.y);\r\n\t                this.shrinkAxisWidth(panes);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    reflowPaneAxes: function(pane) {\r\n\t        var axes = pane.axes;\r\n\t        var length = axes.length;\r\n\r\n\t        if (length > 0) {\r\n\t            for (var i = 0; i < length; i++) {\r\n\t                axes[i].reflow(pane.contentBox);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    reflowCharts: function(panes) {\r\n\t        var charts = this.charts;\r\n\t        var count = charts.length;\r\n\t        var box = this.box;\r\n\r\n\t        for (var i = 0; i < count; i++) {\r\n\t            var chartPane = charts[i].pane;\r\n\t            if (!chartPane || inArray(chartPane, panes)) {\r\n\t                charts[i].reflow(box);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    reflowPanes: function() {\r\n\t        var ref = this;\r\n\t        var box = ref.box;\r\n\t        var panes = ref.panes;\r\n\t        var panesLength = panes.length;\r\n\t        var remainingHeight = box.height();\r\n\t        var remainingPanes = panesLength;\r\n\t        var autoHeightPanes = 0;\r\n\t        var top = box.y1;\r\n\r\n\t        for (var i = 0; i < panesLength; i++) {\r\n\t            var currentPane = panes[i];\r\n\t            var height = currentPane.options.height;\r\n\r\n\t            currentPane.options.width = box.width();\r\n\r\n\t            if (!currentPane.options.height) {\r\n\t                autoHeightPanes++;\r\n\t            } else {\r\n\t                if (height.indexOf && height.indexOf(\"%\")) {\r\n\t                    var percents = parseInt(height, 10) / 100;\r\n\t                    currentPane.options.height = percents * box.height();\r\n\t                }\r\n\r\n\t                currentPane.reflow(box.clone());\r\n\r\n\t                remainingHeight -= currentPane.options.height;\r\n\t            }\r\n\t        }\r\n\r\n\t        for (var i$1 = 0; i$1 < panesLength; i$1++) {\r\n\t            var currentPane$1 = panes[i$1];\r\n\r\n\t            if (!currentPane$1.options.height) {\r\n\t                currentPane$1.options.height = remainingHeight / autoHeightPanes;\r\n\t            }\r\n\t        }\r\n\r\n\t        for (var i$2 = 0; i$2 < panesLength; i$2++) {\r\n\t            var currentPane$2 = panes[i$2];\r\n\t            var paneBox = box\r\n\t                .clone()\r\n\t                .move(box.x1, top);\r\n\r\n\t            currentPane$2.reflow(paneBox);\r\n\r\n\t            remainingPanes--;\r\n\t            top += currentPane$2.options.height;\r\n\t        }\r\n\t    },\r\n\r\n\t    backgroundBox: function() {\r\n\t        var axes = this.axes;\r\n\t        var axesCount = axes.length;\r\n\t        var box;\r\n\r\n\t        for (var i = 0; i < axesCount; i++) {\r\n\t            var axisA = axes[i];\r\n\r\n\t            for (var j = 0; j < axesCount; j++) {\r\n\t                var axisB = axes[j];\r\n\r\n\t                if (axisA.options.vertical !== axisB.options.vertical) {\r\n\t                    var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());\r\n\r\n\t                    if (!box) {\r\n\t                        box = lineBox;\r\n\t                    } else {\r\n\t                        box = box.wrap(lineBox);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return box || this.box;\r\n\t    },\r\n\r\n\t    chartsBoxes: function() {\r\n\t        var panes = this.panes;\r\n\t        var boxes = [];\r\n\r\n\t        for (var idx = 0; idx < panes.length; idx++) {\r\n\t            boxes.push(panes[idx].chartsBox());\r\n\t        }\r\n\r\n\t        return boxes;\r\n\t    },\r\n\r\n\t    addBackgroundPaths: function(multipath) {\r\n\t        var boxes = this.chartsBoxes();\r\n\t        for (var idx = 0; idx < boxes.length; idx++) {\r\n\t            multipath.paths.push(Path.fromRect(boxes[idx].toRect()));\r\n\t        }\r\n\t    },\r\n\r\n\t    backgroundContainsPoint: function(point) {\r\n\t        var boxes = this.chartsBoxes();\r\n\t        for (var idx = 0; idx < boxes.length; idx++) {\r\n\t            if (boxes[idx].containsPoint(point)) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\r\n\t        var options = this.options.plotArea;\r\n\t        var opacity = options.opacity;\r\n\t        var background = options.background;\r\n\t        var border = options.border; if (border === void 0) { border = {}; }\r\n\t        if (isTransparent(background)) {\r\n\t            background = WHITE;\r\n\t            opacity = 0;\r\n\t        }\r\n\r\n\t        var bg = this._bgVisual = new drawing.MultiPath({\r\n\t            fill: {\r\n\t                color: background,\r\n\t                opacity: opacity\r\n\t            },\r\n\t            stroke: {\r\n\t                color: border.width ? border.color : \"\",\r\n\t                width: border.width,\r\n\t                dashType: border.dashType\r\n\t            },\r\n\t            zIndex: -1\r\n\t        });\r\n\r\n\t        this.addBackgroundPaths(bg);\r\n\r\n\t        this.appendVisual(bg);\r\n\t    },\r\n\r\n\t    pointsByCategoryIndex: function(categoryIndex) {\r\n\t        var charts = this.charts;\r\n\t        var result = [];\r\n\r\n\t        if (categoryIndex !== null) {\r\n\t            for (var i = 0; i < charts.length; i++) {\r\n\t                var chart = charts[i];\r\n\t                if (chart.pane.options.name === \"_navigator\") {\r\n\t                    continue;\r\n\t                }\r\n\r\n\t                var points = charts[i].categoryPoints[categoryIndex];\r\n\t                if (points && points.length) {\r\n\t                    for (var j = 0; j < points.length; j++) {\r\n\t                        var point = points[j];\r\n\t                        if (point && defined(point.value) && point.value !== null) {\r\n\t                            result.push(point);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    pointsBySeriesIndex: function(seriesIndex) {\r\n\t        return this.filterPoints(function(point) {\r\n\t            return point.series.index === seriesIndex;\r\n\t        });\r\n\t    },\r\n\r\n\t    pointsBySeriesName: function(name) {\r\n\t        return this.filterPoints(function(point) {\r\n\t            return point.series.name === name;\r\n\t        });\r\n\t    },\r\n\r\n\t    filterPoints: function(callback) {\r\n\t        var charts = this.charts;\r\n\t        var result = [];\r\n\r\n\t        for (var i = 0; i < charts.length; i++) {\r\n\t            var chart = charts[i];\r\n\t            var points = chart.points;\r\n\t            for (var j = 0; j < points.length; j++) {\r\n\t                var point = points[j];\r\n\t                if (point && callback(point)) {\r\n\t                    result.push(point);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    findPoint: function(callback) {\r\n\t        var charts = this.charts;\r\n\r\n\t        for (var i = 0; i < charts.length; i++) {\r\n\t            var chart = charts[i];\r\n\t            var points = chart.points;\r\n\t            for (var j = 0; j < points.length; j++) {\r\n\t                var point = points[j];\r\n\t                if (point && callback(point)) {\r\n\t                    return point;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    paneByPoint: function(point) {\r\n\t        var panes = this.panes;\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            var pane = panes[i];\r\n\t            if (pane.box.containsPoint(point)) {\r\n\t                return pane;\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tfunction axisGroupBox(axes) {\r\n\t    var length = axes.length;\r\n\t    var box;\r\n\r\n\t    if (length > 0) {\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var axisBox = axes[i].contentBox();\r\n\r\n\t            if (!box) {\r\n\t                box = axisBox.clone();\r\n\t            } else {\r\n\t                box.wrap(axisBox);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    return box || new Box();\r\n\t}\r\n\r\n\tfunction paneAnchor(axes, pane) {\r\n\t    for (var i = 0; i < axes.length; i++) {\r\n\t        var anchor = axes[i];\r\n\t        if (anchor && anchor.pane === pane) {\r\n\t            return anchor;\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction isTransparent(color) {\r\n\t    return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !defined(color);\r\n\t}\r\n\r\n\tsetDefaultOptions(PlotAreaBase, {\r\n\t    series: [],\r\n\t    plotArea: {\r\n\t        margin: {}\r\n\t    },\r\n\t    background: \"\",\r\n\t    border: {\r\n\t        color: BLACK,\r\n\t        width: 0\r\n\t    },\r\n\t    legend: {\r\n\t        inactiveItems: {\r\n\t            labels: {\r\n\t                color: \"#919191\"\r\n\t            },\r\n\t            markers: {\r\n\t                color: \"#919191\"\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar PlotAreaEventsMixin = {\r\n\t    hover: function(chart, e) {\r\n\t        this._dispatchEvent(chart, e, PLOT_AREA_HOVER);\r\n\t    },\r\n\r\n\t    click: function(chart, e) {\r\n\t        this._dispatchEvent(chart, e, PLOT_AREA_CLICK);\r\n\t    }\r\n\t};\r\n\r\n\tvar SeriesAggregator = Class.extend({\r\n\t    init: function(series, binder, defaultAggregates) {\r\n\r\n\t        var canonicalFields = binder.canonicalFields(series);\r\n\t        var valueFields = binder.valueFields(series);\r\n\t        var sourceFields = binder.sourceFields(series, canonicalFields);\r\n\t        var seriesFields = this._seriesFields = [];\r\n\t        var defaults = defaultAggregates.query(series.type);\r\n\t        var rootAggregate = series.aggregate || defaults;\r\n\r\n\t        this._series = series;\r\n\t        this._binder = binder;\r\n\r\n\t        for (var i = 0; i < canonicalFields.length; i++) {\r\n\t            var field = canonicalFields[i];\r\n\t            var fieldAggregate = (void 0);\r\n\r\n\t            if (isObject(rootAggregate)) {\r\n\t                fieldAggregate = rootAggregate[field];\r\n\t            } else if (i === 0 || inArray(field, valueFields)) {\r\n\t                fieldAggregate = rootAggregate;\r\n\t            } else {\r\n\t                break;\r\n\t            }\r\n\r\n\t            if (fieldAggregate) {\r\n\t                seriesFields.push({\r\n\t                    canonicalName: field,\r\n\t                    name: sourceFields[i],\r\n\t                    transform: isFunction(fieldAggregate) ? fieldAggregate : Aggregates[fieldAggregate]\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    aggregatePoints: function(srcPoints, group) {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var series = ref._series;\r\n\t        var seriesFields = ref._seriesFields;\r\n\t        var data = this._bindPoints(srcPoints || []);\r\n\t        var firstDataItem = data.dataItems[0];\r\n\t        var result = {};\r\n\r\n\t        if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {\r\n\t            var fn = function() {};\r\n\t            fn.prototype = firstDataItem;\r\n\t            result = new fn();\r\n\t        }\r\n\r\n\t        for (var i = 0; i < seriesFields.length; i++) {\r\n\t            var field = seriesFields[i];\r\n\t            var srcValues = this$1._bindField(data.values, field.canonicalName);\r\n\t            var value = field.transform(srcValues, series, data.dataItems, group);\r\n\r\n\t            if (value !== null && isObject(value) && !defined(value.length) && !(value instanceof Date)) {\r\n\t                result = value;\r\n\t                break;\r\n\t            } else {\r\n\t                if (defined(value)) {\r\n\t                    setValue(field.name, result, value);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    _bindPoints: function(points) {\r\n\t        var ref = this;\r\n\t        var binder = ref._binder;\r\n\t        var series = ref._series;\r\n\t        var values = [];\r\n\t        var dataItems = [];\r\n\r\n\t        for (var i = 0; i < points.length; i++) {\r\n\t            var pointIx = points[i];\r\n\r\n\t            values.push(binder.bindPoint(series, pointIx));\r\n\t            dataItems.push(series.data[pointIx]);\r\n\t        }\r\n\r\n\t        return {\r\n\t            values: values,\r\n\t            dataItems: dataItems\r\n\t        };\r\n\t    },\r\n\r\n\t    _bindField: function(data, field) {\r\n\t        var values = [];\r\n\t        var count = data.length;\r\n\r\n\t        for (var i = 0; i < count; i++) {\r\n\t            var item = data[i];\r\n\t            var valueFields = item.valueFields;\r\n\t            var value = (void 0);\r\n\r\n\t            if (defined(valueFields[field])) {\r\n\t                value = valueFields[field];\r\n\t            } else {\r\n\t                value = item.fields[field];\r\n\t            }\r\n\r\n\t            values.push(value);\r\n\t        }\r\n\r\n\t        return values;\r\n\t    }\r\n\t});\r\n\r\n\tfunction setValue(fieldName, target, value) {\r\n\t    var parentObj = target;\r\n\t    var field = fieldName;\r\n\r\n\t    if (fieldName.indexOf(\".\") > -1) {\r\n\t        var parts = fieldName.split(\".\");\r\n\r\n\t        while (parts.length > 1) {\r\n\t            field = parts.shift();\r\n\t            if (!defined(parentObj[field])) {\r\n\t                parentObj[field] = {};\r\n\t            }\r\n\t            parentObj = parentObj[field];\r\n\t        }\r\n\t        field = parts.shift();\r\n\t    }\r\n\r\n\t    parentObj[field] = value;\r\n\t}\r\n\r\n\tvar DefaultAggregates = Class.extend({\r\n\t    init: function() {\r\n\r\n\t        this._defaults = {};\r\n\t    },\r\n\r\n\t    register: function(seriesTypes, aggregates) {\r\n\t        var this$1 = this;\r\n\r\n\t        for (var i = 0; i < seriesTypes.length; i++) {\r\n\t            this$1._defaults[seriesTypes[i]] = aggregates;\r\n\t        }\r\n\t    },\r\n\r\n\t    query: function(seriesType) {\r\n\t        return this._defaults[seriesType];\r\n\t    }\r\n\t});\r\n\r\n\tDefaultAggregates.current = new DefaultAggregates();\r\n\r\n\tvar RangeBar = Bar.extend({\r\n\t    createLabel: function() {\r\n\t        var labels = this.options.labels;\r\n\t        var fromOptions = deepExtend({}, labels, labels.from);\r\n\t        var toOptions = deepExtend({}, labels, labels.to);\r\n\r\n\t        if (fromOptions.visible) {\r\n\t            this.labelFrom = this._createLabel(fromOptions);\r\n\t            this.append(this.labelFrom);\r\n\t        }\r\n\r\n\t        if (toOptions.visible) {\r\n\t            this.labelTo = this._createLabel(toOptions);\r\n\t            this.append(this.labelTo);\r\n\t        }\r\n\t    },\r\n\r\n\t    _createLabel: function(options) {\r\n\t        var labelTemplate = getTemplate(options);\r\n\t        var labelText;\r\n\r\n\t        if (labelTemplate) {\r\n\t            labelText = labelTemplate({\r\n\t                dataItem: this.dataItem,\r\n\t                category: this.category,\r\n\t                value: this.value,\r\n\t                percentage: this.percentage,\r\n\t                runningTotal: this.runningTotal,\r\n\t                total: this.total,\r\n\t                series: this.series\r\n\t            });\r\n\t        } else {\r\n\t            labelText = this.formatValue(options.format);\r\n\t        }\r\n\r\n\t        return new BarLabel(labelText,\r\n\t            deepExtend({\r\n\t                vertical: this.options.vertical\r\n\t            },\r\n\t            options\r\n\t        ));\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        this.render();\r\n\r\n\t        var ref = this;\r\n\t        var labelFrom = ref.labelFrom;\r\n\t        var labelTo = ref.labelTo;\r\n\t        var value = ref.value;\r\n\r\n\t        this.box = targetBox;\r\n\r\n\t        if (labelFrom) {\r\n\t            labelFrom.options.aboveAxis = value.from > value.to;\r\n\t            labelFrom.reflow(targetBox);\r\n\t        }\r\n\r\n\t        if (labelTo) {\r\n\t            labelTo.options.aboveAxis = value.to > value.from;\r\n\t            labelTo.reflow(targetBox);\r\n\t        }\r\n\r\n\t        if (this.note) {\r\n\t            this.note.reflow(targetBox);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tRangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {\r\n\t    labels: {\r\n\t        format: \"{0} - {1}\"\r\n\t    },\r\n\t    tooltip: {\r\n\t        format: \"{1}\"\r\n\t    }\r\n\t});\r\n\r\n\tvar RangeBarChart = BarChart.extend({\r\n\t    pointType: function() {\r\n\t        return RangeBar;\r\n\t    },\r\n\r\n\t    pointValue: function(data) {\r\n\t        return data.valueFields;\r\n\t    },\r\n\r\n\t    formatPointValue: function(point, format) {\r\n\t        if (point.value.from === null && point.value.to === null) {\r\n\t            return \"\";\r\n\t        }\r\n\r\n\t        return this.chartService.format.auto(format, point.value.from, point.value.to);\r\n\t    },\r\n\r\n\t    plotRange: function(point) {\r\n\t        if (!point) {\r\n\t            return 0;\r\n\t        }\r\n\r\n\t        return [ point.value.from, point.value.to ];\r\n\t    },\r\n\r\n\t    updateRange: function(value, fields) {\r\n\t        var axisName = fields.series.axis;\r\n\t        var from = value.from;\r\n\t        var to = value.to;\r\n\t        var axisRange = this.valueAxisRanges[axisName];\r\n\r\n\t        if (value !== null && isNumber(from) && isNumber(to)) {\r\n\t            axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };\r\n\r\n\t            axisRange.min = Math.min(axisRange.min, from);\r\n\t            axisRange.max = Math.max(axisRange.max, from);\r\n\r\n\t            axisRange.min = Math.min(axisRange.min, to);\r\n\t            axisRange.max = Math.max(axisRange.max, to);\r\n\t        }\r\n\t    },\r\n\r\n\t    aboveAxis: function(point) {\r\n\t        var value = point.value;\r\n\t        return value.from < value.to;\r\n\t    }\r\n\t});\r\n\r\n\tRangeBarChart.prototype.plotLimits = CategoricalChart.prototype.plotLimits;\r\n\r\n\tvar RangeLinePoint = LinePoint.extend({\r\n\t    aliasFor: function() {\r\n\t        return this.parent;\r\n\t    }\r\n\t});\r\n\r\n\tvar AUTO = 'auto';\r\n\tvar DEFAULT_FROM_FORMAT = '{0}';\r\n\tvar DEFAULT_TO_FORMAT = '{1}';\r\n\r\n\tvar RangeAreaPoint = ChartElement.extend({\r\n\t    init: function(value, options) {\r\n\t        ChartElement.fn.init.call(this);\r\n\r\n\t        this.value = value;\r\n\t        this.options = options;\r\n\t        this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);\r\n\t        this.tooltipTracking = true;\r\n\t        this.initLabelsFormat();\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        if (this._rendered) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        this._rendered = true;\r\n\r\n\t        var ref = this.options;\r\n\t        var markers = ref.markers;\r\n\t        var labels = ref.labels;\r\n\t        var value = this.value;\r\n\r\n\t        var fromPoint = this.fromPoint = new RangeLinePoint(value, deepExtend({}, this.options, {\r\n\t            labels: labels.from,\r\n\t            markers: markers.from\r\n\t        }));\r\n\r\n\t        var toPoint = this.toPoint = new RangeLinePoint(value, deepExtend({}, this.options, {\r\n\t            labels: labels.to,\r\n\t            markers: markers.to\r\n\t        }));\r\n\r\n\t        this.copyFields(fromPoint);\r\n\t        this.copyFields(toPoint);\r\n\r\n\t        this.append(fromPoint);\r\n\t        this.append(toPoint);\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        this.render();\r\n\r\n\t        var fromBox = targetBox.from;\r\n\t        var toBox = targetBox.to;\r\n\r\n\t        this.positionLabels(fromBox, toBox);\r\n\r\n\t        this.fromPoint.reflow(fromBox);\r\n\t        this.toPoint.reflow(toBox);\r\n\r\n\t        this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());\r\n\t    },\r\n\r\n\t    createHighlight: function() {\r\n\t        var group = new Group();\r\n\t        group.append(this.fromPoint.createHighlight());\r\n\t        group.append(this.toPoint.createHighlight());\r\n\r\n\t        return group;\r\n\t    },\r\n\r\n\t    highlightVisual: function() {\r\n\t        return this.visual;\r\n\t    },\r\n\r\n\t    highlightVisualArgs: function() {\r\n\t        return {\r\n\t            options: this.options,\r\n\t            from: this.fromPoint.highlightVisualArgs(),\r\n\t            to: this.toPoint.highlightVisualArgs()\r\n\t        };\r\n\t    },\r\n\r\n\t    tooltipAnchor: function() {\r\n\t        var clipBox = this.owner.pane.clipBox();\r\n\t        var showTooltip = !clipBox || clipBox.overlaps(this.box);\r\n\r\n\t        if (showTooltip) {\r\n\t            var box = this.box;\r\n\t            var center = box.center();\r\n\t            var horizontalAlign = LEFT;\r\n\t            var x, y, verticalAlign;\r\n\r\n\t            if (this.options.vertical) {\r\n\t                x = center.x;\r\n\t                y = box.y1 - TOOLTIP_OFFSET;\r\n\t                verticalAlign = BOTTOM;\r\n\t            } else {\r\n\t                x = box.x2 + TOOLTIP_OFFSET;\r\n\t                y = center.y;\r\n\t                verticalAlign = CENTER;\r\n\t            }\r\n\r\n\t            return {\r\n\t                point: new Point(x, y),\r\n\t                align: {\r\n\t                    horizontal: horizontalAlign,\r\n\t                    vertical: verticalAlign\r\n\t                }\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    formatValue: function(format) {\r\n\t        return this.owner.formatPointValue(this, format);\r\n\t    },\r\n\r\n\t    overlapsBox: function(box) {\r\n\t        return this.box.overlaps(box);\r\n\t    },\r\n\r\n\t    unclipElements: function() {\r\n\t        this.fromPoint.unclipElements();\r\n\t        this.toPoint.unclipElements();\r\n\t    },\r\n\r\n\t    initLabelsFormat: function() {\r\n\t        var labels = this.options.labels;\r\n\t        if (!labels.format) {\r\n\t            if (!labels.from || !labels.from.format) {\r\n\t                labels.from = $.extend({}, labels.from, {\r\n\t                    format: DEFAULT_FROM_FORMAT\r\n\t                });\r\n\t            }\r\n\r\n\t            if (!labels.to || !labels.to.format) {\r\n\t                labels.to = $.extend({}, labels.to, {\r\n\t                    format: DEFAULT_TO_FORMAT\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    positionLabels: function(fromBox, toBox) {\r\n\t        var ref = this.options;\r\n\t        var labels = ref.labels;\r\n\t        var vertical = ref.vertical;\r\n\r\n\t        if (labels.position === AUTO) {\r\n\t            var fromLabelPosition, toLabelPosition;\r\n\t            if (vertical) {\r\n\t                if (toBox.y1 <= fromBox.y1) {\r\n\t                    toLabelPosition = ABOVE;\r\n\t                    fromLabelPosition = BELOW;\r\n\t                } else {\r\n\t                    toLabelPosition = BELOW;\r\n\t                    fromLabelPosition = ABOVE;\r\n\t                }\r\n\t            } else {\r\n\t                if (toBox.x1 <= fromBox.x1) {\r\n\t                    toLabelPosition = LEFT;\r\n\t                    fromLabelPosition = RIGHT;\r\n\t                } else {\r\n\t                    toLabelPosition = RIGHT;\r\n\t                    fromLabelPosition = LEFT;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (!labels.from || !labels.from.position) {\r\n\t                this.fromPoint.options.labels.position = fromLabelPosition;\r\n\t            }\r\n\r\n\t            if (!labels.to || !labels.to.position) {\r\n\t                this.toPoint.options.labels.position = toLabelPosition;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    copyFields: function(point) {\r\n\t        point.dataItem = this.dataItem;\r\n\t        point.category = this.category;\r\n\t        point.series = this.series;\r\n\t        point.color = this.color;\r\n\t        point.owner = this.owner;\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(RangeAreaPoint.prototype, PointEventsMixin);\r\n\tdeepExtend(RangeAreaPoint.prototype, NoteMixin);\r\n\r\n\tRangeAreaPoint.prototype.defaults = {\r\n\t    markers: {\r\n\t        visible: false,\r\n\t        background: WHITE,\r\n\t        size: LINE_MARKER_SIZE,\r\n\t        type: CIRCLE,\r\n\t        border: {\r\n\t            width: 2\r\n\t        },\r\n\t        opacity: 1\r\n\t    },\r\n\t    labels: {\r\n\t        visible: false,\r\n\t        margin: getSpacing(3),\r\n\t        padding: getSpacing(4),\r\n\t        animation: {\r\n\t            type: FADEIN,\r\n\t            delay: INITIAL_ANIMATION_DURATION\r\n\t        },\r\n\t        position: AUTO\r\n\t    },\r\n\t    notes: {\r\n\t        label: {}\r\n\t    },\r\n\t    highlight: {\r\n\t        markers: {\r\n\t            border: {\r\n\t                color: WHITE,\r\n\t                width: 2\r\n\t            }\r\n\t        },\r\n\t        zIndex: datavizConstants.HIGHLIGHT_ZINDEX\r\n\t    },\r\n\t    tooltip: {\r\n\t        format: '{0} - {1}'\r\n\t    }\r\n\t};\r\n\r\n\tvar RangeAreaSegment = AreaSegment.extend({\r\n\t    createStrokeSegments: function() {\r\n\t        return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));\r\n\t    },\r\n\r\n\t    stackSegments: function() {\r\n\t        var fromSegments = this.fromSegments;\r\n\t        if (!this.fromSegments) {\r\n\t            fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));\r\n\t        }\r\n\r\n\t        return fromSegments;\r\n\t    },\r\n\r\n\t    createStroke: function(style) {\r\n\t        var toPath = new Path(style);\r\n\t        var fromPath = new Path(style);\r\n\r\n\t        toPath.segments.push.apply(toPath.segments, this.strokeSegments());\r\n\t        fromPath.segments.push.apply(fromPath.segments, this.stackSegments());\r\n\r\n\t        this.visual.append(toPath);\r\n\t        this.visual.append(fromPath);\r\n\t    },\r\n\r\n\t    hasStackSegment: function() {\r\n\t        return true;\r\n\t    },\r\n\r\n\t    fromPoints: function() {\r\n\t        return this.linePoints.map(function (point) { return point.fromPoint; });\r\n\t    },\r\n\r\n\t    toPoints: function() {\r\n\t        return this.linePoints.map(function (point) { return point.toPoint; });\r\n\t    }\r\n\t});\r\n\r\n\tvar SplineRangeAreaSegment = RangeAreaSegment.extend({\r\n\t    createStrokeSegments: function() {\r\n\t        return this.createCurveSegments(this.toPoints());\r\n\t    },\r\n\r\n\t    stackSegments: function() {\r\n\t        var fromSegments = this.fromSegments;\r\n\t        if (!this.fromSegments) {\r\n\t            fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());\r\n\t        }\r\n\r\n\t        return fromSegments;\r\n\t    },\r\n\r\n\t    createCurveSegments: function(points) {\r\n\t        var curveProcessor = new CurveProcessor();\r\n\r\n\t        return curveProcessor.process(this.toGeometryPoints(points));\r\n\t    }\r\n\t});\r\n\r\n\tvar StepRangeAreaSegment = RangeAreaSegment.extend({\r\n\t    createStrokeSegments: function() {\r\n\t        return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));\r\n\t    },\r\n\r\n\t    stackSegments: function() {\r\n\t        var fromSegments = this.fromSegments;\r\n\t        if (!this.fromSegments) {\r\n\t            fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));\r\n\t            fromSegments.reverse();\r\n\t        }\r\n\r\n\t        return fromSegments;\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(StepRangeAreaSegment.prototype, StepLineMixin);\r\n\r\n\tvar RangeAreaChart = CategoricalChart.extend({\r\n\t    render: function() {\r\n\t        CategoricalChart.fn.render.call(this);\r\n\r\n\t        this.renderSegments();\r\n\t    },\r\n\r\n\t    pointType: function() {\r\n\t        return RangeAreaPoint;\r\n\t    },\r\n\r\n\t    createPoint: function(data, fields) {\r\n\t        var categoryIx = fields.categoryIx;\r\n\t        var category = fields.category;\r\n\t        var series = fields.series;\r\n\t        var seriesIx = fields.seriesIx;\r\n\t        var value = data.valueFields;\r\n\r\n\t        if (!hasValue(value.from) && !hasValue(value.to)) {\r\n\t            if (this.seriesMissingValues(series) === ZERO) {\r\n\t                value = {\r\n\t                    from: 0,\r\n\t                    to: 0\r\n\t                };\r\n\t            } else {\r\n\t                return null;\r\n\t            }\r\n\t        }\r\n\r\n\t        var pointOptions = this.pointOptions(series, seriesIx);\r\n\t        pointOptions = this.evalPointOptions(\r\n\t            pointOptions, value, category, categoryIx, series, seriesIx\r\n\t        );\r\n\r\n\t        var color = data.fields.color || series.color;\r\n\t        if (isFunction(series.color)) {\r\n\t            color = pointOptions.color;\r\n\t        }\r\n\r\n\t        var point = new RangeAreaPoint(value, pointOptions);\r\n\t        point.color = color;\r\n\r\n\t        this.append(point);\r\n\r\n\t        return point;\r\n\t    },\r\n\r\n\t    createSegment: function(linePoints, currentSeries, seriesIx) {\r\n\t        var style = (currentSeries.line || {}).style;\r\n\t        var segmentType;\r\n\t        if (style === \"smooth\") {\r\n\t            segmentType = SplineRangeAreaSegment;\r\n\t        } else if (style === \"step\") {\r\n\t            segmentType = StepRangeAreaSegment;\r\n\t        } else {\r\n\t            segmentType = RangeAreaSegment;\r\n\t        }\r\n\r\n\t        return new segmentType(linePoints, currentSeries, seriesIx);\r\n\t    },\r\n\r\n\t    plotRange: function(point, startValue) {\r\n\t        if (!point) {\r\n\t            return [ startValue, startValue ];\r\n\t        }\r\n\r\n\t        return [ point.value.from, point.value.to ];\r\n\t    },\r\n\r\n\t    valueSlot: function(valueAxis, plotRange) {\r\n\t        var fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);\r\n\t        var toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);\r\n\t        if (fromSlot && toSlot) {\r\n\t            return {\r\n\t                from: fromSlot,\r\n\t                to: toSlot\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    pointSlot: function(categorySlot, valueSlot) {\r\n\t        var from = valueSlot.from;\r\n\t        var to = valueSlot.to;\r\n\t        var fromSlot, toSlot;\r\n\r\n\t        if (this.options.invertAxes) {\r\n\t            fromSlot = new Box(from.x1, categorySlot.y1, from.x2, categorySlot.y2);\r\n\t            toSlot = new Box(to.x1, categorySlot.y1, to.x2, categorySlot.y2);\r\n\t        } else {\r\n\t            fromSlot = new Box(categorySlot.x1, from.y1, categorySlot.x2, from.y2);\r\n\t            toSlot = new Box(categorySlot.x1, to.y1, categorySlot.x2, to.y2);\r\n\t        }\r\n\r\n\t        return {\r\n\t            from: fromSlot,\r\n\t            to: toSlot\r\n\t        };\r\n\t    },\r\n\r\n\t    addValue: function(data, fields) {\r\n\t        var valueFields = data.valueFields;\r\n\t        if (!isNumber(valueFields.from)) {\r\n\t            valueFields.from = valueFields.to;\r\n\t        }\r\n\r\n\t        if (!isNumber(valueFields.to)) {\r\n\t            valueFields.to = valueFields.from;\r\n\t        }\r\n\r\n\t        CategoricalChart.fn.addValue.call(this, data, fields);\r\n\t    },\r\n\r\n\t    updateRange: function(value, fields) {\r\n\t        if (value !== null && isNumber(value.from) && isNumber(value.to)) {\r\n\t            var axisName = fields.series.axis;\r\n\t            var axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };\r\n\t            var from = value.from;\r\n\t            var to = value.to;\r\n\r\n\t            axisRange.min = Math.min(axisRange.min, from, to);\r\n\t            axisRange.max = Math.max(axisRange.max, from, to);\r\n\t        }\r\n\t    },\r\n\r\n\t    formatPointValue: function(point, format) {\r\n\t        var value = point.value;\r\n\r\n\t        return this.chartService.format.auto(format, value.from, value.to);\r\n\t    },\r\n\r\n\t    animationPoints: function() {\r\n\t        var points = this.points;\r\n\t        var result = [];\r\n\t        for (var idx = 0; idx < points.length; idx++) {\r\n\t            var point = points[idx];\r\n\t            if (point) {\r\n\t                result.push((point.fromPoint || {}).marker);\r\n\t                result.push((point.toPoint || {}).marker);\r\n\t            }\r\n\t        }\r\n\r\n\t        return result.concat(this._segments);\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(RangeAreaChart.prototype, LineChartMixin, ClipAnimationMixin);\r\n\r\n\tvar OHLCPoint = Candlestick.extend({\r\n\t    reflow: function(box) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var value = ref.value;\r\n\t        var chart = ref.owner;\r\n\t        var valueAxis = chart.seriesValueAxis(options);\r\n\t        var oPoints = [];\r\n\t        var cPoints = [];\r\n\t        var lhPoints = [];\r\n\r\n\t        var lhSlot = valueAxis.getSlot(value.low, value.high);\r\n\t        var oSlot = valueAxis.getSlot(value.open, value.open);\r\n\t        var cSlot = valueAxis.getSlot(value.close, value.close);\r\n\r\n\t        oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;\r\n\t        oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;\r\n\r\n\t        var mid = lhSlot.center().x;\r\n\r\n\t        oPoints.push([ oSlot.x1, oSlot.y1 ]);\r\n\t        oPoints.push([ mid, oSlot.y1 ]);\r\n\t        cPoints.push([ mid, cSlot.y1 ]);\r\n\t        cPoints.push([ cSlot.x2, cSlot.y1 ]);\r\n\t        lhPoints.push([ mid, lhSlot.y1 ]);\r\n\t        lhPoints.push([ mid, lhSlot.y2 ]);\r\n\r\n\t        this.lines = [\r\n\t            oPoints, cPoints, lhPoints\r\n\t        ];\r\n\r\n\t        this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));\r\n\r\n\t        this.reflowNote();\r\n\t    },\r\n\r\n\t    createBody: function() {}\r\n\t});\r\n\r\n\tvar OHLCChart = CandlestickChart.extend({\r\n\t    pointType: function() {\r\n\t        return OHLCPoint;\r\n\t    }\r\n\t});\r\n\r\n\tvar WaterfallSegment = ChartElement.extend({\r\n\t    init: function(from, to, series) {\r\n\t        ChartElement.fn.init.call(this);\r\n\r\n\t        this.from = from;\r\n\t        this.to = to;\r\n\t        this.series = series;\r\n\t    },\r\n\r\n\t    linePoints: function() {\r\n\t        var from = this.from;\r\n\t        var ref = this;\r\n\t        var fromBox = ref.from.box;\r\n\t        var toBox = ref.to.box;\r\n\t        var points = [];\r\n\r\n\t        if (from.isVertical) {\r\n\t            var y = from.aboveAxis ? fromBox.y1 : fromBox.y2;\r\n\t            points.push(\r\n\t                [ fromBox.x1, y ],\r\n\t                [ toBox.x2, y ]\r\n\t            );\r\n\t        } else {\r\n\t            var x = from.aboveAxis ? fromBox.x2 : fromBox.x1;\r\n\t            points.push(\r\n\t                [ x, fromBox.y1 ],\r\n\t                [ x, toBox.y2 ]\r\n\t            );\r\n\t        }\r\n\r\n\t        return points;\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\r\n\t        var line = this.series.line || {};\r\n\r\n\t        var path = Path.fromPoints(this.linePoints(), {\r\n\t            stroke: {\r\n\t                color: line.color,\r\n\t                width: line.width,\r\n\t                opacity: line.opacity,\r\n\t                dashType: line.dashType\r\n\t            }\r\n\t        });\r\n\r\n\t        alignPathToPixel(path);\r\n\t        this.visual.append(path);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(WaterfallSegment, {\r\n\t    animation: {\r\n\t        type: FADEIN,\r\n\t        delay: INITIAL_ANIMATION_DURATION\r\n\t    }\r\n\t});\r\n\r\n\tvar WaterfallChart = BarChart.extend({\r\n\t    render: function() {\r\n\t        BarChart.fn.render.call(this);\r\n\t        this.createSegments();\r\n\t    },\r\n\r\n\t    traverseDataPoints: function(callback) {\r\n\t        var series = this.options.series;\r\n\t        var categories = this.categoryAxis.options.categories || [];\r\n\t        var totalCategories = categoriesCount(series);\r\n\t        var isVertical = !this.options.invertAxes;\r\n\r\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\r\n\t            var currentSeries = series[seriesIx];\r\n\t            var total = 0;\r\n\t            var runningTotal = 0;\r\n\r\n\t            for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {\r\n\t                var data = SeriesBinder.current.bindPoint(currentSeries, categoryIx);\r\n\t                var value = data.valueFields.value;\r\n\t                var summary = data.fields.summary;\r\n\t                var from = total;\r\n\t                var to = (void 0);\r\n\r\n\t                if (summary) {\r\n\t                    if (summary.toLowerCase() === \"total\") {\r\n\t                        data.valueFields.value = total;\r\n\t                        from = 0;\r\n\t                        to = total;\r\n\t                    } else {\r\n\t                        data.valueFields.value = runningTotal;\r\n\t                        to = from - runningTotal;\r\n\t                        runningTotal = 0;\r\n\t                    }\r\n\t                } else if (isNumber(value)) {\r\n\t                    runningTotal += value;\r\n\t                    total += value;\r\n\t                    to = total;\r\n\t                }\r\n\r\n\t                callback(data, {\r\n\t                    category: categories[categoryIx],\r\n\t                    categoryIx: categoryIx,\r\n\t                    series: currentSeries,\r\n\t                    seriesIx: seriesIx,\r\n\t                    total: total,\r\n\t                    runningTotal: runningTotal,\r\n\t                    from: from,\r\n\t                    to: to,\r\n\t                    isVertical: isVertical\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    updateRange: function(value, fields) {\r\n\t        BarChart.fn.updateRange.call(this, { value: fields.to }, fields);\r\n\t    },\r\n\r\n\t    aboveAxis: function(point) {\r\n\t        return point.value >= 0;\r\n\t    },\r\n\r\n\t    plotRange: function(point) {\r\n\t        return [ point.from, point.to ];\r\n\t    },\r\n\r\n\t    createSegments: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var series = this.options.series;\r\n\t        var seriesPoints = this.seriesPoints;\r\n\t        var segments = this.segments = [];\r\n\r\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\r\n\t            var currentSeries = series[seriesIx];\r\n\t            var points = seriesPoints[seriesIx];\r\n\r\n\t            if (points) {\r\n\t                var prevPoint = (void 0);\r\n\t                for (var pointIx = 0; pointIx < points.length; pointIx++) {\r\n\t                    var point = points[pointIx];\r\n\r\n\t                    if (point && prevPoint) {\r\n\t                        var segment = new WaterfallSegment(prevPoint, point, currentSeries);\r\n\t                        segments.push(segment);\r\n\t                        this$1.append(segment);\r\n\t                    }\r\n\r\n\t                    prevPoint = point;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tfunction appendIfNotNull(array, element) {\r\n\t    if (element !== null) {\r\n\t        array.push(element);\r\n\t    }\r\n\t}\r\n\r\n\tvar AREA_SERIES = [ AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA ];\r\n\tvar OUT_OF_RANGE_SERIES = [ LINE, VERTICAL_LINE ].concat(AREA_SERIES);\r\n\r\n\tvar CategoricalPlotArea = PlotAreaBase.extend({\r\n\t    initFields: function(series) {\r\n\t        var this$1 = this;\r\n\r\n\t        this.namedCategoryAxes = {};\r\n\t        this.namedValueAxes = {};\r\n\t        this.valueAxisRangeTracker = new AxisGroupRangeTracker();\r\n\r\n\t        if (series.length > 0) {\r\n\t            this.invertAxes = inArray(\r\n\t                series[0].type, [ BAR, BULLET, VERTICAL_LINE, VERTICAL_AREA, VERTICAL_RANGE_AREA,\r\n\t                                 RANGE_BAR, HORIZONTAL_WATERFALL, VERTICAL_BOX_PLOT ]\r\n\t            );\r\n\r\n\t            for (var i = 0; i < series.length; i++) {\r\n\t                var stack = series[i].stack;\r\n\t                if (stack && stack.type === \"100%\") {\r\n\t                    this$1.stack100 = true;\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t    },\r\n\r\n\t    render: function(panes) {\r\n\t        if (panes === void 0) { panes = this.panes; }\r\n\r\n\t        this.createCategoryAxes(panes);\r\n\t        this.aggregateCategories(panes);\r\n\t        this.createCategoryAxesLabels(panes);\r\n\t        this.createCharts(panes);\r\n\t        this.createValueAxes(panes);\r\n\t    },\r\n\r\n\t    removeAxis: function(axis) {\r\n\t        var axisName = axis.options.name;\r\n\r\n\t        PlotAreaBase.fn.removeAxis.call(this, axis);\r\n\r\n\t        if (axis instanceof CategoryAxis) {\r\n\t            delete this.namedCategoryAxes[axisName];\r\n\t        } else {\r\n\t            this.valueAxisRangeTracker.reset(axisName);\r\n\t            delete this.namedValueAxes[axisName];\r\n\t        }\r\n\r\n\t        if (axis === this.categoryAxis) {\r\n\t            delete this.categoryAxis;\r\n\t        }\r\n\r\n\t        if (axis === this.valueAxis) {\r\n\t            delete this.valueAxis;\r\n\t        }\r\n\t    },\r\n\r\n\t    createCharts: function(panes) {\r\n\t        var this$1 = this;\r\n\r\n\t        var seriesByPane = this.groupSeriesByPane();\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            var pane = panes[i];\r\n\t            var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\r\n\t            this$1.addToLegend(paneSeries);\r\n\r\n\t            var visibleSeries = this$1.filterVisibleSeries(paneSeries);\r\n\t            if (!visibleSeries) {\r\n\t                continue;\r\n\t            }\r\n\r\n\t            var groups = this$1.groupSeriesByCategoryAxis(visibleSeries);\r\n\t            for (var groupIx = 0; groupIx < groups.length; groupIx++) {\r\n\t                this$1.createChartGroup(groups[groupIx], pane);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createChartGroup: function(series, pane) {\r\n\t        this.createAreaChart(\r\n\t            filterSeriesByType(series, [ AREA, VERTICAL_AREA ]), pane\r\n\t        );\r\n\r\n\t        this.createRangeAreaChart(\r\n\t            filterSeriesByType(series, [ RANGE_AREA, VERTICAL_RANGE_AREA ]), pane\r\n\t        );\r\n\r\n\t        this.createBarChart(\r\n\t            filterSeriesByType(series, [ COLUMN, BAR ]), pane\r\n\t        );\r\n\r\n\t        this.createRangeBarChart(\r\n\t            filterSeriesByType(series, [ RANGE_COLUMN, RANGE_BAR ]), pane\r\n\t        );\r\n\r\n\t        this.createBulletChart(\r\n\t            filterSeriesByType(series, [ BULLET, VERTICAL_BULLET ]), pane\r\n\t        );\r\n\r\n\t        this.createCandlestickChart(\r\n\t            filterSeriesByType(series, CANDLESTICK), pane\r\n\t        );\r\n\r\n\t        this.createBoxPlotChart(\r\n\t            filterSeriesByType(series, [ BOX_PLOT, VERTICAL_BOX_PLOT ]), pane\r\n\t        );\r\n\r\n\t        this.createOHLCChart(\r\n\t            filterSeriesByType(series, OHLC), pane\r\n\t        );\r\n\r\n\t        this.createWaterfallChart(\r\n\t            filterSeriesByType(series, [ WATERFALL, HORIZONTAL_WATERFALL ]), pane\r\n\t        );\r\n\r\n\t        this.createLineChart(\r\n\t            filterSeriesByType(series, [ LINE, VERTICAL_LINE ]), pane\r\n\t        );\r\n\t    },\r\n\r\n\t    aggregateCategories: function(panes) {\r\n\t        var this$1 = this;\r\n\r\n\t        var series = this.srcSeries || this.series;\r\n\t        var processedSeries = [];\r\n\r\n\t        for (var i = 0; i < series.length; i++) {\r\n\t            var currentSeries = series[i];\r\n\t            var categoryAxis = this$1.seriesCategoryAxis(currentSeries);\r\n\t            var axisPane = this$1.findPane(categoryAxis.options.pane);\r\n\t            var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\r\n\r\n\t            if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {\r\n\t                currentSeries = this$1.aggregateSeries(currentSeries, categoryAxis);\r\n\t            } else if (isNumber(categoryAxis.options.min) || isNumber(categoryAxis.options.max)) {\r\n\t                currentSeries = this$1.filterSeries(currentSeries, categoryAxis);\r\n\t            }\r\n\r\n\t            processedSeries.push(currentSeries);\r\n\t        }\r\n\r\n\t        this.srcSeries = series;\r\n\t        this.series = processedSeries;\r\n\t    },\r\n\r\n\t    filterSeries: function(series, categoryAxis) {\r\n\t        var range = categoryAxis.totalRangeIndices();\r\n\t        var justified = categoryAxis.options.justified;\r\n\t        var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);\r\n\r\n\t        range.min = isNumber(categoryAxis.options.min) ? Math.floor(range.min) : 0;\r\n\t        if (isNumber(categoryAxis.options.max)) {\r\n\t            range.max = justified ? Math.floor(range.max) + 1 : Math.ceil(range.max);\r\n\t        } else {\r\n\t            range.max = series.data.length;\r\n\t        }\r\n\r\n\t        var currentSeries = deepExtend({}, series);\r\n\r\n\t        if (outOfRangePoints) {\r\n\t            var minCategory = range.min - 1;\r\n\t            var srcCategories = categoryAxis.options.srcCategories || [];\r\n\t            if (minCategory >= 0 && minCategory < currentSeries.data.length) {\r\n\t                currentSeries._outOfRangeMinPoint = {\r\n\t                    item: currentSeries.data[minCategory],\r\n\t                    category: srcCategories[minCategory],\r\n\t                    categoryIx: -1\r\n\t                };\r\n\t            }\r\n\r\n\t            if (range.max < currentSeries.data.length) {\r\n\t                currentSeries._outOfRangeMaxPoint = {\r\n\t                    item: currentSeries.data[range.max],\r\n\t                    category: srcCategories[range.max],\r\n\t                    categoryIx: range.max - range.min\r\n\t                };\r\n\t            }\r\n\t        }\r\n\r\n\t        categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, currentSeries.data.length);\r\n\r\n\t        currentSeries.data = (currentSeries.data || []).slice(range.min, range.max);\r\n\r\n\t        return currentSeries;\r\n\t    },\r\n\r\n\t    aggregateSeries: function(series, categoryAxis) {\r\n\t        var this$1 = this;\r\n\r\n\t        var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);\r\n\t        var ref = categoryAxis.options;\r\n\t        var categories = ref.categories;\r\n\t        var srcCategories = ref.srcCategories; if (srcCategories === void 0) { srcCategories = categories; }\r\n\t        var dataItems = ref.dataItems; if (dataItems === void 0) { dataItems = []; }\r\n\t        var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\r\n\t        var aggregatorSeries = deepExtend({}, series);\r\n\t        var result = deepExtend({}, series);\r\n\t        var srcData = series.data;\r\n\t        var srcPoints = [];\r\n\t        var outOfRangeMinIdx = MIN_VALUE;\r\n\t        var outOfRangeMaxIdx = MAX_VALUE;\r\n\t        var getFn = getField;\r\n\t        var outOfRangeMinCategory, outOfRangeMaxCategory;\r\n\r\n\t        if (dateAxis) {\r\n\t            getFn = getDateField;\r\n\t        }\r\n\r\n\t        for (var i = 0; i < srcData.length; i++) {\r\n\t            var category = (void 0);\r\n\t            if (series.categoryField) {\r\n\t                category = getFn(series.categoryField, srcData[i], this$1.chartService.intl);\r\n\t            } else {\r\n\t                category = srcCategories[i];\r\n\t            }\r\n\r\n\t            if (defined(category)) {\r\n\t                var categoryIx = categoryAxis.categoryIndex(category);\r\n\t                if (0 <= categoryIx && categoryIx < categories.length) {\r\n\t                    srcPoints[categoryIx] = srcPoints[categoryIx] || [];\r\n\t                    srcPoints[categoryIx].push(i);\r\n\t                } else if (outOfRangePoints) {\r\n\t                    if (categoryIx < 0) {\r\n\t                        if (categoryIx === outOfRangeMinIdx) {\r\n\t                            outOfRangeMinCategory.points.push(i);\r\n\t                        } else if (categoryIx > outOfRangeMinIdx) {\r\n\t                            outOfRangeMinIdx = categoryIx;\r\n\t                            outOfRangeMinCategory = {\r\n\t                                category: category,\r\n\t                                points: [ i ]\r\n\t                            };\r\n\t                        }\r\n\t                    } else if (categoryIx >= categories.length) {\r\n\t                        if (categoryIx === outOfRangeMaxIdx) {\r\n\t                            outOfRangeMaxCategory.points.push(i);\r\n\t                        } else if (categoryIx < outOfRangeMaxIdx) {\r\n\t                            outOfRangeMaxIdx = categoryIx;\r\n\t                            outOfRangeMaxCategory = {\r\n\t                                category: category,\r\n\t                                points: [ i ]\r\n\t                            };\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        var aggregator = new SeriesAggregator(aggregatorSeries, SeriesBinder.current, DefaultAggregates.current);\r\n\t        var data = result.data = [];\r\n\t        for (var i$1 = 0; i$1 < categories.length; i$1++) {\r\n\t            data[i$1] = aggregator.aggregatePoints(\r\n\t                srcPoints[i$1], categories[i$1]\r\n\t            );\r\n\t            if (srcPoints[i$1]) {\r\n\t                dataItems[i$1] = data[i$1];\r\n\t            }\r\n\t        }\r\n\r\n\t        if (outOfRangeMinCategory && data.length) {\r\n\t            result._outOfRangeMinPoint = {\r\n\t                item: aggregator.aggregatePoints(\r\n\t                    outOfRangeMinCategory.points, outOfRangeMinCategory.category\r\n\t                ),\r\n\t                categoryIx: outOfRangeMinIdx,\r\n\t                category: outOfRangeMinCategory.category\r\n\t            };\r\n\t        }\r\n\r\n\t        if (outOfRangeMaxCategory && data.length) {\r\n\t            result._outOfRangeMaxPoint = {\r\n\t                item: aggregator.aggregatePoints(\r\n\t                    outOfRangeMaxCategory.points, outOfRangeMaxCategory.category\r\n\t                ),\r\n\t                categoryIx: outOfRangeMaxIdx,\r\n\t                category: outOfRangeMaxCategory.category\r\n\t            };\r\n\t        }\r\n\t        categoryAxis.options.dataItems = dataItems;\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    appendChart: function(chart, pane) {\r\n\t        var series = chart.options.series;\r\n\t        var categoryAxis = this.seriesCategoryAxis(series[0]);\r\n\t        var categories = categoryAxis.options.categories;\r\n\t        var categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);\r\n\r\n\t        while (categoriesToAdd--) {\r\n\t            categories.push(\"\");\r\n\t        }\r\n\r\n\t        this.valueAxisRangeTracker.update(chart.valueAxisRanges);\r\n\r\n\t        PlotAreaBase.fn.appendChart.call(this, chart, pane);\r\n\t    },\r\n\r\n\t    seriesPaneName: function(series) {\r\n\t        var options = this.options;\r\n\t        var axisName = series.axis;\r\n\t        var axisOptions = [].concat(options.valueAxis);\r\n\t        var axis = grep(axisOptions, function(a) { return a.name === axisName; })[0];\r\n\t        var panes = options.panes || [ {} ];\r\n\t        var defaultPaneName = (panes[0] || {}).name || \"default\";\r\n\t        var paneName = (axis || {}).pane || defaultPaneName;\r\n\r\n\t        return paneName;\r\n\t    },\r\n\r\n\t    seriesCategoryAxis: function(series) {\r\n\t        var axisName = series.categoryAxis;\r\n\t        var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;\r\n\r\n\t        if (!axis) {\r\n\t            throw new Error(\"Unable to locate category axis with name \" + axisName);\r\n\t        }\r\n\r\n\t        return axis;\r\n\t    },\r\n\r\n\t    stackableChartOptions: function(firstSeries, pane) {\r\n\t        var stack = firstSeries.stack;\r\n\t        var isStacked100 = stack && stack.type === \"100%\";\r\n\t        var clip = pane.options.clip;\r\n\r\n\t        return {\r\n\t            isStacked: stack,\r\n\t            isStacked100: isStacked100,\r\n\t            clip: clip\r\n\t        };\r\n\t    },\r\n\r\n\t    groupSeriesByCategoryAxis: function(series) {\r\n\t        var categoryAxes = [];\r\n\t        var unique = {};\r\n\t        for (var idx = 0; idx < series.length; idx++) {\r\n\t            var name = series[idx].categoryAxis || \"$$default$$\";\r\n\t            if (!unique.hasOwnProperty(name)) {\r\n\t                unique[name] = true;\r\n\t                categoryAxes.push(name);\r\n\t            }\r\n\t        }\r\n\r\n\t        var groups = [];\r\n\t        for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {\r\n\t            var axis = categoryAxes[axisIx];\r\n\t            var axisSeries = groupSeries(series, axis, axisIx);\r\n\t            if (axisSeries.length === 0) {\r\n\t                continue;\r\n\t            }\r\n\r\n\t            groups.push(axisSeries);\r\n\t        }\r\n\r\n\t        return groups;\r\n\t    },\r\n\r\n\t    createBarChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var firstSeries = series[0];\r\n\t        var barChart = new BarChart(this, $.extend({\r\n\t            series: series,\r\n\t            invertAxes: this.invertAxes,\r\n\t            gap: firstSeries.gap,\r\n\t            spacing: firstSeries.spacing\r\n\t        }, this.stackableChartOptions(firstSeries, pane)));\r\n\r\n\t        this.appendChart(barChart, pane);\r\n\t    },\r\n\r\n\t    createRangeBarChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var firstSeries = series[0];\r\n\t        var rangeColumnChart = new RangeBarChart(this, {\r\n\t            series: series,\r\n\t            invertAxes: this.invertAxes,\r\n\t            gap: firstSeries.gap,\r\n\t            spacing: firstSeries.spacing\r\n\t        });\r\n\r\n\t        this.appendChart(rangeColumnChart, pane);\r\n\t    },\r\n\r\n\t    createBulletChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var firstSeries = series[0];\r\n\t        var bulletChart = new BulletChart(this, {\r\n\t            series: series,\r\n\t            invertAxes: this.invertAxes,\r\n\t            gap: firstSeries.gap,\r\n\t            spacing: firstSeries.spacing,\r\n\t            clip: pane.options.clip\r\n\t        });\r\n\r\n\t        this.appendChart(bulletChart, pane);\r\n\t    },\r\n\r\n\t    createLineChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var firstSeries = series[0];\r\n\t        var lineChart = new LineChart(this, $.extend({\r\n\t            invertAxes: this.invertAxes,\r\n\t            series: series\r\n\t        }, this.stackableChartOptions(firstSeries, pane)));\r\n\r\n\t        this.appendChart(lineChart, pane);\r\n\t    },\r\n\r\n\t    createAreaChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var firstSeries = series[0];\r\n\t        var areaChart = new AreaChart(this, $.extend({\r\n\t            invertAxes: this.invertAxes,\r\n\t            series: series\r\n\t        }, this.stackableChartOptions(firstSeries, pane)));\r\n\r\n\t        this.appendChart(areaChart, pane);\r\n\t    },\r\n\r\n\t    createRangeAreaChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var rangeAreaChart = new RangeAreaChart(this, {\r\n\t            invertAxes: this.invertAxes,\r\n\t            series: series,\r\n\t            clip: pane.options.clip\r\n\t        });\r\n\r\n\t        this.appendChart(rangeAreaChart, pane);\r\n\t    },\r\n\r\n\t    createOHLCChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var firstSeries = series[0];\r\n\t        var chart = new OHLCChart(this, {\r\n\t            invertAxes: this.invertAxes,\r\n\t            gap: firstSeries.gap,\r\n\t            series: series,\r\n\t            spacing: firstSeries.spacing,\r\n\t            clip: pane.options.clip\r\n\t        });\r\n\r\n\t        this.appendChart(chart, pane);\r\n\t    },\r\n\r\n\t    createCandlestickChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var firstSeries = series[0];\r\n\t        var chart = new CandlestickChart(this, {\r\n\t            invertAxes: this.invertAxes,\r\n\t            gap: firstSeries.gap,\r\n\t            series: series,\r\n\t            spacing: firstSeries.spacing,\r\n\t            clip: pane.options.clip\r\n\t        });\r\n\r\n\t        this.appendChart(chart, pane);\r\n\t    },\r\n\r\n\t    createBoxPlotChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var firstSeries = series[0];\r\n\t        var chart = new BoxPlotChart(this, {\r\n\t            invertAxes: this.invertAxes,\r\n\t            gap: firstSeries.gap,\r\n\t            series: series,\r\n\t            spacing: firstSeries.spacing,\r\n\t            clip: pane.options.clip\r\n\t        });\r\n\r\n\t        this.appendChart(chart, pane);\r\n\t    },\r\n\r\n\t    createWaterfallChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var firstSeries = series[0];\r\n\t        var waterfallChart = new WaterfallChart(this, {\r\n\t            series: series,\r\n\t            invertAxes: this.invertAxes,\r\n\t            gap: firstSeries.gap,\r\n\t            spacing: firstSeries.spacing\r\n\t        });\r\n\r\n\t        this.appendChart(waterfallChart, pane);\r\n\t    },\r\n\r\n\t    axisRequiresRounding: function(categoryAxisName, categoryAxisIndex) {\r\n\t        var this$1 = this;\r\n\r\n\t        var centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);\r\n\r\n\t        for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {\r\n\t            var currentSeries = this$1.series[seriesIx];\r\n\t            if (inArray(currentSeries.type, AREA_SERIES)) {\r\n\t                var line = currentSeries.line;\r\n\t                if (line && line.style === STEP) {\r\n\t                    centeredSeries.push(currentSeries);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        for (var seriesIx$1 = 0; seriesIx$1 < centeredSeries.length; seriesIx$1++) {\r\n\t            var seriesAxis = centeredSeries[seriesIx$1].categoryAxis || \"\";\r\n\t            if (seriesAxis === categoryAxisName || (!seriesAxis && categoryAxisIndex === 0)) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    aggregatedAxis: function(categoryAxisName, categoryAxisIndex) {\r\n\t        var series = this.series;\r\n\r\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\r\n\t            var seriesAxis = series[seriesIx].categoryAxis || \"\";\r\n\t            if ((seriesAxis === categoryAxisName || (!seriesAxis && categoryAxisIndex === 0)) && series[seriesIx].categoryField) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createCategoryAxesLabels: function() {\r\n\t        var axes = this.axes;\r\n\t        for (var i = 0; i < axes.length; i++) {\r\n\t            if (axes[i] instanceof CategoryAxis) {\r\n\t                axes[i].createLabels();\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createCategoryAxes: function(panes) {\r\n\t        var this$1 = this;\r\n\r\n\t        var invertAxes = this.invertAxes;\r\n\t        var definitions = [].concat(this.options.categoryAxis);\r\n\t        var axes = [];\r\n\r\n\t        for (var i = 0; i < definitions.length; i++) {\r\n\t            var axisOptions = definitions[i];\r\n\t            var axisPane = this$1.findPane(axisOptions.pane);\r\n\r\n\t            if (inArray(axisPane, panes)) {\r\n\t                var name = axisOptions.name;\r\n\t                var categories = axisOptions.categories; if (categories === void 0) { categories = []; }\r\n\t                axisOptions = deepExtend({\r\n\t                    vertical: invertAxes,\r\n\t                    reverse: !invertAxes && this$1.chartService.rtl,\r\n\t                    axisCrossingValue: invertAxes ? MAX_VALUE : 0\r\n\t                }, axisOptions);\r\n\r\n\t                if (!defined(axisOptions.justified)) {\r\n\t                    axisOptions.justified = this$1.isJustified();\r\n\t                }\r\n\r\n\t                if (this$1.axisRequiresRounding(name, i)) {\r\n\t                    axisOptions.justified = false;\r\n\t                }\r\n\r\n\t                var categoryAxis = (void 0);\r\n\r\n\t                if (isDateAxis(axisOptions, categories[0])) {\r\n\t                    categoryAxis = new DateCategoryAxis(axisOptions, this$1.chartService);\r\n\t                } else {\r\n\t                    categoryAxis = new CategoryAxis(axisOptions, this$1.chartService);\r\n\t                }\r\n\r\n\t                if (name) {\r\n\t                    if (this$1.namedCategoryAxes[name]) {\r\n\t                        throw new Error((\"Category axis with name \" + name + \" is already defined\"));\r\n\t                    }\r\n\t                    this$1.namedCategoryAxes[name] = categoryAxis;\r\n\t                }\r\n\r\n\t                categoryAxis.axisIndex = i;\r\n\t                axes.push(categoryAxis);\r\n\t                this$1.appendAxis(categoryAxis);\r\n\t            }\r\n\t        }\r\n\r\n\t        var primaryAxis = this.categoryAxis || axes[0];\r\n\t        this.categoryAxis = primaryAxis;\r\n\r\n\t        if (invertAxes) {\r\n\t            this.axisY = primaryAxis;\r\n\t        } else {\r\n\t            this.axisX = primaryAxis;\r\n\t        }\r\n\t    },\r\n\r\n\t    isJustified: function() {\r\n\t        var series = this.series;\r\n\r\n\t        for (var i = 0; i < series.length; i++) {\r\n\t            var currentSeries = series[i];\r\n\t            if (!inArray(currentSeries.type, AREA_SERIES)) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\r\n\t        return true;\r\n\t    },\r\n\r\n\t    createValueAxes: function(panes) {\r\n\t        var this$1 = this;\r\n\r\n\t        var tracker = this.valueAxisRangeTracker;\r\n\t        var defaultRange = tracker.query();\r\n\t        var definitions = [].concat(this.options.valueAxis);\r\n\t        var invertAxes = this.invertAxes;\r\n\t        var baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };\r\n\t        var axes = [];\r\n\r\n\t        if (this.stack100) {\r\n\t            baseOptions.roundToMajorUnit = false;\r\n\t            baseOptions.labels = { format: \"P0\" };\r\n\t        }\r\n\r\n\t        for (var i = 0; i < definitions.length; i++) {\r\n\t            var axisOptions = definitions[i];\r\n\t            var axisPane = this$1.findPane(axisOptions.pane);\r\n\r\n\t            if (inArray(axisPane, panes)) {\r\n\t                var name = axisOptions.name;\r\n\t                var defaultAxisRange = equalsIgnoreCase(axisOptions.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };\r\n\t                var range = tracker.query(name) || defaultRange || defaultAxisRange;\r\n\r\n\t                if (i === 0 && range && defaultRange) {\r\n\t                    range.min = Math.min(range.min, defaultRange.min);\r\n\t                    range.max = Math.max(range.max, defaultRange.max);\r\n\t                }\r\n\r\n\t                var axisType = (void 0);\r\n\t                if (equalsIgnoreCase(axisOptions.type, LOGARITHMIC)) {\r\n\t                    axisType = dataviz.LogarithmicAxis;\r\n\t                } else {\r\n\t                    axisType = dataviz.NumericAxis;\r\n\t                }\r\n\r\n\t                var valueAxis = new axisType(range.min, range.max,\r\n\t                    deepExtend({}, baseOptions, axisOptions),\r\n\t                    this$1.chartService\r\n\t                );\r\n\r\n\t                if (name) {\r\n\t                    if (this$1.namedValueAxes[name]) {\r\n\t                        throw new Error((\"Value axis with name \" + name + \" is already defined\"));\r\n\t                    }\r\n\t                    this$1.namedValueAxes[name] = valueAxis;\r\n\t                }\r\n\t                valueAxis.axisIndex = i;\r\n\r\n\t                axes.push(valueAxis);\r\n\t                this$1.appendAxis(valueAxis);\r\n\t            }\r\n\t        }\r\n\r\n\t        var primaryAxis = this.valueAxis || axes[0];\r\n\t        this.valueAxis = primaryAxis;\r\n\r\n\t        if (invertAxes) {\r\n\t            this.axisX = primaryAxis;\r\n\t        } else {\r\n\t            this.axisY = primaryAxis;\r\n\t        }\r\n\t    },\r\n\r\n\t    _dispatchEvent: function(chart, e, eventType) {\r\n\t        var coords = chart._eventCoordinates(e);\r\n\t        var point = new Point(coords.x, coords.y);\r\n\t        var pane = this.pointPane(point);\r\n\t        var categories = [];\r\n\t        var values = [];\r\n\r\n\t        if (!pane) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var allAxes = pane.axes;\r\n\t        for (var i = 0; i < allAxes.length; i++) {\r\n\t            var axis = allAxes[i];\r\n\t            if (axis.getValue) {\r\n\t                appendIfNotNull(values, axis.getValue(point));\r\n\t            } else {\r\n\t                appendIfNotNull(categories, axis.getCategory(point));\r\n\t            }\r\n\t        }\r\n\r\n\t        if (categories.length === 0) {\r\n\t            appendIfNotNull(categories, this.categoryAxis.getCategory(point));\r\n\t        }\r\n\r\n\t        if (categories.length > 0 && values.length > 0) {\r\n\t            chart.trigger(eventType, {\r\n\t                element: eventElement(e),\r\n\t                originalEvent: e,\r\n\t                category: singleItemOrArray(categories),\r\n\t                value: singleItemOrArray(values)\r\n\t            });\r\n\t        }\r\n\t    },\r\n\r\n\t    pointPane: function(point) {\r\n\t        var panes = this.panes;\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            var currentPane = panes[i];\r\n\t            if (currentPane.contentBox.containsPoint(point)) {\r\n\t                return currentPane;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    updateAxisOptions: function(axis, options) {\r\n\t        updateAxisOptions(this.options, axis, options);\r\n\t        updateAxisOptions(this.originalOptions, axis, options);\r\n\t    }\r\n\t});\r\n\r\n\tfunction updateAxisOptions(targetOptions, axis, options) {\r\n\t    var axesOptions = axis instanceof CategoryAxis ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);\r\n\t    deepExtend(axesOptions[axis.axisIndex], options);\r\n\t}\r\n\r\n\tfunction groupSeries(series, axis, axisIx) {\r\n\t    return grep(series, function(s) {\r\n\t        return (axisIx === 0 && !s.categoryAxis) || (s.categoryAxis === axis);\r\n\t    });\r\n\t}\r\n\r\n\tsetDefaultOptions(CategoricalPlotArea, {\r\n\t    categoryAxis: {\r\n\t        categories: []\r\n\t    },\r\n\t    valueAxis: {}\r\n\t});\r\n\r\n\tdeepExtend(CategoricalPlotArea.prototype, PlotAreaEventsMixin);\r\n\r\n\tvar Highlight = Class.extend({\r\n\t    init: function() {\r\n\r\n\t        this._points = [];\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        this._points = [];\r\n\t    },\r\n\r\n\t    show: function(points) {\r\n\t        var this$1 = this;\r\n\r\n\t        var arrayPoints = [].concat(points);\r\n\t        this.hide();\r\n\r\n\t        for (var i = 0; i < arrayPoints.length; i++) {\r\n\t            var point = arrayPoints[i];\r\n\t            if (point && point.toggleHighlight && point.hasHighlight()) {\r\n\t                this$1.togglePointHighlight(point, true);\r\n\t                this$1._points.push(point);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    togglePointHighlight: function(point, show) {\r\n\t        var toggleHandler = (point.options.highlight || {}).toggle;\r\n\t        if (toggleHandler) {\r\n\t            var eventArgs = {\r\n\t                category: point.category,\r\n\t                series: point.series,\r\n\t                dataItem: point.dataItem,\r\n\t                value: point.value,\r\n\t                stackValue: point.stackValue,\r\n\t                preventDefault: preventDefault,\r\n\t                visual: point.highlightVisual(),\r\n\t                show: show\r\n\t            };\r\n\t            toggleHandler(eventArgs);\r\n\t            if (!eventArgs._defaultPrevented) {\r\n\t                point.toggleHighlight(show);\r\n\t            }\r\n\t        } else {\r\n\t            point.toggleHighlight(show);\r\n\t        }\r\n\t    },\r\n\r\n\t    hide: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var points = this._points;\r\n\t        while (points.length) {\r\n\t            this$1.togglePointHighlight(points.pop(), false);\r\n\t        }\r\n\t    },\r\n\r\n\t    isHighlighted: function(element) {\r\n\t        var points = this._points;\r\n\r\n\t        for (var i = 0; i < points.length; i++) {\r\n\t            var point = points[i];\r\n\t            if (element === point) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\r\n\t        return false;\r\n\t    }\r\n\t});\r\n\r\n\tfunction preventDefault() {\r\n\t    this._defaultPrevented = true;\r\n\t}\r\n\r\n\tfunction acceptKey(e, mouseKey) {\r\n\t    var key = (mouseKey || \"\").toLowerCase();\r\n\t    var event = e.event;\r\n\t    var accept = (key === \"none\" && !(event.ctrlKey || event.shiftKey || event.altKey)) || event[key + \"Key\"];\r\n\r\n\t    return accept;\r\n\t}\r\n\r\n\tfunction toChartAxisRanges(axisRanges) {\r\n\t    var ranges = {};\r\n\t    for (var idx = 0; idx < axisRanges.length; idx++) {\r\n\t        var axisRange = axisRanges[idx];\r\n\t        if (axisRange.axis.options.name) {\r\n\t            ranges[axisRange.axis.options.name] = {\r\n\t                min: axisRange.range.min,\r\n\t                max: axisRange.range.max\r\n\t            };\r\n\t        }\r\n\t    }\r\n\t    return ranges;\r\n\t}\r\n\r\n\tvar Pannable = Class.extend({\r\n\t    init: function(plotArea, options) {\r\n\r\n\t        this.plotArea = plotArea;\r\n\t        this.options = deepExtend({}, this.options, options);\r\n\t    },\r\n\r\n\t    start: function(e) {\r\n\t        this._active = acceptKey(e, this.options.key);\r\n\t        return this._active;\r\n\t    },\r\n\r\n\t    move: function(e) {\r\n\t        if (this._active) {\r\n\t            var axisRanges = this.axisRanges = this._panAxes(e, X).concat(this._panAxes(e, Y));\r\n\t            if (axisRanges.length) {\r\n\t                this.axisRanges = axisRanges;\r\n\t                return toChartAxisRanges(axisRanges);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    end: function() {\r\n\t        var active = this._active;\r\n\t        this._active = false;\r\n\r\n\t        return active;\r\n\t    },\r\n\r\n\t    pan: function() {\r\n\t        var ref = this;\r\n\t        var plotArea = ref.plotArea;\r\n\t        var axisRanges = ref.axisRanges;\r\n\t        if (axisRanges.length) {\r\n\t            for (var idx = 0; idx < axisRanges.length; idx++) {\r\n\t                var range = axisRanges[idx];\r\n\t                plotArea.updateAxisOptions(range.axis, range.range);\r\n\t            }\r\n\t            plotArea.redraw(plotArea.panes);\r\n\t        }\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        delete this.plotArea;\r\n\t    },\r\n\r\n\t    _panAxes: function(e, position) {\r\n\t        var plotArea = this.plotArea;\r\n\t        var delta = -e[position].delta;\r\n\t        var lock = (this.options.lock || \"\").toLowerCase();\r\n\t        var updatedAxes = [];\r\n\r\n\t        if (delta !== 0 && (lock || \"\").toLowerCase() !== position) {\r\n\t            var axes = plotArea.axes;\r\n\t            for (var idx = 0; idx < axes.length; idx++) {\r\n\t                var axis = axes[idx];\r\n\r\n\t                if (position === X && !axis.options.vertical || position === Y && axis.options.vertical) {\r\n\t                    var range = axis.pan(delta);\r\n\r\n\t                    if (range) {\r\n\t                        range.limitRange = true;\r\n\t                        updatedAxes.push({\r\n\t                            axis: axis,\r\n\t                            range: range\r\n\t                        });\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return updatedAxes;\r\n\t    }\r\n\t});\r\n\r\n\tPannable.prototype.options = {\r\n\t    key: \"none\",\r\n\t    lock: \"none\"\r\n\t};\r\n\r\n\tvar ZoomSelection = Class.extend({\r\n\t    init: function(chart, options) {\r\n\r\n\t        this.chart = chart;\r\n\t        this.options = deepExtend({}, this.options, options);\r\n\t        this.createElement();\r\n\t    },\r\n\r\n\t    createElement: function() {\r\n\t        var marquee = this._marquee = document.createElement(\"div\");\r\n\t        marquee.className = \"k-marquee\";\r\n\t        var marqueeColor = document.createElement(\"div\");\r\n\t        marqueeColor.className = \"k-marquee-color\";\r\n\t        marquee.appendChild(marqueeColor);\r\n\t    },\r\n\r\n\t    removeElement: function() {\r\n\t        if (this._marquee.parentNode) {\r\n\t            this._marquee.parentNode.removeChild(this._marquee);\r\n\t        }\r\n\t    },\r\n\r\n\t    setStyles: function(styles) {\r\n\t        elementStyles(this._marquee, styles);\r\n\t    },\r\n\r\n\t    start: function(e) {\r\n\t        if (acceptKey(e, this.options.key)) {\r\n\t            var chart = this.chart;\r\n\t            var point = chart._eventCoordinates(e);\r\n\t            var zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point);\r\n\t            if (zoomPane && zoomPane.clipBox()) {\r\n\t                var clipBox = zoomPane.clipBox().clone();\r\n\t                var offset = this._elementOffset();\r\n\r\n\t                clipBox.translate(offset.left, offset.top);\r\n\t                this._zoomPaneClipBox = clipBox;\r\n\r\n\t                document.body.appendChild(this._marquee);\r\n\t                this.setStyles({\r\n\t                    left: e.pageX + 1,\r\n\t                    top: e.pageY + 1,\r\n\t                    width: 0,\r\n\t                    height: 0\r\n\t                });\r\n\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t        return false;\r\n\t    },\r\n\r\n\t    _elementOffset: function() {\r\n\t        var chartElement = this.chart.element;\r\n\t        var ref = elementStyles(chartElement, [ \"paddingLeft\", \"paddingTop\" ]);\r\n\t        var paddingLeft = ref.paddingLeft;\r\n\t        var paddingTop = ref.paddingTop;\r\n\t        var offset = dataviz.elementOffset(chartElement);\r\n\r\n\t        return {\r\n\t            left: paddingLeft + offset.left,\r\n\t            top: paddingTop + offset.top\r\n\t        };\r\n\t    },\r\n\r\n\t    move: function(e) {\r\n\t        var zoomPane = this._zoomPane;\r\n\t        if (zoomPane) {\r\n\t            this.setStyles(this._selectionPosition(e));\r\n\t        }\r\n\t    },\r\n\r\n\t    end: function(e) {\r\n\t        var zoomPane = this._zoomPane;\r\n\t        if (zoomPane) {\r\n\t            var elementOffset$$1 = this._elementOffset();\r\n\t            var selectionPosition = this._selectionPosition(e);\r\n\t            selectionPosition.left -= elementOffset$$1.left;\r\n\t            selectionPosition.top -= elementOffset$$1.top;\r\n\r\n\t            var start = { x: selectionPosition.left, y: selectionPosition.top };\r\n\t            var end = { x: selectionPosition.left + selectionPosition.width, y: selectionPosition.top + selectionPosition.height };\r\n\t            this._updateAxisRanges(start, end);\r\n\r\n\t            this.removeElement();\r\n\t            delete this._zoomPane;\r\n\r\n\t            return toChartAxisRanges(this.axisRanges);\r\n\t        }\r\n\t    },\r\n\r\n\t    zoom: function() {\r\n\t        var axisRanges = this.axisRanges;\r\n\t        if (axisRanges && axisRanges.length) {\r\n\t            var plotArea = this.chart._plotArea;\r\n\t            for (var idx = 0; idx < axisRanges.length; idx++) {\r\n\t                var axisRange = axisRanges[idx];\r\n\t                plotArea.updateAxisOptions(axisRange.axis, axisRange.range);\r\n\t            }\r\n\t            plotArea.redraw(plotArea.panes);\r\n\t        }\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        this.removeElement();\r\n\t        delete this._marquee;\r\n\t        delete this.chart;\r\n\t    },\r\n\r\n\t    _updateAxisRanges: function(start, end) {\r\n\t        var lock = (this.options.lock || \"\").toLowerCase();\r\n\t        var axisRanges = [];\r\n\r\n\t        var axes = this._zoomPane.axes;\r\n\t        for (var idx = 0; idx < axes.length; idx++) {\r\n\t            var axis = axes[idx];\r\n\t            var vertical = axis.options.vertical;\r\n\t            if (!(lock === X && !vertical) && !(lock === Y && vertical)) {\r\n\t                var range = axis.pointsRange(start, end);\r\n\t                if (range) {\r\n\t                    axisRanges.push({\r\n\t                        axis: axis,\r\n\t                        range: range\r\n\t                    });\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        this.axisRanges = axisRanges;\r\n\t    },\r\n\r\n\t    _selectionPosition: function(e) {\r\n\t        var clipBox = this._zoomPaneClipBox;\r\n\t        var startLocation = {\r\n\t            x: e.x.startLocation,\r\n\t            y: e.y.startLocation\r\n\t        };\r\n\t        var pageX = e.x.location;\r\n\t        var pageY = e.y.location;\r\n\t        var lock = (this.options.lock || \"\").toLowerCase();\r\n\t        var left = Math.min(startLocation.x, pageX);\r\n\t        var top = Math.min(startLocation.y, pageY);\r\n\t        var width = Math.abs(startLocation.x - pageX);\r\n\t        var height = Math.abs(startLocation.y - pageY);\r\n\r\n\t        if (lock === X) {\r\n\t            left = clipBox.x1;\r\n\t            width = clipBox.width();\r\n\t        }\r\n\t        if (lock === Y) {\r\n\t            top = clipBox.y1;\r\n\t            height = clipBox.height();\r\n\t        }\r\n\r\n\t        if (pageX > clipBox.x2) {\r\n\t            width = clipBox.x2 - startLocation.x;\r\n\t        }\r\n\r\n\t        if (pageX < clipBox.x1) {\r\n\t            width = startLocation.x - clipBox.x1;\r\n\t        }\r\n\r\n\t        if (pageY > clipBox.y2) {\r\n\t            height = clipBox.y2 - startLocation.y;\r\n\t        }\r\n\r\n\t        if (pageY < clipBox.y1) {\r\n\t            height = startLocation.y - clipBox.y1;\r\n\t        }\r\n\r\n\t        return {\r\n\t            left: Math.max(left, clipBox.x1),\r\n\t            top: Math.max(top, clipBox.y1),\r\n\t            width: width,\r\n\t            height: height\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tZoomSelection.prototype.options = {\r\n\t    key: \"shift\",\r\n\t    lock: \"none\"\r\n\t};\r\n\r\n\tvar MousewheelZoom = Class.extend({\r\n\t    init: function(chart, options) {\r\n\r\n\t        this.chart = chart;\r\n\t        this.options = deepExtend({}, this.options, options);\r\n\t    },\r\n\r\n\t    updateRanges: function(delta) {\r\n\t        var lock = (this.options.lock || \"\").toLowerCase();\r\n\t        var axisRanges = [];\r\n\t        var axes = this.chart._plotArea.axes;\r\n\r\n\t        for (var idx = 0; idx < axes.length; idx++) {\r\n\t            var axis = axes[idx];\r\n\t            var vertical = axis.options.vertical;\r\n\r\n\t            if (!(lock === X && !vertical) && !(lock === Y && vertical)) {\r\n\t                var range = axis.zoomRange(-delta);\r\n\r\n\t                if (range) {\r\n\t                    axisRanges.push({\r\n\t                        axis: axis,\r\n\t                        range: range\r\n\t                    });\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        this.axisRanges = axisRanges;\r\n\t        return toChartAxisRanges(axisRanges);\r\n\t    },\r\n\r\n\t    zoom: function() {\r\n\t        var axisRanges = this.axisRanges;\r\n\t        if (axisRanges && axisRanges.length) {\r\n\t            var plotArea = this.chart._plotArea;\r\n\t            for (var idx = 0; idx < axisRanges.length; idx++) {\r\n\t                var axisRange = axisRanges[idx];\r\n\t                plotArea.updateAxisOptions(axisRange.axis, axisRange.range);\r\n\t            }\r\n\t            plotArea.redraw(plotArea.panes);\r\n\t        }\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        delete this.chart;\r\n\t    }\r\n\t});\r\n\r\n\tvar LegendLayout = ChartElement.extend({\r\n\t    init: function(options, chartService) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.chartService = chartService;\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        var ref = this;\r\n\t        var children = ref.children;\r\n\t        var options = ref.options;\r\n\t        var vertical = options.vertical;\r\n\r\n\t        this.visual = new drawing.Layout(null, {\r\n\t            spacing: vertical ? 0 : options.spacing,\r\n\t            lineSpacing: vertical ? options.spacing : 0,\r\n\t            orientation: vertical ? \"vertical\" : \"horizontal\",\r\n\t            reverse: options.rtl,\r\n\t            alignItems: vertical ? \"start\" : \"center\"\r\n\t        });\r\n\r\n\t        for (var idx = 0; idx < children.length; idx++) {\r\n\t            var legendItem = children[idx];\r\n\t            legendItem.reflow(new Box());\r\n\t            legendItem.renderVisual();\r\n\t        }\r\n\t    },\r\n\r\n\t    reflow: function(box) {\r\n\t        this.visual.rect(box.toRect());\r\n\t        this.visual.reflow();\r\n\t        var bbox = this.visual.clippedBBox();\r\n\r\n\t        if (bbox) {\r\n\t            this.box = dataviz.rectToBox(bbox);\r\n\t        } else {\r\n\t            this.box = new Box();\r\n\t        }\r\n\t    },\r\n\r\n\t    renderVisual: function() {\r\n\t        this.addVisual();\r\n\t    },\r\n\r\n\t    createVisual: function() {}\r\n\t});\r\n\r\n\tvar LegendItem = BoxElement.extend({\r\n\t    init: function(options) {\r\n\t        BoxElement.fn.init.call(this, options);\r\n\r\n\t        this.createContainer();\r\n\t        if (!options.rtl) {\r\n\t            this.createMarker();\r\n\t            this.createLabel();\r\n\t        } else {\r\n\t            this.createLabel();\r\n\t            this.createMarker();\r\n\t        }\r\n\t    },\r\n\r\n\t    createContainer: function() {\r\n\t        this.container = new dataviz.FloatElement({ vertical: false, wrap: false, align: CENTER, spacing: this.options.spacing });\r\n\t        this.append(this.container);\r\n\t    },\r\n\r\n\t    createMarker: function() {\r\n\t        this.container.append(new ShapeElement(this.markerOptions()));\r\n\t    },\r\n\r\n\t    markerOptions: function() {\r\n\t        var options = this.options;\r\n\t        var markerColor = options.markerColor;\r\n\t        return deepExtend({}, options.markers, {\r\n\t            background: markerColor,\r\n\t            border: {\r\n\t                color: markerColor\r\n\t            }\r\n\t        });\r\n\t    },\r\n\r\n\t    createLabel: function() {\r\n\t        var options = this.options;\r\n\t        var labelOptions = deepExtend({}, options.labels);\r\n\r\n\t        this.container.append(new TextBox(options.text, labelOptions));\r\n\t    },\r\n\r\n\t    renderComplete: function() {\r\n\t        BoxElement.fn.renderComplete.call(this);\r\n\r\n\t        var cursor = this.options.cursor || {};\r\n\t        var eventSink = this._itemOverlay = Path.fromRect(this.container.box.toRect(), {\r\n\t            fill: {\r\n\t                color: WHITE,\r\n\t                opacity: 0\r\n\t            },\r\n\t            stroke: null,\r\n\t            cursor: cursor.style || cursor\r\n\t        });\r\n\r\n\t        this.appendVisual(eventSink);\r\n\t    },\r\n\r\n\t    click: function(widget, e) {\r\n\t        var args = this.eventArgs(e);\r\n\r\n\t        if (!widget.trigger(LEGEND_ITEM_CLICK, args)) {\r\n\t            e.preventDefault();\r\n\t        }\r\n\t    },\r\n\r\n\t    hover: function(widget, e) {\r\n\t        var args = this.eventArgs(e);\r\n\r\n\t        if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {\r\n\t            e.preventDefault();\r\n\t            widget._legendItemHover(args.seriesIndex, args.pointIndex);\r\n\t        }\r\n\r\n\t        // Don't trigger point hover for legend items\r\n\t        return true;\r\n\t    },\r\n\r\n\t    leave: function(widget) {\r\n\t        widget._unsetActivePoint();\r\n\t    },\r\n\r\n\t    eventArgs: function(e) {\r\n\t        var options = this.options;\r\n\r\n\t        return {\r\n\t            element: eventElement(e),\r\n\t            text: options.text,\r\n\t            series: options.series,\r\n\t            seriesIndex: options.series.index,\r\n\t            pointIndex: options.pointIndex\r\n\t        };\r\n\t    },\r\n\r\n\t    renderVisual: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var customVisual = options.visual;\r\n\r\n\t        if (customVisual) {\r\n\t            this.visual = customVisual({\r\n\t                active: options.active,\r\n\t                series: options.series,\r\n\t                sender: this.getSender(),\r\n\t                pointIndex: options.pointIndex,\r\n\t                options: {\r\n\t                    markers: this.markerOptions(),\r\n\t                    labels: options.labels\r\n\t                },\r\n\t                createVisual: function () {\r\n\t                    this$1.createVisual();\r\n\t                    this$1.renderChildren();\r\n\t                    this$1.renderComplete();\r\n\r\n\t                    var defaultVisual = this$1.visual;\r\n\r\n\t                    delete this$1.visual;\r\n\r\n\t                    return defaultVisual;\r\n\t                }\r\n\t            });\r\n\t            this.addVisual();\r\n\t        } else {\r\n\t            BoxElement.fn.renderVisual.call(this);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar HORIZONTAL = \"horizontal\";\r\n\tvar POINTER = \"pointer\";\r\n\tvar CUSTOM = \"custom\";\r\n\r\n\tvar Legend = ChartElement.extend({\r\n\t    init: function(options, chartService) {\r\n\t        if (chartService === void 0) { chartService = {}; }\r\n\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.chartService = chartService;\r\n\r\n\t        if (!inArray(this.options.position, [ TOP, RIGHT, BOTTOM, LEFT, CUSTOM ])) {\r\n\t            this.options.position = RIGHT;\r\n\t        }\r\n\r\n\t        this.createContainer();\r\n\r\n\t        this.createItems();\r\n\t    },\r\n\r\n\t    createContainer: function() {\r\n\t        var options = this.options;\r\n\t        var position = options.position;\r\n\t        var userAlign = options.align;\r\n\t        var align = position;\r\n\t        var vAlign = CENTER;\r\n\r\n\t        if (position === CUSTOM) {\r\n\t            align = LEFT;\r\n\t        } else if (inArray(position, [ TOP, BOTTOM ])) {\r\n\t            if (userAlign === \"start\") {\r\n\t                align = LEFT;\r\n\t            } else if (userAlign === \"end\") {\r\n\t                align = RIGHT;\r\n\t            } else {\r\n\t                align = CENTER;\r\n\t            }\r\n\t            vAlign = position;\r\n\t        } else if (userAlign) {\r\n\t            if (userAlign === \"start\") {\r\n\t                vAlign = TOP;\r\n\t            } else if (userAlign === \"end\") {\r\n\t                vAlign = BOTTOM;\r\n\t            }\r\n\t        }\r\n\r\n\t        this.container = new BoxElement({\r\n\t            margin: options.margin,\r\n\t            padding: options.padding,\r\n\t            background: options.background,\r\n\t            border: options.border,\r\n\t            vAlign: vAlign,\r\n\t            align: align,\r\n\t            zIndex: options.zIndex,\r\n\t            shrinkToFit: true\r\n\t        });\r\n\r\n\t        this.append(this.container);\r\n\t    },\r\n\r\n\t    createItems: function() {\r\n\t        var chartService = this.getService();\r\n\t        var options = this.options;\r\n\t        var vertical = this.isVertical();\r\n\t        var innerElement = new LegendLayout({\r\n\t            vertical: vertical,\r\n\t            spacing: options.spacing,\r\n\t            rtl: chartService.rtl\r\n\t        }, chartService);\r\n\t        var items = options.items;\r\n\r\n\t        if (options.reverse) {\r\n\t            items = items.slice(0).reverse();\r\n\t        }\r\n\r\n\t        var count = items.length;\r\n\r\n\t        for (var i = 0; i < count; i++) {\r\n\t            var item = items[i];\r\n\r\n\t            innerElement.append(new LegendItem(deepExtend({}, {\r\n\t                markers: options.markers,\r\n\t                labels: options.labels,\r\n\t                rtl: chartService.rtl\r\n\t            }, options.item, item)));\r\n\t        }\r\n\r\n\t        innerElement.render();\r\n\r\n\t        this.container.append(innerElement);\r\n\t    },\r\n\r\n\t    isVertical: function() {\r\n\t        var ref = this.options;\r\n\t        var orientation = ref.orientation;\r\n\t        var position = ref.position;\r\n\t        var vertical = (position === CUSTOM && orientation !== HORIZONTAL) ||\r\n\t               (defined(orientation) ? orientation !== HORIZONTAL : inArray(position, [ LEFT, RIGHT ]));\r\n\r\n\t        return vertical;\r\n\t    },\r\n\r\n\t    hasItems: function() {\r\n\t        return this.container.children[0].children.length > 0;\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var options = this.options;\r\n\t        var legendBox = targetBox.clone();\r\n\r\n\t        if (!this.hasItems()) {\r\n\t            this.box = legendBox;\r\n\t            return;\r\n\t        }\r\n\r\n\t        if (options.position === CUSTOM) {\r\n\t            this.containerCustomReflow(legendBox);\r\n\t            this.box = legendBox;\r\n\t        } else {\r\n\t            this.containerReflow(legendBox);\r\n\t        }\r\n\t    },\r\n\r\n\t    containerReflow: function(targetBox) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var container = ref.container;\r\n\t        var position = options.position;\r\n\t        var width = options.width;\r\n\t        var height = options.height;\r\n\t        var pos = position === TOP || position === BOTTOM ? X : Y;\r\n\t        var vertical = this.isVertical();\r\n\t        var alignTarget = targetBox.clone();\r\n\t        var containerBox = targetBox.clone();\r\n\r\n\t        if (position === LEFT || position === RIGHT) {\r\n\t            containerBox.y1 = alignTarget.y1 = 0;\r\n\t        }\r\n\r\n\t        if (vertical && height) {\r\n\t            containerBox.y2 = containerBox.y1 + height;\r\n\t            containerBox.align(alignTarget, Y, container.options.vAlign);\r\n\t        } else if (!vertical && width) {\r\n\t            containerBox.x2 = containerBox.x1 + width;\r\n\t            containerBox.align(alignTarget, X, container.options.align);\r\n\t        }\r\n\r\n\t        container.reflow(containerBox);\r\n\t        containerBox = container.box;\r\n\r\n\t        var box = containerBox.clone();\r\n\r\n\t        if (options.offsetX || options.offsetY) {\r\n\t            containerBox.translate(options.offsetX, options.offsetY);\r\n\t            this.container.reflow(containerBox);\r\n\t        }\r\n\r\n\t        box[pos + 1] = targetBox[pos + 1];\r\n\t        box[pos + 2] = targetBox[pos + 2];\r\n\r\n\t        this.box = box;\r\n\t    },\r\n\r\n\t    containerCustomReflow: function(targetBox) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var container = ref.container;\r\n\t        var offsetX = options.offsetX;\r\n\t        var offsetY = options.offsetY;\r\n\t        var width = options.width;\r\n\t        var height = options.height;\r\n\t        var vertical = this.isVertical();\r\n\t        var containerBox = targetBox.clone();\r\n\r\n\t        if (vertical && height) {\r\n\t            containerBox.y2 = containerBox.y1 + height;\r\n\t        } else if (!vertical && width) {\r\n\t            containerBox.x2 = containerBox.x1 + width;\r\n\t        }\r\n\t        container.reflow(containerBox);\r\n\t        containerBox = container.box;\r\n\r\n\t        container.reflow(new Box(\r\n\t            offsetX, offsetY,\r\n\t            offsetX + containerBox.width(), offsetY + containerBox.height()\r\n\t        ));\r\n\t    },\r\n\r\n\t    renderVisual: function() {\r\n\t        if (this.hasItems()) {\r\n\t            ChartElement.fn.renderVisual.call(this);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(Legend, {\r\n\t    position: RIGHT,\r\n\t    items: [],\r\n\t    offsetX: 0,\r\n\t    offsetY: 0,\r\n\t    margin: getSpacing(5),\r\n\t    padding: getSpacing(5),\r\n\t    border: {\r\n\t        color: BLACK,\r\n\t        width: 0\r\n\t    },\r\n\t    item: {\r\n\t        cursor: POINTER,\r\n\t        spacing: 6\r\n\t    },\r\n\t    spacing: 6,\r\n\t    background: \"\",\r\n\t    zIndex: 1,\r\n\t    markers: {\r\n\t        border: {\r\n\t            width: 0\r\n\t        },\r\n\t        width: 15,\r\n\t        height: 3,\r\n\t        type: \"rect\",\r\n\t        align: LEFT,\r\n\t        vAlign: CENTER\r\n\t    }\r\n\t});\r\n\r\n\tvar PlotAreaFactory = Class.extend({\r\n\t    init: function() {\r\n\r\n\t        this._registry = [];\r\n\t    },\r\n\r\n\t    register: function(type, seriesTypes) {\r\n\t        this._registry.push({\r\n\t            type: type,\r\n\t            seriesTypes: seriesTypes\r\n\t        });\r\n\t    },\r\n\r\n\t    create: function(srcSeries, options, chartService) {\r\n\t        var registry = this._registry;\r\n\t        var match = registry[0];\r\n\t        var series;\r\n\r\n\t        for (var idx = 0; idx < registry.length; idx++) {\r\n\t            var entry = registry[idx];\r\n\t            series = filterSeriesByType(srcSeries, entry.seriesTypes);\r\n\r\n\t            if (series.length > 0) {\r\n\t                match = entry;\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        return new match.type(series, options, chartService);\r\n\t    }\r\n\t});\r\n\r\n\tPlotAreaFactory.current = new PlotAreaFactory();\r\n\r\n\tvar ZOOM_ACCELERATION = 3;\r\n\tvar SELECTOR_HEIGHT_ADJUST = 0.1;\r\n\r\n\tfunction createDiv(className) {\r\n\t    var element = document.createElement(\"div\");\r\n\t    if (className) {\r\n\t        element.className = className;\r\n\t    }\r\n\r\n\t    return element;\r\n\t}\r\n\r\n\tfunction closestHandle(element) {\r\n\t    var current = element;\r\n\t    while (current && !hasClasses(current, \"k-handle\")) {\r\n\t        current = current.parentNode;\r\n\t    }\r\n\r\n\t    return current;\r\n\t}\r\n\r\n\tvar Selection = Class.extend({\r\n\t    init: function(chart, categoryAxis, options, observer) {\r\n\r\n\t        var chartElement = chart.element;\r\n\r\n\t        this.options = deepExtend({}, this.options, options);\r\n\t        this.chart = chart;\r\n\t        this.observer = observer;\r\n\t        this.chartElement = chartElement;\r\n\t        this.categoryAxis = categoryAxis;\r\n\t        this._dateAxis = this.categoryAxis instanceof DateCategoryAxis;\r\n\r\n\t        this.initOptions();\r\n\r\n\t        if (this.options.visible) {\r\n\t            this.createElements();\r\n\r\n\t            this.set(this._index(this.options.from), this._index(this.options.to));\r\n\r\n\t            this.bindEvents();\r\n\t        }\r\n\t    },\r\n\r\n\t    createElements: function() {\r\n\t        var options = this.options;\r\n\t        var wrapper = this.wrapper = createDiv(\"k-selector\");\r\n\t        elementStyles(wrapper, {\r\n\t            top: options.offset.top,\r\n\t            left: options.offset.left,\r\n\t            width: options.width,\r\n\t            height: options.height,\r\n\t            direction: 'ltr'\r\n\t        });\r\n\t        var selection = this.selection = createDiv(\"k-selection\");\r\n\t        this.leftMask = createDiv(\"k-mask\");\r\n\t        this.rightMask = createDiv(\"k-mask\");\r\n\r\n\t        wrapper.appendChild(this.leftMask);\r\n\t        wrapper.appendChild(this.rightMask);\r\n\t        wrapper.appendChild(selection);\r\n\r\n\t        selection.appendChild(createDiv(\"k-selection-bg\"));\r\n\r\n\t        var leftHandle = this.leftHandle = createDiv(\"k-handle k-left-handle\");\r\n\t        var rightHandle = this.rightHandle = createDiv(\"k-handle k-right-handle\");\r\n\t        leftHandle.appendChild(createDiv());\r\n\t        rightHandle.appendChild(createDiv());\r\n\r\n\t        selection.appendChild(leftHandle);\r\n\t        selection.appendChild(rightHandle);\r\n\r\n\t        this.chartElement.appendChild(wrapper);\r\n\t        var selectionStyles = elementStyles(selection, [ \"borderLeftWidth\", \"borderRightWidth\", \"height\" ]);\r\n\t        var leftHandleHeight = elementStyles(leftHandle, \"height\").height;\r\n\t        var rightHandleHeight = elementStyles(rightHandle, \"height\").height;\r\n\r\n\t        options.selection = {\r\n\t            border: {\r\n\t                left: selectionStyles.borderLeftWidth,\r\n\t                right: selectionStyles.borderRightWidth\r\n\t            }\r\n\t        };\r\n\r\n\t        elementStyles(leftHandle, {\r\n\t            top: (selectionStyles.height - leftHandleHeight) / 2\r\n\t        });\r\n\r\n\t        elementStyles(rightHandle, {\r\n\t            top: (selectionStyles.height - rightHandleHeight) / 2\r\n\t        });\r\n\r\n\t        wrapper.style.cssText = wrapper.style.cssText;\r\n\t    },\r\n\r\n\t    bindEvents: function() {\r\n\t        this._mousewheelHandler = this.options.mousewheel !== false ? this._mousewheel.bind(this) : stopPropagation;\r\n\r\n\t        var obj;\r\n\t        bindEvents(this.wrapper, ( obj = {}, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj ));\r\n\r\n\t        this._domEvents = services.DomEventsBuilder.create(this.wrapper, {\r\n\t            start: this._start.bind(this),\r\n\t            move: this._move.bind(this),\r\n\t            end: this._end.bind(this),\r\n\t            tap: this._tap.bind(this),\r\n\t            press: this._press.bind(this),\r\n\t            gesturestart: this._gesturestart.bind(this),\r\n\t            gesturechange: this._gesturechange.bind(this),\r\n\t            gestureend: this._gestureend.bind(this)\r\n\t        });\r\n\t    },\r\n\r\n\t    initOptions: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var categoryAxis = ref.categoryAxis;\r\n\t        var box = categoryAxis.pane.chartsBox();\r\n\t        var intlService = this.chart.chartService.intl;\r\n\r\n\t        if (this._dateAxis) {\r\n\t            deepExtend(options, {\r\n\t                min: parseDate(intlService, options.min),\r\n\t                max: parseDate(intlService, options.max),\r\n\t                from: parseDate(intlService, options.from),\r\n\t                to: parseDate(intlService, options.to)\r\n\t            });\r\n\t        }\r\n\r\n\t        var ref$1 = elementStyles(this.chartElement, [ \"paddingLeft\", \"paddingTop\" ]);\r\n\t        var paddingLeft = ref$1.paddingLeft;\r\n\t        var paddingTop = ref$1.paddingTop;\r\n\r\n\t        this.options = deepExtend({}, {\r\n\t            width: box.width(),\r\n\t            height: box.height() + SELECTOR_HEIGHT_ADJUST, //workaround for sub-pixel hover on the paths in chrome\r\n\t            padding: {\r\n\t                left: paddingLeft,\r\n\t                top: paddingTop\r\n\t            },\r\n\t            offset: {\r\n\t                left: box.x1 + paddingLeft,\r\n\t                top: box.y1 + paddingTop\r\n\t            },\r\n\t            from: options.min,\r\n\t            to: options.max\r\n\t        }, options);\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        if (this._domEvents) {\r\n\t            this._domEvents.destroy();\r\n\t            delete this._domEvents;\r\n\t        }\r\n\r\n\t        clearTimeout(this._mwTimeout);\r\n\t        this._state = null;\r\n\r\n\t        if (this.wrapper) {\r\n\t            var obj;\r\n\t            unbindEvents(this.wrapper, ( obj = {}, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj ));\r\n\t            this.chartElement.removeChild(this.wrapper);\r\n\t        }\r\n\t    },\r\n\r\n\t    _rangeEventArgs: function(range) {\r\n\r\n\t        return {\r\n\t            axis: this.categoryAxis.options,\r\n\t            from: this._value(range.from),\r\n\t            to: this._value(range.to)\r\n\t        };\r\n\t    },\r\n\r\n\t    _start: function(e) {\r\n\t        var options = this.options;\r\n\t        var target = eventElement(e);\r\n\r\n\t        if (this._state || !target) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        this.chart._unsetActivePoint();\r\n\t        this._state = {\r\n\t            moveTarget: closestHandle(target) || target,\r\n\t            startLocation: e.x ? e.x.location : 0,\r\n\t            range: {\r\n\t                from: this._index(options.from),\r\n\t                to: this._index(options.to)\r\n\t            }\r\n\t        };\r\n\r\n\t        var args = this._rangeEventArgs({\r\n\t            from: this._index(options.from),\r\n\t            to: this._index(options.to)\r\n\t        });\r\n\r\n\t        if (this.trigger(SELECT_START, args)) {\r\n\t            this._state = null;\r\n\t        }\r\n\t    },\r\n\r\n\t    _press: function(e) {\r\n\t        var handle;\r\n\t        if (this._state) {\r\n\t            handle = this._state.moveTarget;\r\n\t        } else {\r\n\t            handle = closestHandle(eventElement(e));\r\n\t        }\r\n\t        if (handle) {\r\n\t            dataviz.addClass(handle, \"k-handle-active\");\r\n\t        }\r\n\t    },\r\n\r\n\t    _move: function(e) {\r\n\t        if (!this._state) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var ref = this;\r\n\t        var state = ref._state;\r\n\t        var options = ref.options;\r\n\t        var axisOptions = ref.categoryAxis.options;\r\n\t        var range = state.range;\r\n\t        var target = state.moveTarget;\r\n\t        var reverse = axisOptions.reverse;\r\n\t        var from = this._index(options.from);\r\n\t        var to = this._index(options.to);\r\n\t        var min = this._index(options.min);\r\n\t        var max = this._index(options.max);\r\n\t        var delta = state.startLocation - e.x.location;\r\n\t        var oldRange = { from: range.from, to: range.to };\r\n\t        var span = range.to - range.from;\r\n\t        var scale = elementStyles(this.wrapper, \"width\").width / (axisOptions.categories.length - 1);\r\n\t        var offset = Math.round(delta / scale) * (reverse ? -1 : 1);\r\n\r\n\t        if (!target) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var leftHandle = hasClasses(target, \"k-left-handle\");\r\n\t        var rightHandle = hasClasses(target, \"k-right-handle\");\r\n\r\n\t        if (hasClasses(target, \"k-selection k-selection-bg\")) {\r\n\t            range.from = Math.min(\r\n\t                Math.max(min, from - offset),\r\n\t                max - span\r\n\t            );\r\n\t            range.to = Math.min(\r\n\t                range.from + span,\r\n\t                max\r\n\t            );\r\n\t        } else if ((leftHandle && !reverse) || (rightHandle && reverse)) {\r\n\t            range.from = Math.min(\r\n\t                Math.max(min, from - offset),\r\n\t                max - 1\r\n\t            );\r\n\t            range.to = Math.max(range.from + 1, range.to);\r\n\t        } else if ((leftHandle && reverse) || (rightHandle && !reverse)) {\r\n\t            range.to = Math.min(\r\n\t                Math.max(min + 1, to - offset),\r\n\t                max\r\n\t            );\r\n\t            range.from = Math.min(range.to - 1, range.from);\r\n\t        }\r\n\r\n\t        if (range.from !== oldRange.from || range.to !== oldRange.to) {\r\n\t            this.move(range.from, range.to);\r\n\t            this.trigger(SELECT, this._rangeEventArgs(range));\r\n\t        }\r\n\t    },\r\n\r\n\t    _end: function() {\r\n\t        if (this._state) {\r\n\t            var moveTarget = this._state.moveTarget;\r\n\t            if (moveTarget) {\r\n\t                dataviz.removeClass(moveTarget, \"k-handle-active\");\r\n\t            }\r\n\r\n\t            var range = this._state.range;\r\n\t            this.set(range.from, range.to);\r\n\t            this.trigger(SELECT_END, this._rangeEventArgs(range));\r\n\r\n\t            delete this._state;\r\n\t        }\r\n\t    },\r\n\r\n\t    _tap: function(e) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var categoryAxis = ref.categoryAxis;\r\n\t        var coords = this.chart._eventCoordinates(e);\r\n\t        var categoryIx = categoryAxis.pointCategoryIndex(new Point(coords.x, categoryAxis.box.y1));\r\n\t        var from = this._index(options.from);\r\n\t        var to = this._index(options.to);\r\n\t        var min = this._index(options.min);\r\n\t        var max = this._index(options.max);\r\n\t        var span = to - from;\r\n\t        var mid = from + span / 2;\r\n\t        var range = {};\r\n\t        var rightClick = e.event.which === 3;\r\n\t        var offset = Math.round(mid - categoryIx);\r\n\r\n\t        if (this._state || rightClick) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        this.chart._unsetActivePoint();\r\n\r\n\t        if (!categoryAxis.options.justified) {\r\n\t            offset--;\r\n\t        }\r\n\r\n\t        range.from = Math.min(\r\n\t            Math.max(min, from - offset),\r\n\t            max - span\r\n\t        );\r\n\r\n\t        range.to = Math.min(range.from + span, max);\r\n\r\n\t        this._start(e);\r\n\t        if (this._state) {\r\n\t            this._state.range = range;\r\n\t            this.trigger(SELECT, this._rangeEventArgs(range));\r\n\t            this._end();\r\n\t        }\r\n\t    },\r\n\r\n\t    _mousewheel: function(e) {\r\n\t        var this$1 = this;\r\n\r\n\t        var delta = dataviz.mousewheelDelta(e);\r\n\r\n\t        this._start({ target: this.selection });\r\n\r\n\t        if (this._state) {\r\n\t            var range = this._state.range;\r\n\r\n\t            e.preventDefault();\r\n\t            e.stopPropagation();\r\n\r\n\t            if (Math.abs(delta) > 1) {\r\n\t                delta *= ZOOM_ACCELERATION;\r\n\t            }\r\n\r\n\t            if (this.options.mousewheel.reverse) {\r\n\t                delta *= -1;\r\n\t            }\r\n\r\n\t            if (this.expand(delta)) {\r\n\t                this.trigger(SELECT, {\r\n\t                    axis: this.categoryAxis.options,\r\n\t                    delta: delta,\r\n\t                    originalEvent: e,\r\n\t                    from: this._value(range.from),\r\n\t                    to: this._value(range.to)\r\n\t                });\r\n\t            }\r\n\r\n\t            if (this._mwTimeout) {\r\n\t                clearTimeout(this._mwTimeout);\r\n\t            }\r\n\r\n\t            this._mwTimeout = setTimeout(function () {\r\n\t                this$1._end();\r\n\t            }, MOUSEWHEEL_DELAY);\r\n\t        }\r\n\t    },\r\n\r\n\t    _gesturestart: function(e) {\r\n\t        var options = this.options;\r\n\r\n\t        this._state = {\r\n\t            range: {\r\n\t                from: this._index(options.from),\r\n\t                to: this._index(options.to)\r\n\t            }\r\n\t        };\r\n\t        var args = this._rangeEventArgs(this._state.range);\r\n\r\n\t        if (this.trigger(SELECT_START, args)) {\r\n\t            this._state = null;\r\n\t        } else {\r\n\t            e.preventDefault();\r\n\t        }\r\n\t    },\r\n\r\n\t    _gestureend: function() {\r\n\t        if (this._state) {\r\n\t            this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));\r\n\t            delete this._state;\r\n\t        }\r\n\t    },\r\n\r\n\t    _gesturechange: function(e) {\r\n\t        var ref = this;\r\n\t        var chart = ref.chart;\r\n\t        var state = ref._state;\r\n\t        var options = ref.options;\r\n\t        var categoryAxis = ref.categoryAxis;\r\n\t        var range = state.range;\r\n\t        var p0 = chart._toModelCoordinates(e.touches[0].x.location).x;\r\n\t        var p1 = chart._toModelCoordinates(e.touches[1].x.location).x;\r\n\t        var left = Math.min(p0, p1);\r\n\t        var right = Math.max(p0, p1);\r\n\r\n\t        e.preventDefault();\r\n\r\n\t        range.from = categoryAxis.pointCategoryIndex(new Point(left)) || options.min;\r\n\r\n\t        range.to = categoryAxis.pointCategoryIndex(new Point(right)) || options.max;\r\n\r\n\t        this.move(range.from, range.to);\r\n\r\n\t        this.trigger(SELECT, this._rangeEventArgs(range));\r\n\t    },\r\n\r\n\t    _index: function(value) {\r\n\t        var index = value;\r\n\r\n\t        if (value instanceof Date) {\r\n\t            index = this.categoryAxis.categoryIndex(value);\r\n\t        }\r\n\r\n\t        return index;\r\n\t    },\r\n\r\n\t    _value: function(index) {\r\n\t        var categories = this.categoryAxis.options.categories;\r\n\t        var value = index;\r\n\r\n\t        if (this._dateAxis) {\r\n\t            if (index > categories.length - 1) {\r\n\t                value = this.options.max;\r\n\t            } else {\r\n\t                value = categories[Math.ceil(index)];\r\n\t            }\r\n\t        }\r\n\r\n\t        return value;\r\n\t    },\r\n\r\n\t    _slot: function(value) {\r\n\t        var categoryAxis = this.categoryAxis;\r\n\t        var index = this._index(value);\r\n\r\n\t        return categoryAxis.getSlot(index, index, true);\r\n\t    },\r\n\r\n\t    move: function(from, to) {\r\n\t        var options = this.options;\r\n\t        var reverse = this.categoryAxis.options.reverse;\r\n\t        var offset = options.offset;\r\n\t        var padding = options.padding;\r\n\t        var border = options.selection.border;\r\n\t        var left = reverse ? to : from;\r\n\t        var right = reverse ? from : to;\r\n\t        var edge = 'x' + (reverse ? 2 : 1);\r\n\r\n\t        var box = this._slot(left);\r\n\t        var leftMaskWidth = round(box[edge] - offset.left + padding.left);\r\n\r\n\t        elementStyles(this.leftMask, {\r\n\t            width: leftMaskWidth\r\n\t        });\r\n\t        elementStyles(this.selection, {\r\n\t            left: leftMaskWidth\r\n\t        });\r\n\r\n\t        box = this._slot(right);\r\n\r\n\t        var rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));\r\n\t        elementStyles(this.rightMask, {\r\n\t            width: rightMaskWidth\r\n\t        });\r\n\r\n\t        var distance = options.width - rightMaskWidth;\r\n\t        if (distance !== options.width) {\r\n\t            distance += border.right;\r\n\t        }\r\n\r\n\t        elementStyles(this.rightMask, {\r\n\t            left: distance\r\n\t        });\r\n\t        elementStyles(this.selection, {\r\n\t            width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)\r\n\t        });\r\n\t    },\r\n\r\n\t    set: function(from, to) {\r\n\t        var options = this.options;\r\n\t        var min = this._index(options.min);\r\n\t        var max = this._index(options.max);\r\n\t        var fromValue = limitValue(this._index(from), min, max);\r\n\t        var toValue = limitValue(this._index(to), fromValue + 1, max);\r\n\r\n\t        if (options.visible) {\r\n\t            this.move(fromValue, toValue);\r\n\t        }\r\n\r\n\t        options.from = this._value(fromValue);\r\n\t        options.to = this._value(toValue);\r\n\t    },\r\n\r\n\t    expand: function(delta) {\r\n\t        var options = this.options;\r\n\t        var min = this._index(options.min);\r\n\t        var max = this._index(options.max);\r\n\t        var zDir = options.mousewheel.zoom;\r\n\t        var from = this._index(options.from);\r\n\t        var to = this._index(options.to);\r\n\t        var range = { from: from, to: to };\r\n\t        var oldRange = deepExtend({}, range);\r\n\r\n\t        if (this._state) {\r\n\t            range = this._state.range;\r\n\t        }\r\n\r\n\t        if (zDir !== RIGHT) {\r\n\t            range.from = limitValue(\r\n\t                limitValue(from - delta, 0, to - 1),\r\n\t                min, max\r\n\t            );\r\n\t        }\r\n\r\n\t        if (zDir !== LEFT) {\r\n\t            range.to = limitValue(\r\n\t                limitValue(to + delta, range.from + 1, max),\r\n\t                min,\r\n\t                max\r\n\t             );\r\n\t        }\r\n\r\n\t        if (range.from !== oldRange.from || range.to !== oldRange.to) {\r\n\t            this.set(range.from, range.to);\r\n\t            return true;\r\n\t        }\r\n\t    },\r\n\r\n\t    trigger: function(name, args) {\r\n\t        return (this.observer || this.chart).trigger(name, args);\r\n\t    }\r\n\t});\r\n\r\n\tfunction stopPropagation(e) {\r\n\t    e.stopPropagation();\r\n\t}\r\n\r\n\tsetDefaultOptions(Selection, {\r\n\t    visible: true,\r\n\t    mousewheel: {\r\n\t        zoom: \"both\"\r\n\t    },\r\n\t    min: MIN_VALUE,\r\n\t    max: MAX_VALUE\r\n\t});\r\n\r\n\tvar Tooltip = BaseTooltip.extend({\r\n\t    show: function(point) {\r\n\t        if (!point || !point.tooltipAnchor || (this._current && this._current === point)) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var options = deepExtend({}, this.options, point.options.tooltip);\r\n\t        var anchor = point.tooltipAnchor();\r\n\r\n\t        if (anchor) {\r\n\t            this._current = point;\r\n\t            BaseTooltip.fn.show.call(this, {\r\n\t                point: point,\r\n\t                anchor: anchor\r\n\t            }, options, point);\r\n\t        } else {\r\n\t            this.hide();\r\n\t        }\r\n\t    },\r\n\r\n\t    hide: function() {\r\n\t        delete this._current;\r\n\t        BaseTooltip.fn.hide.call(this);\r\n\t    }\r\n\t});\r\n\r\n\tvar SharedTooltip = BaseTooltip.extend({\r\n\t    init: function(plotArea, options) {\r\n\t        BaseTooltip.fn.init.call(this, plotArea.chartService, options);\r\n\r\n\t        this.plotArea = plotArea;\r\n\t        this.formatService = plotArea.chartService.format;\r\n\t    },\r\n\r\n\t    showAt: function(points, coords) {\r\n\t        var tooltipPoints = grep(points, function(point) {\r\n\t            var tooltip = point.series.tooltip;\r\n\t            var excluded = tooltip && tooltip.visible === false;\r\n\r\n\t            return !excluded;\r\n\t        });\r\n\r\n\t        if (tooltipPoints.length > 0) {\r\n\t            var point = tooltipPoints[0];\r\n\t            var slot = this.plotArea.categoryAxis.getSlot(point.categoryIx);\r\n\r\n\t            var anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point, slot);\r\n\r\n\t            this.show({\r\n\t                anchor: anchor,\r\n\t                shared: true,\r\n\t                points: points,\r\n\t                category: point.category,\r\n\t                categoryText: this.formatService.auto(this.options.categoryFormat, point.category),\r\n\t                series: this.plotArea.series\r\n\t            }, this.options);\r\n\t        }\r\n\t    },\r\n\r\n\t    _slotAnchor: function(point, slot) {\r\n\t        var axis = this.plotArea.categoryAxis;\r\n\t        var align = {\r\n\t            horizontal: \"left\",\r\n\t            vertical: \"center\"\r\n\t        };\r\n\r\n\t        if (!axis.options.vertical) {\r\n\t            point.x = slot.center().x;\r\n\t        }\r\n\r\n\t        return {\r\n\t            point: point,\r\n\t            align: align\r\n\t        };\r\n\t    },\r\n\r\n\t    _defaultAnchor: function(point, slot) {\r\n\t        var box = point.owner.pane.chartsBox();\r\n\t        var vertical = this.plotArea.categoryAxis.options.vertical;\r\n\t        var center = box.center();\r\n\t        var slotCenter = slot.center();\r\n\t        var align = {\r\n\t            horizontal: \"center\",\r\n\t            vertical: \"center\"\r\n\t        };\r\n\r\n\t        var centerPoint;\r\n\t        if (vertical) {\r\n\t            centerPoint = new Point(center.x, slotCenter.y);\r\n\t        } else {\r\n\t            centerPoint = new Point(slotCenter.x, center.y);\r\n\t        }\r\n\r\n\t        return {\r\n\t            point: centerPoint,\r\n\t            align: align\r\n\t        };\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(SharedTooltip, {\r\n\t    categoryFormat: '{0:d}'\r\n\t});\r\n\r\n\tvar BarChartAnimation = Animation.extend({\r\n\t    setup: function() {\r\n\t        var ref = this;\r\n\t        var element = ref.element;\r\n\t        var options = ref.options;\r\n\t        var bbox = element.bbox();\r\n\r\n\t        if (bbox) {\r\n\t            this.origin = options.origin;\r\n\t            var axis = options.vertical ? Y : X;\r\n\r\n\t            var fromScale = this.fromScale = new GeometryPoint(1, 1);\r\n\t            fromScale[axis] = START_SCALE;\r\n\r\n\t            element.transform(transform()\r\n\t                .scale(fromScale.x, fromScale.y)\r\n\t            );\r\n\t        } else {\r\n\t            this.abort();\r\n\t        }\r\n\t    },\r\n\r\n\t    step: function(pos) {\r\n\t        var scaleX = dataviz.interpolateValue(this.fromScale.x, 1, pos);\r\n\t        var scaleY = dataviz.interpolateValue(this.fromScale.y, 1, pos);\r\n\r\n\t        this.element.transform(transform()\r\n\t            .scale(scaleX, scaleY, this.origin)\r\n\t        );\r\n\t    },\r\n\r\n\t    abort: function() {\r\n\t        Animation.fn.abort.call(this);\r\n\t        this.element.transform(null);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(BarChartAnimation, {\r\n\t    duration: INITIAL_ANIMATION_DURATION\r\n\t});\r\n\r\n\tAnimationFactory.current.register(BAR, BarChartAnimation);\r\n\r\n\tvar BubbleAnimation = Animation.extend({\r\n\t    setup: function() {\r\n\t        var center = this.center = this.element.bbox().center();\r\n\t        this.element.transform(transform()\r\n\t            .scale(START_SCALE, START_SCALE, center)\r\n\t        );\r\n\t    },\r\n\r\n\t    step: function(pos) {\r\n\t        this.element.transform(transform()\r\n\t            .scale(pos, pos, this.center)\r\n\t        );\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(BubbleAnimation, {\r\n\t    easing: \"easeOutElastic\"\r\n\t});\r\n\r\n\tAnimationFactory.current.register(BUBBLE, BubbleAnimation);\r\n\r\n\tvar FadeInAnimation = Animation.extend({\r\n\t    setup: function() {\r\n\t        this.fadeTo = this.element.opacity();\r\n\t        this.element.opacity(0);\r\n\t    },\r\n\r\n\t    step: function(pos) {\r\n\t        this.element.opacity(pos * this.fadeTo);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(FadeInAnimation, {\r\n\t    duration: 200,\r\n\t    easing: \"linear\"\r\n\t});\r\n\r\n\tAnimationFactory.current.register(FADEIN, FadeInAnimation);\r\n\r\n\tvar PieAnimation = Animation.extend({\r\n\t    setup: function() {\r\n\t        this.element.transform(transform()\r\n\t            .scale(START_SCALE, START_SCALE, this.options.center)\r\n\t        );\r\n\t    },\r\n\r\n\t    step: function(pos) {\r\n\t        this.element.transform(transform()\r\n\t            .scale(pos, pos, this.options.center)\r\n\t        );\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(PieAnimation, {\r\n\t    easing: \"easeOutElastic\",\r\n\t    duration: INITIAL_ANIMATION_DURATION\r\n\t});\r\n\r\n\tAnimationFactory.current.register(PIE, PieAnimation);\r\n\r\n\tvar ScatterLineChart = ScatterChart.extend({\r\n\t    render: function() {\r\n\t        ScatterChart.fn.render.call(this);\r\n\r\n\t        this.renderSegments();\r\n\t    },\r\n\r\n\t    createSegment: function(linePoints, currentSeries, seriesIx) {\r\n\t        var style = currentSeries.style;\r\n\t        var pointType;\r\n\r\n\t        if (style === SMOOTH) {\r\n\t            pointType = SplineSegment;\r\n\t        } else {\r\n\t            pointType = LineSegment;\r\n\t        }\r\n\r\n\t        return new pointType(linePoints, currentSeries, seriesIx);\r\n\t    },\r\n\r\n\t    animationPoints: function() {\r\n\t        var points = ScatterChart.fn.animationPoints.call(this);\r\n\t        return points.concat(this._segments);\r\n\t    },\r\n\r\n\t    createMissingValue: function(value, missingValues) {\r\n\t        if (missingValues === ZERO) {\r\n\t            var missingValue = {\r\n\t                x: value.x,\r\n\t                y: value.y\r\n\t            };\r\n\t            if (!hasValue(missingValue.x)) {\r\n\t                missingValue.x = 0;\r\n\t            }\r\n\t            if (!hasValue(missingValue.y)) {\r\n\t                missingValue.y = 0;\r\n\t            }\r\n\t            return missingValue;\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(ScatterLineChart.prototype, LineChartMixin);\r\n\r\n\tvar XYPlotArea = PlotAreaBase.extend({\r\n\t    initFields: function() {\r\n\t        this.namedXAxes = {};\r\n\t        this.namedYAxes = {};\r\n\r\n\t        this.xAxisRangeTracker = new AxisGroupRangeTracker();\r\n\t        this.yAxisRangeTracker = new AxisGroupRangeTracker();\r\n\t    },\r\n\r\n\t    render: function(panes) {\r\n\t        var this$1 = this;\r\n\t        if (panes === void 0) { panes = this.panes; }\r\n\r\n\t        var seriesByPane = this.groupSeriesByPane();\r\n\r\n\t        for (var i = 0; i < panes.length; i++) {\r\n\t            var pane = panes[i];\r\n\t            var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\r\n\t            this$1.addToLegend(paneSeries);\r\n\t            var filteredSeries = this$1.filterVisibleSeries(paneSeries);\r\n\r\n\t            if (!filteredSeries) {\r\n\t                continue;\r\n\t            }\r\n\r\n\t            this$1.createScatterChart(\r\n\t                filterSeriesByType(filteredSeries, SCATTER),\r\n\t                pane\r\n\t            );\r\n\r\n\t            this$1.createScatterLineChart(\r\n\t                filterSeriesByType(filteredSeries, SCATTER_LINE),\r\n\t                pane\r\n\t            );\r\n\r\n\t            this$1.createBubbleChart(\r\n\t                filterSeriesByType(filteredSeries, BUBBLE),\r\n\t                pane\r\n\t            );\r\n\t        }\r\n\r\n\t        this.createAxes(panes);\r\n\t    },\r\n\r\n\t    appendChart: function(chart, pane) {\r\n\t        this.xAxisRangeTracker.update(chart.xAxisRanges);\r\n\t        this.yAxisRangeTracker.update(chart.yAxisRanges);\r\n\r\n\t        PlotAreaBase.fn.appendChart.call(this, chart, pane);\r\n\t    },\r\n\r\n\t    removeAxis: function(axis) {\r\n\t        var axisName = axis.options.name;\r\n\r\n\t        PlotAreaBase.fn.removeAxis.call(this, axis);\r\n\r\n\t        if (axis.options.vertical) {\r\n\t            this.yAxisRangeTracker.reset(axisName);\r\n\t            delete this.namedYAxes[axisName];\r\n\t        } else {\r\n\t            this.xAxisRangeTracker.reset(axisName);\r\n\t            delete this.namedXAxes[axisName];\r\n\t        }\r\n\r\n\t        if (axis === this.axisX) {\r\n\t            delete this.axisX;\r\n\t        }\r\n\r\n\t        if (axis === this.axisY) {\r\n\t            delete this.axisY;\r\n\t        }\r\n\t    },\r\n\r\n\t    seriesPaneName: function(series) {\r\n\t        var options = this.options;\r\n\t        var xAxisName = series.xAxis;\r\n\t        var xAxisOptions = [].concat(options.xAxis);\r\n\t        var xAxis = grep(xAxisOptions, function(a) { return a.name === xAxisName; })[0];\r\n\t        var yAxisName = series.yAxis;\r\n\t        var yAxisOptions = [].concat(options.yAxis);\r\n\t        var yAxis = grep(yAxisOptions, function(a) { return a.name === yAxisName; })[0];\r\n\t        var panes = options.panes || [ {} ];\r\n\t        var defaultPaneName = panes[0].name || \"default\";\r\n\t        var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\r\n\r\n\t        return paneName;\r\n\t    },\r\n\r\n\t    createScatterChart: function(series, pane) {\r\n\t        if (series.length > 0) {\r\n\t            this.appendChart(\r\n\t                new ScatterChart(this, { series: series, clip: pane.options.clip }),\r\n\t                pane\r\n\t            );\r\n\t        }\r\n\t    },\r\n\r\n\t    createScatterLineChart: function(series, pane) {\r\n\t        if (series.length > 0) {\r\n\t            this.appendChart(\r\n\t                new ScatterLineChart(this, { series: series, clip: pane.options.clip }),\r\n\t                pane\r\n\t            );\r\n\t        }\r\n\t    },\r\n\r\n\t    createBubbleChart: function(series, pane) {\r\n\t        if (series.length > 0) {\r\n\t            this.appendChart(\r\n\t                new BubbleChart(this, { series: series, clip: pane.options.clip }),\r\n\t                pane\r\n\t            );\r\n\t        }\r\n\t    },\r\n\r\n\t    createXYAxis: function(options, vertical, axisIndex) {\r\n\t        var axisName = options.name;\r\n\t        var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\r\n\t        var tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;\r\n\t        var axisOptions = deepExtend({ reverse: !vertical && this.chartService.rtl }, options, { vertical: vertical });\r\n\t        var isLog = equalsIgnoreCase(axisOptions.type, LOGARITHMIC);\r\n\t        var defaultRange = tracker.query();\r\n\t        var defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };\r\n\t        var range = tracker.query(axisName) || defaultRange || defaultAxisRange;\r\n\t        var typeSamples = [ axisOptions.min, axisOptions.max ];\r\n\t        var series = this.series;\r\n\r\n\t        for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\r\n\t            var currentSeries = series[seriesIx];\r\n\t            var seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\r\n\t            if ((seriesAxisName === axisOptions.name) || (axisIndex === 0 && !seriesAxisName)) {\r\n\t                var firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\r\n\t                typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\r\n\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        if (axisIndex === 0 && defaultRange) {\r\n\t            range.min = Math.min(range.min, defaultRange.min);\r\n\t            range.max = Math.max(range.max, defaultRange.max);\r\n\t        }\r\n\r\n\t        var inferredDate;\r\n\r\n\t        for (var i = 0; i < typeSamples.length; i++) {\r\n\t            if (typeSamples[i] instanceof Date) {\r\n\t                inferredDate = true;\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        var axisType;\r\n\t        if (equalsIgnoreCase(axisOptions.type, DATE) || (!axisOptions.type && inferredDate)) {\r\n\t            axisType = dataviz.DateValueAxis;\r\n\t        } else if (isLog) {\r\n\t            axisType = dataviz.LogarithmicAxis;\r\n\t        } else {\r\n\t            axisType = dataviz.NumericAxis;\r\n\t        }\r\n\r\n\t        var axis = new axisType(range.min, range.max, axisOptions, this.chartService);\r\n\t        axis.axisIndex = axisIndex;\r\n\r\n\t        if (axisName) {\r\n\t            if (namedAxes[axisName]) {\r\n\t                throw new Error(((vertical ? \"Y\" : \"X\") + \" axis with name \" + axisName + \" is already defined\"));\r\n\t            }\r\n\t            namedAxes[axisName] = axis;\r\n\t        }\r\n\r\n\t        this.appendAxis(axis);\r\n\r\n\t        return axis;\r\n\t    },\r\n\r\n\t    createAxes: function(panes) {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var xAxesOptions = [].concat(options.xAxis);\r\n\t        var xAxes = [];\r\n\t        var yAxesOptions = [].concat(options.yAxis);\r\n\t        var yAxes = [];\r\n\r\n\t        for (var idx = 0; idx < xAxesOptions.length; idx++) {\r\n\t            var axisPane = this$1.findPane(xAxesOptions[idx].pane);\r\n\t            if (inArray(axisPane, panes)) {\r\n\t                xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));\r\n\t            }\r\n\t        }\r\n\r\n\t        for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {\r\n\t            var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);\r\n\t            if (inArray(axisPane$1, panes)) {\r\n\t                yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));\r\n\t            }\r\n\t        }\r\n\r\n\t        this.axisX = this.axisX || xAxes[0];\r\n\t        this.axisY = this.axisY || yAxes[0];\r\n\t    },\r\n\r\n\t    _dispatchEvent: function(chart, e, eventType) {\r\n\t        var coords = chart._eventCoordinates(e);\r\n\t        var point = new Point(coords.x, coords.y);\r\n\t        var allAxes = this.axes;\r\n\t        var length = allAxes.length;\r\n\t        var xValues = [];\r\n\t        var yValues = [];\r\n\r\n\t        for (var i = 0; i < length; i++) {\r\n\t            var axis = allAxes[i];\r\n\t            var values = axis.options.vertical ? yValues : xValues;\r\n\t            var currentValue = axis.getValue(point);\r\n\t            if (currentValue !== null) {\r\n\t                values.push(currentValue);\r\n\t            }\r\n\t        }\r\n\r\n\t        if (xValues.length > 0 && yValues.length > 0) {\r\n\t            chart.trigger(eventType, {\r\n\t                element: eventElement(e),\r\n\t                originalEvent: e,\r\n\t                x: singleItemOrArray(xValues),\r\n\t                y: singleItemOrArray(yValues)\r\n\t            });\r\n\t        }\r\n\t    },\r\n\r\n\t    updateAxisOptions: function(axis, options) {\r\n\t        var vertical = axis.options.vertical;\r\n\t        var axes = this.groupAxes(this.panes);\r\n\t        var index = (vertical ? axes.y : axes.x).indexOf(axis);\r\n\r\n\t        updateAxisOptions$1(this.options, index, vertical, options);\r\n\t        updateAxisOptions$1(this.originalOptions, index, vertical, options);\r\n\t    }\r\n\t});\r\n\r\n\tfunction updateAxisOptions$1(targetOptions, axisIndex, vertical, options) {\r\n\t    var axisOptions = ([].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis))[axisIndex];\r\n\t    deepExtend(axisOptions, options);\r\n\t}\r\n\r\n\tsetDefaultOptions(XYPlotArea, {\r\n\t    xAxis: {},\r\n\t    yAxis: {}\r\n\t});\r\n\r\n\tdeepExtend(XYPlotArea.prototype, PlotAreaEventsMixin);\r\n\r\n\tvar PieSegment = ChartElement.extend({\r\n\t    init: function(value, sector, options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.value = value;\r\n\t        this.sector = sector;\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        var labels = this.options.labels;\r\n\t        var chartService = this.owner.chartService;\r\n\t        var labelText = this.value;\r\n\r\n\t        if (this._rendered || this.visible === false) {\r\n\t            return;\r\n\t        }\r\n\t        this._rendered = true;\r\n\r\n\t        var labelTemplate = getTemplate(labels);\r\n\t        if (labelTemplate) {\r\n\t            labelText = labelTemplate({\r\n\t                dataItem: this.dataItem,\r\n\t                category: this.category,\r\n\t                value: this.value,\r\n\t                series: this.series,\r\n\t                percentage: this.percentage\r\n\t            });\r\n\t        } else if (labels.format) {\r\n\t            labelText = chartService.format.auto(labels.format, labelText);\r\n\t        }\r\n\r\n\t        if (labels.visible && (labelText || labelText === 0)) {\r\n\t            if (labels.position === CENTER || labels.position === INSIDE_END) {\r\n\t                if (!labels.color) {\r\n\t                    var brightnessValue = new Color(this.options.color).percBrightness();\r\n\t                    if (brightnessValue > 180) {\r\n\t                        labels.color = BLACK;\r\n\t                    } else {\r\n\t                        labels.color = WHITE;\r\n\t                    }\r\n\t                }\r\n\t                if (!labels.background) {\r\n\t                    labels.background = this.options.color;\r\n\t                }\r\n\t            } else {\r\n\t                var themeLabels = chartService.theme.seriesDefaults.labels;\r\n\t                labels.color = labels.color || themeLabels.color;\r\n\t                labels.background = labels.background || themeLabels.background;\r\n\t            }\r\n\r\n\t            this.label = new TextBox(labelText, deepExtend({}, labels, {\r\n\t                align: CENTER,\r\n\t                vAlign: \"\",\r\n\t                animation: {\r\n\t                    type: FADEIN,\r\n\t                    delay: this.animationDelay\r\n\t                }\r\n\t            }));\r\n\r\n\t            this.append(this.label);\r\n\t        }\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        this.render();\r\n\t        this.box = targetBox;\r\n\t        this.reflowLabel();\r\n\t    },\r\n\r\n\t    reflowLabel: function() {\r\n\t        var ref = this;\r\n\t        var labelsOptions = ref.options.labels;\r\n\t        var label = ref.label;\r\n\t        var sector = this.sector.clone();\r\n\t        var labelsDistance = labelsOptions.distance;\r\n\t        var angle = sector.middle();\r\n\r\n\t        if (label) {\r\n\t            var labelHeight = label.box.height();\r\n\t            var labelWidth = label.box.width();\r\n\t            var lp;\r\n\r\n\t            if (labelsOptions.position === CENTER) {\r\n\t                sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;\r\n\t                lp = sector.point(angle);\r\n\t                label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\r\n\t            } else if (labelsOptions.position === INSIDE_END) {\r\n\t                sector.radius = sector.radius - labelHeight / 2;\r\n\t                lp = sector.point(angle);\r\n\t                label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\r\n\t            } else {\r\n\t                var x1;\r\n\t                lp = sector.clone().expand(labelsDistance).point(angle);\r\n\t                if (lp.x >= sector.center.x) {\r\n\t                    x1 = lp.x + labelWidth;\r\n\t                    label.orientation = RIGHT;\r\n\t                } else {\r\n\t                    x1 = lp.x - labelWidth;\r\n\t                    label.orientation = LEFT;\r\n\t                }\r\n\t                label.reflow(new Box(x1, lp.y - labelHeight, lp.x, lp.y));\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var sector = ref.sector;\r\n\t        var options = ref.options;\r\n\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\r\n\t        if (this.value) {\r\n\t            if (options.visual) {\r\n\t                var startAngle = (sector.startAngle + 180) % 360;\r\n\t                var visual = options.visual({\r\n\t                    category: this.category,\r\n\t                    dataItem: this.dataItem,\r\n\t                    value: this.value,\r\n\t                    series: this.series,\r\n\t                    percentage: this.percentage,\r\n\t                    center: new GeometryPoint(sector.center.x, sector.center.y),\r\n\t                    radius: sector.radius,\r\n\t                    innerRadius: sector.innerRadius,\r\n\t                    startAngle: startAngle,\r\n\t                    endAngle: startAngle + sector.angle,\r\n\t                    options: options,\r\n\t                    sender: this.getSender(),\r\n\t                    createVisual: function () {\r\n\t                        var group = new Group();\r\n\t                        this$1.createSegmentVisual(group);\r\n\r\n\t                        return group;\r\n\t                    }\r\n\t                });\r\n\r\n\t                if (visual) {\r\n\t                    this.visual.append(visual);\r\n\t                }\r\n\t            } else {\r\n\t                this.createSegmentVisual(this.visual);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createSegmentVisual: function(group) {\r\n\t        var ref = this;\r\n\t        var sector = ref.sector;\r\n\t        var options = ref.options;\r\n\t        var borderOptions = options.border || {};\r\n\t        var border = borderOptions.width > 0 ? {\r\n\t            stroke: {\r\n\t                color: borderOptions.color,\r\n\t                width: borderOptions.width,\r\n\t                opacity: borderOptions.opacity,\r\n\t                dashType: borderOptions.dashType\r\n\t            }\r\n\t        } : {};\r\n\t        var color = options.color;\r\n\t        var fill = {\r\n\t            color: color,\r\n\t            opacity: options.opacity\r\n\t        };\r\n\t        var visual = this.createSegment(sector, deepExtend({\r\n\t            fill: fill,\r\n\t            stroke: {\r\n\t                opacity: options.opacity\r\n\t            },\r\n\t            zIndex: options.zIndex\r\n\t        }, border));\r\n\r\n\t        group.append(visual);\r\n\r\n\t        if (hasGradientOverlay(options)) {\r\n\t            group.append(this.createGradientOverlay(visual, {\r\n\t                baseColor: color,\r\n\t                fallbackFill: fill\r\n\t            }, deepExtend({\r\n\t                center: [ sector.center.x, sector.center.y ],\r\n\t                innerRadius: sector.innerRadius,\r\n\t                radius: sector.radius,\r\n\t                userSpace: true\r\n\t            }, options.overlay)));\r\n\t        }\r\n\t    },\r\n\r\n\t    createSegment: function(sector, options) {\r\n\t        if (options.singleSegment) {\r\n\t            return new drawing.Circle(new geometry.Circle(new GeometryPoint(sector.center.x, sector.center.y), sector.radius), options);\r\n\t        }\r\n\r\n\t        return dataviz.ShapeBuilder.current.createRing(sector, options);\r\n\t    },\r\n\r\n\t    createAnimation: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var center = ref.sector.center;\r\n\r\n\t        deepExtend(options, {\r\n\t            animation: {\r\n\t                center: [ center.x, center.y ],\r\n\t                delay: this.animationDelay\r\n\t            }\r\n\t        });\r\n\r\n\t        ChartElement.fn.createAnimation.call(this);\r\n\t    },\r\n\r\n\t    createHighlight: function(options) {\r\n\t        var highlight = this.options.highlight || {};\r\n\t        var border = highlight.border || {};\r\n\r\n\t        return this.createSegment(this.sector, deepExtend({}, options, {\r\n\t            fill: {\r\n\t                color: highlight.color,\r\n\t                opacity: highlight.opacity\r\n\t            },\r\n\t            stroke: {\r\n\t                opacity: border.opacity,\r\n\t                width: border.width,\r\n\t                color: border.color\r\n\t            }\r\n\t        }));\r\n\t    },\r\n\r\n\t    highlightVisual: function() {\r\n\t        return this.visual.children[0];\r\n\t    },\r\n\r\n\t    highlightVisualArgs: function() {\r\n\t        var sector = this.sector;\r\n\r\n\t        return {\r\n\t            options: this.options,\r\n\t            radius: sector.radius,\r\n\t            innerRadius: sector.innerRadius,\r\n\t            center: new GeometryPoint(sector.center.x, sector.center.y),\r\n\t            startAngle: sector.startAngle,\r\n\t            endAngle: sector.angle + sector.startAngle,\r\n\t            visual: this.visual\r\n\t        };\r\n\t    },\r\n\r\n\t    tooltipAnchor: function() {\r\n\t        var sector = this.sector.clone().expand(TOOLTIP_OFFSET);\r\n\t        var midAndle = sector.middle();\r\n\t        var midPoint = sector.point(midAndle);\r\n\r\n\t        return {\r\n\t            point: midPoint,\r\n\t            align: tooltipAlignment(midAndle + 180)\r\n\t        };\r\n\t    },\r\n\r\n\t    formatValue: function(format) {\r\n\t        return this.owner.formatPointValue(this, format);\r\n\t    }\r\n\t});\r\n\r\n\tvar RAD_30 = round(dataviz.rad(30), DEFAULT_PRECISION);\r\n\tvar RAD_60 = round(dataviz.rad(60), DEFAULT_PRECISION);\r\n\r\n\tfunction tooltipAlignment(angle) {\r\n\t    var radians = dataviz.rad(angle);\r\n\t    var sine = round(Math.sin(radians), DEFAULT_PRECISION);\r\n\t    var cosine = round(Math.cos(radians), DEFAULT_PRECISION);\r\n\r\n\t    var horizontal;\r\n\t    if (Math.abs(sine) > RAD_60) {\r\n\t        horizontal = CENTER;\r\n\t    } else if (cosine < 0) {\r\n\t        horizontal = RIGHT;\r\n\t    } else {\r\n\t        horizontal = LEFT;\r\n\t    }\r\n\r\n\t    var vertical;\r\n\t    if (Math.abs(sine) < RAD_30) {\r\n\t        vertical = CENTER;\r\n\t    } else if (sine < 0) {\r\n\t        vertical = BOTTOM;\r\n\t    } else {\r\n\t        vertical = TOP;\r\n\t    }\r\n\r\n\t    return {\r\n\t        horizontal: horizontal,\r\n\t        vertical: vertical\r\n\t    };\r\n\t}\r\n\r\n\tsetDefaultOptions(PieSegment, {\r\n\t    color: WHITE,\r\n\t    overlay: {\r\n\t        gradient: \"roundedBevel\"\r\n\t    },\r\n\t    border: {\r\n\t        width: 0.5\r\n\t    },\r\n\t    labels: {\r\n\t        visible: false,\r\n\t        distance: 35,\r\n\t        font: datavizConstants.DEFAULT_FONT,\r\n\t        margin: getSpacing(0.5),\r\n\t        align: CIRCLE,\r\n\t        zIndex: 1,\r\n\t        position: OUTSIDE_END\r\n\t    },\r\n\t    animation: {\r\n\t        type: PIE\r\n\t    },\r\n\t    highlight: {\r\n\t        visible: true,\r\n\t        border: {\r\n\t            width: 1\r\n\t        }\r\n\t    },\r\n\t    visible: true\r\n\t});\r\n\r\n\tdeepExtend(PieSegment.prototype, PointEventsMixin);\r\n\r\n\tvar PieChartMixin = {\r\n\t    createLegendItem: function(value, point, options) {\r\n\t        var legendOptions = this.options.legend || {};\r\n\t        var labelsOptions = legendOptions.labels || {};\r\n\t        var inactiveItems = legendOptions.inactiveItems || {};\r\n\t        var inactiveItemsLabels = inactiveItems.labels || {};\r\n\r\n\t        if (options && options.visibleInLegend !== false) {\r\n\t            var pointVisible = options.visible !== false;\r\n\t            var labelTemplate = pointVisible ? getTemplate(labelsOptions) :\r\n\t                getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);\r\n\t            var text = options.category;\r\n\r\n\t            if (labelTemplate) {\r\n\t                text = labelTemplate({\r\n\t                    text: text,\r\n\t                    series: options.series,\r\n\t                    dataItem: options.dataItem,\r\n\t                    percentage: options.percentage,\r\n\t                    value: value\r\n\t                });\r\n\t            }\r\n\r\n\t            var itemLabelOptions, markerColor;\r\n\t            if (pointVisible) {\r\n\t                itemLabelOptions = {};\r\n\t                markerColor = point.color;\r\n\t            } else {\r\n\t                itemLabelOptions = {\r\n\t                    color: inactiveItemsLabels.color,\r\n\t                    font: inactiveItemsLabels.font\r\n\t                };\r\n\t                markerColor = (inactiveItems.markers || {}).color;\r\n\t            }\r\n\r\n\t            if (hasValue(text) && text !== \"\") {\r\n\t                this.legendItems.push({\r\n\t                    pointIndex: options.index,\r\n\t                    text: text,\r\n\t                    series: options.series,\r\n\t                    markerColor: markerColor,\r\n\t                    labels: itemLabelOptions\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t};\r\n\r\n\tvar PIE_SECTOR_ANIM_DELAY = 70;\r\n\r\n\tvar PieChart = ChartElement.extend({\r\n\t    init: function(plotArea, options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.plotArea = plotArea;\r\n\t        this.chartService = plotArea.chartService;\r\n\t        this.points = [];\r\n\t        this.legendItems = [];\r\n\t        this.render();\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        this.traverseDataPoints(this.addValue.bind(this));\r\n\t    },\r\n\r\n\t    traverseDataPoints: function(callback) {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var seriesColors = ref.plotArea.options.seriesColors; if (seriesColors === void 0) { seriesColors = []; }\r\n\t        var colorsCount = seriesColors.length;\r\n\t        var series = options.series;\r\n\t        var seriesCount = series.length;\r\n\r\n\t        for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\r\n\t            var currentSeries = series[seriesIx];\r\n\t            var data = currentSeries.data;\r\n\t            var ref$1 = bindSegments(currentSeries);\r\n\t            var total = ref$1.total;\r\n\t            var points = ref$1.points;\r\n\t            var count = ref$1.count;\r\n\t            var anglePerValue = 360 / total;\r\n\t            var constantAngle = (void 0);\r\n\t            if (!isFinite(anglePerValue)) {\r\n\t                constantAngle = 360 / count;\r\n\t            }\r\n\t            var currentAngle = (void 0);\r\n\r\n\t            if (defined(currentSeries.startAngle)) {\r\n\t                currentAngle = currentSeries.startAngle;\r\n\t            } else {\r\n\t                currentAngle = options.startAngle;\r\n\t            }\r\n\r\n\t            if (seriesIx !== seriesCount - 1) {\r\n\t                if (currentSeries.labels.position === OUTSIDE_END) {\r\n\t                    currentSeries.labels.position = CENTER;\r\n\t                }\r\n\t            }\r\n\r\n\t            for (var i = 0; i < points.length; i++) {\r\n\t                var pointData = points[i];\r\n\t                if (!pointData) {\r\n\t                    continue;\r\n\t                }\r\n\r\n\t                var fields = pointData.fields;\r\n\t                var value = pointData.value;\r\n\t                var visible = pointData.visible;\r\n\t                var angle = value !== 0 ? (constantAngle || (value * anglePerValue)) : 0;\r\n\t                var explode = data.length !== 1 && Boolean(fields.explode);\r\n\r\n\t                if (!isFunction(currentSeries.color)) {\r\n\t                    currentSeries.color = fields.color || seriesColors[i % colorsCount];\r\n\t                }\r\n\r\n\t                callback(pointData.valueFields.value, new dataviz.Ring(null, 0, 0, currentAngle, angle), {\r\n\t                    owner: this$1,\r\n\t                    category: defined(fields.category) ? fields.category : \"\",\r\n\t                    index: i,\r\n\t                    series: currentSeries,\r\n\t                    seriesIx: seriesIx,\r\n\t                    dataItem: data[i],\r\n\t                    percentage: total !== 0 ? value / total : 0,\r\n\t                    explode: explode,\r\n\t                    visibleInLegend: fields.visibleInLegend,\r\n\t                    visible: visible,\r\n\t                    zIndex: seriesCount - seriesIx,\r\n\t                    animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)\r\n\t                });\r\n\r\n\t                if (visible !== false) {\r\n\t                    currentAngle += angle;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    evalSegmentOptions: function(options, value, fields) {\r\n\t        var series = fields.series;\r\n\r\n\t        evalOptions(options, {\r\n\t            value: value,\r\n\t            series: series,\r\n\t            dataItem: fields.dataItem,\r\n\t            category: fields.category,\r\n\t            percentage: fields.percentage\r\n\t        }, { defaults: series._defaults, excluded: [ \"data\", \"content\", \"template\", \"visual\", \"toggle\" ] });\r\n\t    },\r\n\r\n\t    addValue: function(value, sector, fields) {\r\n\t        var segmentOptions = deepExtend({}, fields.series, { index: fields.index });\r\n\t        this.evalSegmentOptions(segmentOptions, value, fields);\r\n\r\n\t        this.createLegendItem(value, segmentOptions, fields);\r\n\r\n\t        if (fields.visible === false) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var segment = new PieSegment(value, sector, segmentOptions);\r\n\t        $.extend(segment, fields);\r\n\t        this.append(segment);\r\n\t        this.points.push(segment);\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var points = ref.points;\r\n\t        var seriesConfigs = ref.seriesConfigs; if (seriesConfigs === void 0) { seriesConfigs = []; }\r\n\t        var count = points.length;\r\n\t        var box = targetBox.clone();\r\n\t        var space = 5;\r\n\t        var minWidth = Math.min(box.width(), box.height());\r\n\t        var halfMinWidth = minWidth / 2;\r\n\t        var defaultPadding = minWidth - minWidth * 0.85;\r\n\t        var newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\r\n\t        var newBoxCenter = newBox.center();\r\n\t        var boxCenter = box.center();\r\n\t        var seriesCount = options.series.length;\r\n\t        var leftSideLabels = [];\r\n\t        var rightSideLabels = [];\r\n\t        var padding = valueOrDefault(options.padding, defaultPadding);\r\n\r\n\t        padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\r\n\t        newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\r\n\r\n\t        var radius = halfMinWidth - padding;\r\n\t        var center = new Point(\r\n\t            radius + newBox.x1 + padding,\r\n\t            radius + newBox.y1 + padding\r\n\t        );\r\n\r\n\t        for (var i = 0; i < count; i++) {\r\n\t            var segment = points[i];\r\n\t            var sector = segment.sector;\r\n\t            var seriesIndex = segment.seriesIx;\r\n\t            sector.radius = radius;\r\n\t            sector.center = center;\r\n\r\n\t            if (seriesConfigs.length) {\r\n\t                var seriesConfig = seriesConfigs[seriesIndex];\r\n\t                sector.innerRadius = seriesConfig.innerRadius;\r\n\t                sector.radius = seriesConfig.radius;\r\n\t            }\r\n\r\n\t            if (seriesIndex === seriesCount - 1 && segment.explode) {\r\n\t                sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\r\n\t            }\r\n\r\n\t            segment.reflow(newBox);\r\n\r\n\t            var label = segment.label;\r\n\t            if (label) {\r\n\t                if (label.options.position === OUTSIDE_END) {\r\n\t                    if (seriesIndex === seriesCount - 1) {\r\n\t                        if (label.orientation === RIGHT) {\r\n\t                            rightSideLabels.push(label);\r\n\t                        } else {\r\n\t                            leftSideLabels.push(label);\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (leftSideLabels.length > 0) {\r\n\t            leftSideLabels.sort(this.labelComparator(true));\r\n\t            this.leftLabelsReflow(leftSideLabels);\r\n\t        }\r\n\r\n\t        if (rightSideLabels.length > 0) {\r\n\t            rightSideLabels.sort(this.labelComparator(false));\r\n\t            this.rightLabelsReflow(rightSideLabels);\r\n\t        }\r\n\r\n\t        this.box = newBox;\r\n\t    },\r\n\r\n\t    leftLabelsReflow: function(labels) {\r\n\t        var distances = this.distanceBetweenLabels(labels);\r\n\r\n\t        this.distributeLabels(distances, labels);\r\n\t    },\r\n\r\n\t    rightLabelsReflow: function(labels) {\r\n\t        var distances = this.distanceBetweenLabels(labels);\r\n\r\n\t        this.distributeLabels(distances, labels);\r\n\t    },\r\n\r\n\t    distanceBetweenLabels: function(labels) {\r\n\t        var segment = last(this.points);\r\n\t        var sector = segment.sector;\r\n\t        var count = labels.length - 1;\r\n\t        var lr = sector.radius + segment.options.labels.distance;\r\n\t        var distances = [];\r\n\t        var firstBox = labels[0].box;\r\n\t        var distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\r\n\r\n\t        distances.push(distance);\r\n\r\n\t        for (var i = 0; i < count; i++) {\r\n\t            var secondBox = labels[i + 1].box;\r\n\r\n\t            firstBox = labels[i].box;\r\n\t            distance = round(secondBox.y1 - firstBox.y2);\r\n\t            distances.push(distance);\r\n\t        }\r\n\t        distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\r\n\t        distances.push(distance);\r\n\r\n\t        return distances;\r\n\t    },\r\n\r\n\t    distributeLabels: function(distances, labels) {\r\n\t        var this$1 = this;\r\n\r\n\t        var count = distances.length;\r\n\t        var left, right, remaining;\r\n\r\n\t        for (var i = 0; i < count; i++) {\r\n\t            remaining = -distances[i];\r\n\t            left = right = i;\r\n\r\n\t            while (remaining > 0 && (left >= 0 || right < count)) {\r\n\t                remaining = this$1._takeDistance(distances, i, --left, remaining);\r\n\t                remaining = this$1._takeDistance(distances, i, ++right, remaining);\r\n\t            }\r\n\t        }\r\n\r\n\t        this.reflowLabels(distances, labels);\r\n\t    },\r\n\r\n\t    _takeDistance: function(distances, anchor, position, amount) {\r\n\t        var result = amount;\r\n\t        if (distances[position] > 0) {\r\n\t            var available = Math.min(distances[position], result);\r\n\t            result -= available;\r\n\t            distances[position] -= available;\r\n\t            distances[anchor] += available;\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    reflowLabels: function(distances, labels) {\r\n\t        var this$1 = this;\r\n\r\n\t        var segment = last(this.points);\r\n\t        var sector = segment.sector;\r\n\t        var labelOptions = segment.options.labels;\r\n\t        var labelsCount = labels.length;\r\n\t        var labelDistance = labelOptions.distance;\r\n\t        var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\r\n\t        var boxX;\r\n\r\n\t        distances[0] += 2;\r\n\t        for (var i = 0; i < labelsCount; i++) {\r\n\t            var label = labels[i];\r\n\t            var box = label.box;\r\n\r\n\t            boxY += distances[i];\r\n\t            boxX = this$1.hAlignLabel(\r\n\t                box.x2,\r\n\t                sector.clone().expand(labelDistance),\r\n\t                boxY,\r\n\t                boxY + box.height(),\r\n\t                label.orientation === RIGHT);\r\n\r\n\t            if (label.orientation === RIGHT) {\r\n\t                if (labelOptions.align !== CIRCLE) {\r\n\t                    boxX = sector.radius + sector.center.x + labelDistance;\r\n\t                }\r\n\t                label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\r\n\t            } else {\r\n\t                if (labelOptions.align !== CIRCLE) {\r\n\t                    boxX = sector.center.x - sector.radius - labelDistance;\r\n\t                }\r\n\t                label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\r\n\t            }\r\n\r\n\t            boxY += box.height();\r\n\t        }\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var connectors = ref.options.connectors;\r\n\t        var points = ref.points;\r\n\t        var count = points.length;\r\n\t        var space = 4;\r\n\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\r\n\t        this._connectorLines = [];\r\n\r\n\t        for (var i = 0; i < count; i++) {\r\n\t            var segment = points[i];\r\n\t            var sector = segment.sector;\r\n\t            var label = segment.label;\r\n\t            var angle = sector.middle();\r\n\t            var connectorsColor = (segment.options.connectors || {}).color || connectors.color;\r\n\r\n\t            if (label) {\r\n\t                var connectorLine = new Path({\r\n\t                    stroke: {\r\n\t                        color: connectorsColor,\r\n\t                        width: connectors.width\r\n\t                    },\r\n\t                    animation: {\r\n\t                        type: FADEIN,\r\n\t                        delay: segment.animationDelay\r\n\t                    }\r\n\t                });\r\n\r\n\t                if (label.options.position === OUTSIDE_END) {\r\n\t                    var box = label.box;\r\n\t                    var centerPoint = sector.center;\r\n\t                    var start = sector.point(angle);\r\n\t                    var middle = new Point(box.x1, box.center().y);\r\n\t                    var sr = (void 0), end = (void 0), crossing = (void 0);\r\n\r\n\t                    start = sector.clone().expand(connectors.padding).point(angle);\r\n\t                    connectorLine.moveTo(start.x, start.y);\r\n\t                    // TODO: Extract into a method to remove duplication\r\n\t                    if (label.orientation === RIGHT) {\r\n\t                        end = new Point(box.x1 - connectors.padding, box.center().y);\r\n\t                        crossing = intersection(centerPoint, start, middle, end);\r\n\t                        middle = new Point(end.x - space, end.y);\r\n\t                        crossing = crossing || middle;\r\n\t                        crossing.x = Math.min(crossing.x, middle.x);\r\n\r\n\t                        if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) ||\r\n\t                            crossing.x < sector.center.x) {\r\n\t                            sr = sector.center.x + sector.radius + space;\r\n\t                            if (segment.options.labels.align !== COLUMN) {\r\n\t                                if (sr < middle.x) {\r\n\t                                    connectorLine.lineTo(sr, start.y);\r\n\t                                } else {\r\n\t                                    connectorLine.lineTo(start.x + space * 2, start.y);\r\n\t                                }\r\n\t                            } else {\r\n\t                                connectorLine.lineTo(sr, start.y);\r\n\t                            }\r\n\t                            connectorLine.lineTo(middle.x, end.y);\r\n\t                        } else {\r\n\t                            crossing.y = end.y;\r\n\t                            connectorLine.lineTo(crossing.x, crossing.y);\r\n\t                        }\r\n\t                    } else {\r\n\t                        end = new Point(box.x2 + connectors.padding, box.center().y);\r\n\t                        crossing = intersection(centerPoint, start, middle, end);\r\n\t                        middle = new Point(end.x + space, end.y);\r\n\t                        crossing = crossing || middle;\r\n\t                        crossing.x = Math.max(crossing.x, middle.x);\r\n\r\n\t                        if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) ||\r\n\t                            crossing.x > sector.center.x) {\r\n\t                            sr = sector.center.x - sector.radius - space;\r\n\t                            if (segment.options.labels.align !== COLUMN) {\r\n\t                                if (sr > middle.x) {\r\n\t                                    connectorLine.lineTo(sr, start.y);\r\n\t                                } else {\r\n\t                                    connectorLine.lineTo(start.x - space * 2, start.y);\r\n\t                                }\r\n\t                            } else {\r\n\t                                connectorLine.lineTo(sr, start.y);\r\n\t                            }\r\n\t                            connectorLine.lineTo(middle.x, end.y);\r\n\t                        } else {\r\n\t                            crossing.y = end.y;\r\n\t                            connectorLine.lineTo(crossing.x, crossing.y);\r\n\t                        }\r\n\t                    }\r\n\r\n\t                    connectorLine.lineTo(end.x, end.y);\r\n\r\n\t                    this$1._connectorLines.push(connectorLine);\r\n\t                    this$1.visual.append(connectorLine);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    labelComparator: function(reverse) {\r\n\t        var reverseValue = reverse ? -1 : 1;\r\n\r\n\t        return function(a, b) {\r\n\t            var first = (a.parent.sector.middle() + 270) % 360;\r\n\t            var second = (b.parent.sector.middle() + 270) % 360;\r\n\t            return (first - second) * reverseValue;\r\n\t        };\r\n\t    },\r\n\r\n\t    hAlignLabel: function(originalX, sector, y1, y2, direction) {\r\n\t        var radius = sector.radius;\r\n\t        var sector_center = sector.center;\r\n\t        var cx = sector_center.x;\r\n\t        var cy = sector_center.y;\r\n\t        var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\r\n\r\n\t        if (t > radius) {\r\n\t            return originalX;\r\n\t        }\r\n\r\n\t        return cx + Math.sqrt((radius * radius) - (t * t)) * (direction ? 1 : -1);\r\n\t    },\r\n\r\n\t    pointInCircle: function(point, center, radius) {\r\n\t        return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\r\n\t    },\r\n\r\n\t    formatPointValue: function(point, format) {\r\n\t        return this.chartService.format.auto(format, point.value);\r\n\t    },\r\n\r\n\t    animationDelay: function(categoryIndex) {\r\n\t        return categoryIndex * PIE_SECTOR_ANIM_DELAY;\r\n\t    }\r\n\t});\r\n\r\n\tfunction intersection(a1, a2, b1, b2) {\r\n\t    var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\r\n\t    var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\r\n\r\n\t    var result;\r\n\t    if (ub !== 0) {\r\n\t        var ua = (uat / ub);\r\n\r\n\t        result = new Point(\r\n\t            a1.x + ua * (a2.x - a1.x),\r\n\t            a1.y + ua * (a2.y - a1.y)\r\n\t        );\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tsetDefaultOptions(PieChart, {\r\n\t    startAngle: 90,\r\n\t    connectors: {\r\n\t        width: 2,\r\n\t        color: \"#939393\",\r\n\t        padding: 8\r\n\t    },\r\n\t    inactiveItems: {\r\n\t        markers: {},\r\n\t        labels: {}\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(PieChart.prototype, PieChartMixin);\r\n\r\n\tvar PiePlotArea = PlotAreaBase.extend({\r\n\t    render: function() {\r\n\t        this.createPieChart(this.series);\r\n\t    },\r\n\r\n\t    createPieChart: function(series) {\r\n\t        var firstSeries = series[0];\r\n\t        var pieChart = new PieChart(this, {\r\n\t            series: series,\r\n\t            padding: firstSeries.padding,\r\n\t            startAngle: firstSeries.startAngle,\r\n\t            connectors: firstSeries.connectors,\r\n\t            legend: this.options.legend\r\n\t        });\r\n\r\n\t        this.appendChart(pieChart);\r\n\t    },\r\n\r\n\t    appendChart: function(chart, pane) {\r\n\t        PlotAreaBase.fn.appendChart.call(this, chart, pane);\r\n\t        append(this.options.legend.items, chart.legendItems);\r\n\t    }\r\n\t});\r\n\r\n\tvar DonutSegment = PieSegment.extend({\r\n\t    reflowLabel: function() {\r\n\t        var ref = this;\r\n\t        var labelsOptions = ref.options.labels;\r\n\t        var label = ref.label;\r\n\t        var sector = this.sector.clone();\r\n\t        var angle = sector.middle();\r\n\r\n\t        if (label) {\r\n\t            var labelHeight = label.box.height();\r\n\t            if (labelsOptions.position === CENTER) {\r\n\t                sector.radius -= (sector.radius - sector.innerRadius) / 2;\r\n\r\n\t                var lp = sector.point(angle);\r\n\r\n\t                label.reflow(new Box(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));\r\n\t            } else {\r\n\t                PieSegment.fn.reflowLabel.call(this);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    createSegment: function(sector, options) {\r\n\t        return dataviz.ShapeBuilder.current.createRing(sector, options);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(DonutSegment, {\r\n\t    overlay: {\r\n\t        gradient: \"roundedGlass\"\r\n\t    },\r\n\t    labels: {\r\n\t        position: CENTER\r\n\t    },\r\n\t    animation: {\r\n\t        type: PIE\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(DonutSegment.prototype, PointEventsMixin);\r\n\r\n\tvar DONUT_SECTOR_ANIM_DELAY = 50;\r\n\r\n\tvar DonutChart = PieChart.extend({\r\n\t    addValue: function(value, sector, fields) {\r\n\t        var segmentOptions = deepExtend({}, fields.series, { index: fields.index });\r\n\t        this.evalSegmentOptions(segmentOptions, value, fields);\r\n\r\n\t        this.createLegendItem(value, segmentOptions, fields);\r\n\r\n\t        if (!value || fields.visible === false) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var segment = new DonutSegment(value, sector, segmentOptions);\r\n\r\n\t        $.extend(segment, fields);\r\n\t        this.append(segment);\r\n\t        this.points.push(segment);\r\n\t    },\r\n\r\n\t    reflow: function(targetBox) {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var box = targetBox.clone();\r\n\t        var space = 5;\r\n\t        var minWidth = Math.min(box.width(), box.height());\r\n\t        var halfMinWidth = minWidth / 2;\r\n\t        var defaultPadding = minWidth - minWidth * 0.85;\r\n\t        var series = options.series;\r\n\t        var seriesCount = series.length;\r\n\r\n\t        var padding = valueOrDefault(options.padding, defaultPadding);\r\n\t        padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\r\n\r\n\t        var totalSize = halfMinWidth - padding;\r\n\t        var seriesWithoutSize = 0;\r\n\t        var holeSize;\r\n\r\n\t        for (var i = 0; i < seriesCount; i++) {\r\n\t            var currentSeries = series[i];\r\n\t            if (i === 0) {\r\n\t                if (defined(currentSeries.holeSize)) {\r\n\t                    holeSize = currentSeries.holeSize;\r\n\t                    totalSize -= currentSeries.holeSize;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (defined(currentSeries.size)) {\r\n\t                totalSize -= currentSeries.size;\r\n\t            } else {\r\n\t                seriesWithoutSize++;\r\n\t            }\r\n\r\n\t            if (defined(currentSeries.margin) && i !== seriesCount - 1) {\r\n\t                totalSize -= currentSeries.margin;\r\n\t            }\r\n\t        }\r\n\r\n\t        if (!defined(holeSize)) {\r\n\t            var currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);\r\n\t            holeSize = currentSize * 0.75;\r\n\t            totalSize -= holeSize;\r\n\t        }\r\n\r\n\t        var innerRadius = holeSize;\r\n\t        var margin = 0;\r\n\t        var size, radius;\r\n\r\n\t        this.seriesConfigs = [];\r\n\r\n\t        for (var i$1 = 0; i$1 < seriesCount; i$1++) {\r\n\t            var currentSeries$1 = series[i$1];\r\n\t            size = valueOrDefault(currentSeries$1.size, totalSize / seriesWithoutSize);\r\n\t            innerRadius += margin;\r\n\t            radius = innerRadius + size;\r\n\t            this$1.seriesConfigs.push({ innerRadius: innerRadius, radius: radius });\r\n\t            margin = currentSeries$1.margin || 0;\r\n\t            innerRadius = radius;\r\n\t        }\r\n\r\n\t        PieChart.fn.reflow.call(this, targetBox);\r\n\t    },\r\n\r\n\t    animationDelay: function(categoryIndex, seriesIndex, seriesCount) {\r\n\t        return categoryIndex * DONUT_SECTOR_ANIM_DELAY +\r\n\t            (INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1));\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(DonutChart, {\r\n\t    startAngle: 90,\r\n\t    connectors: {\r\n\t        width: 2,\r\n\t        color: \"#939393\",\r\n\t        padding: 8\r\n\t    }\r\n\t});\r\n\r\n\tvar DonutPlotArea = PiePlotArea.extend({\r\n\t    render: function() {\r\n\t        this.createDonutChart(this.series);\r\n\t    },\r\n\r\n\t    createDonutChart: function(series) {\r\n\t        var firstSeries = series[0];\r\n\t        var donutChart = new DonutChart(this, {\r\n\t            series: series,\r\n\t            padding: firstSeries.padding,\r\n\t            connectors: firstSeries.connectors,\r\n\t            legend: this.options.legend\r\n\t        });\r\n\r\n\t        this.appendChart(donutChart);\r\n\t    }\r\n\t});\r\n\r\n\tvar DEFAULT_PADDING = 0.15;\r\n\r\n\tvar PolarPlotAreaBase = PlotAreaBase.extend({\r\n\t    initFields: function() {\r\n\t        this.valueAxisRangeTracker = new AxisGroupRangeTracker();\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        this.addToLegend(this.series);\r\n\t        this.createPolarAxis();\r\n\t        this.createCharts();\r\n\t        this.createValueAxis();\r\n\t    },\r\n\r\n\t    alignAxes: function() {\r\n\t        var axis = this.valueAxis;\r\n\t        var range = axis.range();\r\n\t        var crossingValue = axis.options.reverse ? range.max : range.min;\r\n\t        var slot = axis.getSlot(crossingValue);\r\n\t        var center = this.polarAxis.getSlot(0).center;\r\n\t        var axisBox = axis.box.translate(\r\n\t            center.x - slot.x1,\r\n\t            center.y - slot.y1\r\n\t        );\r\n\r\n\t        axis.reflow(axisBox);\r\n\t    },\r\n\r\n\t    createValueAxis: function() {\r\n\t        var tracker = this.valueAxisRangeTracker;\r\n\t        var defaultRange = tracker.query();\r\n\t        var axisOptions = this.valueAxisOptions({\r\n\t            roundToMajorUnit: false,\r\n\t            zIndex: -1\r\n\t        });\r\n\t        var axisType, axisDefaultRange;\r\n\r\n\t        if (axisOptions.type === LOGARITHMIC) {\r\n\t            axisType = dataviz.RadarLogarithmicAxis;\r\n\t            axisDefaultRange = { min: 0.1, max: 1 };\r\n\t        } else {\r\n\t            axisType = dataviz.RadarNumericAxis;\r\n\t            axisDefaultRange = { min: 0, max: 1 };\r\n\t        }\r\n\r\n\t        var range = tracker.query(name) || defaultRange || axisDefaultRange;\r\n\r\n\t        if (range && defaultRange) {\r\n\t            range.min = Math.min(range.min, defaultRange.min);\r\n\t            range.max = Math.max(range.max, defaultRange.max);\r\n\t        }\r\n\r\n\t        var valueAxis = new axisType(\r\n\t            range.min, range.max,\r\n\t            axisOptions,\r\n\t            this.chartService\r\n\t        );\r\n\r\n\t        this.valueAxis = valueAxis;\r\n\t        this.appendAxis(valueAxis);\r\n\t    },\r\n\r\n\t    reflowAxes: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options.plotArea;\r\n\t        var valueAxis = ref.valueAxis;\r\n\t        var polarAxis = ref.polarAxis;\r\n\t        var box = ref.box;\r\n\t        var defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;\r\n\t        var padding = getSpacing(options.padding || {}, defaultPadding);\r\n\t        var paddingBox = box.clone().unpad(padding);\r\n\t        var axisBox = paddingBox.clone();\r\n\r\n\t        axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());\r\n\t        axisBox.align(paddingBox, Y, CENTER);\r\n\r\n\t        var valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);\r\n\r\n\t        polarAxis.reflow(axisBox);\r\n\t        valueAxis.reflow(valueAxisBox);\r\n\t        var heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();\r\n\t        valueAxis.reflow(valueAxis.box.unpad({ top: heightDiff }));\r\n\r\n\t        this.axisBox = axisBox;\r\n\t        this.alignAxes(axisBox);\r\n\t    },\r\n\r\n\t    backgroundBox: function() {\r\n\t        return this.box;\r\n\t    }\r\n\t});\r\n\r\n\tvar PolarScatterChart = ScatterChart.extend({\r\n\t    pointSlot: function(slotX, slotY) {\r\n\t        var valueRadius = slotX.center.y - slotY.y1;\r\n\t        var slot = Point.onCircle(slotX.center, slotX.startAngle, valueRadius);\r\n\r\n\t        return new Box(slot.x, slot.y, slot.x, slot.y);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(PolarScatterChart, {\r\n\t    clip: false\r\n\t});\r\n\r\n\tvar PolarLineChart = ScatterLineChart.extend({\r\n\r\n\t});\r\n\r\n\tPolarLineChart.prototype.pointSlot = PolarScatterChart.prototype.pointSlot;\r\n\r\n\tsetDefaultOptions(PolarLineChart, {\r\n\t    clip: false\r\n\t});\r\n\r\n\tvar SplinePolarAreaSegment = SplineAreaSegment.extend({\r\n\t    fillToAxes: function(fillPath) {\r\n\t        var center = this._polarAxisCenter();\r\n\t        fillPath.lineTo(center.x, center.y);\r\n\t    },\r\n\r\n\t    _polarAxisCenter: function() {\r\n\t        var polarAxis = this.parent.plotArea.polarAxis;\r\n\t        var center = polarAxis.box.center();\r\n\t        return center;\r\n\t    },\r\n\r\n\t    strokeSegments: function() {\r\n\t        var segments = this._strokeSegments;\r\n\r\n\t        if (!segments) {\r\n\t            var center = this._polarAxisCenter();\r\n\t            var curveProcessor = new CurveProcessor(false);\r\n\t            var linePoints = this.points();\r\n\r\n\t            linePoints.push(center);\r\n\t            segments = this._strokeSegments = curveProcessor.process(linePoints);\r\n\t            segments.pop();\r\n\t        }\r\n\r\n\t        return segments;\r\n\t    }\r\n\t});\r\n\r\n\tvar PolarAreaSegment = AreaSegment.extend({\r\n\t    fillToAxes: function(fillPath) {\r\n\t        var polarAxis = this.parent.plotArea.polarAxis;\r\n\t        var center = polarAxis.box.center();\r\n\t        var centerSegment = new geometry.Segment([ center.x, center.y ]);\r\n\r\n\t        fillPath.segments.unshift(centerSegment);\r\n\t        fillPath.segments.push(centerSegment);\r\n\t    }\r\n\t});\r\n\r\n\tvar PolarAreaChart = PolarLineChart.extend({\r\n\t    createSegment: function(linePoints, currentSeries, seriesIx) {\r\n\t        var style = (currentSeries.line || {}).style;\r\n\t        var segment;\r\n\r\n\t        if (style === SMOOTH) {\r\n\t            segment = new SplinePolarAreaSegment(linePoints, currentSeries, seriesIx);\r\n\t        } else {\r\n\t            segment = new PolarAreaSegment(linePoints, currentSeries, seriesIx);\r\n\t        }\r\n\t        return segment;\r\n\t    },\r\n\r\n\t    createMissingValue: function(value, missingValues) {\r\n\t        var missingValue;\r\n\r\n\t        if (hasValue(value.x) && missingValues !== INTERPOLATE) {\r\n\t            missingValue = {\r\n\t                x: value.x,\r\n\t                y: value.y\r\n\t            };\r\n\t            if (missingValues === ZERO) {\r\n\t                missingValue.y = 0;\r\n\t            }\r\n\t        }\r\n\r\n\t        return missingValue;\r\n\t    },\r\n\r\n\t    seriesMissingValues: function(series) {\r\n\t        return series.missingValues || ZERO;\r\n\t    },\r\n\r\n\t    _hasMissingValuesGap: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var series = this.options.series;\r\n\r\n\t        for (var idx = 0; idx < series.length; idx++) {\r\n\t            if (this$1.seriesMissingValues(series[idx]) === GAP) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    sortPoints: function(points) {\r\n\t        var this$1 = this;\r\n\r\n\t        points.sort(xComparer);\r\n\r\n\t        if (this._hasMissingValuesGap()) {\r\n\t            for (var idx = 0; idx < points.length; idx++) {\r\n\t                var point = points[idx];\r\n\t                if (point) {\r\n\t                    var value = point.value;\r\n\t                    if (!hasValue(value.y) && this$1.seriesMissingValues(point.series) === GAP) {\r\n\t                        delete points[idx];\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return points;\r\n\t    }\r\n\t});\r\n\r\n\tfunction xComparer(a, b) {\r\n\t    return a.value.x - b.value.x;\r\n\t}\r\n\r\n\tvar PolarPlotArea = PolarPlotAreaBase.extend({\r\n\t    createPolarAxis: function() {\r\n\t        var polarAxis = new dataviz.PolarAxis(this.options.xAxis, this.chartService);\r\n\r\n\t        this.polarAxis = polarAxis;\r\n\t        this.axisX = polarAxis;\r\n\t        this.appendAxis(polarAxis);\r\n\t    },\r\n\r\n\t    valueAxisOptions: function(defaults) {\r\n\t        return deepExtend(defaults, {\r\n\t            majorGridLines: { type: ARC },\r\n\t            minorGridLines: { type: ARC }\r\n\t        }, this.options.yAxis);\r\n\t    },\r\n\r\n\t    createValueAxis: function() {\r\n\t        PolarPlotAreaBase.fn.createValueAxis.call(this);\r\n\t        this.axisY = this.valueAxis;\r\n\t    },\r\n\r\n\t    appendChart: function(chart, pane) {\r\n\t        this.valueAxisRangeTracker.update(chart.yAxisRanges);\r\n\r\n\t        PlotAreaBase.prototype.appendChart.call(this, chart, pane);\r\n\t    },\r\n\r\n\t    createCharts: function() {\r\n\t        var series = this.filterVisibleSeries(this.series);\r\n\t        var pane = this.panes[0];\r\n\r\n\t        this.createLineChart(\r\n\t            filterSeriesByType(series, [ POLAR_LINE ]),\r\n\t            pane\r\n\t        );\r\n\r\n\t        this.createScatterChart(\r\n\t            filterSeriesByType(series, [ POLAR_SCATTER ]),\r\n\t            pane\r\n\t        );\r\n\r\n\t        this.createAreaChart(\r\n\t            filterSeriesByType(series, [ POLAR_AREA ]),\r\n\t            pane\r\n\t        );\r\n\t    },\r\n\r\n\t    createLineChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var lineChart = new PolarLineChart(this, { series: series });\r\n\r\n\t        this.appendChart(lineChart, pane);\r\n\t    },\r\n\r\n\t    createScatterChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var scatterChart = new PolarScatterChart(this, { series: series });\r\n\r\n\t        this.appendChart(scatterChart, pane);\r\n\t    },\r\n\r\n\t    createAreaChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var areaChart = new PolarAreaChart(this, { series: series });\r\n\r\n\t        this.appendChart(areaChart, pane);\r\n\t    },\r\n\r\n\t    _dispatchEvent: function(chart, e, eventType) {\r\n\t        var coords = chart._eventCoordinates(e);\r\n\t        var point = new Point(coords.x, coords.y);\r\n\t        var xValue = this.axisX.getValue(point);\r\n\t        var yValue = this.axisY.getValue(point);\r\n\r\n\t        if (xValue !== null && yValue !== null) {\r\n\t            chart.trigger(eventType, {\r\n\t                element: eventElement(e),\r\n\t                x: xValue,\r\n\t                y: yValue\r\n\t            });\r\n\t        }\r\n\t    },\r\n\r\n\t    createCrosshairs: function() {}\r\n\t});\r\n\r\n\tsetDefaultOptions(PolarPlotArea, {\r\n\t    xAxis: {},\r\n\t    yAxis: {}\r\n\t});\r\n\r\n\tdeepExtend(PolarPlotArea.prototype, PlotAreaEventsMixin);\r\n\r\n\tvar RadarLineChart = LineChart.extend({\r\n\t    pointSlot: function(categorySlot, valueSlot) {\r\n\t        var valueRadius = categorySlot.center.y - valueSlot.y1;\r\n\t        var slot = Point.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);\r\n\r\n\t        return new Box(slot.x, slot.y, slot.x, slot.y);\r\n\t    },\r\n\r\n\t    createSegment: function(linePoints, currentSeries, seriesIx) {\r\n\t        var style = currentSeries.style;\r\n\t        var pointType;\r\n\r\n\t        if (style === SMOOTH) {\r\n\t            pointType = SplineSegment;\r\n\t        } else {\r\n\t            pointType = LineSegment;\r\n\t        }\r\n\r\n\t        var segment = new pointType(linePoints, currentSeries, seriesIx);\r\n\r\n\t        if (linePoints.length === currentSeries.data.length) {\r\n\t            segment.options.closed = true;\r\n\t        }\r\n\r\n\t        return segment;\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(RadarLineChart, {\r\n\t    clip: false,\r\n\t    limitPoints: false\r\n\t});\r\n\r\n\tvar SplineRadarAreaSegment = SplineAreaSegment.extend({\r\n\t    fillToAxes: function() {}\r\n\t});\r\n\r\n\tvar RadarAreaSegment = AreaSegment.extend({\r\n\t    fillToAxes: function() {}\r\n\t});\r\n\r\n\tvar RadarAreaChart = RadarLineChart.extend({\r\n\t    createSegment: function(linePoints, currentSeries, seriesIx, prevSegment) {\r\n\t        var isStacked = this.options.isStacked;\r\n\t        var style = (currentSeries.line || {}).style;\r\n\t        var previousSegment;\r\n\t        var stackPoints;\r\n\t        var segment;\r\n\r\n\t        if (isStacked && seriesIx > 0 && prevSegment) {\r\n\t            stackPoints = prevSegment.linePoints.slice(0);\r\n\t            previousSegment = prevSegment;\r\n\t        }\r\n\r\n\t        if (style === SMOOTH) {\r\n\t            segment = new SplineRadarAreaSegment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\r\n\t            segment.options.closed = true;\r\n\t        } else {\r\n\t            linePoints.push(linePoints[0]);\r\n\t            segment = new RadarAreaSegment(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\r\n\t        }\r\n\r\n\t        return segment;\r\n\t    },\r\n\r\n\t    seriesMissingValues: function(series) {\r\n\t        return series.missingValues || ZERO;\r\n\t    }\r\n\t});\r\n\r\n\tvar RadarSegment = DonutSegment.extend({\r\n\t    init: function(value, options) {\r\n\t        DonutSegment.fn.init.call(this, value, null, options);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(RadarSegment, {\r\n\t    overlay: {\r\n\t        gradient: \"none\"\r\n\t    },\r\n\t    labels: {\r\n\t        distance: 10\r\n\t    }\r\n\t});\r\n\r\n\tvar RadarClusterLayout = ChartElement.extend({\r\n\t    init: function(options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.forEach = options.rtl ? forEachReverse : forEach;\r\n\t    },\r\n\r\n\t    reflow: function(sector) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var children = ref.children;\r\n\t        var gap = options.gap;\r\n\t        var spacing = options.spacing;\r\n\t        var count = children.length;\r\n\t        var slots = count + gap + (spacing * (count - 1));\r\n\t        var slotAngle = sector.angle / slots;\r\n\t        var angle = sector.startAngle + slotAngle * (gap / 2);\r\n\r\n\t        this.forEach(children, function (child) {\r\n\t            var slotSector = sector.clone();\r\n\t            slotSector.startAngle = angle;\r\n\t            slotSector.angle = slotAngle;\r\n\r\n\t            if (child.sector) {\r\n\t                slotSector.radius = child.sector.radius;\r\n\t            }\r\n\r\n\t            child.reflow(slotSector);\r\n\t            child.sector = slotSector;\r\n\r\n\t            angle += slotAngle + (slotAngle * spacing);\r\n\t        });\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(RadarClusterLayout, {\r\n\t    gap: 1,\r\n\t    spacing: 0\r\n\t});\r\n\r\n\tvar RadarStackLayout = ChartElement.extend({\r\n\t    reflow: function(sector) {\r\n\t        var ref = this;\r\n\t        var reverse = ref.options.reverse;\r\n\t        var children = ref.children;\r\n\t        var childrenCount = children.length;\r\n\t        var first = reverse ? childrenCount - 1 : 0;\r\n\t        var step = reverse ? -1 : 1;\r\n\r\n\t        this.box = new Box();\r\n\r\n\t        for (var i = first; i >= 0 && i < childrenCount; i += step) {\r\n\t            var childSector = children[i].sector;\r\n\t            childSector.startAngle = sector.startAngle;\r\n\t            childSector.angle = sector.angle;\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar RadarBarChart = BarChart.extend({\r\n\t    pointType: function() {\r\n\t        return RadarSegment;\r\n\t    },\r\n\r\n\t    clusterType: function() {\r\n\t        return RadarClusterLayout;\r\n\t    },\r\n\r\n\t    stackType: function() {\r\n\t        return RadarStackLayout;\r\n\t    },\r\n\r\n\t    categorySlot: function(categoryAxis, categoryIx) {\r\n\t        return categoryAxis.getSlot(categoryIx);\r\n\t    },\r\n\r\n\t    pointSlot: function(categorySlot, valueSlot) {\r\n\t        var slot = categorySlot.clone();\r\n\t        var y = categorySlot.center.y;\r\n\r\n\t        slot.radius = y - valueSlot.y1;\r\n\t        slot.innerRadius = y - valueSlot.y2;\r\n\r\n\t        return slot;\r\n\t    },\r\n\r\n\t    reflowPoint: function(point, pointSlot) {\r\n\t        point.sector = pointSlot;\r\n\t        point.reflow();\r\n\t    },\r\n\r\n\t    createAnimation: function() {\r\n\t        this.options.animation.center = this.box.toRect().center();\r\n\t        BarChart.fn.createAnimation.call(this);\r\n\t    }\r\n\t});\r\n\r\n\tRadarBarChart.prototype.reflow = CategoricalChart.prototype.reflow;\r\n\r\n\tsetDefaultOptions(RadarBarChart, {\r\n\t    clip: false,\r\n\t    limitPoints: false,\r\n\t    animation: {\r\n\t        type: \"pie\"\r\n\t    }\r\n\t});\r\n\r\n\tvar RadarPlotArea = PolarPlotAreaBase.extend({\r\n\t    createPolarAxis: function() {\r\n\t        var categoryAxis = new dataviz.RadarCategoryAxis(this.options.categoryAxis, this.chartService);\r\n\r\n\t        this.polarAxis = categoryAxis;\r\n\t        this.categoryAxis = categoryAxis;\r\n\t        this.appendAxis(categoryAxis);\r\n\t        this.aggregateCategories();\r\n\t        this.createCategoryAxesLabels();\r\n\t    },\r\n\r\n\t    valueAxisOptions: function(defaults) {\r\n\t        if (this._hasBarCharts) {\r\n\t            deepExtend(defaults, {\r\n\t                majorGridLines: { type: ARC },\r\n\t                minorGridLines: { type: ARC }\r\n\t            });\r\n\t        }\r\n\r\n\t        if (this._isStacked100) {\r\n\t            deepExtend(defaults, {\r\n\t                roundToMajorUnit: false,\r\n\t                labels: { format: \"P0\" }\r\n\t            });\r\n\t        }\r\n\r\n\t        return deepExtend(defaults, this.options.valueAxis);\r\n\t    },\r\n\r\n\t    aggregateCategories: function() {\r\n\t        // No separate panes in radar charts\r\n\t        CategoricalPlotArea.prototype.aggregateCategories.call(this, this.panes);\r\n\t    },\r\n\r\n\t    createCategoryAxesLabels: function() {\r\n\t        CategoricalPlotArea.prototype.createCategoryAxesLabels.call(this, this.panes);\r\n\t    },\r\n\r\n\t    filterSeries: function(currentSeries) {\r\n\t        // Not supported for radar charts\r\n\t        return currentSeries;\r\n\t    },\r\n\r\n\t    createCharts: function() {\r\n\t        var series = this.filterVisibleSeries(this.series);\r\n\t        var pane = this.panes[0];\r\n\r\n\t        this.createAreaChart(\r\n\t            filterSeriesByType(series, [ RADAR_AREA ]),\r\n\t            pane\r\n\t        );\r\n\r\n\t        this.createLineChart(\r\n\t            filterSeriesByType(series, [ RADAR_LINE ]),\r\n\t            pane\r\n\t        );\r\n\r\n\t        this.createBarChart(\r\n\t            filterSeriesByType(series, [ RADAR_COLUMN ]),\r\n\t            pane\r\n\t        );\r\n\t    },\r\n\r\n\t    chartOptions: function(series) {\r\n\t        var options = { series: series };\r\n\t        var firstSeries = series[0];\r\n\t        if (firstSeries) {\r\n\t            var filteredSeries = this.filterVisibleSeries(series);\r\n\t            var stack = firstSeries.stack;\r\n\t            options.isStacked = stack && filteredSeries.length > 1;\r\n\t            options.isStacked100 = stack && stack.type === \"100%\" && filteredSeries.length > 1;\r\n\r\n\t            if (options.isStacked100) {\r\n\t                this._isStacked100 = true;\r\n\t            }\r\n\t        }\r\n\r\n\t        return options;\r\n\t    },\r\n\r\n\t    createAreaChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var areaChart = new RadarAreaChart(this, this.chartOptions(series));\r\n\t        this.appendChart(areaChart, pane);\r\n\t    },\r\n\r\n\t    createLineChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var lineChart = new RadarLineChart(this, this.chartOptions(series));\r\n\t        this.appendChart(lineChart, pane);\r\n\t    },\r\n\r\n\t    createBarChart: function(series, pane) {\r\n\t        if (series.length === 0) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var firstSeries = series[0];\r\n\t        var options = this.chartOptions(series);\r\n\t        options.gap = firstSeries.gap;\r\n\t        options.spacing = firstSeries.spacing;\r\n\r\n\t        var barChart = new RadarBarChart(this, options);\r\n\t        this.appendChart(barChart, pane);\r\n\r\n\t        this._hasBarCharts = true;\r\n\t    },\r\n\r\n\t    seriesCategoryAxis: function() {\r\n\t        return this.categoryAxis;\r\n\t    },\r\n\r\n\t    _dispatchEvent: function(chart, e, eventType) {\r\n\t        var coords = chart._eventCoordinates(e);\r\n\t        var point = new Point(coords.x, coords.y);\r\n\t        var category = this.categoryAxis.getCategory(point);\r\n\t        var value = this.valueAxis.getValue(point);\r\n\r\n\t        if (category !== null && value !== null) {\r\n\t            chart.trigger(eventType, {\r\n\t                element: eventElement(e),\r\n\t                category: category,\r\n\t                value: value\r\n\t            });\r\n\t        }\r\n\t    },\r\n\r\n\t    createCrosshairs: function() {}\r\n\t});\r\n\r\n\tdeepExtend(RadarPlotArea.prototype, PlotAreaEventsMixin, {\r\n\t    appendChart: CategoricalPlotArea.prototype.appendChart,\r\n\t    aggregateSeries: CategoricalPlotArea.prototype.aggregateSeries\r\n\t});\r\n\r\n\tsetDefaultOptions(RadarPlotArea, {\r\n\t    categoryAxis: {\r\n\t        categories: []\r\n\t    },\r\n\t    valueAxis: {}\r\n\t});\r\n\r\n\tvar FunnelSegment = ChartElement.extend({\r\n\t    init: function(value, options, segmentOptions) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.value = value;\r\n\t        this.options.index = segmentOptions.index;\r\n\t    },\r\n\r\n\t    reflow: function(chartBox) {\r\n\t        var points = this.points;\r\n\t        var label = this.children[0];\r\n\r\n\t        this.box = new Box(points[0].x, points[0].y, points[1].x, points[2].y);\r\n\r\n\t        if (label) {\r\n\t            label.reflow(new Box(chartBox.x1, points[0].y, chartBox.x2, points[2].y));\r\n\t        }\r\n\t    },\r\n\r\n\t    createVisual: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var visual;\r\n\r\n\t        ChartElement.fn.createVisual.call(this);\r\n\r\n\t        if (options.visual) {\r\n\t            visual = options.visual({\r\n\t                category: this.category,\r\n\t                dataItem: this.dataItem,\r\n\t                value: this.value,\r\n\t                series: this.series,\r\n\t                percentage: this.percentage,\r\n\t                points: this.points,\r\n\t                options: options,\r\n\t                sender: this.getSender(),\r\n\t                createVisual: function () { return this$1.createPath(); }\r\n\t            });\r\n\t        } else {\r\n\t            visual = this.createPath();\r\n\t        }\r\n\r\n\t        if (visual) {\r\n\t            this.visual.append(visual);\r\n\t        }\r\n\t    },\r\n\r\n\t    createPath: function() {\r\n\t        var options = this.options;\r\n\t        var border = options.border;\r\n\t        var path = Path.fromPoints(this.points, {\r\n\t            fill: {\r\n\t                color: options.color,\r\n\t                opacity: options.opacity\r\n\t            },\r\n\t            stroke: {\r\n\t                color: border.color,\r\n\t                opacity: border.opacity,\r\n\t                width: border.width\r\n\t            }\r\n\t        }).close();\r\n\r\n\t        return path;\r\n\t    },\r\n\r\n\t    createHighlight: function(style) {\r\n\t        return Path.fromPoints(this.points, style);\r\n\t    },\r\n\r\n\t    highlightVisual: function() {\r\n\t        return this.visual.children[0];\r\n\t    },\r\n\r\n\t    highlightVisualArgs: function() {\r\n\t        var path = Path.fromPoints(this.points).close();\r\n\r\n\t        return {\r\n\t            options: this.options,\r\n\t            path: path\r\n\t        };\r\n\t    },\r\n\r\n\t    tooltipAnchor: function() {\r\n\t        var box = this.box;\r\n\t        return {\r\n\t            point: new Point(box.center().x, box.y1),\r\n\t            align: {\r\n\t                horizontal: \"center\",\r\n\t                vertical: \"top\"\r\n\t            }\r\n\t        };\r\n\t    },\r\n\r\n\t    formatValue: function(format) {\r\n\t        var point = this;\r\n\t        return point.owner.formatPointValue(point, format);\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(FunnelSegment, {\r\n\t    color: WHITE,\r\n\t    border: {\r\n\t        width: 1\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(FunnelSegment.prototype, PointEventsMixin);\r\n\r\n\tvar FunnelChart = ChartElement.extend({\r\n\t    init: function(plotArea, options) {\r\n\t        ChartElement.fn.init.call(this, options);\r\n\r\n\t        this.plotArea = plotArea;\r\n\t        this.points = [];\r\n\t        this.labels = [];\r\n\t        this.legendItems = [];\r\n\t        this.render();\r\n\t    },\r\n\r\n\t    formatPointValue: function(point, format) {\r\n\t        return this.chartService.format.auto(format,point.value);\r\n\t    },\r\n\r\n\t    render: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var seriesColors = ref.plotArea.options.seriesColors; if (seriesColors === void 0) { seriesColors = []; }\r\n\t        var series = options.series[0];\r\n\t        var data = series.data;\r\n\r\n\t        if (!data) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var ref$1 = bindSegments(series);\r\n\t        var total = ref$1.total;\r\n\t        var points = ref$1.points;\r\n\r\n\t        for (var i = 0; i < points.length; i++) {\r\n\t            var pointData = points[i];\r\n\r\n\t            if (!pointData) {\r\n\t                continue;\r\n\t            }\r\n\r\n\t            var fields = pointData.fields;\r\n\r\n\t            if (!isFunction(series.color)) {\r\n\t                series.color = fields.color || seriesColors[i % seriesColors.length];\r\n\t            }\r\n\r\n\t            fields = deepExtend({\r\n\t                index: i,\r\n\t                owner: this$1,\r\n\t                series: series,\r\n\t                dataItem: data[i],\r\n\t                percentage: pointData.value / total\r\n\t            }, fields, { visible: pointData.visible });\r\n\r\n\t            var value = pointData.valueFields.value;\r\n\t            var segment = this$1.createSegment(value, fields);\r\n\t            var label = this$1.createLabel(value, fields);\r\n\r\n\t            if (segment && label) {\r\n\t                segment.append(label);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    evalSegmentOptions: function(options, value, fields) {\r\n\t        var series = fields.series;\r\n\r\n\t        evalOptions(options, {\r\n\t            value: value,\r\n\t            series: series,\r\n\t            dataItem: fields.dataItem,\r\n\t            index: fields.index\r\n\t        }, { defaults: series._defaults, excluded: [ \"data\", \"content\", \"template\", \"toggle\", \"visual\" ] });\r\n\t    },\r\n\r\n\t    createSegment: function(value, fields) {\r\n\t        var seriesOptions = deepExtend({}, fields.series);\r\n\t        this.evalSegmentOptions(seriesOptions, value, fields);\r\n\r\n\t        this.createLegendItem(value, seriesOptions, fields);\r\n\r\n\t        if (fields.visible !== false) {\r\n\r\n\t            var segment = new FunnelSegment(value, seriesOptions, fields);\r\n\t            $.extend(segment, fields);\r\n\r\n\t            this.append(segment);\r\n\t            this.points.push(segment);\r\n\r\n\t            return segment;\r\n\t        }\r\n\t    },\r\n\r\n\t    createLabel: function(value, fields) {\r\n\t        var series = fields.series;\r\n\t        var dataItem = fields.dataItem;\r\n\t        var labels = deepExtend({}, this.options.labels, series.labels);\r\n\t        var text = value;\r\n\r\n\t        if (labels.visible) {\r\n\t            var labelTemplate = getTemplate(labels);\r\n\t            if (labelTemplate) {\r\n\t                text = labelTemplate({\r\n\t                    dataItem: dataItem,\r\n\t                    value: value,\r\n\t                    percentage: fields.percentage,\r\n\t                    category: fields.category,\r\n\t                    series: series\r\n\t                });\r\n\t            } else if (labels.format) {\r\n\t                text = this.plotArea.chartService.format.auto(labels.format, text);\r\n\t            }\r\n\r\n\t            if (!labels.color) {\r\n\t                var brightnessValue = new Color(series.color).percBrightness();\r\n\t                if (brightnessValue > 180) {\r\n\t                    labels.color = BLACK;\r\n\t                } else {\r\n\t                    labels.color = WHITE;\r\n\t                }\r\n\t                if (!labels.background) {\r\n\t                    labels.background = series.color;\r\n\t                }\r\n\t            }\r\n\r\n\t            this.evalSegmentOptions(labels, value, fields);\r\n\t            var textBox = new TextBox(text, deepExtend({\r\n\t                vAlign: labels.position\r\n\t            }, labels));\r\n\r\n\t            this.labels.push(textBox);\r\n\r\n\t            return textBox;\r\n\t        }\r\n\t    },\r\n\r\n\t    labelPadding: function() {\r\n\t        var labels = this.labels;\r\n\t        var padding = { left: 0, right: 0 };\r\n\r\n\t        for (var i = 0; i < labels.length; i++) {\r\n\t            var label = labels[i];\r\n\t            var align = label.options.align;\r\n\t            if (align !== CENTER) {\r\n\t                var width = labels[i].box.width();\r\n\r\n\t                if (align === LEFT) {\r\n\t                    padding.left = Math.max(padding.left, width);\r\n\t                } else {\r\n\t                    padding.right = Math.max(padding.right, width);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        return padding;\r\n\t    },\r\n\r\n\t    dynamicSlopeReflow: function(box, width, totalHeight) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var segments = ref.points;\r\n\t        var count = segments.length;\r\n\t        var firstSegment = segments[0];\r\n\t        var maxSegment = firstSegment;\r\n\r\n\t        for (var idx = 0; idx < segments.length; idx++) {\r\n\t            if (segments[idx].percentage > maxSegment.percentage) {\r\n\t                maxSegment = segments[idx];\r\n\t            }\r\n\t        }\r\n\r\n\t        var lastUpperSide = (firstSegment.percentage / maxSegment.percentage) * width;\r\n\t        var previousOffset = (width - lastUpperSide) / 2;\r\n\t        var previousHeight = 0;\r\n\r\n\t        for (var idx$1 = 0; idx$1 < count; idx$1++) {\r\n\t            var percentage = segments[idx$1].percentage;\r\n\t            var nextSegment = segments[idx$1 + 1];\r\n\t            var nextPercentage = (nextSegment ? nextSegment.percentage : percentage);\r\n\t            var points = segments[idx$1].points = [];\r\n\t            var height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\r\n\t            var offset = (void 0);\r\n\r\n\t            if (!percentage) {\r\n\t                offset = nextPercentage ? 0 : width / 2;\r\n\t            } else {\r\n\t                offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\r\n\t            }\r\n\r\n\t            offset = limitValue(offset, 0, width);\r\n\r\n\t            points.push(new GeometryPoint(box.x1 + previousOffset, box.y1 + previousHeight));\r\n\t            points.push(new GeometryPoint(box.x1 + width - previousOffset, box.y1 + previousHeight));\r\n\t            points.push(new GeometryPoint(box.x1 + width - offset, box.y1 + height + previousHeight));\r\n\t            points.push(new GeometryPoint(box.x1 + offset, box.y1 + height + previousHeight));\r\n\r\n\t            previousOffset = offset;\r\n\t            previousHeight += height + options.segmentSpacing;\r\n\t            lastUpperSide = limitValue(width - 2 * offset, 0, width);\r\n\t        }\r\n\t    },\r\n\r\n\t    constantSlopeReflow: function(box, width, totalHeight) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var segments = ref.points;\r\n\t        var count = segments.length;\r\n\t        var decreasingWidth = options.neckRatio <= 1;\r\n\t        var neckRatio = decreasingWidth ? options.neckRatio * width : width;\r\n\t        var previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\r\n\t        var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\r\n\t        var finalNarrow = (topMostWidth - neckRatio) / 2;\r\n\t        var previousHeight = 0;\r\n\r\n\t        for (var idx = 0; idx < count; idx++) {\r\n\t            var points = segments[idx].points = [];\r\n\t            var percentage = segments[idx].percentage;\r\n\t            var offset = (options.dynamicHeight) ? (finalNarrow * percentage) : (finalNarrow / count);\r\n\t            var height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\r\n\r\n\t            points.push(new GeometryPoint(box.x1 + previousOffset, box.y1 + previousHeight));\r\n\t            points.push(new GeometryPoint(box.x1 + width - previousOffset, box.y1 + previousHeight));\r\n\t            points.push(new GeometryPoint(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\r\n\t            points.push(new GeometryPoint(box.x1 + previousOffset + offset,box.y1 + height + previousHeight));\r\n\t            previousOffset += offset;\r\n\t            previousHeight += height + options.segmentSpacing;\r\n\t        }\r\n\t    },\r\n\r\n\t    reflow: function(chartBox) {\r\n\t        var points = this.points;\r\n\t        var count = points.length;\r\n\r\n\t        if (!count) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var options = this.options;\r\n\t        var box = chartBox.clone().unpad(this.labelPadding());\r\n\t        var totalHeight = box.height() - options.segmentSpacing * (count - 1);\r\n\t        var width = box.width();\r\n\r\n\t        if (options.dynamicSlope) {\r\n\t            this.dynamicSlopeReflow(box, width, totalHeight);\r\n\t        } else {\r\n\t            this.constantSlopeReflow(box, width, totalHeight);\r\n\t        }\r\n\r\n\t        for (var idx = 0; idx < count; idx++) {\r\n\t            points[idx].reflow(chartBox);\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tsetDefaultOptions(FunnelChart, {\r\n\t    neckRatio: 0.3,\r\n\t    width: 300,\r\n\t    dynamicSlope: false,\r\n\t    dynamicHeight: true,\r\n\t    segmentSpacing: 0,\r\n\t    labels: {\r\n\t        visible: false,\r\n\t        align: CENTER,\r\n\t        position: CENTER,\r\n\t        zIndex: 1\r\n\t    }\r\n\t});\r\n\r\n\tdeepExtend(FunnelChart.prototype, PieChartMixin);\r\n\r\n\tvar FunnelPlotArea = PlotAreaBase.extend({\r\n\t    render: function() {\r\n\t        this.createFunnelChart(this.series);\r\n\t    },\r\n\r\n\t    createFunnelChart: function(series) {\r\n\t        var firstSeries = series[0];\r\n\t        var funnelChart = new FunnelChart(this, {\r\n\t            series: series,\r\n\t            legend: this.options.legend,\r\n\t            neckRatio: firstSeries.neckRatio,\r\n\t            dynamicHeight: firstSeries.dynamicHeight,\r\n\t            dynamicSlope: firstSeries.dynamicSlope,\r\n\t            segmentSpacing: firstSeries.segmentSpacing,\r\n\t            highlight: firstSeries.highlight\r\n\t        });\r\n\r\n\t        this.appendChart(funnelChart);\r\n\t    },\r\n\r\n\t    appendChart: function(chart, pane) {\r\n\t        PlotAreaBase.fn.appendChart.call(this, chart, pane);\r\n\t        append(this.options.legend.items, chart.legendItems);\r\n\t    }\r\n\t});\r\n\r\n\tvar COLOR = \"color\";\r\n\tvar FIRST = \"first\";\r\n\tvar FROM = \"from\";\r\n\tvar MAX = \"max\";\r\n\tvar MIN = \"min\";\r\n\tvar NOTE_TEXT = \"noteText\";\r\n\tvar SUMMARY_FIELD = \"summary\";\r\n\tvar TO = \"to\";\r\n\r\n\tPlotAreaFactory.current.register(CategoricalPlotArea, [\r\n\t    BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA,\r\n\t    CANDLESTICK, OHLC, BULLET, VERTICAL_BULLET, BOX_PLOT, VERTICAL_BOX_PLOT,\r\n\t    RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL, RANGE_AREA, VERTICAL_RANGE_AREA\r\n\t]);\r\n\r\n\tPlotAreaFactory.current.register(XYPlotArea, [\r\n\t    SCATTER, SCATTER_LINE, BUBBLE\r\n\t]);\r\n\r\n\tPlotAreaFactory.current.register(PiePlotArea, [ PIE ]);\r\n\tPlotAreaFactory.current.register(DonutPlotArea, [ DONUT ]);\r\n\tPlotAreaFactory.current.register(FunnelPlotArea, [ FUNNEL ]);\r\n\r\n\tPlotAreaFactory.current.register(PolarPlotArea, [ POLAR_AREA, POLAR_LINE, POLAR_SCATTER ]);\r\n\tPlotAreaFactory.current.register(RadarPlotArea, [ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ]);\r\n\r\n\tSeriesBinder.current.register(\r\n\t    [ BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA ],\r\n\t    [ VALUE ], [ CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD ]\r\n\t);\r\n\r\n\tSeriesBinder.current.register(\r\n\t    [ RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA ],\r\n\t    [ FROM, TO ], [ CATEGORY, COLOR, NOTE_TEXT ]\r\n\t);\r\n\r\n\tSeriesBinder.current.register(\r\n\t    [ WATERFALL, HORIZONTAL_WATERFALL ],\r\n\t    [ VALUE ], [ CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD ]\r\n\t);\r\n\r\n\tSeriesBinder.current.register([ POLAR_AREA, POLAR_LINE, POLAR_SCATTER ], [ X, Y ], [ COLOR ]);\r\n\tSeriesBinder.current.register([ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ], [ VALUE ], [ COLOR ]);\r\n\r\n\tSeriesBinder.current.register(\r\n\t    [ FUNNEL ],\r\n\t    [ VALUE ], [ CATEGORY, COLOR, \"visibleInLegend\", \"visible\" ]\r\n\t);\r\n\r\n\tDefaultAggregates.current.register(\r\n\t    [ BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL ],\r\n\t    { value: MAX, color: FIRST, noteText: FIRST, errorLow: MIN, errorHigh: MAX }\r\n\t);\r\n\r\n\tDefaultAggregates.current.register(\r\n\t    [ RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA ],\r\n\t    { from: MIN, to: MAX, color: FIRST, noteText: FIRST }\r\n\t);\r\n\r\n\tDefaultAggregates.current.register(\r\n\t    [ RADAR_AREA, RADAR_COLUMN, RADAR_LINE ],\r\n\t    { value: MAX, color: FIRST }\r\n\t);\r\n\r\n\tSeriesBinder.current.register(\r\n\t    [ SCATTER, SCATTER_LINE, BUBBLE ],\r\n\t    [ X, Y ], [ COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD ]\r\n\t);\r\n\r\n\tSeriesBinder.current.register(\r\n\t    [ BUBBLE ], [ X, Y, \"size\" ], [ COLOR, CATEGORY, NOTE_TEXT ]\r\n\t);\r\n\r\n\tSeriesBinder.current.register(\r\n\t    [ CANDLESTICK, OHLC ],\r\n\t    [ \"open\", \"high\", \"low\", \"close\" ], [ CATEGORY, COLOR, \"downColor\", NOTE_TEXT ]\r\n\t);\r\n\r\n\tDefaultAggregates.current.register(\r\n\t    [ CANDLESTICK, OHLC ],\r\n\t    { open: MAX, high: MAX, low: MIN, close: MAX,\r\n\t      color: FIRST, downColor: FIRST, noteText: FIRST }\r\n\t);\r\n\r\n\tSeriesBinder.current.register(\r\n\t    [ BOX_PLOT, VERTICAL_BOX_PLOT ],\r\n\t    [ \"lower\", \"q1\", \"median\", \"q3\", \"upper\", \"mean\", \"outliers\" ], [ CATEGORY, COLOR, NOTE_TEXT ]\r\n\t);\r\n\r\n\tDefaultAggregates.current.register(\r\n\t    [ BOX_PLOT, VERTICAL_BOX_PLOT ],\r\n\t    { lower: MAX, q1: MAX, median: MAX, q3: MAX, upper: MAX, mean: MAX, outliers: FIRST,\r\n\t      color: FIRST, noteText: FIRST }\r\n\t);\r\n\r\n\tSeriesBinder.current.register(\r\n\t    [ BULLET, VERTICAL_BULLET ],\r\n\t    [ \"current\", \"target\" ], [ CATEGORY, COLOR, \"visibleInLegend\", NOTE_TEXT ]\r\n\t);\r\n\r\n\tDefaultAggregates.current.register(\r\n\t    [ BULLET, VERTICAL_BULLET ],\r\n\t    { current: MAX, target: MAX, color: FIRST, noteText: FIRST }\r\n\t);\r\n\r\n\tSeriesBinder.current.register(\r\n\t    [ PIE, DONUT ],\r\n\t    [ VALUE ], [ CATEGORY, COLOR, \"explode\", \"visibleInLegend\", \"visible\" ]\r\n\t);\r\n\r\n\tvar AXIS_NAMES = [ CATEGORY, VALUE, X, Y ];\r\n\r\n\tvar MOUSEMOVE = \"mousemove\";\r\n\tvar CONTEXTMENU = \"contextmenu\";\r\n\tvar MOUSEMOVE_DELAY = 20;\r\n\r\n\tvar Chart = Class.extend({\r\n\t    init: function(element, userOptions, themeOptions, context) {\r\n\t        var this$1 = this;\r\n\t        if (context === void 0) { context = {}; }\r\n\r\n\t        this.observers = [];\r\n\t        this.addObserver(context.observer);\r\n\t        this.chartService = new services.ChartService(this, context);\r\n\t        this.chartService.theme = themeOptions;\r\n\r\n\t        this._initElement(element);\r\n\r\n\t        var options = deepExtend({}, this.options, userOptions);\r\n\t        this._originalOptions = deepExtend({}, options);\r\n\t        this._theme = themeOptions;\r\n\t        this._initTheme(options, themeOptions);\r\n\r\n\t        this._initSurface();\r\n\r\n\t        this._initHandlers();\r\n\r\n\t        this.bindCategories();\r\n\t        dataviz.FontLoader.preloadFonts(userOptions, function () {\r\n\t            if (!this$1._destroyed) {\r\n\t                this$1.trigger('init');\r\n\t                this$1._redraw();\r\n\t                this$1._attachEvents();\r\n\t            }\r\n\t        });\r\n\t    },\r\n\r\n\t    _initElement: function(element) {\r\n\t        this._setElementClass(element);\r\n\t        element.style.position = \"relative\";\r\n\t        while (element.firstChild) {\r\n\t            element.removeChild(element.firstChild);\r\n\t        }\r\n\t        this.element = element;\r\n\t    },\r\n\r\n\t    _setElementClass: function(element) {\r\n\t        dataviz.addClass(element, \"k-chart\");\r\n\t    },\r\n\r\n\t    _initTheme: function(options, themeOptions) {\r\n\t        var seriesCopies = [];\r\n\t        var series = options.series || [];\r\n\r\n\t        for (var i = 0; i < series.length; i++) {\r\n\t            seriesCopies.push($.extend({}, series[i]));\r\n\t        }\r\n\t        options.series = seriesCopies;\r\n\r\n\t        resolveAxisAliases(options);\r\n\t        this.applyDefaults(options, themeOptions);\r\n\r\n\t        // Clean up default if not overriden by data attributes\r\n\t        if (options.seriesColors === null) {\r\n\t            delete options.seriesColors;\r\n\t        }\r\n\r\n\t        this.options = deepExtend({}, themeOptions, options);\r\n\t        this.applySeriesColors();\r\n\t    },\r\n\r\n\t    getSize: function() {\r\n\t        return { width: this.element.offsetWidth, height: this.element.offsetHeight };\r\n\t        // return kendo.dimensions(this.element);\r\n\t    },\r\n\r\n\t    resize: function(force) {\r\n\t        var size = this.getSize();\r\n\t        var currentSize = this._size;\r\n\r\n\t        if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\r\n\t            this._size = size;\r\n\t            this._resize(size, force);\r\n\t            this.trigger(\"resize\", size);\r\n\t        }\r\n\t    },\r\n\r\n\t    _resize: function() {\r\n\t        this._noTransitionsRedraw();\r\n\t    },\r\n\r\n\t    redraw: function(paneName) {\r\n\t        this.applyDefaults(this.options);\r\n\t        this.applySeriesColors();\r\n\r\n\t        if (paneName) {\r\n\t            var plotArea = this._model._plotArea;\r\n\t            var pane = plotArea.findPane(paneName);\r\n\t            plotArea.redraw(pane);\r\n\t        } else {\r\n\t            this._redraw();\r\n\t        }\r\n\t    },\r\n\r\n\t    getAxis: function(name) {\r\n\t        var axes = this._plotArea.axes;\r\n\r\n\t        for (var idx = 0; idx < axes.length; idx++) {\r\n\t            if (axes[idx].options.name === name) {\r\n\t                return new ChartAxis(axes[idx]);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    findAxisByName: function(name) {\r\n\t        return this.getAxis(name);\r\n\t    },\r\n\r\n\t    findPaneByName: function(name) {\r\n\t        var panes = this._plotArea.panes;\r\n\r\n\t        for (var idx = 0; idx < panes.length; idx++) {\r\n\t            if (panes[idx].options.name === name) {\r\n\t                return new ChartPane(panes[idx]);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    findPaneByIndex: function(idx) {\r\n\t        var panes = this._plotArea.panes;\r\n\t        if (panes[idx]) {\r\n\t            return new ChartPane(panes[idx]);\r\n\t        }\r\n\t    },\r\n\r\n\t    plotArea: function() {\r\n\t        return new ChartPlotArea(this._plotArea);\r\n\t    },\r\n\r\n\t    toggleHighlight: function(show, filter) {\r\n\t        var plotArea = this._plotArea;\r\n\t        var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];\r\n\t        var points;\r\n\r\n\t        if (isFunction(filter)) {\r\n\t            points = plotArea.filterPoints(filter);\r\n\t        } else {\r\n\t            var seriesName, categoryName;\r\n\t            if (isObject(filter)) {\r\n\t                seriesName = filter.series;\r\n\t                categoryName = filter.category;\r\n\t            } else {\r\n\t                seriesName = categoryName = filter;\r\n\t            }\r\n\r\n\t            if (firstSeries.type === DONUT) {\r\n\t                points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);\r\n\t            } else if (firstSeries.type === PIE || firstSeries.type === FUNNEL) {\r\n\t                points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);\r\n\t            } else {\r\n\t                points = plotArea.pointsBySeriesName(seriesName);\r\n\t            }\r\n\t        }\r\n\r\n\t        if (points) {\r\n\t            this.togglePointsHighlight(show, points);\r\n\t        }\r\n\t    },\r\n\r\n\t    togglePointsHighlight: function(show, points) {\r\n\t        var highlight = this._highlight;\r\n\t        for (var idx = 0; idx < points.length; idx++) {\r\n\t            highlight.togglePointHighlight(points[idx], show);\r\n\t        }\r\n\t    },\r\n\r\n\t    showTooltip: function(filter) {\r\n\t        var shared = this._sharedTooltip();\r\n\t        var ref = this;\r\n\t        var tooltip = ref._tooltip;\r\n\t        var plotArea = ref._plotArea;\r\n\t        var point, categoryIndex;\r\n\r\n\t        if (isFunction(filter)) {\r\n\t            point = plotArea.findPoint(filter);\r\n\t            if (point && shared) {\r\n\t                categoryIndex = point.categoryIx;\r\n\t            }\r\n\t        } else if (shared && defined(filter)) {\r\n\t            categoryIndex = plotArea.categoryAxis.categoryIndex(filter);\r\n\t        }\r\n\r\n\t        if (shared) {\r\n\t            if (categoryIndex >= 0) {\r\n\t                var points = this._plotArea.pointsByCategoryIndex(categoryIndex);\r\n\t                tooltip.showAt(points);\r\n\t            }\r\n\t        } else if (point) {\r\n\t            tooltip.show(point);\r\n\t        }\r\n\t    },\r\n\r\n\t    hideTooltip: function() {\r\n\t        this._tooltip.hide();\r\n\t    },\r\n\r\n\t    _initSurface: function() {\r\n\t        var surface = this.surface;\r\n\t        var wrap = this._surfaceWrap();\r\n\r\n\t        var chartArea = this.options.chartArea;\r\n\t        if (chartArea.width) {\r\n\t            dataviz.elementSize(wrap, { width: chartArea.width });\r\n\t        }\r\n\t        if (chartArea.height) {\r\n\t            dataviz.elementSize(wrap, { height: chartArea.height });\r\n\t        }\r\n\r\n\t        if (!surface || surface.options.type !== this.options.renderAs) {\r\n\t            if (surface) {\r\n\t                surface.destroy();\r\n\t            }\r\n\r\n\t            this.surface = drawing.Surface.create(wrap, {\r\n\t                type: this.options.renderAs\r\n\t            });\r\n\r\n\t        } else {\r\n\t            this.surface.clear();\r\n\t            this.surface.resize();\r\n\t        }\r\n\t    },\r\n\r\n\t    _surfaceWrap: function() {\r\n\t        return this.element;\r\n\t    },\r\n\r\n\t    _redraw: function() {\r\n\t        var model = this._getModel();\r\n\r\n\t        this._destroyView();\r\n\r\n\t        this._model = model;\r\n\t        this._plotArea = model._plotArea;\r\n\r\n\t        model.renderVisual();\r\n\r\n\t        if (this.options.transitions !== false) {\r\n\t            model.traverse(function(element) {\r\n\t                if (element.animation) {\r\n\t                    element.animation.setup();\r\n\t                }\r\n\t            });\r\n\t        }\r\n\r\n\t        this._initSurface();\r\n\t        this.surface.draw(model.visual);\r\n\r\n\t        if (this.options.transitions !== false) {\r\n\t            model.traverse(function(element) {\r\n\t                if (element.animation) {\r\n\t                    element.animation.play();\r\n\t                }\r\n\t            });\r\n\t        }\r\n\r\n\t        this._tooltip = this._createTooltip();\r\n\t        this._highlight = new Highlight();\r\n\t        this._setupSelection();\r\n\t        this._createPannable();\r\n\t        this._createZoomSelection();\r\n\t        this._createMousewheelZoom();\r\n\r\n\t        this.trigger(RENDER);\r\n\r\n\t        if (!this._navState) {\r\n\t            this._cancelDomEvents();\r\n\t        }\r\n\t    },\r\n\r\n\t    exportVisual: function(exportOptions) {\r\n\t        var visual;\r\n\t        if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {\r\n\t            var currentOptions = this.options;\r\n\t            var options = deepExtend({}, exportOptions.options, {\r\n\t                chartArea: {\r\n\t                    width: exportOptions.width,\r\n\t                    height: exportOptions.height\r\n\t                }\r\n\t            });\r\n\r\n\t            clearMissingValues(this._originalOptions, options);\r\n\t            this.options = deepExtend({}, this._originalOptions, options);\r\n\t            this._initTheme(this.options, this._theme);\r\n\t            this.bindCategories();\r\n\r\n\t            var model = this._getModel();\r\n\r\n\t            model.renderVisual();\r\n\t            visual = model.visual;\r\n\r\n\t            this.options = currentOptions;\r\n\t        } else {\r\n\t            visual = this.surface.exportVisual();\r\n\t        }\r\n\r\n\t        return visual;\r\n\t    },\r\n\r\n\t    _sharedTooltip: function() {\r\n\t        return this._plotArea instanceof CategoricalPlotArea && this.options.tooltip.shared;\r\n\t    },\r\n\r\n\t    _createPannable: function() {\r\n\t        var options = this.options;\r\n\t        if (options.pannable !== false) {\r\n\t            this._pannable = new Pannable(this._plotArea, options.pannable);\r\n\t        }\r\n\t    },\r\n\r\n\t    _createZoomSelection: function() {\r\n\t        var zoomable = this.options.zoomable;\r\n\t        var selection = (zoomable || {}).selection;\r\n\t        if (zoomable !== false && selection !== false) {\r\n\t            this._zoomSelection = new ZoomSelection(this, selection);\r\n\t        }\r\n\t    },\r\n\r\n\t    _toggleDomDrag: function() {\r\n\t        if (!this.domEvents || !this.domEvents.toggleDrag) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var pannable = this.options.pannable;\r\n\t        var zoomable = this.options.zoomable;\r\n\t        var selection = (zoomable || {}).selection;\r\n\t        if (!pannable && (zoomable === false || selection === false) && !this.requiresHandlers([ DRAG_START, DRAG, DRAG_END ])) {\r\n\t            this.domEvents.toggleDrag(false);\r\n\t        } else {\r\n\t            this.domEvents.toggleDrag(true);\r\n\t        }\r\n\t    },\r\n\r\n\t    _createMousewheelZoom: function() {\r\n\t        var zoomable = this.options.zoomable;\r\n\t        var mousewheel = (zoomable || {}).mousewheel;\r\n\t        if (zoomable !== false && mousewheel !== false) {\r\n\t            this._mousewheelZoom = new MousewheelZoom(this, mousewheel);\r\n\t        }\r\n\t    },\r\n\r\n\t    _toggleDomZoom: function() {\r\n\t        if (!this.domEvents || !this.domEvents.toggleZoom) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var zoomable = this.options.zoomable;\r\n\t        var mousewheel = (zoomable || {}).mousewheel;\r\n\t        if ((zoomable === false || mousewheel === false) && !this.requiresHandlers([ ZOOM_START, ZOOM, ZOOM_END ])) {\r\n\t            this.domEvents.toggleZoom(false);\r\n\t        } else {\r\n\t            this.domEvents.toggleZoom(true);\r\n\t        }\r\n\t    },\r\n\r\n\t    _createTooltip: function() {\r\n\t        var ref = this;\r\n\t        var tooltipOptions = ref.options.tooltip;\r\n\t        var tooltip;\r\n\r\n\t        if (this._sharedTooltip()) {\r\n\t            tooltip = this._createSharedTooltip(tooltipOptions);\r\n\t        } else {\r\n\t            tooltip = new Tooltip(this.chartService, tooltipOptions);\r\n\t        }\r\n\r\n\t        return tooltip;\r\n\t    },\r\n\r\n\t    _createSharedTooltip: function(options) {\r\n\t        return new SharedTooltip(this._plotArea, options);\r\n\t    },\r\n\r\n\t    applyDefaults: function(options, themeOptions) {\r\n\t        applyAxisDefaults(options, themeOptions);\r\n\t        applySeriesDefaults(options, themeOptions);\r\n\t    },\r\n\r\n\t    applySeriesColors: function() {\r\n\t        var options = this.options;\r\n\t        var series = options.series;\r\n\t        var colors = options.seriesColors || [];\r\n\r\n\t        for (var i = 0; i < series.length; i++) {\r\n\t            var currentSeries = series[i];\r\n\t            var seriesColor = colors[i % colors.length];\r\n\t            var defaults = currentSeries._defaults;\r\n\r\n\t            currentSeries.color = currentSeries.color || seriesColor;\r\n\t            if (defaults) {\r\n\t                defaults.color = defaults.color || seriesColor;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _getModel: function() {\r\n\t        var options = this.options;\r\n\t        var plotArea = this._createPlotArea();\r\n\t        var model = new dataviz.RootElement(this._modelOptions());\r\n\t        model.chart = this;\r\n\t        model._plotArea = plotArea;\r\n\r\n\t        dataviz.Title.buildTitle(options.title, model);\r\n\r\n\t        if (options.legend.visible) {\r\n\t            model.append(new Legend(plotArea.options.legend, this.chartService));\r\n\t        }\r\n\t        model.append(plotArea);\r\n\t        model.reflow();\r\n\r\n\t        return model;\r\n\t    },\r\n\r\n\t    _modelOptions: function() {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var element = ref.element;\r\n\t        var size = dataviz.elementSize(element);\r\n\r\n\t        this._size = null;\r\n\r\n\t        return deepExtend({\r\n\t            width: Math.floor(size.width) || datavizConstants.DEFAULT_WIDTH,\r\n\t            height: Math.floor(size.height) || datavizConstants.DEFAULT_HEIGHT,\r\n\t            transitions: options.transitions\r\n\t        }, options.chartArea);\r\n\t    },\r\n\r\n\t    _createPlotArea: function(skipSeries) {\r\n\t        var options = this.options;\r\n\r\n\t        var plotArea = PlotAreaFactory.current.create(skipSeries ? [] : options.series, options, this.chartService);\r\n\r\n\t        return plotArea;\r\n\t    },\r\n\r\n\t    _hasSelection: function() {\r\n\t        return this._selections && this._selections.length;\r\n\t    },\r\n\r\n\t    _setupSelection: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var ref = this;\r\n\t        var axes = ref._plotArea.axes;\r\n\t        var selections = this._selections = [];\r\n\r\n\t        for (var i = 0; i < axes.length; i++) {\r\n\t            var axis = axes[i];\r\n\t            var options = axis.options;\r\n\t            if (axis instanceof CategoryAxis && options.select && !options.vertical) {\r\n\t                var min = 0;\r\n\t                var max = options.categories.length - 1;\r\n\r\n\t                if (axis instanceof DateCategoryAxis) {\r\n\t                    min = options.categories[min];\r\n\t                    max = options.categories[max];\r\n\t                }\r\n\r\n\t                if (!options.justified) {\r\n\t                    if (axis instanceof DateCategoryAxis) {\r\n\t                        max = dataviz.addDuration(max, 1, options.baseUnit, options.weekStartDay);\r\n\t                    } else {\r\n\t                        max++;\r\n\t                    }\r\n\t                }\r\n\r\n\t                var selection = new Selection(this$1, axis,\r\n\t                    deepExtend({ min: min, max: max }, options.select)\r\n\t                );\r\n\r\n\t                selections.push(selection);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _selectStart: function(e) {\r\n\t        return this.trigger(SELECT_START, e);\r\n\t    },\r\n\r\n\t    _select: function(e) {\r\n\t        return this.trigger(SELECT, e);\r\n\t    },\r\n\r\n\t    _selectEnd: function(e) {\r\n\t        return this.trigger(SELECT_END, e);\r\n\t    },\r\n\r\n\t    _initHandlers: function() {\r\n\t        this._clickHandler = this._click.bind(this);\r\n\t        this._mousewheelHandler = this._mousewheel.bind(this);\r\n\t        this._surfaceMouseenterHandler = this._mouseover.bind(this);\r\n\t        this._surfaceMouseleaveHandler = this._mouseout.bind(this);\r\n\r\n\t        this._mousemove = kendo.throttle(\r\n\t            this._mousemove.bind(this),\r\n\t            MOUSEMOVE_DELAY\r\n\t        );\r\n\t    },\r\n\r\n\t    addObserver: function(observer) {\r\n\t        if (observer) {\r\n\t            this.observers.push(observer);\r\n\t        }\r\n\t    },\r\n\r\n\t    removeObserver: function(observer) {\r\n\t        var index = this.observers.indexOf(observer);\r\n\t        if (index >= 0) {\r\n\t            this.observers.splice(index, 1);\r\n\t        }\r\n\t    },\r\n\r\n\t    requiresHandlers: function(eventNames) {\r\n\t        var observers = this.observers;\r\n\t        for (var idx = 0; idx < observers.length; idx++) {\r\n\t            if (observers[idx].requiresHandlers(eventNames)) {\r\n\t                return true;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    trigger: function(name, args) {\r\n\t        if (args === void 0) { args = {}; }\r\n\r\n\t        if (name === SHOW_TOOLTIP) {\r\n\t            args.anchor.point = this._toDocumentCoordinates(args.anchor.point);\r\n\t        }\r\n\t        args.sender = this;\r\n\r\n\t        var observers = this.observers;\r\n\t        var isDefaultPrevented = false;\r\n\t        for (var idx = 0; idx < observers.length; idx++) {\r\n\t            if (observers[idx].trigger(name, args)) {\r\n\t                isDefaultPrevented = true;\r\n\t            }\r\n\t        }\r\n\r\n\t        return isDefaultPrevented;\r\n\t    },\r\n\r\n\t    _attachEvents: function() {\r\n\t        var ref = this;\r\n\t        var element = ref.element;\r\n\t        var surface = ref.surface;\r\n\r\n\t        surface.bind(\"mouseenter\", this._surfaceMouseenterHandler);\r\n\t        surface.bind(\"mouseleave\", this._surfaceMouseleaveHandler);\r\n\t        var obj;\r\n\t        bindEvents(element, ( obj = {}, obj[ CONTEXTMENU ] = this._clickHandler, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj ));\r\n\r\n\t        if (this._shouldAttachMouseMove()) {\r\n\t            var obj$1;\r\n\t            bindEvents(element, ( obj$1 = {}, obj$1[ MOUSEMOVE ] = this._mousemove, obj$1 ));\r\n\t        }\r\n\r\n\t        this.domEvents = services.DomEventsBuilder.create(this.element, {\r\n\t            start: this._start.bind(this),\r\n\t            move: this._move.bind(this),\r\n\t            end: this._end.bind(this),\r\n\t            tap: this._tap.bind(this),\r\n\t            gesturestart: this._gesturestart.bind(this),\r\n\t            gesturechange: this._gesturechange.bind(this),\r\n\t            gestureend: this._gestureend.bind(this)\r\n\t        });\r\n\r\n\t        this._toggleDomDrag();\r\n\t        this._toggleDomZoom();\r\n\t    },\r\n\r\n\t    _cancelDomEvents: function() {\r\n\t        if (this.domEvents && this.domEvents.cancel) {\r\n\t            this.domEvents.cancel();\r\n\t        }\r\n\t    },\r\n\r\n\t    _gesturestart: function(e) {\r\n\t        if (this._mousewheelZoom && !this._stopDragEvent(e)) {\r\n\t            this._gestureDistance = e.distance;\r\n\t            this._unsetActivePoint();\r\n\t            this.surface.suspendTracking();\r\n\t        }\r\n\t    },\r\n\r\n\t    _gestureend: function(e) {\r\n\t        if (this._zooming && !this._stopDragEvent(e)) {\r\n\t            if (this.surface) {\r\n\t                this.surface.resumeTracking();\r\n\t            }\r\n\t            this._zooming = false;\r\n\t            this.trigger(ZOOM_END, {});\r\n\t        }\r\n\t    },\r\n\r\n\t    _gesturechange: function(e) {\r\n\t        var mousewheelZoom = this._mousewheelZoom;\r\n\r\n\t        if (mousewheelZoom && !this._stopDragEvent(e)) {\r\n\t            e.preventDefault();\r\n\t            var previousGestureDistance = this._gestureDistance;\r\n\t            var scaleDelta = -e.distance / previousGestureDistance + 1;\r\n\r\n\t            if (Math.abs(scaleDelta) >= 0.1) {\r\n\t                scaleDelta = Math.round(scaleDelta * 10);\r\n\r\n\t                this._gestureDistance = e.distance;\r\n\t                var args = { delta: scaleDelta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };\r\n\t                if (this._zooming || !this.trigger(ZOOM_START, args)) {\r\n\r\n\t                    if (!this._zooming) {\r\n\t                        this._zooming = true;\r\n\t                    }\r\n\r\n\t                    var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta);\r\n\t                    if (ranges && !this.trigger(ZOOM, args)) {\r\n\t                        mousewheelZoom.zoom();\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _mouseout: function(e) {\r\n\t        if (e.element) {\r\n\t            var element = this._drawingChartElement(e.element, e);\r\n\r\n\t            if (element && element.leave) {\r\n\t                element.leave(this, e.originalEvent);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _start: function(e) {\r\n\t        var coords = this._eventCoordinates(e);\r\n\r\n\t        if (this._stopDragEvent(e) || !this._plotArea.backgroundContainsPoint(coords)) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        if (this.requiresHandlers([ DRAG_START, DRAG, DRAG_END ])) {\r\n\t            this._startNavigation(e, coords, DRAG_START);\r\n\t        }\r\n\r\n\t        if (this._pannable && this._pannable.start(e)) {\r\n\t            this.surface.suspendTracking();\r\n\t            this._unsetActivePoint();\r\n\t            this._suppressHover = true;\r\n\t        }\r\n\r\n\t        if (this._zoomSelection) {\r\n\t            if (this._zoomSelection.start(e)) {\r\n\t                this.trigger(ZOOM_START, { axisRanges: axisRanges(this._plotArea.axes), originalEvent: e });\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _move: function(e) {\r\n\t        var ref = this;\r\n\t        var state = ref._navState;\r\n\t        var pannable = ref._pannable;\r\n\r\n\t        if (this._stopDragEvent(e)) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        if (pannable) {\r\n\t            var ranges = pannable.move(e);\r\n\r\n\t            if (ranges && !this.trigger(DRAG, { axisRanges: ranges, originalEvent: e })) {\r\n\t                pannable.pan();\r\n\t            }\r\n\t        } else if (state) {\r\n\t            var ranges$1 = {};\r\n\t            var axes = state.axes;\r\n\r\n\t            for (var i = 0; i < axes.length; i++) {\r\n\t                var currentAxis = axes[i];\r\n\t                var axisName = currentAxis.options.name;\r\n\t                if (axisName) {\r\n\t                    var axis = currentAxis.options.vertical ? e.y : e.x;\r\n\t                    var delta = axis.startLocation - axis.location;\r\n\r\n\t                    if (delta !== 0) {\r\n\t                        ranges$1[currentAxis.options.name] = currentAxis.translateRange(delta);\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            state.axisRanges = ranges$1;\r\n\t            this.trigger(DRAG, {\r\n\t                axisRanges: ranges$1,\r\n\t                originalEvent: e\r\n\t            });\r\n\t        }\r\n\r\n\t        if (this._zoomSelection) {\r\n\t            this._zoomSelection.move(e);\r\n\t        }\r\n\t    },\r\n\r\n\t    _end: function(e) {\r\n\t        if (this._stopDragEvent(e)) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var pannable = this._pannable;\r\n\t        if (pannable && pannable.end(e)) {\r\n\t            this.surface.resumeTracking();\r\n\t            this.trigger(DRAG_END, {\r\n\t                axisRanges: axisRanges(this._plotArea.axes),\r\n\t                originalEvent: e\r\n\t            });\r\n\t            this._suppressHover = false;\r\n\t        } else {\r\n\t            this._endNavigation(e, DRAG_END);\r\n\t        }\r\n\r\n\t        if (this._zoomSelection) {\r\n\t            var ranges = this._zoomSelection.end(e);\r\n\t            if (ranges && !this.trigger(ZOOM, { axisRanges: ranges, originalEvent: e })) {\r\n\t                this._zoomSelection.zoom();\r\n\t                this.trigger(ZOOM_END, { axisRanges: ranges, originalEvent: e });\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _stopDragEvent: function() {\r\n\t        return this._hasSelection();\r\n\t    },\r\n\r\n\t    _mousewheel: function(e) {\r\n\t        var this$1 = this;\r\n\r\n\t        var delta = dataviz.mousewheelDelta(e);\r\n\t        var mousewheelZoom = this._mousewheelZoom;\r\n\t        var coords = this._eventCoordinates(e);\r\n\r\n\t        if (!this._plotArea.backgroundContainsPoint(coords)) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        if (mousewheelZoom) {\r\n\t            var args = { delta: delta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };\r\n\t            if (this._zooming || !this.trigger(ZOOM_START, args)) {\r\n\t                e.preventDefault();\r\n\r\n\t                if (!this._zooming) {\r\n\t                    this._unsetActivePoint();\r\n\t                    this.surface.suspendTracking();\r\n\t                    this._zooming = true;\r\n\t                }\r\n\r\n\t                if (this._mwTimeout) {\r\n\t                    clearTimeout(this._mwTimeout);\r\n\t                }\r\n\r\n\t                args.axisRanges = mousewheelZoom.updateRanges(delta);\r\n\t                if (args.axisRanges && !this.trigger(ZOOM, args)) {\r\n\t                    mousewheelZoom.zoom();\r\n\t                }\r\n\r\n\t                this._mwTimeout = setTimeout(function () {\r\n\t                    this$1.trigger(ZOOM_END, args);\r\n\t                    this$1._zooming = false;\r\n\t                    if (this$1.surface) {\r\n\t                        this$1.surface.resumeTracking();\r\n\t                    }\r\n\t                }, MOUSEWHEEL_DELAY);\r\n\t            }\r\n\t        } else {\r\n\t            var state = this._navState;\r\n\t            if (!state) {\r\n\t                var prevented = this._startNavigation(e, coords, ZOOM_START);\r\n\t                if (!prevented) {\r\n\t                    state = this._navState;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (state) {\r\n\t                var totalDelta = state.totalDelta || delta;\r\n\t                state.totalDelta = totalDelta + delta;\r\n\r\n\t                var axes = this._navState.axes;\r\n\t                var ranges = {};\r\n\r\n\t                for (var i = 0; i < axes.length; i++) {\r\n\t                    var currentAxis = axes[i];\r\n\t                    var axisName = currentAxis.options.name;\r\n\t                    if (axisName) {\r\n\t                        ranges[axisName] = currentAxis.scaleRange(-totalDelta);\r\n\t                    }\r\n\t                }\r\n\r\n\t                this.trigger(ZOOM, {\r\n\t                    delta: delta,\r\n\t                    axisRanges: ranges,\r\n\t                    originalEvent: e\r\n\t                });\r\n\r\n\t                if (this._mwTimeout) {\r\n\t                    clearTimeout(this._mwTimeout);\r\n\t                }\r\n\r\n\t                this._mwTimeout = setTimeout(function () {\r\n\t                    this$1._endNavigation(e, ZOOM_END);\r\n\t                }, MOUSEWHEEL_DELAY);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _startNavigation: function(e, coords, chartEvent) {\r\n\t        var plotArea = this._model._plotArea;\r\n\t        var pane = plotArea.findPointPane(coords);\r\n\t        var axes = plotArea.axes.slice(0);\r\n\r\n\t        if (!pane) {\r\n\t            return;\r\n\t        }\r\n\r\n\t        var ranges = axisRanges(axes);\r\n\r\n\t        var prevented = this.trigger(chartEvent, {\r\n\t            axisRanges: ranges,\r\n\t            originalEvent: e\r\n\t        });\r\n\r\n\t        if (prevented) {\r\n\t            this._cancelDomEvents();\r\n\t        } else {\r\n\t            this._suppressHover = true;\r\n\t            this._unsetActivePoint();\r\n\t            this._navState = {\r\n\t                axisRanges: ranges,\r\n\t                pane: pane,\r\n\t                axes: axes\r\n\t            };\r\n\t        }\r\n\t    },\r\n\r\n\t    _endNavigation: function(e, chartEvent) {\r\n\t        if (this._navState) {\r\n\t            this.trigger(chartEvent, {\r\n\t                axisRanges: this._navState.axisRanges,\r\n\t                originalEvent: e\r\n\t            });\r\n\t            this._suppressHover = false;\r\n\t            this._navState = null;\r\n\t        }\r\n\t    },\r\n\r\n\t    _getChartElement: function(e, match) {\r\n\t        var element = this.surface.eventTarget(e);\r\n\t        if (element) {\r\n\t            return this._drawingChartElement(element, e, match);\r\n\t        }\r\n\t    },\r\n\r\n\t    _drawingChartElement: function(element, e, match) {\r\n\t        var current = element;\r\n\t        var chartElement;\r\n\t        while (current && !chartElement) {\r\n\t            chartElement = current.chartElement;\r\n\t            current = current.parent;\r\n\t        }\r\n\r\n\t        if (chartElement) {\r\n\t            if (chartElement.aliasFor) {\r\n\t                chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));\r\n\t            }\r\n\r\n\t            if (match) {\r\n\t                chartElement = chartElement.closest(match);\r\n\t                if (chartElement && chartElement.aliasFor) {\r\n\t                    chartElement = chartElement.aliasFor();\r\n\t                }\r\n\t            }\r\n\r\n\t            return chartElement;\r\n\t        }\r\n\t    },\r\n\r\n\t    _eventCoordinates: function(e) {\r\n\t        var coordinates = dataviz.eventCoordinates(e);\r\n\t        return this._toModelCoordinates(coordinates.x, coordinates.y);\r\n\t    },\r\n\r\n\t    _elementPadding: function() {\r\n\t        if (!this._padding) {\r\n\t            var ref = elementStyles(this.element, [ \"paddingLeft\", \"paddingTop\" ]);\r\n\t            var paddingLeft = ref.paddingLeft;\r\n\t            var paddingTop = ref.paddingTop;\r\n\t            this._padding = {\r\n\t                top: paddingTop,\r\n\t                left: paddingLeft\r\n\t            };\r\n\t        }\r\n\r\n\t        return this._padding;\r\n\t    },\r\n\r\n\t    _toDocumentCoordinates: function(point) {\r\n\t        var padding = this._elementPadding();\r\n\t        var offset = dataviz.elementOffset(this.element);\r\n\r\n\t        return {\r\n\t            left: round(point.x + padding.left + offset.left),\r\n\t            top: round(point.y + padding.top + offset.top)\r\n\t        };\r\n\t    },\r\n\r\n\t    _toModelCoordinates: function(clientX, clientY) {\r\n\t        var element = this.element;\r\n\t        var offset = dataviz.elementOffset(element);\r\n\t        var padding = this._elementPadding();\r\n\r\n\t        return new Point(\r\n\t            clientX - offset.left - padding.left,\r\n\t            clientY - offset.top - padding.top\r\n\t        );\r\n\t    },\r\n\r\n\t    _tap: function(e) {\r\n\t        var this$1 = this;\r\n\r\n\t        var drawingElement = this.surface.eventTarget(e);\r\n\t        var element = this._drawingChartElement(drawingElement, e);\r\n\r\n\t        if (this._activePoint === element) {\r\n\t            this._propagateClick(element, e);\r\n\t        } else {\r\n\t            if (!this._startHover(drawingElement, e)) {\r\n\t                this._unsetActivePoint();\r\n\t            }\r\n\r\n\t            this._propagateClick(element, e);\r\n\t        }\r\n\r\n\t        //part of fix for hover issue on windows touch\r\n\t        this.handlingTap = true;\r\n\t        setTimeout(function () {\r\n\t            this$1.handlingTap = false;\r\n\t        }, 0);\r\n\t    },\r\n\r\n\t    _click: function(e) {\r\n\t        var element = this._getChartElement(e);\r\n\t        this._propagateClick(element, e);\r\n\t    },\r\n\r\n\t    _propagateClick: function(element, e) {\r\n\t        var this$1 = this;\r\n\r\n\t        var current = element;\r\n\t        while (current) {\r\n\t            if (current.click) {\r\n\t                current.click(this$1, e);\r\n\t            }\r\n\r\n\t            current = current.parent;\r\n\t        }\r\n\t    },\r\n\r\n\t    _startHover: function(element, e) {\r\n\t        var chartElement = this._drawingChartElement(element, e);\r\n\t        var ref = this;\r\n\t        var tooltip = ref._tooltip;\r\n\t        var highlight = ref._highlight;\r\n\r\n\t        if (this._suppressHover || !highlight || highlight.isHighlighted(chartElement) || this._sharedTooltip()) {\r\n\t            return false;\r\n\t        }\r\n\r\n\t        var point = this._drawingChartElement(element, e, function(element) {\r\n\t            return element.hover && !(element instanceof PlotAreaBase);\r\n\t        });\r\n\r\n\t        if (point && !point.hover(this, e)) {\r\n\t            this._activePoint = point;\r\n\r\n\t            var tooltipOptions = deepExtend({}, tooltipOptions, point.options.tooltip);\r\n\t            if (tooltipOptions.visible) {\r\n\t                tooltip.show(point);\r\n\t            }\r\n\r\n\t            highlight.show(point);\r\n\r\n\t            return point;\r\n\t        }\r\n\t    },\r\n\r\n\t    _mouseover: function(e) {\r\n\t        var point = this._startHover(e.element, e.originalEvent);\r\n\r\n\t        if (point && point.tooltipTracking) {\r\n\t            this._mouseMoveTrackHandler = this._mouseMoveTrackHandler || this._mouseMoveTracking.bind(this);\r\n\t            var obj;\r\n\t            bindEvents(document, ( obj = {}, obj[ MOUSEMOVE ] = this._mouseMoveTrackHandler, obj ));\r\n\t        }\r\n\t    },\r\n\r\n\t    _mouseMoveTracking: function(e) {\r\n\t        var ref = this;\r\n\t        var options = ref.options;\r\n\t        var tooltip = ref._tooltip;\r\n\t        var highlight = ref._highlight;\r\n\t        var point = ref._activePoint;\r\n\t        var coords = this._eventCoordinates(e);\r\n\r\n\t        if (this._plotArea.box.containsPoint(coords)) {\r\n\t            if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {\r\n\t                var seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);\r\n\t                if (seriesPoint && seriesPoint !== point) {\r\n\t                    seriesPoint.hover(this, e);\r\n\t                    this._activePoint = seriesPoint;\r\n\r\n\t                    var tooltipOptions = deepExtend({}, options.tooltip, point.options.tooltip);\r\n\t                    if (tooltipOptions.visible) {\r\n\t                        tooltip.show(seriesPoint);\r\n\t                    }\r\n\r\n\t                    highlight.show(seriesPoint);\r\n\t                }\r\n\t            }\r\n\t        } else {\r\n\t            var obj;\r\n\t            unbindEvents(document, ( obj = {}, obj[ MOUSEMOVE ] = this._mouseMoveTrackHandler, obj ));\r\n\t            this._unsetActivePoint();\r\n\t        }\r\n\t    },\r\n\r\n\t    _mousemove: function(e) {\r\n\t        var coords = this._eventCoordinates(e);\r\n\r\n\t        this._trackCrosshairs(coords);\r\n\r\n\t        if (this._plotArea.hover) {\r\n\t            this._plotArea.hover(this, e);\r\n\t        }\r\n\r\n\t        if (this._sharedTooltip()) {\r\n\t            this._trackSharedTooltip(coords, e);\r\n\t        }\r\n\t    },\r\n\r\n\t    _trackCrosshairs: function(coords) {\r\n\t        var crosshairs = this._plotArea.crosshairs;\r\n\r\n\t        for (var i = 0; i < crosshairs.length; i++) {\r\n\t            var current = crosshairs[i];\r\n\r\n\t            if (current.box.containsPoint(coords)) {\r\n\t                current.showAt(coords);\r\n\t            } else {\r\n\t                current.hide();\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    _trackSharedTooltip: function(coords, e) {\r\n\t        var ref = this;\r\n\t        var tooltipOptions = ref.options.tooltip;\r\n\t        var plotArea = ref._plotArea;\r\n\t        var categoryAxis = ref._plotArea.categoryAxis;\r\n\t        var tooltip = ref._tooltip;\r\n\t        var highlight = ref._highlight;\r\n\r\n\t        if (plotArea.box.containsPoint(coords)) {\r\n\t            var index = categoryAxis.pointCategoryIndex(coords);\r\n\t            if (index !== this._tooltipCategoryIx) {\r\n\t                var points = plotArea.pointsByCategoryIndex(index);\r\n\r\n\t                var pointArgs = points.map(function(point) {\r\n\t                    return point.eventArgs(e);\r\n\t                });\r\n\r\n\t                var hoverArgs = pointArgs[0] || {};\r\n\t                hoverArgs.categoryPoints = pointArgs;\r\n\r\n\t                if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {\r\n\t                    if (tooltipOptions.visible) {\r\n\t                        tooltip.showAt(points, coords);\r\n\t                    }\r\n\r\n\t                    highlight.show(points);\r\n\t                } else {\r\n\t                    tooltip.hide();\r\n\t                }\r\n\r\n\t                this._tooltipCategoryIx = index;\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    hideElements: function() {\r\n\t        var ref = this;\r\n\t        var plotArea = ref._plotArea;\r\n\t        var tooltip = ref._tooltip;\r\n\t        var highlight = ref._highlight;\r\n\t        this._mousemove.cancel();\r\n\r\n\t        plotArea.hideCrosshairs();\r\n\r\n\t        highlight.hide();\r\n\r\n\t        tooltip.hide();\r\n\r\n\t        delete this._tooltipCategoryIx;\r\n\t    },\r\n\r\n\t    _unsetActivePoint: function() {\r\n\t        var ref = this;\r\n\t        var tooltip = ref._tooltip;\r\n\t        var highlight = ref._highlight;\r\n\r\n\t        this._activePoint = null;\r\n\r\n\t        if (tooltip) {\r\n\t            tooltip.hide();\r\n\t        }\r\n\r\n\t        if (highlight) {\r\n\t            highlight.hide();\r\n\t        }\r\n\t    },\r\n\r\n\t    _deferRedraw: function() {\r\n\t        this._redraw();\r\n\t    },\r\n\r\n\t    _clearRedrawTimeout: function() {\r\n\t        if (this._redrawTimeout) {\r\n\t            clearInterval(this._redrawTimeout);\r\n\t            this._redrawTimeout = null;\r\n\t        }\r\n\t    },\r\n\r\n\t    bindCategories: function() {\r\n\t        var this$1 = this;\r\n\r\n\t        var options = this.options;\r\n\t        var definitions = [].concat(options.categoryAxis);\r\n\r\n\t        for (var axisIx = 0; axisIx < definitions.length; axisIx++) {\r\n\t            var axis = definitions[axisIx];\r\n\t            if (axis.autoBind !== false) {\r\n\t                this$1.bindCategoryAxisFromSeries(axis, axisIx);\r\n\t            }\r\n\t        }\r\n\t    },\r\n\r\n\t    bindCategoryAxisFromSeries: function(axis, axisIx) {\r\n\t        var this$1 = this;\r\n\r\n\t        var series = this.options.series;\r\n\t        var seriesLength = series.length;\r\n\t        var uniqueCategories = {};\r\n\t        var items = [];\r\n\t        var dateAxis;\r\n\r\n\t        for (var seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\r\n\t            var s = series[seriesIx];\r\n\t            var onAxis = s.categoryAxis === axis.name || (!s.categoryAxis && axisIx === 0);\r\n\t            var data = s.data;\r\n\t            var dataLength = data.length;\r\n\r\n\t            if (s.categoryField && onAxis && dataLength > 0) {\r\n\t                dateAxis = isDateAxis(axis, getField(s.categoryField, data[0]));\r\n\r\n\t                var getFn = dateAxis ? getDateField : getField;\r\n\r\n\t                for (var dataIx = 0; dataIx < dataLength; dataIx++) {\r\n\t                    var dataRow = data[dataIx];\r\n\t                    var category = getFn(s.categoryField, dataRow, this$1.chartService.intl);\r\n\r\n\t                    if (dateAxis || !uniqueCategories[category]) {\r\n\t                        items.push([ category, dataRow ]);\r\n\r\n\t                        if (!dateAxis) {\r\n\t                            uniqueCategories[category] = true;\r\n\t                        }\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        }\r\n\r\n\t        if (items.length > 0) {\r\n\t            if (dateAxis) {\r\n\t                items = uniqueDates(items, function(a, b) {\r\n\t                    return dataviz.dateComparer(a[0], b[0]);\r\n\t                });\r\n\t            }\r\n\r\n\t            var result = transpose(items);\r\n\t            axis.categories = result[0];\r\n\t        }\r\n\t    },\r\n\r\n\t    _isBindable: function(series) {\r\n\t        var valueFields = SeriesBinder.current.valueFields(series);\r\n\t        var result = true;\r\n\r\n\t        for (var i = 0; i < valueFields.length; i++) {\r\n\t            var field = valueFields[i];\r\n\t            if (field === VALUE) {\r\n\t                field = \"field\";\r\n\t            } else {\r\n\t                field = field + \"Field\";\r\n\t            }\r\n\r\n\t            if (!defined(series[field])) {\r\n\t                result = false;\r\n\t                break;\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    },\r\n\r\n\t    _noTransitionsRedraw: function() {\r\n\t        var options = this.options;\r\n\t        var transitionsState;\r\n\r\n\t        if (options.transitions) {\r\n\t            options.transitions = false;\r\n\t            transitionsState = true;\r\n\t        }\r\n\r\n\t        this._redraw();\r\n\r\n\t        if (transitionsState) {\r\n\t            options.transitions = true;\r\n\t        }\r\n\t    },\r\n\r\n\t    _legendItemHover: function(seriesIndex, pointIndex) {\r\n\t        var ref = this;\r\n\t        var plotArea = ref._plotArea;\r\n\t        var highlight = ref._highlight;\r\n\t        var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\r\n\t        var items;\r\n\r\n\t        if (inArray(currentSeries.type, [ PIE, DONUT, FUNNEL ])) {\r\n\t            items = plotArea.findPoint(function(point) {\r\n\t                return point.series.index === seriesIndex && point.index === pointIndex;\r\n\t            });\r\n\t        } else {\r\n\t            items = plotArea.pointsBySeriesIndex(seriesIndex);\r\n\t        }\r\n\r\n\t        highlight.show(items);\r\n\t    },\r\n\r\n\t    _shouldAttachMouseMove: function() {\r\n\t        return this._plotArea.crosshairs.length || (this._tooltip && this._sharedTooltip()) || this.requiresHandlers([ PLOT_AREA_HOVER ]);\r\n\t    },\r\n\r\n\t    updateMouseMoveHandler: function() {\r\n\t        var obj;\r\n\t        unbindEvents(this.element, ( obj = {}, obj[ MOUSEMOVE ] = this._mousemove, obj ));\r\n\r\n\t        if (this._shouldAttachMouseMove()) {\r\n\t            var obj$1;\r\n\t            bindEvents(this.element, ( obj$1 = {}, obj$1[ MOUSEMOVE ] = this._mousemove, obj$1 ));\r\n\t        }\r\n\t    },\r\n\r\n\t    applyOptions: function(options, theme) {\r\n\t        clearMissingValues(this._originalOptions, options);\r\n\t        this._originalOptions = deepExtend(this._originalOptions, options);\r\n\t        this.options = deepExtend({}, this._originalOptions);\r\n\r\n\t        if (theme) {\r\n\t            this._theme = theme;\r\n\t            this.chartService.theme = theme;\r\n\t        }\r\n\t        this._initTheme(this.options, this._theme);\r\n\t    },\r\n\r\n\t    setOptions: function(options, theme) {\r\n\t        this.applyOptions(options, theme);\r\n\t        this.bindCategories();\r\n\t        this.redraw();\r\n\t        this.updateMouseMoveHandler();\r\n\r\n\t        this._toggleDomDrag();\r\n\t        this._toggleDomZoom();\r\n\t    },\r\n\r\n\t    destroy: function() {\r\n\t        this._destroyed = true;\r\n\r\n\t        var obj;\r\n\t        unbindEvents(this.element, ( obj = {}, obj[ CONTEXTMENU ] = this._clickHandler, obj[ MOUSEWHEEL ] = this._mousewheelHandler, obj[ MOUSEMOVE ] = this._mousemove, obj ));\r\n\r\n\t        if (this.domEvents) {\r\n\t            this.domEvents.destroy();\r\n\t            delete this.domEvents;\r\n\t        }\r\n\r\n\t        var obj$1;\r\n\t        unbindEvents(document, ( obj$1 = {}, obj$1[ MOUSEMOVE ] = this._mouseMoveTrackHandler, obj$1 ));\r\n\r\n\t        this._destroyView();\r\n\r\n\t        if (this.surface) {\r\n\t            this.surface.destroy();\r\n\t            this.surface = null;\r\n\t        }\r\n\r\n\t        this._clearRedrawTimeout();\r\n\t    },\r\n\r\n\t    _destroyView: function() {\r\n\t        var ref = this;\r\n\t        var model = ref._model;\r\n\t        var selections = ref._selections;\r\n\r\n\t        if (model) {\r\n\t            model.destroy();\r\n\t            this._model = null;\r\n\t        }\r\n\r\n\t        if (selections) {\r\n\t            while (selections.length > 0) {\r\n\t                selections.shift().destroy();\r\n\t            }\r\n\t        }\r\n\r\n\t        this._unsetActivePoint();\r\n\r\n\t        if (this._tooltip) {\r\n\t            this._tooltip.destroy();\r\n\t        }\r\n\r\n\t        if (this._highlight) {\r\n\t            this._highlight.destroy();\r\n\t        }\r\n\r\n\t        if (this._zoomSelection) {\r\n\t            this._zoomSelection.destroy();\r\n\t            delete this._zoomSelection;\r\n\t        }\r\n\r\n\t        if (this._pannable) {\r\n\t            this._pannable.destroy();\r\n\t            delete this._pannable;\r\n\t        }\r\n\r\n\t        if (this._mousewheelZoom) {\r\n\t            this._mousewheelZoom.destroy();\r\n\t            delete this._mousewheelZoom;\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tfunction resolveAxisAliases(options) {\r\n\t    var aliases = AXIS_NAMES;\r\n\r\n\t    for (var idx = 0; idx < aliases.length; idx++) {\r\n\t        var alias = aliases[idx] + \"Axes\";\r\n\t        if (options[alias]) {\r\n\t            options[aliases[idx] + \"Axis\"] = options[alias];\r\n\t            delete options[alias];\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction pointByCategoryName(points, name) {\r\n\t    if (points) {\r\n\t        for (var idx = 0; idx < points.length; idx++) {\r\n\t            if (points[idx].category === name) {\r\n\t                return [ points[idx] ];\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tfunction applyAxisDefaults(options, themeOptions) {\r\n\t    var themeAxisDefaults = ((themeOptions || {}).axisDefaults) || {};\r\n\t    var axisName, axisDefaults, axes;\r\n\r\n\t    function mapAxisOptions(axisOptions) {\r\n\t        var axisColor = (axisOptions || {}).color || axisDefaults.color;\r\n\t        var result = deepExtend({},\r\n\t            themeAxisDefaults,\r\n\t            themeAxisDefaults[axisName],\r\n\t            axisDefaults,\r\n\t            axisDefaults[axisName], {\r\n\t                line: { color: axisColor },\r\n\t                labels: { color: axisColor },\r\n\t                title: { color: axisColor }\r\n\t            },\r\n\t            axisOptions\r\n\t        );\r\n\r\n\t        delete result[axisName];\r\n\r\n\t        return result;\r\n\t    }\r\n\r\n\t    for (var idx = 0; idx < AXIS_NAMES.length; idx++) {\r\n\t        axisName = AXIS_NAMES[idx] + \"Axis\";\r\n\t        axisDefaults = options.axisDefaults || {};\r\n\t        axes = [].concat(options[axisName]);\r\n\r\n\t        axes = axes.map(mapAxisOptions);\r\n\r\n\t        options[axisName] = axes.length > 1 ? axes : axes[0];\r\n\t    }\r\n\t}\r\n\r\n\tfunction applySeriesDefaults(options, themeOptions) {\r\n\t    var series = options.series;\r\n\t    var seriesLength = series.length;\r\n\t    var seriesDefaults = options.seriesDefaults;\r\n\t    var commonDefaults = deepExtend({}, options.seriesDefaults);\r\n\t    var themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};\r\n\t    var commonThemeDefaults = deepExtend({}, themeSeriesDefaults);\r\n\r\n\t    cleanupNestedSeriesDefaults(commonDefaults);\r\n\t    cleanupNestedSeriesDefaults(commonThemeDefaults);\r\n\r\n\t    for (var i = 0; i < seriesLength; i++) {\r\n\t        var seriesType = series[i].type || options.seriesDefaults.type;\r\n\r\n\t        var baseOptions = deepExtend(\r\n\t            { data: [] },\r\n\t            commonThemeDefaults,\r\n\t            themeSeriesDefaults[seriesType],\r\n\t            { tooltip: options.tooltip },\r\n\t            commonDefaults,\r\n\t            seriesDefaults[seriesType]\r\n\t        );\r\n\r\n\t        series[i]._defaults = baseOptions;\r\n\t        series[i] = deepExtend({}, baseOptions, series[i]);\r\n\t    }\r\n\t}\r\n\r\n\tfunction cleanupNestedSeriesDefaults(seriesDefaults) {\r\n\t    delete seriesDefaults.bar;\r\n\t    delete seriesDefaults.column;\r\n\t    delete seriesDefaults.rangeColumn;\r\n\t    delete seriesDefaults.line;\r\n\t    delete seriesDefaults.verticalLine;\r\n\t    delete seriesDefaults.pie;\r\n\t    delete seriesDefaults.donut;\r\n\t    delete seriesDefaults.area;\r\n\t    delete seriesDefaults.verticalArea;\r\n\t    delete seriesDefaults.scatter;\r\n\t    delete seriesDefaults.scatterLine;\r\n\t    delete seriesDefaults.bubble;\r\n\t    delete seriesDefaults.candlestick;\r\n\t    delete seriesDefaults.ohlc;\r\n\t    delete seriesDefaults.boxPlot;\r\n\t    delete seriesDefaults.bullet;\r\n\t    delete seriesDefaults.verticalBullet;\r\n\t    delete seriesDefaults.polarArea;\r\n\t    delete seriesDefaults.polarLine;\r\n\t    delete seriesDefaults.radarArea;\r\n\t    delete seriesDefaults.radarLine;\r\n\t    delete seriesDefaults.waterfall;\r\n\t}\r\n\r\n\tfunction axisRanges(axes) {\r\n\t    var ranges = {};\r\n\r\n\t    for (var i = 0; i < axes.length; i++) {\r\n\t        var axis = axes[i];\r\n\t        var axisName = axis.options.name;\r\n\t        if (axisName) {\r\n\t            ranges[axisName] = axis.range();\r\n\t        }\r\n\t    }\r\n\r\n\t    return ranges;\r\n\t}\r\n\r\n\tfunction sortDates(dates, comparer) {\r\n\t    if (comparer === void 0) { comparer = dataviz.dateComparer; }\r\n\r\n\t    for (var i = 1, length = dates.length; i < length; i++) {\r\n\t        if (comparer(dates[i], dates[i - 1]) < 0) {\r\n\t            dates.sort(comparer);\r\n\t            break;\r\n\t        }\r\n\t    }\r\n\r\n\t    return dates;\r\n\t}\r\n\r\n\tfunction uniqueDates(srcDates, comparer) {\r\n\t    if (comparer === void 0) { comparer = dataviz.dateComparer; }\r\n\r\n\t    var dates = sortDates(srcDates, comparer);\r\n\t    var length = dates.length;\r\n\t    var result = length > 0 ? [ dates[0] ] : [];\r\n\r\n\t    for (var i = 1; i < length; i++) {\r\n\t        if (comparer(dates[i], last(result)) !== 0) {\r\n\t            result.push(dates[i]);\r\n\t        }\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction transpose(rows) {\r\n\t    var rowCount = rows.length;\r\n\t    var result = [];\r\n\r\n\t    for (var rowIx = 0; rowIx < rowCount; rowIx++) {\r\n\t        var row = rows[rowIx];\r\n\t        var colCount = row.length;\r\n\r\n\t        for (var colIx = 0; colIx < colCount; colIx++) {\r\n\t            result[colIx] = result[colIx] || [];\r\n\t            result[colIx].push(row[colIx]);\r\n\t        }\r\n\t    }\r\n\r\n\t    return result;\r\n\t}\r\n\r\n\tfunction clearMissingValues(originalOptions, options) {\r\n\t    for (var field in options) {\r\n\t        var fieldValue = options[field];\r\n\t        var originalValue = originalOptions[field];\r\n\t        if (defined(originalValue)) {\r\n\t            var nullValue = fieldValue === null;\r\n\t            if ((nullValue || !defined(fieldValue))) {\r\n\t                delete originalOptions[field];\r\n\t                if (nullValue) {\r\n\t                    delete options[field];\r\n\t                }\r\n\t            } else if (originalValue && isObject(fieldValue)) {\r\n\t                if (isObject(originalValue)) {\r\n\t                    clearMissingValues(originalValue, fieldValue);\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\r\n\tsetDefaultOptions(Chart, {\r\n\t    renderAs: \"\",\r\n\t    chartArea: {},\r\n\t    legend: {\r\n\t        visible: true,\r\n\t        labels: {}\r\n\t    },\r\n\t    categoryAxis: {},\r\n\t    seriesDefaults: {\r\n\t        type: COLUMN,\r\n\t        data: [],\r\n\t        highlight: {\r\n\t            visible: true\r\n\t        },\r\n\t        labels: {},\r\n\t        negativeValues: {\r\n\t            visible: false\r\n\t        }\r\n\t    },\r\n\t    series: [],\r\n\t    seriesColors: null,\r\n\t    tooltip: {\r\n\t        visible: false\r\n\t    },\r\n\t    transitions: true,\r\n\t    valueAxis: {},\r\n\t    plotArea: {},\r\n\t    title: {},\r\n\t    xAxis: {},\r\n\t    yAxis: {},\r\n\t    panes: [ {} ],\r\n\t    pannable: false,\r\n\t    zoomable: false\r\n\t});\r\n\r\n\tkendo.deepExtend(kendo.dataviz, {\r\n\t    constants: constants,\r\n\t    Aggregates: Aggregates,\r\n\t    AreaChart: AreaChart,\r\n\t    AreaSegment: AreaSegment,\r\n\t    AxisGroupRangeTracker: AxisGroupRangeTracker,\r\n\t    Bar: Bar,\r\n\t    BarChart: BarChart,\r\n\t    BarLabel: BarLabel,\r\n\t    BoxPlotChart: BoxPlotChart,\r\n\t    BoxPlot: BoxPlot,\r\n\t    BubbleChart: BubbleChart,\r\n\t    Bullet: Bullet,\r\n\t    BulletChart: BulletChart,\r\n\t    CandlestickChart: CandlestickChart,\r\n\t    Candlestick: Candlestick,\r\n\t    CategoricalChart: CategoricalChart,\r\n\t    CategoricalErrorBar: CategoricalErrorBar,\r\n\t    CategoricalPlotArea: CategoricalPlotArea,\r\n\t    Chart: Chart,\r\n\t    ChartContainer: ChartContainer,\r\n\t    ClipAnimation: ClipAnimation,\r\n\t    ClusterLayout: ClusterLayout,\r\n\t    Crosshair: Crosshair,\r\n\t    CrosshairTooltip: CrosshairTooltip,\r\n\t    DefaultAggregates: DefaultAggregates,\r\n\t    DonutChart: DonutChart,\r\n\t    DonutPlotArea: DonutPlotArea,\r\n\t    DonutSegment: DonutSegment,\r\n\t    ErrorBarBase: ErrorBarBase,\r\n\t    ErrorRangeCalculator: ErrorRangeCalculator,\r\n\t    Highlight: Highlight,\r\n\t    SharedTooltip: SharedTooltip,\r\n\t    Legend: Legend,\r\n\t    LegendItem: LegendItem,\r\n\t    LegendLayout: LegendLayout,\r\n\t    LineChart: LineChart,\r\n\t    LinePoint: LinePoint,\r\n\t    LineSegment: LineSegment,\r\n\t    Pane: Pane,\r\n\t    PieAnimation: PieAnimation,\r\n\t    PieChart: PieChart,\r\n\t    PieChartMixin: PieChartMixin,\r\n\t    PiePlotArea: PiePlotArea,\r\n\t    PieSegment: PieSegment,\r\n\t    PlotAreaBase: PlotAreaBase,\r\n\t    PlotAreaEventsMixin: PlotAreaEventsMixin,\r\n\t    PlotAreaFactory: PlotAreaFactory,\r\n\t    PointEventsMixin: PointEventsMixin,\r\n\t    RangeBar: RangeBar,\r\n\t    RangeBarChart: RangeBarChart,\r\n\t    RangeAreaPoint: RangeAreaPoint,\r\n\t    RangeAreaChart: RangeAreaChart,\r\n\t    ScatterChart: ScatterChart,\r\n\t    ScatterErrorBar: ScatterErrorBar,\r\n\t    ScatterLineChart: ScatterLineChart,\r\n\t    Selection: Selection,\r\n\t    SeriesAggregator: SeriesAggregator,\r\n\t    SeriesBinder: SeriesBinder,\r\n\t    SplineSegment: SplineSegment,\r\n\t    SplineAreaSegment: SplineAreaSegment,\r\n\t    StackWrap: StackWrap,\r\n\t    Tooltip: Tooltip,\r\n\t    OHLCChart: OHLCChart,\r\n\t    OHLCPoint: OHLCPoint,\r\n\t    WaterfallChart: WaterfallChart,\r\n\t    WaterfallSegment: WaterfallSegment,\r\n\t    XYPlotArea: XYPlotArea,\r\n\t    MousewheelZoom: MousewheelZoom,\r\n\t    ZoomSelection: ZoomSelection,\r\n\t    Pannable: Pannable,\r\n\t    ChartAxis: ChartAxis,\r\n\t    ChartPane: ChartPane,\r\n\t    ChartPlotArea: ChartPlotArea,\r\n\t    anyHasZIndex: anyHasZIndex,\r\n\t    appendIfNotNull: areNumbers,\r\n\t    areNumbers: areNumbers,\r\n\t    bindSegments: bindSegments,\r\n\t    categoriesCount: categoriesCount,\r\n\t    countNumbers: countNumbers,\r\n\t    equalsIgnoreCase: equalsIgnoreCase,\r\n\t    evalOptions: evalOptions,\r\n\t    filterSeriesByType: filterSeriesByType,\r\n\t    getDateField: getDateField,\r\n\t    getField: getField,\r\n\t    hasGradientOverlay: hasGradientOverlay,\r\n\t    hasValue: hasValue,\r\n\t    isDateAxis: isDateAxis,\r\n\t    segmentVisible: segmentVisible,\r\n\t    singleItemOrArray: singleItemOrArray\r\n\t});\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 855:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.core\");\n\n/***/ }),\n\n/***/ 856:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.color\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/dataviz/chart/kendo-chart.js\n// module id = 472\n// module chunks = 3","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nrequire(\"@progress/kendo-ui/js/kendo.core.js\");\r\nrequire(\"@progress/kendo-ui/js/kendo.data.js\");\r\nrequire(\"@progress/kendo-ui/js/kendo.userevents.js\");\r\nrequire(\"@progress/kendo-ui/js/kendo.color.js\");\r\nrequire(\"@progress/kendo-ui/js/kendo.popup.js\");\r\nrequire(\"@progress/kendo-ui/js/kendo.drawing.js\");\r\nrequire(\"@progress/kendo-ui/js/kendo.dataviz.core.js\");\r\nrequire(\"@progress/kendo-ui/js/kendo.dataviz.themes.js\");\r\nrequire(\"@progress/kendo-ui/js/kendo.dataviz.chart.js\");\r\nconst $ = require(\"jquery\");\r\nclass AvlXyChartImpl extends Polymer.Element {\r\n    constructor() {\r\n        super();\r\n        this.refreshRate = 100; // 100 ms TODO debouncing\r\n        this.sequences = [];\r\n    }\r\n    static get is() { return 'avl-xy-chart'; }\r\n    connectedCallback() {\r\n        super.connectedCallback();\r\n        const chartDiv = this.shadowRoot.querySelector('#chart');\r\n        const options = {\r\n            chartArea: {\r\n                height: 500\r\n            },\r\n            legend: {\r\n                position: 'bottom'\r\n            },\r\n            seriesDefaults: {\r\n                type: 'scatterLine'\r\n            },\r\n            renderAs: 'canvas',\r\n            series: [],\r\n            yAxis: [],\r\n            tooltip: {\r\n                visible: true\r\n            },\r\n            pannable: true,\r\n            zoomable: true,\r\n            transitions: false\r\n        };\r\n        this.chart = $(chartDiv).kendoChart(options).data(\"kendoChart\");\r\n        setTimeout(() => this.setChartStyles(), 0);\r\n    }\r\n    initialize(title, xAxis, height, width) {\r\n        this.chart.options.title.text = title;\r\n        this.chart.options.xAxis.min = xAxis.min !== undefined ? xAxis.min : 0;\r\n        this.chart.options.xAxis.max = xAxis.min !== undefined ? xAxis.max : 100;\r\n        // Sorry about anys. Kendo  sometimes puts an object for xAxis, sometimes array. \r\n        // I set it to object immediately so it doesn't cause problems later, but the types declare it as an array              \r\n        this.xAxis = xAxis;\r\n        if (height)\r\n            this.chart.options.chartArea.height = height;\r\n        if (width)\r\n            this.chart.options.chartArea.width = width;\r\n    }\r\n    addSequence(sequence) {\r\n        //if sequence with same label already exists\r\n        if (this.chart.options.series.find(oneSeries => oneSeries.name === sequence.label) != undefined)\r\n            throw new Error(`Sequence label already exists: ${sequence.label}`);\r\n        //keep track of sequences\r\n        this.sequences.push(sequence);\r\n        this.assignYAxesToSeries(sequence.yAxis);\r\n        this.chart.options.series.push(this.createSeriesFromSequence(sequence));\r\n        this.subscribeToSequenceChange(sequence);\r\n        this.chart.refresh();\r\n    }\r\n    setChartStyles() {\r\n        const style = window.getComputedStyle(this);\r\n        const backgroundColor = style.backgroundColor || '#FFFFFF';\r\n        const textColor = style.color || '#3E3D3D';\r\n        const newOptions = Object.assign({}, this.chart.options, { axisDefaults: Object.assign({}, this.chart.options.axisDefaults, { color: textColor }), chartArea: Object.assign({}, this.chart.options.chartArea, { background: backgroundColor }), legend: Object.assign({}, this.chart.options.legend, { labels: {\r\n                    color: textColor,\r\n                } }), title: Object.assign({}, this.chart.options.title, { color: textColor }) });\r\n        this.chart.setOptions(newOptions);\r\n    }\r\n    assignYAxesToSeries(yAxis) {\r\n        // check if already exists; ? n sequences - 1 y axes? TODO\r\n        let yAxes = this.sequences.map(seq => ({\r\n            name: seq.yAxis.name,\r\n            color: seq.yAxis.color,\r\n            labels: { color: seq.yAxis.color }\r\n        }));\r\n        this.chart.options.yAxis = yAxes;\r\n    }\r\n    subscribeToSequenceChange(sequence) {\r\n        let handler = (points) => {\r\n            let oneSeries = this.chart.options.series.find(s => s.name == sequence.label);\r\n            let transformedPoints = points.map(point => [point.x, point.y]);\r\n            oneSeries.data.push(...transformedPoints);\r\n            this.adjustXAxes(points);\r\n            this.chart.refresh();\r\n        };\r\n        sequence.newPoints.subscribe(points => handler(points));\r\n    }\r\n    createSeriesFromSequence(sequence) {\r\n        let series = {\r\n            name: sequence.label,\r\n            data: [],\r\n            yAxis: sequence.yAxis.name,\r\n            color: sequence.yAxis.color\r\n        };\r\n        return series;\r\n    }\r\n    adjustXAxes(points) {\r\n        if (!this.xAxis.automaticallyAdjustRange)\r\n            return;\r\n        let xs = points.map(point => point.x);\r\n        let min = Math.min(this.chart.options.xAxis.min, ...xs);\r\n        let max = Math.max(this.chart.options.xAxis.max, ...xs);\r\n        this.chart.options.xAxis.min = Math.min(this.chart.options.xAxis.min, ...xs);\r\n        this.chart.options.xAxis.max = Math.max(this.chart.options.xAxis.max, ...xs);\r\n        // Sorry about anys. Kendo  sometimes puts an object for xAxis, sometimes array. \r\n        // I set it to object immediately so it doesn't cause problems later, but the types declare it as an array\r\n        //TODO\r\n        // if (!this.xAxis.centerLineInTheMiddleOfGraph) return;\r\n        // let center = (max - min) / 2;\r\n        // if (max>center)\r\n        // (this.chart.options.xAxis as any).max+=((this.chart.options.xAxis as any).max -(this.chart.options.xAxis as any).min)/2;     \r\n    }\r\n    getSequence(label) {\r\n        return this.sequences.find(sequence => sequence.label === label);\r\n    }\r\n    removeSequence(label) {\r\n        throw Error('NotImplemented');\r\n    }\r\n}\r\nexports.AvlXyChartImpl = AvlXyChartImpl;\r\ncustomElements.define(AvlXyChartImpl.is, AvlXyChartImpl);\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/avl-xy-chart/avl-xy-chart.ts\n// module id = 513\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1030);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 993:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo.core\");\n\n/***/ }),\n\n/***/ 1030:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(993) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"data.odata\",\r\n\t    name: \"OData\",\r\n\t    category: \"framework\",\r\n\t    depends: [ \"core\" ],\r\n\t    hidden: true\r\n\t};\r\n\r\n\t(function($, undefined) {\r\n\t    var kendo = window.kendo,\r\n\t        extend = $.extend,\r\n\t        odataFilters = {\r\n\t            eq: \"eq\",\r\n\t            neq: \"ne\",\r\n\t            gt: \"gt\",\r\n\t            gte: \"ge\",\r\n\t            lt: \"lt\",\r\n\t            lte: \"le\",\r\n\t            contains : \"substringof\",\r\n\t            doesnotcontain: \"substringof\",\r\n\t            endswith: \"endswith\",\r\n\t            startswith: \"startswith\",\r\n\t            isnull: \"eq\",\r\n\t            isnotnull: \"ne\",\r\n\t            isempty: \"eq\",\r\n\t            isnotempty: \"ne\"\r\n\t        },\r\n\t        odataFiltersVersionFour = extend({}, odataFilters, {\r\n\t            contains: \"contains\"\r\n\t        }),\r\n\t        mappers = {\r\n\t            pageSize: $.noop,\r\n\t            page: $.noop,\r\n\t            filter: function(params, filter, useVersionFour) {\r\n\t                if (filter) {\r\n\t                    filter = toOdataFilter(filter, useVersionFour);\r\n\t                    if (filter) {\r\n\t                        params.$filter = filter;\r\n\t                    }\r\n\t                }\r\n\t            },\r\n\t            sort: function(params, orderby) {\r\n\t                var expr = $.map(orderby, function(value) {\r\n\t                    var order = value.field.replace(/\\./g, \"/\");\r\n\r\n\t                    if (value.dir === \"desc\") {\r\n\t                        order += \" desc\";\r\n\t                    }\r\n\r\n\t                    return order;\r\n\t                }).join(\",\");\r\n\r\n\t                if (expr) {\r\n\t                    params.$orderby = expr;\r\n\t                }\r\n\t            },\r\n\t            skip: function(params, skip) {\r\n\t                if (skip) {\r\n\t                    params.$skip = skip;\r\n\t                }\r\n\t            },\r\n\t            take: function(params, take) {\r\n\t                if (take) {\r\n\t                    params.$top = take;\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t        defaultDataType = {\r\n\t            read: {\r\n\t                dataType: \"jsonp\"\r\n\t            }\r\n\t        };\r\n\r\n\t    function toOdataFilter(filter, useOdataFour) {\r\n\t        var result = [],\r\n\t            logic = filter.logic || \"and\",\r\n\t            idx,\r\n\t            length,\r\n\t            field,\r\n\t            type,\r\n\t            format,\r\n\t            operator,\r\n\t            value,\r\n\t            ignoreCase,\r\n\t            filters = filter.filters;\r\n\r\n\t        for (idx = 0, length = filters.length; idx < length; idx++) {\r\n\t            filter = filters[idx];\r\n\t            field = filter.field;\r\n\t            value = filter.value;\r\n\t            operator = filter.operator;\r\n\r\n\t            if (filter.filters) {\r\n\t                filter = toOdataFilter(filter, useOdataFour);\r\n\t            } else {\r\n\t                ignoreCase = filter.ignoreCase;\r\n\t                field = field.replace(/\\./g, \"/\");\r\n\t                filter = odataFilters[operator];\r\n\t                if (useOdataFour) {\r\n\t                    filter = odataFiltersVersionFour[operator];\r\n\t                }\r\n\r\n\t                if (operator === \"isnull\" || operator === \"isnotnull\") {\r\n\t                    filter = kendo.format(\"{0} {1} null\", field, filter);\r\n\t                } else if (operator === \"isempty\" || operator === \"isnotempty\") {\r\n\t                    filter = kendo.format(\"{0} {1} ''\", field, filter);\r\n\t                } else if (filter && value !== undefined) {\r\n\t                    type = $.type(value);\r\n\t                    if (type === \"string\") {\r\n\t                        format = \"'{1}'\";\r\n\t                        value = value.replace(/'/g, \"''\");\r\n\r\n\t                        if (ignoreCase === true) {\r\n\t                            field = \"tolower(\" + field + \")\";\r\n\t                        }\r\n\r\n\t                    } else if (type === \"date\") {\r\n\t                        if (useOdataFour) {\r\n\t                            format = \"{1:yyyy-MM-ddTHH:mm:ss+00:00}\";\r\n\t                            value = kendo.timezone.apply(value, 'Etc/UTC');\r\n\t                        } else {\r\n\t                            format = \"datetime'{1:yyyy-MM-ddTHH:mm:ss}'\";\r\n\t                        }\r\n\t                    } else {\r\n\t                        format = \"{1}\";\r\n\t                    }\r\n\r\n\t                    if (filter.length > 3) {\r\n\t                        if (filter !== \"substringof\") {\r\n\t                            format = \"{0}({2},\" + format + \")\";\r\n\t                        } else {\r\n\t                            format = \"{0}(\" + format + \",{2})\";\r\n\t                            if (operator === \"doesnotcontain\") {\r\n\t                                if (useOdataFour) {\r\n\t                                    format = \"{0}({2},'{1}') eq -1\";\r\n\t                                    filter = \"indexof\";\r\n\t                                } else {\r\n\t                                    format += \" eq false\";\r\n\t                                }\r\n\t                            }\r\n\t                        }\r\n\t                    } else {\r\n\t                        format = \"{2} {0} \" + format;\r\n\t                    }\r\n\r\n\t                    filter = kendo.format(format, filter, value, field);\r\n\t                }\r\n\t            }\r\n\r\n\t            result.push(filter);\r\n\t        }\r\n\r\n\t        filter = result.join(\" \" + logic + \" \");\r\n\r\n\t        if (result.length > 1) {\r\n\t            filter = \"(\" + filter + \")\";\r\n\t        }\r\n\r\n\t        return filter;\r\n\t    }\r\n\r\n\t    function stripMetadata(obj) {\r\n\t        for (var name in obj) {\r\n\t            if(name.indexOf(\"@odata\") === 0) {\r\n\t                delete obj[name];\r\n\t            }\r\n\t        }\r\n\t    }\r\n\r\n\t    extend(true, kendo.data, {\r\n\t        schemas: {\r\n\t            odata: {\r\n\t                type: \"json\",\r\n\t                data: function(data) {\r\n\t                    return data.d.results || [data.d];\r\n\t                },\r\n\t                total: \"d.__count\"\r\n\t            }\r\n\t        },\r\n\t        transports: {\r\n\t            odata: {\r\n\t                read: {\r\n\t                    cache: true, // to prevent jQuery from adding cache buster\r\n\t                    dataType: \"jsonp\",\r\n\t                    jsonp: \"$callback\"\r\n\t                },\r\n\t                update: {\r\n\t                    cache: true,\r\n\t                    dataType: \"json\",\r\n\t                    contentType: \"application/json\", // to inform the server the the request body is JSON encoded\r\n\t                    type: \"PUT\" // can be PUT or MERGE\r\n\t                },\r\n\t                create: {\r\n\t                    cache: true,\r\n\t                    dataType: \"json\",\r\n\t                    contentType: \"application/json\",\r\n\t                    type: \"POST\" // must be POST to create new entity\r\n\t                },\r\n\t                destroy: {\r\n\t                    cache: true,\r\n\t                    dataType: \"json\",\r\n\t                    type: \"DELETE\"\r\n\t                },\r\n\t                parameterMap: function(options, type, useVersionFour) {\r\n\t                    var params,\r\n\t                        value,\r\n\t                        option,\r\n\t                        dataType;\r\n\r\n\t                    options = options || {};\r\n\t                    type = type || \"read\";\r\n\t                    dataType = (this.options || defaultDataType)[type];\r\n\t                    dataType = dataType ? dataType.dataType : \"json\";\r\n\r\n\t                    if (type === \"read\") {\r\n\t                        params = {\r\n\t                            $inlinecount: \"allpages\"\r\n\t                        };\r\n\r\n\t                        if (dataType != \"json\") {\r\n\t                            params.$format = \"json\";\r\n\t                        }\r\n\r\n\t                        for (option in options) {\r\n\t                            if (mappers[option]) {\r\n\t                                mappers[option](params, options[option], useVersionFour);\r\n\t                            } else {\r\n\t                                params[option] = options[option];\r\n\t                            }\r\n\t                        }\r\n\t                    } else {\r\n\t                        if (dataType !== \"json\") {\r\n\t                            throw new Error(\"Only json dataType can be used for \" + type + \" operation.\");\r\n\t                        }\r\n\r\n\t                        if (type !== \"destroy\") {\r\n\t                            for (option in options) {\r\n\t                                value = options[option];\r\n\t                                if (typeof value === \"number\") {\r\n\t                                    options[option] = value + \"\";\r\n\t                                }\r\n\t                            }\r\n\r\n\t                            params = kendo.stringify(options);\r\n\t                        }\r\n\t                    }\r\n\r\n\t                    return params;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    });\r\n\r\n\t    extend(true, kendo.data, {\r\n\t        schemas: {\r\n\t            \"odata-v4\": {\r\n\t                type: \"json\",\r\n\t                data: function(data) {\r\n\t                    data = $.extend({}, data);\r\n\t                    stripMetadata(data);\r\n\r\n\t                    if (data.value) {\r\n\t                        return data.value;\r\n\t                    }\r\n\t                    return [data];\r\n\t                },\r\n\t                total: function(data) {\r\n\t                    return data[\"@odata.count\"];\r\n\t                }\r\n\t            }\r\n\t        },\r\n\t        transports: {\r\n\t            \"odata-v4\": {\r\n\t                read: {\r\n\t                    cache: true, // to prevent jQuery from adding cache buster\r\n\t                    dataType: \"json\"\r\n\t                },\r\n\t                update: {\r\n\t                    cache: true,\r\n\t                    dataType: \"json\",\r\n\t                    contentType: \"application/json;IEEE754Compatible=true\", // to inform the server the the request body is JSON encoded\r\n\t                    type: \"PUT\" // can be PUT or MERGE\r\n\t                },\r\n\t                create: {\r\n\t                    cache: true,\r\n\t                    dataType: \"json\",\r\n\t                    contentType: \"application/json;IEEE754Compatible=true\",\r\n\t                    type: \"POST\" // must be POST to create new entity\r\n\t                },\r\n\t                destroy: {\r\n\t                    cache: true,\r\n\t                    dataType: \"json\",\r\n\t                    type: \"DELETE\"\r\n\t                },\r\n\t                parameterMap: function(options, type) {\r\n\t                    var result = kendo.data.transports.odata.parameterMap(options, type, true);\r\n\t                    if (type == \"read\") {\r\n\t                        result.$count = true;\r\n\t                        delete result.$inlinecount;\r\n\t                    }\r\n\r\n\t                    return result;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    });\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\treturn window.kendo;\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.data.odata.js\n// module id = 514\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1032);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 993:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo.core\");\n\n/***/ }),\n\n/***/ 1032:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(993) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"data.xml\",\r\n\t    name: \"XML\",\r\n\t    category: \"framework\",\r\n\t    depends: [ \"core\" ],\r\n\t    hidden: true\r\n\t};\r\n\r\n\t/*jshint  eqnull: true, boss: true */\r\n\t(function($, undefined) {\r\n\t    var kendo = window.kendo,\r\n\t        isArray = $.isArray,\r\n\t        isPlainObject = $.isPlainObject,\r\n\t        map = $.map,\r\n\t        each = $.each,\r\n\t        extend = $.extend,\r\n\t        getter = kendo.getter,\r\n\t        Class = kendo.Class;\r\n\r\n\t    var XmlDataReader = Class.extend({\r\n\t        init: function(options) {\r\n\t            var that = this,\r\n\t                total = options.total,\r\n\t                model = options.model,\r\n\t                parse = options.parse,\r\n\t                errors = options.errors,\r\n\t                serialize = options.serialize,\r\n\t                data = options.data;\r\n\r\n\t            if (model) {\r\n\t                if (isPlainObject(model)) {\r\n\t                    var base = options.modelBase || kendo.data.Model;\r\n\r\n\t                    if (model.fields) {\r\n\t                        each(model.fields, function(field, value) {\r\n\t                            if (isPlainObject(value) && value.field) {\r\n\t                                if (!$.isFunction(value.field)) {\r\n\t                                    value = extend(value, { field: that.getter(value.field) });\r\n\t                                }\r\n\t                            } else {\r\n\t                                value = { field: that.getter(value) };\r\n\t                            }\r\n\t                            model.fields[field] = value;\r\n\t                        });\r\n\t                    }\r\n\r\n\t                    var id = model.id;\r\n\t                    if (id) {\r\n\t                        var idField = {};\r\n\r\n\t                        idField[that.xpathToMember(id, true)] = { field : that.getter(id) };\r\n\t                        model.fields = extend(idField, model.fields);\r\n\t                        model.id = that.xpathToMember(id);\r\n\t                    }\r\n\t                    model = base.define(model);\r\n\t                }\r\n\r\n\t                that.model = model;\r\n\t            }\r\n\r\n\t            if (total) {\r\n\t                if (typeof total == \"string\") {\r\n\t                    total = that.getter(total);\r\n\t                    that.total = function(data) {\r\n\t                        return parseInt(total(data), 10);\r\n\t                    };\r\n\t                } else if (typeof total == \"function\"){\r\n\t                    that.total = total;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (errors) {\r\n\t                if (typeof errors == \"string\") {\r\n\t                    errors = that.getter(errors);\r\n\t                    that.errors = function(data) {\r\n\t                        return errors(data) || null;\r\n\t                    };\r\n\t                } else if (typeof errors == \"function\"){\r\n\t                    that.errors = errors;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (data) {\r\n\t                if (typeof data == \"string\") {\r\n\t                    data = that.xpathToMember(data);\r\n\t                    that.data = function(value) {\r\n\t                        var result = that.evaluate(value, data),\r\n\t                            modelInstance;\r\n\r\n\t                        result = isArray(result) ? result : [result];\r\n\r\n\t                        if (that.model && model.fields) {\r\n\t                            modelInstance = new that.model();\r\n\r\n\t                            return map(result, function(value) {\r\n\t                                if (value) {\r\n\t                                    var record = {}, field;\r\n\r\n\t                                    for (field in model.fields) {\r\n\t                                        record[field] = modelInstance._parse(field, model.fields[field].field(value));\r\n\t                                    }\r\n\r\n\t                                    return record;\r\n\t                                }\r\n\t                            });\r\n\t                        }\r\n\r\n\t                        return result;\r\n\t                    };\r\n\t                } else if (typeof data == \"function\") {\r\n\t                    that.data = data;\r\n\t                }\r\n\t            }\r\n\r\n\t            if (typeof parse == \"function\") {\r\n\t                var xmlParse = that.parse;\r\n\r\n\t                that.parse = function(data) {\r\n\t                    var xml = parse.call(that, data);\r\n\t                    return xmlParse.call(that, xml);\r\n\t                };\r\n\t            }\r\n\r\n\t            if (typeof serialize == \"function\") {\r\n\t                that.serialize = serialize;\r\n\t            }\r\n\t        },\r\n\t        total: function(result) {\r\n\t            return this.data(result).length;\r\n\t        },\r\n\t        errors: function(data) {\r\n\t            return data ? data.errors : null;\r\n\t        },\r\n\t        serialize: function(data) {\r\n\t            return data;\r\n\t        },\r\n\t        parseDOM: function(element) {\r\n\t            var result = {},\r\n\t                parsedNode,\r\n\t                node,\r\n\t                nodeType,\r\n\t                nodeName,\r\n\t                member,\r\n\t                attribute,\r\n\t                attributes = element.attributes,\r\n\t                attributeCount = attributes.length,\r\n\t                idx;\r\n\r\n\t            for (idx = 0; idx < attributeCount; idx++) {\r\n\t                attribute = attributes[idx];\r\n\t                result[\"@\" + attribute.nodeName] = attribute.nodeValue;\r\n\t            }\r\n\r\n\t            for (node = element.firstChild; node; node = node.nextSibling) {\r\n\t                nodeType = node.nodeType;\r\n\r\n\t                if (nodeType === 3 || nodeType === 4) {\r\n\t                    // text nodes or CDATA are stored as #text field\r\n\t                    result[\"#text\"] = node.nodeValue;\r\n\t                } else if (nodeType === 1) {\r\n\t                    // elements are stored as fields\r\n\t                    parsedNode = this.parseDOM(node);\r\n\r\n\t                    nodeName = node.nodeName;\r\n\r\n\t                    member = result[nodeName];\r\n\r\n\t                    if (isArray(member)) {\r\n\t                        // elements of same nodeName are stored as array\r\n\t                        member.push(parsedNode);\r\n\t                    } else if (member !== undefined) {\r\n\t                        member = [member, parsedNode];\r\n\t                    } else {\r\n\t                        member = parsedNode;\r\n\t                    }\r\n\r\n\t                    result[nodeName] = member;\r\n\t                }\r\n\t            }\r\n\t            return result;\r\n\t        },\r\n\r\n\t        evaluate: function(value, expression) {\r\n\t            var members = expression.split(\".\"),\r\n\t                member,\r\n\t                result,\r\n\t                length,\r\n\t                intermediateResult,\r\n\t                idx;\r\n\r\n\t            while (member = members.shift()) {\r\n\t                value = value[member];\r\n\r\n\t                if (isArray(value)) {\r\n\t                    result = [];\r\n\t                    expression = members.join(\".\");\r\n\r\n\t                    for (idx = 0, length = value.length; idx < length; idx++) {\r\n\t                        intermediateResult = this.evaluate(value[idx], expression);\r\n\r\n\t                        intermediateResult = isArray(intermediateResult) ? intermediateResult : [intermediateResult];\r\n\r\n\t                        result.push.apply(result, intermediateResult);\r\n\t                    }\r\n\r\n\t                    return result;\r\n\t                }\r\n\t            }\r\n\r\n\t            return value;\r\n\t        },\r\n\r\n\t        parse: function(xml) {\r\n\t            var documentElement,\r\n\t                tree,\r\n\t                result = {};\r\n\r\n\t            documentElement = xml.documentElement || $.parseXML(xml).documentElement;\r\n\r\n\t            tree = this.parseDOM(documentElement);\r\n\r\n\t            result[documentElement.nodeName] = tree;\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        xpathToMember: function(member, raw) {\r\n\t            if (!member) {\r\n\t                return \"\";\r\n\t            }\r\n\r\n\t            member = member.replace(/^\\//, \"\") // remove the first \"/\"\r\n\t                           .replace(/\\//g, \".\"); // replace all \"/\" with \".\"\r\n\r\n\t            if (member.indexOf(\"@\") >= 0) {\r\n\t                // replace @attribute with '[\"@attribute\"]'\r\n\t                return member.replace(/\\.?(@.*)/, raw? '$1':'[\"$1\"]');\r\n\t            }\r\n\r\n\t            if (member.indexOf(\"text()\") >= 0) {\r\n\t                // replace \".text()\" with '[\"#text\"]'\r\n\t                return member.replace(/(\\.?text\\(\\))/, raw? '#text':'[\"#text\"]');\r\n\t            }\r\n\r\n\t            return member;\r\n\t        },\r\n\t        getter: function(member) {\r\n\t            return getter(this.xpathToMember(member), true);\r\n\t        }\r\n\t    });\r\n\r\n\t    $.extend(true, kendo.data, {\r\n\t        XmlDataReader: XmlDataReader,\r\n\t        readers: {\r\n\t            xml: XmlDataReader\r\n\t        }\r\n\t    });\r\n\t})(window.kendo.jQuery);\r\n\r\n\treturn window.kendo;\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.data.xml.js\n// module id = 515\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1481);\n\tmodule.exports = __webpack_require__(1481);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 920:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../kendo.core\");\n\n/***/ }),\n\n/***/ 1481:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n\t        __webpack_require__(920)\r\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function ($) {\r\n\r\n\twindow.kendo.util = window.kendo.util || {};\r\n\r\n\tvar LRUCache = kendo.Class.extend({\r\n\t    init: function(size) {\r\n\r\n\t        this._size = size;\r\n\t        this._length = 0;\r\n\t        this._map = {};\r\n\t    },\r\n\r\n\t    put: function(key, value) {\r\n\t        var map = this._map;\r\n\t        var entry = { key: key, value: value };\r\n\r\n\t        map[key] = entry;\r\n\r\n\t        if (!this._head) {\r\n\t            this._head = this._tail = entry;\r\n\t        } else {\r\n\t            this._tail.newer = entry;\r\n\t            entry.older = this._tail;\r\n\t            this._tail = entry;\r\n\t        }\r\n\r\n\t        if (this._length >= this._size) {\r\n\t            map[this._head.key] = null;\r\n\t            this._head = this._head.newer;\r\n\t            this._head.older = null;\r\n\t        } else {\r\n\t            this._length++;\r\n\t        }\r\n\t    },\r\n\r\n\t    get: function(key) {\r\n\t        var entry = this._map[key];\r\n\r\n\t        if (entry) {\r\n\t            if (entry === this._head && entry !== this._tail) {\r\n\t                this._head = entry.newer;\r\n\t                this._head.older = null;\r\n\t            }\r\n\r\n\t            if (entry !== this._tail) {\r\n\t                if (entry.older) {\r\n\t                    entry.older.newer = entry.newer;\r\n\t                    entry.newer.older = entry.older;\r\n\t                }\r\n\r\n\t                entry.older = this._tail;\r\n\t                entry.newer = null;\r\n\r\n\t                this._tail.newer = entry;\r\n\t                this._tail = entry;\r\n\t            }\r\n\r\n\t            return entry.value;\r\n\t        }\r\n\t    }\r\n\t});\r\n\r\n\tvar REPLACE_REGEX = /\\r?\\n|\\r|\\t/g;\r\n\tvar SPACE = ' ';\r\n\r\n\tfunction normalizeText(text) {\r\n\t    return String(text).replace(REPLACE_REGEX, SPACE);\r\n\t}\r\n\r\n\tfunction objectKey(object) {\r\n\t    var parts = [];\r\n\t    for (var key in object) {\r\n\t        parts.push(key + object[key]);\r\n\t    }\r\n\r\n\t    return parts.sort().join(\"\");\r\n\t}\r\n\r\n\t// Computes FNV-1 hash\r\n\t// See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\r\n\tfunction hashKey(str) {\r\n\t    // 32-bit FNV-1 offset basis\r\n\t    // See http://isthe.com/chongo/tech/comp/fnv/#FNV-param\r\n\t    var hash = 0x811C9DC5;\r\n\r\n\t    for (var i = 0; i < str.length; ++i) {\r\n\t        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\r\n\t        hash ^= str.charCodeAt(i);\r\n\t    }\r\n\r\n\t    return hash >>> 0;\r\n\t}\r\n\r\n\tfunction zeroSize() {\r\n\t    return { width: 0, height: 0, baseline: 0 };\r\n\t}\r\n\r\n\tvar DEFAULT_OPTIONS = {\r\n\t    baselineMarkerSize: 1\r\n\t};\r\n\r\n\tvar defaultMeasureBox;\r\n\r\n\tif (typeof document !== \"undefined\") {\r\n\t    defaultMeasureBox = document.createElement(\"div\");\r\n\t    defaultMeasureBox.style.cssText = \"position: absolute !important; top: -4000px !important; width: auto !important; height: auto !important;\" +\r\n\t              \"padding: 0 !important; margin: 0 !important; border: 0 !important;\" +\r\n\t              \"line-height: normal !important; visibility: hidden !important; white-space: pre!important;\";\r\n\t}\r\n\r\n\tvar TextMetrics = kendo.Class.extend({\r\n\t    init: function(options) {\r\n\r\n\t        this._cache = new LRUCache(1000);\r\n\t        this.options = $.extend({}, DEFAULT_OPTIONS, options);\r\n\t    },\r\n\r\n\t    measure: function(text, style, options) {\r\n\t        if (options === void 0) { options = {}; }\r\n\r\n\t        if (!text) {\r\n\t            return zeroSize();\r\n\t        }\r\n\r\n\t        var styleKey = objectKey(style);\r\n\t        var cacheKey = hashKey(text + styleKey);\r\n\t        var cachedResult = this._cache.get(cacheKey);\r\n\r\n\t        if (cachedResult) {\r\n\t            return cachedResult;\r\n\t        }\r\n\r\n\t        var size = zeroSize();\r\n\t        var measureBox = options.box || defaultMeasureBox;\r\n\t        var baselineMarker = this._baselineMarker().cloneNode(false);\r\n\r\n\t        for (var key in style) {\r\n\t            var value = style[key];\r\n\t            if (typeof value !== \"undefined\") {\r\n\t                measureBox.style[key] = value;\r\n\t            }\r\n\t        }\r\n\r\n\t        var textStr = options.normalizeText !== false ? normalizeText(text) : String(text);\r\n\r\n\t        measureBox.textContent = textStr;\r\n\t        measureBox.appendChild(baselineMarker);\r\n\t        document.body.appendChild(measureBox);\r\n\r\n\t        if (textStr.length) {\r\n\t            size.width = measureBox.offsetWidth - this.options.baselineMarkerSize;\r\n\t            size.height = measureBox.offsetHeight;\r\n\t            size.baseline = baselineMarker.offsetTop + this.options.baselineMarkerSize;\r\n\t        }\r\n\r\n\t        if (size.width > 0 && size.height > 0) {\r\n\t            this._cache.put(cacheKey, size);\r\n\t        }\r\n\r\n\t        measureBox.parentNode.removeChild(measureBox);\r\n\r\n\t        return size;\r\n\t    },\r\n\r\n\t    _baselineMarker: function() {\r\n\t        var marker = document.createElement(\"div\");\r\n\t        marker.style.cssText = \"display: inline-block; vertical-align: baseline;width: \" +\r\n\t            this.options.baselineMarkerSize + \"px; height: \" + this.options.baselineMarkerSize + \"px;overflow: hidden;\";\r\n\r\n\t        return marker;\r\n\t    }\r\n\t});\r\n\r\n\tTextMetrics.current = new TextMetrics();\r\n\r\n\tfunction measureText(text, style, measureBox) {\r\n\t    return TextMetrics.current.measure(text, style, measureBox);\r\n\t}\r\n\r\n\tkendo.deepExtend(kendo.util, {\r\n\t    LRUCache: LRUCache,\r\n\t    TextMetrics: TextMetrics,\r\n\t    measureText: measureText,\r\n\t    objectKey: objectKey,\r\n\t    hashKey: hashKey,\r\n\t    normalizeText: normalizeText\r\n\t});\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/util/text-metrics.js\n// module id = 516\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(915);\n\tmodule.exports = __webpack_require__(915);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 910:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo-drawing\");\n\n/***/ }),\n\n/***/ 915:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(910), __webpack_require__(916) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function ($) {\r\n\r\n\t    var kendo = window.kendo;\r\n\t    var draw = kendo.drawing;\r\n\t    var DrawingSurface = draw.Surface;\r\n\t    var Widget = kendo.ui.Widget;\r\n\t    var deepExtend = kendo.deepExtend;\r\n\t    var proxy = $.proxy;\r\n\r\n\t    kendo.support.svg = DrawingSurface.support.svg;\r\n\t    kendo.support.canvas = DrawingSurface.support.canvas;\r\n\r\n\t    var Surface = Widget.extend({\r\n\t        init: function(element, options) {\r\n\t            Widget.fn.init.call(this, element, {});\r\n\r\n\t            this.options = deepExtend({}, this.options, options);\r\n\r\n\t            this._instance = DrawingSurface.create(this.element[0], options);\r\n\t            if (this._instance.translate) {\r\n\t                this.translate = translate;\r\n\t            }\r\n\r\n\t            this._triggerInstanceHandler = proxy(this._triggerInstanceEvent, this);\r\n\t            this._bindHandler(\"click\");\r\n\t            this._bindHandler(\"mouseenter\");\r\n\t            this._bindHandler(\"mouseleave\");\r\n\t            this._bindHandler(\"mousemove\");\r\n\r\n\t            this._enableTracking();\r\n\t        },\r\n\r\n\t        options: {\r\n\t            name: \"Surface\",\r\n\t            tooltip: {}\r\n\t        },\r\n\r\n\t        events: [\r\n\t            \"click\",\r\n\t            \"mouseenter\",\r\n\t            \"mouseleave\",\r\n\t            \"mousemove\",\r\n\t            \"resize\",\r\n\t            \"tooltipOpen\",\r\n\t            \"tooltipClose\"\r\n\t        ],\r\n\r\n\t        _triggerInstanceEvent: function(e) {\r\n\t            this.trigger(e.type, e);\r\n\t        },\r\n\r\n\t        _bindHandler: function(event) {\r\n\t            this._instance.bind(event, this._triggerInstanceHandler);\r\n\t        },\r\n\r\n\t        draw: function(element) {\r\n\t            this._instance.draw(element);\r\n\t        },\r\n\r\n\t        clear: function() {\r\n\t            if (this._instance) {\r\n\t                this._instance.clear();\r\n\t            }\r\n\t            this.hideTooltip();\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            if (this._instance) {\r\n\t                this._instance.destroy();\r\n\t                delete this._instance;\r\n\t            }\r\n\r\n\t            if (this._tooltip) {\r\n\t                this._tooltip.destroy();\r\n\t                delete this._tooltip;\r\n\t            }\r\n\r\n\t            Widget.fn.destroy.call(this);\r\n\t        },\r\n\r\n\t        exportVisual: function() {\r\n\t            return this._instance.exportVisual();\r\n\t        },\r\n\r\n\t        eventTarget: function(e) {\r\n\t            return this._instance.eventTarget(e);\r\n\t        },\r\n\r\n\t        showTooltip: function(shape, options) {\r\n\t            if (this._tooltip) {\r\n\t                this._tooltip.show(shape, options);\r\n\t            }\r\n\t        },\r\n\r\n\t        hideTooltip: function() {\r\n\t            if (this._tooltip) {\r\n\t                this._tooltip.hide();\r\n\t            }\r\n\t        },\r\n\r\n\t        suspendTracking: function() {\r\n\t            this._instance.suspendTracking();\r\n\t            this.hideTooltip();\r\n\t        },\r\n\r\n\t        resumeTracking: function() {\r\n\t            this._instance.resumeTracking();\r\n\t        },\r\n\r\n\t        getSize: function() {\r\n\t            return {\r\n\t                width: this.element.width(),\r\n\t                height: this.element.height()\r\n\t            };\r\n\t        },\r\n\r\n\t        setSize: function(size) {\r\n\t            this.element.css({\r\n\t                width: size.width,\r\n\t                height: size.height\r\n\t            });\r\n\r\n\t            this._size = size;\r\n\t            this._instance.currentSize(size);\r\n\t            this._resize();\r\n\t        },\r\n\r\n\t        _resize: function() {\r\n\t            this._instance.currentSize(this._size);\r\n\t            this._instance._resize();\r\n\t        },\r\n\r\n\t        _enableTracking: function() {\r\n\t            if (kendo.ui.Popup) {\r\n\t                this._tooltip = new draw.SurfaceTooltip(this, this.options.tooltip || {});\r\n\t            }\r\n\t        }\r\n\t    });\r\n\r\n\t    kendo.ui.plugin(Surface);\r\n\r\n\t    Surface.create = function(element, options) {\r\n\t        return new Surface(element, options);\r\n\t    };\r\n\r\n\t    kendo.drawing.Surface = Surface;\r\n\r\n\t    function translate(offset) {\r\n\t        this._instance.translate(offset);\r\n\t    }\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 916:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./surface-tooltip\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/drawing/surface.js\n// module id = 517\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(909);\n\tmodule.exports = __webpack_require__(909);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 909:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(910) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function ($) {\r\n\t    \r\n\t    var kendo = window.kendo;\r\n\t    var drawing = kendo.drawing;\r\n\t    var drawDOM = drawing.drawDOM;\r\n\r\n\t    drawing.drawDOM = function(element, options) {\r\n\t        return drawDOM($(element)[0], options);\r\n\t    };\r\n\r\n\t    drawing.drawDOM.drawText = drawDOM.drawText;\r\n\t    drawing.drawDOM.getFontFaces = drawDOM.getFontFaces;\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ }),\n\n/***/ 910:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo-drawing\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/drawing/html.js\n// module id = 518\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(857);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 857:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n\t        __webpack_require__(858)\r\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function ($) {\r\n\r\n\t    var dataviz = kendo.dataviz;\r\n\t    var services = dataviz.services;\r\n\t    var draw = kendo.drawing;\r\n\r\n\t    dataviz.ExportMixin = {\r\n\t        extend: function(proto, skipLegacy) {\r\n\t            if (!proto.exportVisual) {\r\n\t                throw new Error(\"Mixin target has no exportVisual method defined.\");\r\n\t            }\r\n\r\n\t            proto.exportSVG = this.exportSVG;\r\n\t            proto.exportImage = this.exportImage;\r\n\t            proto.exportPDF = this.exportPDF;\r\n\r\n\t            if (!skipLegacy) {\r\n\t                proto.svg = this.svg;\r\n\t                proto.imageDataURL = this.imageDataURL;\r\n\t            }\r\n\t        },\r\n\r\n\t        exportSVG: function(options) {\r\n\t            return draw.exportSVG(this.exportVisual(), options);\r\n\t        },\r\n\r\n\t        exportImage: function(options) {\r\n\t            return draw.exportImage(this.exportVisual(options), options);\r\n\t        },\r\n\r\n\t        exportPDF: function(options) {\r\n\t            return draw.exportPDF(this.exportVisual(), options);\r\n\t        },\r\n\r\n\t        svg: function() {\r\n\t            if (draw.svg.Surface) {\r\n\t                return draw.svg.exportGroup(this.exportVisual());\r\n\t            } else {\r\n\t                throw new Error(\"SVG Export failed. Unable to export instantiate kendo.drawing.svg.Surface\");\r\n\t            }\r\n\t        },\r\n\r\n\t        imageDataURL: function() {\r\n\t            if (!kendo.support.canvas) {\r\n\t                return null;\r\n\t            }\r\n\r\n\t            if (draw.canvas.Surface) {\r\n\t                var container = $(\"<div />\").css({\r\n\t                    display: \"none\",\r\n\t                    width: this.element.width(),\r\n\t                    height: this.element.height()\r\n\t                }).appendTo(document.body);\r\n\r\n\t                var surface = new draw.canvas.Surface(container[0]);\r\n\t                surface.draw(this.exportVisual());\r\n\t                var image = surface._rootElement.toDataURL();\r\n\r\n\t                surface.destroy();\r\n\t                container.remove();\r\n\r\n\t                return image;\r\n\t            } else {\r\n\t                throw new Error(\"Image Export failed. Unable to export instantiate kendo.drawing.canvas.Surface\");\r\n\t            }\r\n\t        }\r\n\t    };\r\n\r\n\t    services.IntlService.register({\r\n\t       format: function(format) {\r\n\t           return kendo.format.apply(null, [format].concat(Array.prototype.slice.call(arguments, 1)));\r\n\t       },\r\n\t       toString: kendo.toString,\r\n\t       parseDate: kendo.parseDate\r\n\t    });\r\n\r\n\t    services.TemplateService.register({\r\n\t       compile: kendo.template\r\n\t    });\r\n\r\n\t    dataviz.Point2D = dataviz.Point;\r\n\t    dataviz.Box2D = dataviz.Box;\r\n\t    dataviz.mwDelta = function(e) {\r\n\t        return dataviz.mousewheelDelta(e.originalEvent);\r\n\t    };\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 858:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo-core\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/dataviz/core/core.js\n// module id = 519\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(905);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 850:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.dataviz.core\");\n\n/***/ }),\n\n/***/ 905:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t     !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(850) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\t    var cache;\n\n\t    function autoTheme(force) {\n\t        if (!force && cache) {\n\t            return cache;\n\t        }\n\n\t        var theme = { chart: kendo.dataviz.chartBaseTheme() };\n\t        var hook = $(\n\t            '<div style=\"display: none\">' +\n\t            '  <div class=\"k-var--accent\"></div>' +\n\t            '  <div class=\"k-var--accent-contrast\"></div>' +\n\t            '  <div class=\"k-var--base\"></div>' +\n\t            '  <div class=\"k-var--background\"></div>' +\n\t            '  <div class=\"k-var--normal-background\"></div>' +\n\t            '  <div class=\"k-var--normal-text-color\"></div>' +\n\t            '  <div class=\"k-var--hover-background\"></div>' +\n\t            '  <div class=\"k-var--hover-text-color\"></div>' +\n\t            '  <div class=\"k-var--selected-background\"></div>' +\n\t            '  <div class=\"k-var--selected-text-color\"></div>' +\n\t            '  <div class=\"k-var--chart-error-bars-background\"></div>' +\n\t            '  <div class=\"k-var--chart-notes-background\"></div>' +\n\t            '  <div class=\"k-var--chart-notes-border\"></div>' +\n\t            '  <div class=\"k-var--chart-notes-lines\"></div>' +\n\t            '  <div class=\"k-var--chart-crosshair-background\"></div>' +\n\t            '  <div class=\"k-var--chart-inactive\"></div>' +\n\t            '  <div class=\"k-var--chart-major-lines\"></div>' +\n\t            '  <div class=\"k-var--chart-minor-lines\"></div>' +\n\t            '  <div class=\"k-var--chart-area-opacity\"></div>' +\n\t            '  <div class=\"k-widget\">' +\n\t            '      <div class=\"k-var--chart-font\"></div>' +\n\t            '      <div class=\"k-var--chart-title-font\"></div>' +\n\t            '      <div class=\"k-var--chart-label-font\"></div>' +\n\t            '  </div>' +\n\t            '  <div class=\"k-var--series\">' +\n\t            '    <div class=\"k-var--series-a\"></div>' +\n\t            '    <div class=\"k-var--series-b\"></div>' +\n\t            '    <div class=\"k-var--series-c\"></div>' +\n\t            '    <div class=\"k-var--series-d\"></div>' +\n\t            '    <div class=\"k-var--series-e\"></div>' +\n\t            '    <div class=\"k-var--series-f\"></div>' +\n\t            '  </div>' +\n\t            '</div>').appendTo(document.body);\n\n\t        function mapColor(key, varName) {\n\t            set(key, queryStyle(varName, \"backgroundColor\"));\n\t        }\n\n\t        function queryStyle(varName, prop) {\n\t            return hook.find(\".k-var--\" + varName).css(prop);\n\t        }\n\n\t        function set(path, value) {\n\t            var store = theme;\n\t            var parts = path.split('.');\n\t            var key = parts.shift();\n\n\t            while (parts.length > 0) {\n\t                store = store[key] = store[key] || {};\n\t                key = parts.shift();\n\t            }\n\n\t            store[key] = value;\n\t        }\n\n\t        (function setColors() {\n\t            mapColor(\"chart.axisDefaults.crosshair.color\", \"chart-crosshair-background\");\n\t            mapColor(\"chart.axisDefaults.labels.color\", \"normal-text-color\");\n\t            mapColor(\"chart.axisDefaults.line.color\", \"chart-major-lines\");\n\t            mapColor(\"chart.axisDefaults.majorGridLines.color\", \"chart-major-lines\");\n\t            mapColor(\"chart.axisDefaults.minorGridLines.color\", \"chart-minor-lines\");\n\t            mapColor(\"chart.axisDefaults.notes.icon.background\", \"chart-notes-background\");\n\t            mapColor(\"chart.axisDefaults.notes.icon.border.color\", \"chart-notes-border\");\n\t            mapColor(\"chart.axisDefaults.notes.line.color\", \"chart-notes-lines\");\n\t            mapColor(\"chart.axisDefaults.title.color\", \"normal-text-color\");\n\t            mapColor('chart.chartArea.background', 'background');\n\t            mapColor(\"chart.legend.inactiveItems.labels.color\", \"chart-inactive\");\n\t            mapColor(\"chart.legend.inactiveItems.markers.color\", \"chart-inactive\");\n\t            mapColor(\"chart.legend.labels.color\", \"normal-text-color\");\n\t            mapColor(\"chart.seriesDefaults.boxPlot.downColor\", \"chart-major-lines\");\n\t            mapColor(\"chart.seriesDefaults.boxPlot.mean.color\", \"base\");\n\t            mapColor(\"chart.seriesDefaults.boxPlot.median.color\", \"base\");\n\t            mapColor(\"chart.seriesDefaults.boxPlot.whiskers.color\", \"accent\");\n\t            mapColor(\"chart.seriesDefaults.bullet.target.color\", \"accent\");\n\t            mapColor(\"chart.seriesDefaults.candlestick.downColor\", \"normal-text-color\");\n\t            mapColor(\"chart.seriesDefaults.candlestick.line.color\", \"normal-text-color\");\n\t            mapColor(\"chart.seriesDefaults.errorBars.color\", \"chart-error-bars-background\");\n\t            mapColor(\"chart.seriesDefaults.horizontalWaterfall.line.color\", \"chart-major-lines\");\n\t            mapColor(\"chart.seriesDefaults.icon.border.color\", \"chart-major-lines\");\n\t            mapColor(\"chart.seriesDefaults.labels.background\", \"background\");\n\t            mapColor(\"chart.seriesDefaults.labels.color\", \"normal-text-color\");\n\t            mapColor(\"chart.seriesDefaults.notes.icon.background\", \"chart-notes-background\");\n\t            mapColor(\"chart.seriesDefaults.notes.icon.border.color\", \"chart-notes-border\");\n\t            mapColor(\"chart.seriesDefaults.notes.line.color\", \"chart-notes-lines\");\n\t            mapColor(\"chart.seriesDefaults.verticalBoxPlot.downColor\", \"chart-major-lines\");\n\t            mapColor(\"chart.seriesDefaults.verticalBoxPlot.mean.color\", \"base\");\n\t            mapColor(\"chart.seriesDefaults.verticalBoxPlot.median.color\", \"base\");\n\t            mapColor(\"chart.seriesDefaults.verticalBoxPlot.whiskers.color\", \"accent\");\n\t            mapColor(\"chart.seriesDefaults.verticalBullet.target.color\", \"accent\");\n\t            mapColor(\"chart.seriesDefaults.waterfall.line.color\", \"chart-major-lines\");\n\t            mapColor(\"chart.title.color\", \"normal-text-color\");\n\n\t            set(\"chart.seriesDefaults.labels.opacity\", queryStyle(\"chart-area-opacity\", \"opacity\"));\n\n\t            mapColor(\"diagram.shapeDefaults.fill.color\", \"accent\");\n\t            mapColor(\"diagram.shapeDefaults.content.color\", \"accent-contrast\");\n\t            mapColor(\"diagram.shapeDefaults.connectorDefaults.fill.color\", \"normal-text-color\");\n\t            mapColor(\"diagram.shapeDefaults.connectorDefaults.stroke.color\", \"accent-contrast\");\n\t            mapColor(\"diagram.shapeDefaults.connectorDefaults.hover.fill.color\", \"accent-contrast\");\n\t            mapColor(\"diagram.shapeDefaults.connectorDefaults.hover.stroke.color\", \"normal-text-color\");\n\t            mapColor(\"diagram.editable.resize.handles.stroke.color\", \"normal-text-color\");\n\t            mapColor(\"diagram.editable.resize.handles.fill.color\", \"normal-background\");\n\t            mapColor(\"diagram.editable.resize.handles.hover.stroke.color\", \"normal-text-color\");\n\t            mapColor(\"diagram.editable.resize.handles.hover.fill.color\", \"normal-text-color\");\n\t            mapColor(\"diagram.selectable.stroke.color\", \"normal-text-color\");\n\t            mapColor(\"diagram.connectionDefaults.stroke.color\", \"normal-text-color\");\n\t            mapColor(\"diagram.connectionDefaults.content.color\", \"normal-text-color\");\n\t            mapColor(\"diagram.connectionDefaults.selection.handles.fill.color\", \"accent-contrast\");\n\t            mapColor(\"diagram.connectionDefaults.selection.handles.stroke.color\", \"normal-text-color\");\n\t            mapColor(\"diagram.connectionDefaults.selection.stroke.color\", \"normal-text-color\");\n\t        })();\n\n\t        (function setFonts() {\n\t            function font(varName) {\n\t                return queryStyle(varName, \"fontSize\") + \" \" +\n\t                       queryStyle(varName, \"fontFamily\");\n\t            }\n\n\t            var defaultFont = font(\"chart-font\");\n\t            var titleFont = font(\"chart-title-font\");\n\t            var labelFont = font(\"chart-label-font\");\n\n\t            set(\"chart.axisDefaults.labels.font\", labelFont);\n\t            set(\"chart.axisDefaults.notes.label.font\", defaultFont);\n\t            set(\"chart.axisDefaults.title.font\", defaultFont);\n\t            set(\"chart.legend.labels.font\", defaultFont);\n\t            set(\"chart.seriesDefaults.labels.font\", labelFont);\n\t            set(\"chart.seriesDefaults.notes.label.font\", defaultFont);\n\t            set(\"chart.title.font\", titleFont);\n\t        })();\n\n\t        (function setSeriesColors() {\n\t            function letterPos(letter) {\n\t                return letter.toLowerCase().charCodeAt(0) - \"a\".charCodeAt(0);\n\t            }\n\n\t            function seriesPos(name) {\n\t                return letterPos(name.match(/series-([a-z])$/)[1]);\n\t            }\n\n\t            var series = $(\".k-var--series div\").toArray();\n\t            var seriesColors = series.reduce(\n\t              function(arr, el) {\n\t                var pos = seriesPos(el.className);\n\t                arr[pos] = $(el).css(\"backgroundColor\");\n\n\t                return arr;\n\t              },\n\t              [] // Will populate the series colors in this array\n\t            );\n\n\t            set(\"chart.seriesColors\", seriesColors);\n\t        })();\n\n\t        hook.remove();\n\n\t        cache = theme;\n\n\t        return theme;\n\t    }\n\n\t    kendo.dataviz.autoTheme = autoTheme;\n\n\t}, __webpack_require__(3));\n\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/dataviz/themes/auto-theme.js\n// module id = 520\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(907);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 907:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(908) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t})(function(){\n\n\t(function ($) {\n\n\t    // Imports ================================================================\n\t    var kendo = window.kendo,\n\t        ui = kendo.dataviz.ui,\n\t        deepExtend = kendo.deepExtend;\n\n\t    // Constants ==============================================================\n\t    var BLACK = \"#000\",\n\t        SANS = \"Arial,Helvetica,sans-serif\",\n\t        SANS12 = \"12px \" + SANS,\n\t        WHITE = \"#fff\";\n\n\t    var chartBaseTheme = kendo.dataviz.chartBaseTheme({\n\t        gradients: true\n\t    });\n\n\t    var gaugeBaseTheme = {\n\t        scale: {\n\t            labels: {\n\t                font: SANS12\n\t            }\n\t        }\n\t    };\n\n\t    var diagramBaseTheme = {\n\t        shapeDefaults: {\n\t            hover: {\n\t                opacity: 0.2\n\t            },\n\t            stroke: {\n\t                width: 0\n\t            }\n\t        },\n\t        editable: {\n\t            resize: {\n\t                handles: {\n\t                    width: 7,\n\t                    height: 7\n\t                }\n\t            }\n\t        },\n\t        selectable: {\n\t            stroke: {\n\t                width: 1,\n\t                dashType: \"dot\"\n\t            }\n\t        },\n\t        connectionDefaults: {\n\t            stroke: {\n\t                width: 2\n\t            },\n\t            selection: {\n\t                handles: {\n\t                    width: 8,\n\t                    height: 8\n\t                }\n\t            },\n\t            editable: {\n\t                tools: [\"edit\", \"delete\"]\n\t            }\n\t        }\n\t    };\n\n\t    var themes = ui.themes,\n\t        registerTheme = ui.registerTheme = function(themeName, options) {\n\t            var result = {};\n\t            // Apply base theme\n\t            result.chart = deepExtend({}, chartBaseTheme, options.chart);\n\t            result.gauge = deepExtend({}, gaugeBaseTheme, options.gauge);\n\t            result.diagram = deepExtend({}, diagramBaseTheme, options.diagram);\n\t            result.treeMap = deepExtend({}, options.treeMap);\n\n\t            // Copy the line/area chart settings for their vertical counterparts\n\t            var defaults = result.chart.seriesDefaults;\n\t            defaults.verticalLine = deepExtend({}, defaults.line);\n\t            defaults.verticalArea = deepExtend({}, defaults.area);\n\t            defaults.rangeArea = deepExtend({}, defaults.area);\n\t            defaults.verticalRangeArea = deepExtend({}, defaults.rangeArea);\n\t            defaults.verticalBoxPlot = deepExtend({}, defaults.boxPlot);\n\t            defaults.polarArea = deepExtend({}, defaults.radarArea);\n\t            defaults.polarLine = deepExtend({}, defaults.radarLine);\n\n\t            themes[themeName] = result;\n\t        };\n\n\t    registerTheme(\"black\", {\n\t        chart: {\n\t            title: {\n\t                color: WHITE\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: WHITE\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#919191\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#919191\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: WHITE\n\t                },\n\t                errorBars: {\n\t                    color: WHITE\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"#3b3b3b\",\n\t                        border: {\n\t                            color: \"#8e8e8e\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: WHITE\n\t                    },\n\t                    line: {\n\t                        color: \"#8e8e8e\"\n\t                    }\n\t                },\n\t                pie: {\n\t                    overlay: {\n\t                        gradient: \"sharpBevel\"\n\t                    }\n\t                },\n\t                donut: {\n\t                    overlay: {\n\t                        gradient: \"sharpGlass\"\n\t                    }\n\t                },\n\t                line: {\n\t                    markers: {\n\t                        background: \"#3d3d3d\"\n\t                    }\n\t                },\n\t                scatter: {\n\t                    markers: {\n\t                        background: \"#3d3d3d\"\n\t                    }\n\t                },\n\t                scatterLine: {\n\t                    markers: {\n\t                        background: \"#3d3d3d\"\n\t                    }\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#8e8e8e\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#8e8e8e\"\n\t                    }\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#555\",\n\t                    line: {\n\t                        color: WHITE\n\t                    },\n\t                    border: {\n\t                        _brightness: 1.5,\n\t                        opacity: 1\n\t                    },\n\t                    highlight: {\n\t                        border: {\n\t                            color: WHITE,\n\t                            opacity: 0.2\n\t                        }\n\t                    }\n\t                },\n\t                ohlc: {\n\t                    line: {\n\t                        color: WHITE\n\t                    }\n\t                }\n\t            },\n\t            chartArea: {\n\t                background: \"#3d3d3d\"\n\t            },\n\t            seriesColors: [\"#0081da\", \"#3aafff\", \"#99c900\", \"#ffeb3d\", \"#b20753\", \"#ff4195\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#8e8e8e\"\n\t                },\n\t                labels: {\n\t                    color: WHITE\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#545454\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#454545\"\n\t                },\n\t                title: {\n\t                    color: WHITE\n\t                },\n\t                crosshair: {\n\t                    color: \"#8e8e8e\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"#3b3b3b\",\n\t                        border: {\n\t                            color: \"#8e8e8e\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: WHITE\n\t                    },\n\t                    line: {\n\t                        color: \"#8e8e8e\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#0070e4\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#1d1d1d\",\n\t                labels: {\n\t                    color: WHITE\n\t                },\n\t                minorTicks: {\n\t                    color: WHITE\n\t                },\n\t                majorTicks: {\n\t                    color: WHITE\n\t                },\n\t                line: {\n\t                    color: WHITE\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#0066cc\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: WHITE\n\t                    },\n\t                    stroke: {\n\t                        color: \"#384049\"\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: \"#3d3d3d\"\n\t                        },\n\t                        stroke: {\n\t                            color: \"#efefef\"\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: WHITE\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: \"#3d3d3d\"\n\t                        },\n\t                        stroke: {\n\t                            color: WHITE\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: WHITE\n\t                            },\n\t                            stroke: {\n\t                                color: WHITE\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: WHITE\n\t                        },\n\t                        fill: {\n\t                            color: WHITE\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: WHITE\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: WHITE\n\t                },\n\t                content: {\n\t                    color: WHITE\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: \"#3d3d3d\"\n\t                        },\n\t                        stroke: {\n\t                            color: \"#efefef\"\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#0081da\", \"#314b5c\"],\n\t                [\"#3aafff\", \"#3c5464\"],\n\t                [\"#99c900\", \"#4f5931\"],\n\t                [\"#ffeb3d\", \"#64603d\"],\n\t                [\"#b20753\", \"#543241\"],\n\t                [\"#ff4195\", \"#643e4f\"]]\n\t        }\n\t    });\n\n\t    registerTheme(\"blueopal\", {\n\t        chart: {\n\t            title: {\n\t                color: \"#293135\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#293135\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#27A5BA\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#27A5BA\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: BLACK,\n\t                    background: WHITE,\n\t                    opacity: 0.5\n\t                },\n\t                errorBars: {\n\t                    color: \"#293135\"\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#c4d0d5\",\n\t                    line: {\n\t                        color: \"#9aabb2\"\n\t                    }\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#9aabb2\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#9aabb2\"\n\t                    }\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#9aabb2\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#293135\"\n\t                    },\n\t                    line: {\n\t                        color: \"#9aabb2\"\n\t                    }\n\t                }\n\t            },\n\t            seriesColors: [\"#0069a5\", \"#0098ee\", \"#7bd2f6\", \"#ffb800\", \"#ff8517\", \"#e34a00\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#9aabb2\"\n\t                },\n\t                labels: {\n\t                    color: \"#293135\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#c4d0d5\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#edf1f2\"\n\t                },\n\t                title: {\n\t                    color: \"#293135\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#9aabb2\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#9aabb2\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#293135\"\n\t                    },\n\t                    line: {\n\t                        color: \"#9aabb2\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#005c83\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#daecf4\",\n\n\t                labels: {\n\t                    color: \"#293135\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#293135\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#293135\"\n\t                },\n\t                line: {\n\t                    color: \"#293135\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#7ec6e3\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: \"#003f59\"\n\t                    },\n\t                    stroke: {\n\t                        color: WHITE\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#003f59\"\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: \"#293135\"\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#003f59\"\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: \"#003f59\"\n\t                            },\n\t                            stroke: {\n\t                                color: \"#003f59\"\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: \"#003f59\"\n\t                        },\n\t                        fill: {\n\t                            color: \"#003f59\"\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: \"#003f59\"\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: \"#003f59\"\n\t                },\n\t                content: {\n\t                    color: \"#293135\"\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: \"#3d3d3d\"\n\t                        },\n\t                        stroke: {\n\t                            color: \"#efefef\"\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#0069a5\", \"#bad7e7\"],\n\t                [\"#0098ee\", \"#b9e0f5\"],\n\t                [\"#7bd2f6\", \"#ceeaf6\"],\n\t                [\"#ffb800\", \"#e6e3c4\"],\n\t                [\"#ff8517\", \"#e4d8c8\"],\n\t                [\"#e34a00\", \"#ddccc2\"]\n\t            ]\n\t        }\n\t    });\n\n\t    registerTheme(\"highcontrast\", {\n\t        chart: {\n\t            title: {\n\t                color: \"#ffffff\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#66465B\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#66465B\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                errorBars: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#ffffff\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#ffffff\"\n\t                    },\n\t                    line: {\n\t                        color: \"#ffffff\"\n\t                    }\n\t                },\n\t                pie: {\n\t                    overlay: {\n\t                        gradient: \"sharpGlass\"\n\t                    }\n\t                },\n\t                donut: {\n\t                    overlay: {\n\t                        gradient: \"sharpGlass\"\n\t                    }\n\t                },\n\t                line: {\n\t                    markers: {\n\t                        background: \"#2c232b\"\n\t                    }\n\t                },\n\t                scatter: {\n\t                    markers: {\n\t                        background: \"#2c232b\"\n\t                    }\n\t                },\n\t                scatterLine: {\n\t                    markers: {\n\t                        background: \"#2c232b\"\n\t                    }\n\t                },\n\t                area: {\n\t                    opacity: 0.5\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#ffffff\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#ffffff\"\n\t                    }\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#664e62\",\n\t                    line: {\n\t                        color: \"#ffffff\"\n\t                    },\n\t                    border: {\n\t                        _brightness: 1.5,\n\t                        opacity: 1\n\t                    },\n\t                    highlight: {\n\t                        border: {\n\t                            color: \"#ffffff\",\n\t                            opacity: 1\n\t                        }\n\t                    }\n\t                },\n\t                ohlc: {\n\t                    line: {\n\t                        color: \"#ffffff\"\n\t                    }\n\t                }\n\t            },\n\t            chartArea: {\n\t                background: \"#2c232b\"\n\t            },\n\t            seriesColors: [\"#a7008f\", \"#ffb800\", \"#3aafff\", \"#99c900\", \"#b20753\", \"#ff4195\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#664e62\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#4f394b\"\n\t                },\n\t                title: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#ffffff\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#ffffff\"\n\t                    },\n\t                    line: {\n\t                        color: \"#ffffff\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#a7008f\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#2c232b\",\n\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#2c232b\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#664e62\"\n\t                },\n\t                line: {\n\t                    color: \"#ffffff\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#a7018f\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: WHITE\n\t                    },\n\t                    stroke: {\n\t                        color: \"#2c232b\"\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: \"#2c232b\"\n\t                        },\n\t                        stroke: {\n\t                            color: WHITE\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: WHITE\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: \"#2c232b\"\n\t                        },\n\t                        stroke: {\n\t                            color: WHITE\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: WHITE\n\t                            },\n\t                            stroke: {\n\t                                color: WHITE\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: WHITE\n\t                        },\n\t                        fill: {\n\t                            color: WHITE\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: WHITE\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: WHITE\n\t                },\n\t                content: {\n\t                    color: WHITE\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: \"#2c232b\"\n\t                        },\n\t                        stroke: {\n\t                            color: WHITE\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#a7008f\", \"#451c3f\"],\n\t                [\"#ffb800\", \"#564122\"],\n\t                [\"#3aafff\", \"#2f3f55\"],\n\t                [\"#99c900\", \"#424422\"],\n\t                [\"#b20753\", \"#471d33\"],\n\t                [\"#ff4195\", \"#562940\"]\n\t            ]\n\t        }\n\t    });\n\n\t    registerTheme(\"default\", {\n\t        chart: {\n\t            title: {\n\t                color: \"#8e8e8e\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#232323\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#919191\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#919191\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: BLACK,\n\t                    background: WHITE,\n\t                    opacity: 0.5\n\t                },\n\t                errorBars: {\n\t                    color: \"#232323\"\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#dedede\",\n\t                    line: {\n\t                        color: \"#8d8d8d\"\n\t                    }\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#8e8e8e\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#8e8e8e\"\n\t                    }\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#8e8e8e\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#232323\"\n\t                    },\n\t                    line: {\n\t                        color: \"#8e8e8e\"\n\t                    }\n\t                }\n\t            },\n\t            seriesColors: [\"#ff6800\", \"#a0a700\", \"#ff8d00\", \"#678900\", \"#ffb53c\", \"#396000\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#8e8e8e\"\n\t                },\n\t                labels: {\n\t                    color: \"#232323\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#f0f0f0\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#dfdfdf\"\n\t                },\n\t                title: {\n\t                    color: \"#232323\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#8e8e8e\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#8e8e8e\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#232323\"\n\t                    },\n\t                    line: {\n\t                        color: \"#8e8e8e\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#ea7001\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#dedede\",\n\n\t                labels: {\n\t                    color: \"#2e2e2e\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#2e2e2e\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#2e2e2e\"\n\t                },\n\t                line: {\n\t                    color: \"#2e2e2e\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#e15613\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: \"#282828\"\n\t                    },\n\t                    stroke: {\n\t                        color: WHITE\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#282828\"\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: \"#2e2e2e\"\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#282828\"\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: \"#282828\"\n\t                            },\n\t                            stroke: {\n\t                                color: \"#282828\"\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: \"#282828\"\n\t                        },\n\t                        fill: {\n\t                            color: \"#282828\"\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: \"#a7018f\"\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: \"#282828\"\n\t                },\n\t                content: {\n\t                    color: \"#2e2e2e\"\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#282828\"\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#ff6800\", \"#edcfba\"],\n\t                [\"#a0a700\", \"#dadcba\"],\n\t                [\"#ff8d00\", \"#edd7ba\"],\n\t                [\"#678900\", \"#cfd6ba\"],\n\t                [\"#ffb53c\", \"#eddfc6\"],\n\t                [\"#396000\", \"#c6ceba\"]\n\t            ]\n\t        }\n\t    });\n\n\t    registerTheme(\"silver\", {\n\t        chart: {\n\t            title: {\n\t                color: \"#4e5968\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#4e5968\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#B1BCC8\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#B1BCC8\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: \"#293135\",\n\t                    background: \"#eaeaec\",\n\t                    opacity: 0.5\n\t                },\n\t                errorBars: {\n\t                    color: \"#4e5968\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#4e5968\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#4e5968\"\n\t                    },\n\t                    line: {\n\t                        color: \"#4e5968\"\n\t                    }\n\t                },\n\t                line: {\n\t                    markers: {\n\t                        background: \"#eaeaec\"\n\t                    }\n\t                },\n\t                scatter: {\n\t                    markers: {\n\t                        background: \"#eaeaec\"\n\t                    }\n\t                },\n\t                scatterLine: {\n\t                    markers: {\n\t                        background: \"#eaeaec\"\n\t                    }\n\t                },\n\t                pie: {\n\t                    connectors: {\n\t                        color: \"#A6B1C0\"\n\t                    }\n\t                },\n\t                donut: {\n\t                    connectors: {\n\t                        color: \"#A6B1C0\"\n\t                    }\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#a6b1c0\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#a6b1c0\"\n\t                    }\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#a6afbe\"\n\t                }\n\t            },\n\t            chartArea: {\n\t                background: \"#eaeaec\"\n\t            },\n\t            seriesColors: [\"#007bc3\", \"#76b800\", \"#ffae00\", \"#ef4c00\", \"#a419b7\", \"#430B62\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#a6b1c0\"\n\t                },\n\t                labels: {\n\t                    color: \"#4e5968\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#dcdcdf\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#eeeeef\"\n\t                },\n\t                title: {\n\t                    color: \"#4e5968\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#a6b1c0\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#4e5968\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#4e5968\"\n\t                    },\n\t                    line: {\n\t                        color: \"#4e5968\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#0879c0\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#f3f3f4\",\n\n\t                labels: {\n\t                    color: \"#515967\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#515967\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#515967\"\n\t                },\n\t                line: {\n\t                    color: \"#515967\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#1c82c2\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: \"#515967\"\n\t                    },\n\t                    stroke: {\n\t                        color: WHITE\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#282828\"\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: \"#515967\"\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#515967\"\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: \"#515967\"\n\t                            },\n\t                            stroke: {\n\t                                color: \"#515967\"\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: \"#515967\"\n\t                        },\n\t                        fill: {\n\t                            color: \"#515967\"\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: \"#515967\"\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: \"#515967\"\n\t                },\n\t                content: {\n\t                    color: \"#515967\"\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#515967\"\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#007bc3\", \"#c2dbea\"],\n\t                [\"#76b800\", \"#dae7c3\"],\n\t                [\"#ffae00\", \"#f5e5c3\"],\n\t                [\"#ef4c00\", \"#f2d2c3\"],\n\t                [\"#a419b7\", \"#e3c7e8\"],\n\t                [\"#430b62\", \"#d0c5d7\"]\n\t            ]\n\t        }\n\t    });\n\n\t    registerTheme(\"metro\", {\n\t        chart: {\n\t            title: {\n\t                color: \"#777777\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#777777\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#CBCBCB\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#CBCBCB\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: BLACK\n\t                },\n\t                errorBars: {\n\t                    color: \"#777777\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#777777\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#777777\"\n\t                    },\n\t                    line: {\n\t                        color: \"#777777\"\n\t                    }\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#c7c7c7\",\n\t                    line: {\n\t                        color: \"#787878\"\n\t                    }\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#c7c7c7\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#c7c7c7\"\n\t                    }\n\t                },\n\t                overlay: {\n\t                    gradient: \"none\"\n\t                },\n\t                border: {\n\t                    _brightness: 1\n\t                }\n\t            },\n\t            seriesColors: [\"#8ebc00\", \"#309b46\", \"#25a0da\", \"#ff6900\", \"#e61e26\", \"#d8e404\", \"#16aba9\", \"#7e51a1\", \"#313131\", \"#ed1691\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#c7c7c7\"\n\t                },\n\t                labels: {\n\t                    color: \"#777777\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#c7c7c7\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#c7c7c7\"\n\t                },\n\t                title: {\n\t                    color: \"#777777\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#c7c7c7\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#777777\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#777777\"\n\t                    },\n\t                    line: {\n\t                        color: \"#777777\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#8ebc00\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#e6e6e6\",\n\n\t                labels: {\n\t                    color: \"#777\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#777\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#777\"\n\t                },\n\t                line: {\n\t                    color: \"#777\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#8ebc00\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: BLACK\n\t                    },\n\t                    stroke: {\n\t                        color: WHITE\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: BLACK\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: \"#777\"\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#787878\"\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: \"#787878\"\n\t                            },\n\t                            stroke: {\n\t                                color: \"#787878\"\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: \"#787878\"\n\t                        },\n\t                        fill: {\n\t                            color: \"#787878\"\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: \"#515967\"\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: \"#787878\"\n\t                },\n\t                content: {\n\t                    color: \"#777\"\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#787878\"\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#8ebc00\", \"#e8f2cc\"],\n\t                [\"#309b46\", \"#d6ebda\"],\n\t                [\"#25a0da\", \"#d3ecf8\"],\n\t                [\"#ff6900\", \"#ffe1cc\"],\n\t                [\"#e61e26\", \"#fad2d4\"],\n\t                [\"#d8e404\", \"#f7facd\"],\n\t                [\"#16aba9\", \"#d0eeee\"],\n\t                [\"#7e51a1\", \"#e5dcec\"],\n\t                [\"#313131\", \"#d6d6d6\"],\n\t                [\"#ed1691\", \"#fbd0e9\"]\n\t            ]\n\t        }\n\t    });\n\n\t    registerTheme(\"metroblack\", {\n\t        chart: {\n\t            title: {\n\t                color: \"#ffffff\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#797979\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#797979\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                border: {\n\t                    _brightness: 1\n\t                },\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                errorBars: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#cecece\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#ffffff\"\n\t                    },\n\t                    line: {\n\t                        color: \"#cecece\"\n\t                    }\n\t                },\n\t                line: {\n\t                    markers: {\n\t                        background: \"#0e0e0e\"\n\t                    }\n\t                },\n\t                bubble: {\n\t                    opacity: 0.6\n\t                },\n\t                scatter: {\n\t                    markers: {\n\t                        background: \"#0e0e0e\"\n\t                    }\n\t                },\n\t                scatterLine: {\n\t                    markers: {\n\t                        background: \"#0e0e0e\"\n\t                    }\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#828282\",\n\t                    line: {\n\t                        color: \"#ffffff\"\n\t                    }\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#cecece\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#cecece\"\n\t                    }\n\t                },\n\t                overlay: {\n\t                    gradient: \"none\"\n\t                }\n\t            },\n\t            chartArea: {\n\t                background: \"#0e0e0e\"\n\t            },\n\t            seriesColors: [\"#00aba9\", \"#309b46\", \"#8ebc00\", \"#ff6900\", \"#e61e26\", \"#d8e404\", \"#25a0da\", \"#7e51a1\", \"#313131\", \"#ed1691\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#cecece\"\n\t                },\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#2d2d2d\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#333333\"\n\t                },\n\t                title: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#cecece\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#cecece\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#ffffff\"\n\t                    },\n\t                    line: {\n\t                        color: \"#cecece\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#00aba9\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#2d2d2d\",\n\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#333333\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#cecece\"\n\t                },\n\t                line: {\n\t                    color: \"#cecece\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#00aba9\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: WHITE\n\t                    },\n\t                    stroke: {\n\t                        color: \"#0e0e0e\"\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: \"#0e0e0e\"\n\t                        },\n\t                        stroke: {\n\t                            color: WHITE\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: WHITE\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: \"#0e0e0e\"\n\t                        },\n\t                        stroke: {\n\t                            color: \"#787878\"\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: \"#787878\"\n\t                            },\n\t                            stroke: {\n\t                                color: \"#787878\"\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: WHITE\n\t                        },\n\t                        fill: {\n\t                            color: WHITE\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: \"#787878\"\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: WHITE\n\t                },\n\t                content: {\n\t                    color: WHITE\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: \"#0e0e0e\"\n\t                        },\n\t                        stroke: {\n\t                            color: WHITE\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#00aba9\", \"#0b2d2d\"],\n\t                [\"#309b46\", \"#152a19\"],\n\t                [\"#8ebc00\", \"#28310b\"],\n\t                [\"#ff6900\", \"#3e200b\"],\n\t                [\"#e61e26\", \"#391113\"],\n\t                [\"#d8e404\", \"#36390c\"],\n\t                [\"#25a0da\", \"#132b37\"],\n\t                [\"#7e51a1\", \"#241b2b\"],\n\t                [\"#313131\", \"#151515\"],\n\t                [\"#ed1691\", \"#3b1028\"]\n\t            ]\n\t        }\n\t    });\n\n\t    registerTheme(\"moonlight\", {\n\t        chart: {\n\t            title: {\n\t                color: \"#ffffff\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#A1A7AB\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#A1A7AB\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                errorBars: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#8c909e\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#ffffff\"\n\t                    },\n\t                    line: {\n\t                        color: \"#8c909e\"\n\t                    }\n\t                },\n\t                pie: {\n\t                    overlay: {\n\t                        gradient: \"sharpBevel\"\n\t                    }\n\t                },\n\t                donut: {\n\t                    overlay: {\n\t                        gradient: \"sharpGlass\"\n\t                    }\n\t                },\n\t                line: {\n\t                    markers: {\n\t                        background: \"#212a33\"\n\t                    }\n\t                },\n\t                bubble: {\n\t                    opacity: 0.6\n\t                },\n\t                scatter: {\n\t                    markers: {\n\t                        background: \"#212a33\"\n\t                    }\n\t                },\n\t                scatterLine: {\n\t                    markers: {\n\t                        background: \"#212a33\"\n\t                    }\n\t                },\n\t                area: {\n\t                    opacity: 0.3\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#757d87\",\n\t                    line: {\n\t                        color: \"#ea9d06\"\n\t                    },\n\t                    border: {\n\t                        _brightness: 1.5,\n\t                        opacity: 1\n\t                    },\n\t                    highlight: {\n\t                        border: {\n\t                            color: WHITE,\n\t                            opacity: 0.2\n\t                        }\n\t                    }\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#8c909e\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#8c909e\"\n\t                    }\n\t                },\n\t                ohlc: {\n\t                    line: {\n\t                        color: \"#ea9d06\"\n\t                    }\n\t                }\n\t            },\n\t            chartArea: {\n\t                background: \"#212a33\"\n\t            },\n\t            seriesColors: [\"#ffca08\", \"#ff710f\", \"#ed2e24\", \"#ff9f03\", \"#e13c02\", \"#a00201\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#8c909e\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#8c909e\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#8c909e\"\n\t                },\n\t                labels: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#3e424d\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#2f3640\"\n\t                },\n\t                title: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#8c909e\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#8c909e\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#ffffff\"\n\t                    },\n\t                    line: {\n\t                        color: \"#8c909e\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#f4af03\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#2f3640\",\n\n\t                labels: {\n\t                    color: WHITE\n\t                },\n\t                minorTicks: {\n\t                    color: \"#8c909e\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#8c909e\"\n\t                },\n\t                line: {\n\t                    color: \"#8c909e\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#f3ae03\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: WHITE\n\t                    },\n\t                    stroke: {\n\t                        color: \"#414550\"\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: \"#414550\"\n\t                        },\n\t                        stroke: {\n\t                            color: WHITE\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: WHITE\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: \"#414550\"\n\t                        },\n\t                        stroke: {\n\t                            color: WHITE\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: WHITE\n\t                            },\n\t                            stroke: {\n\t                                color: WHITE\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: WHITE\n\t                        },\n\t                        fill: {\n\t                            color: WHITE\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: WHITE\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: WHITE\n\t                },\n\t                content: {\n\t                    color: WHITE\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: \"#414550\"\n\t                        },\n\t                        stroke: {\n\t                            color: WHITE\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#ffca08\", \"#4e4b2b\"],\n\t                [\"#ff710f\", \"#4e392d\"],\n\t                [\"#ed2e24\", \"#4b2c31\"],\n\t                [\"#ff9f03\", \"#4e422a\"],\n\t                [\"#e13c02\", \"#482e2a\"],\n\t                [\"#a00201\", \"#3b232a\"]\n\t            ]\n\t        }\n\t    });\n\n\t    registerTheme(\"uniform\", {\n\t        chart: {\n\t            title: {\n\t                color: \"#686868\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#686868\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#B6B6B6\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#B6B6B6\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: \"#686868\"\n\t                },\n\t                errorBars: {\n\t                    color: \"#686868\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#9e9e9e\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#686868\"\n\t                    },\n\t                    line: {\n\t                        color: \"#9e9e9e\"\n\t                    }\n\t                },\n\t                pie: {\n\t                    overlay: {\n\t                        gradient: \"sharpBevel\"\n\t                    }\n\t                },\n\t                donut: {\n\t                    overlay: {\n\t                        gradient: \"sharpGlass\"\n\t                    }\n\t                },\n\t                line: {\n\t                    markers: {\n\t                        background: \"#ffffff\"\n\t                    }\n\t                },\n\t                bubble: {\n\t                    opacity: 0.6\n\t                },\n\t                scatter: {\n\t                    markers: {\n\t                        background: \"#ffffff\"\n\t                    }\n\t                },\n\t                scatterLine: {\n\t                    markers: {\n\t                        background: \"#ffffff\"\n\t                    }\n\t                },\n\t                area: {\n\t                    opacity: 0.3\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#cccccc\",\n\t                    line: {\n\t                        color: \"#cccccc\"\n\t                    },\n\t                    border: {\n\t                        _brightness: 1.5,\n\t                        opacity: 1\n\t                    },\n\t                    highlight: {\n\t                        border: {\n\t                            color: \"#cccccc\",\n\t                            opacity: 0.2\n\t                        }\n\t                    }\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#9e9e9e\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#9e9e9e\"\n\t                    }\n\t                },\n\t                ohlc: {\n\t                    line: {\n\t                        color: \"#cccccc\"\n\t                    }\n\t                }\n\t            },\n\t            chartArea: {\n\t                background: \"#ffffff\"\n\t            },\n\t            seriesColors: [\"#527aa3\", \"#6f91b3\", \"#8ca7c2\", \"#a8bdd1\", \"#c5d3e0\", \"#e2e9f0\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#9e9e9e\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#aaaaaa\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#888888\"\n\t                },\n\t                labels: {\n\t                    color: \"#686868\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#dadada\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#e7e7e7\"\n\t                },\n\t                title: {\n\t                    color: \"#686868\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#9e9e9e\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#9e9e9e\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#686868\"\n\t                    },\n\t                    line: {\n\t                        color: \"#9e9e9e\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#527aa3\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#e7e7e7\",\n\n\t                labels: {\n\t                    color: \"#686868\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#aaaaaa\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#888888\"\n\t                },\n\t                line: {\n\t                    color: \"#9e9e9e\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#d1d1d1\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: \"#686868\"\n\t                    },\n\t                    stroke: {\n\t                        color: WHITE\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#686868\"\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: \"#686868\"\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#686868\"\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: \"#686868\"\n\t                            },\n\t                            stroke: {\n\t                                color: \"#686868\"\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: \"#686868\"\n\t                        },\n\t                        fill: {\n\t                            color: \"#686868\"\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: \"#686868\"\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: \"#686868\"\n\t                },\n\t                content: {\n\t                    color: \"#686868\"\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#686868\"\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#527aa3\", \"#d0d8e1\"],\n\t                [\"#6f91b3\", \"#d6dde4\"],\n\t                [\"#8ca7c2\", \"#dce1e7\"],\n\t                [\"#a8bdd1\", \"#e2e6ea\"],\n\t                [\"#c5d3e0\", \"#e7eaed\"],\n\t                [\"#e2e9f0\", \"#edeff0\"]\n\t            ]\n\t        }\n\t    });\n\n\t    registerTheme(\"bootstrap\", {\n\t        chart: {\n\t            title: {\n\t                color: \"#333333\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#333333\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#999999\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#9A9A9A\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: \"#333333\"\n\t                },\n\t                overlay: {\n\t                    gradient: \"none\"\n\t                },\n\t                errorBars: {\n\t                    color: \"#343434\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"#000000\",\n\t                        border: {\n\t                            color: \"#000000\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#333333\"\n\t                    },\n\t                    line: {\n\t                        color: \"#000000\"\n\t                    }\n\t                },\n\t                pie: {\n\t                    overlay: {\n\t                        gradient: \"none\"\n\t                    }\n\t                },\n\t                donut: {\n\t                    overlay: {\n\t                        gradient: \"none\"\n\t                    }\n\t                },\n\t                line: {\n\t                    markers: {\n\t                        background: \"#ffffff\"\n\t                    }\n\t                },\n\t                bubble: {\n\t                    opacity: 0.6\n\t                },\n\t                scatter: {\n\t                    markers: {\n\t                        background: \"#ffffff\"\n\t                    }\n\t                },\n\t                scatterLine: {\n\t                    markers: {\n\t                        background: \"#ffffff\"\n\t                    }\n\t                },\n\t                area: {\n\t                    opacity: 0.8\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#d0d0d0\",\n\t                    line: {\n\t                        color: \"#333333\"\n\t                    },\n\t                    border: {\n\t                        _brightness: 1.5,\n\t                        opacity: 1\n\t                    },\n\t                    highlight: {\n\t                        border: {\n\t                            color: \"#b8b8b8\",\n\t                            opacity: 0.2\n\t                        }\n\t                    }\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#cccccc\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#cccccc\"\n\t                    }\n\t                },\n\t                ohlc: {\n\t                    line: {\n\t                        color: \"#333333\"\n\t                    }\n\t                }\n\t            },\n\t            chartArea: {\n\t                background: \"#ffffff\"\n\t            },\n\t            seriesColors: [\"#428bca\", \"#5bc0de\", \"#5cb85c\", \"#f2b661\", \"#e67d4a\", \"#da3b36\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#cccccc\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#ebebeb\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#cccccc\"\n\t                },\n\t                labels: {\n\t                    color: \"#333333\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#cccccc\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#ebebeb\"\n\t                },\n\t                title: {\n\t                    color: \"#333333\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#000000\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"#000000\",\n\t                        border: {\n\t                            color: \"#000000\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#ffffff\"\n\t                    },\n\t                    line: {\n\t                        color: \"#000000\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#428bca\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#cccccc\",\n\t                labels: {\n\t                    color: \"#333333\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#ebebeb\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#cccccc\"\n\t                },\n\t                line: {\n\t                    color: \"#cccccc\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#428bca\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: \"#333333\"\n\t                    },\n\t                    stroke: {\n\t                        color: WHITE\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#333333\"\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: \"#333333\"\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#333333\"\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: \"#333333\"\n\t                            },\n\t                            stroke: {\n\t                                color: \"#333333\"\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: \"#333333\"\n\t                        },\n\t                        fill: {\n\t                            color: \"#333333\"\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: \"#333333\"\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: \"#c4c4c4\"\n\t                },\n\t                content: {\n\t                    color: \"#333333\"\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#333333\"\n\t                        }\n\t                    },\n\t                    stroke: {\n\t                        color: \"#333333\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#428bca\", \"#d1e0ec\"],\n\t                [\"#5bc0de\", \"#d6eaf0\"],\n\t                [\"#5cb85c\", \"#d6e9d6\"],\n\t                [\"#5cb85c\", \"#f4e8d7\"],\n\t                [\"#e67d4a\", \"#f2ddd3\"],\n\t                [\"#da3b36\", \"#f0d0cf\"]\n\t            ]\n\t        }\n\t    });\n\n\t    registerTheme(\"flat\", {\n\t            chart: {\n\t            title: {\n\t                color: \"#4c5356\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#4c5356\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#CBCBCB\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#CBCBCB\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: \"#4c5356\"\n\t                },\n\t                errorBars: {\n\t                    color: \"#4c5356\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#cdcdcd\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#4c5356\"\n\t                    },\n\t                    line: {\n\t                        color: \"#cdcdcd\"\n\t                    }\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#c7c7c7\",\n\t                    line: {\n\t                        color: \"#787878\"\n\t                    }\n\t                },\n\t                area: {\n\t                    opacity: 0.9\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#cdcdcd\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#cdcdcd\"\n\t                    }\n\t                },\n\t                overlay: {\n\t                    gradient: \"none\"\n\t                },\n\t                border: {\n\t                    _brightness: 1\n\t                }\n\t            },\n\t            seriesColors: [\"#10c4b2\", \"#ff7663\", \"#ffb74f\", \"#a2df53\", \"#1c9ec4\", \"#ff63a5\", \"#1cc47b\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#cdcdcd\"\n\t                },\n\t                labels: {\n\t                    color: \"#4c5356\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#cdcdcd\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#cdcdcd\"\n\t                },\n\t                title: {\n\t                    color: \"#4c5356\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#cdcdcd\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#cdcdcd\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#4c5356\"\n\t                    },\n\t                    line: {\n\t                        color: \"#cdcdcd\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#10c4b2\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#cdcdcd\",\n\n\t                labels: {\n\t                    color: \"#4c5356\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#4c5356\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#4c5356\"\n\t                },\n\t                line: {\n\t                    color: \"#4c5356\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#10c4b2\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: \"#363940\"\n\t                    },\n\t                    stroke: {\n\t                        color: WHITE\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#363940\"\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: \"#4c5356\"\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#363940\"\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: \"#363940\"\n\t                            },\n\t                            stroke: {\n\t                                color: \"#363940\"\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: \"#363940\"\n\t                        },\n\t                        fill: {\n\t                            color: \"#363940\"\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: \"#363940\"\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: \"#cdcdcd\"\n\t                },\n\t                content: {\n\t                    color: \"#4c5356\"\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#363940\"\n\t                        }\n\t                    },\n\t                    stroke: {\n\t                        color: \"#363940\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#10c4b2\", \"#cff3f0\"],\n\t                [\"#ff7663\", \"#ffe4e0\"],\n\t                [\"#ffb74f\", \"#fff1dc\"],\n\t                [\"#a2df53\", \"#ecf9dd\"],\n\t                [\"#1c9ec4\", \"#d2ecf3\"],\n\t                [\"#ff63a5\", \"#ffe0ed\"],\n\t                [\"#1cc47b\", \"#d2f3e5\"]\n\t            ]\n\t        }\n\t    });\n\n\n\t     registerTheme(\"material\", {\n\t       chart: {\n\t            title: {\n\t                color: \"#444444\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#444444\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#CBCBCB\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#CBCBCB\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: \"#444444\"\n\t                },\n\t                errorBars: {\n\t                    color: \"#444444\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#e5e5e5\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#444444\"\n\t                    },\n\t                    line: {\n\t                        color: \"#e5e5e5\"\n\t                    }\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#c7c7c7\",\n\t                    line: {\n\t                        color: \"#787878\"\n\t                    }\n\t                },\n\t                area: {\n\t                    opacity: 0.9\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#e5e5e5\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#e5e5e5\"\n\t                    }\n\t                },\n\t                overlay: {\n\t                    gradient: \"none\"\n\t                },\n\t                border: {\n\t                    _brightness: 1\n\t                }\n\t            },\n\t            seriesColors: [\"#3f51b5\", \"#03a9f4\", \"#4caf50\", \"#f9ce1d\", \"#ff9800\", \"#ff5722\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#e5e5e5\"\n\t                },\n\t                labels: {\n\t                    color: \"#444444\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#e5e5e5\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#e5e5e5\"\n\t                },\n\t                title: {\n\t                    color: \"#444444\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#7f7f7f\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#e5e5e5\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#444444\"\n\t                    },\n\t                    line: {\n\t                        color: \"#e5e5e5\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#3f51b5\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#e5e5e5\",\n\n\t                labels: {\n\t                    color: \"#444444\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#444444\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#444444\"\n\t                },\n\t                line: {\n\t                    color: \"#444444\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#3f51b5\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: \"#7f7f7f\"\n\t                    },\n\t                    stroke: {\n\t                        color: WHITE\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#7f7f7f\"\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: \"#444444\"\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#444444\"\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: \"#444444\"\n\t                            },\n\t                            stroke: {\n\t                                color: \"#444444\"\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: \"#444444\"\n\t                        },\n\t                        fill: {\n\t                            color: \"#444444\"\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: \"#444444\"\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: \"#7f7f7f\"\n\t                },\n\t                content: {\n\t                    color: \"#444444\"\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#444444\"\n\t                        }\n\t                    },\n\t                    stroke: {\n\t                        color: \"#444444\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#3f51b5\", \"#cff3f0\"],\n\t                [\"#03a9f4\", \"#e5f6fe\"],\n\t                [\"#4caf50\", \"#edf7ed\"],\n\t                [\"#f9ce1d\", \"#fefae8\"],\n\t                [\"#ff9800\", \"#fff4e5\"],\n\t                [\"#ff5722\", \"#ffeee8\"]\n\t            ]\n\t        }\n\t    });\n\n\t    registerTheme(\"materialblack\", {\n\t       chart: {\n\t            title: {\n\t                color: \"#fff\"\n\t            },\n\t            legend: {\n\t                labels: {\n\t                    color: \"#fff\"\n\t                },\n\t                inactiveItems: {\n\t                    labels: {\n\t                        color: \"#CBCBCB\"\n\t                    },\n\t                    markers: {\n\t                        color: \"#CBCBCB\"\n\t                    }\n\t                }\n\t            },\n\t            seriesDefaults: {\n\t                labels: {\n\t                    color: \"#fff\"\n\t                },\n\t                errorBars: {\n\t                    color: \"#fff\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#e5e5e5\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#fff\"\n\t                    },\n\t                    line: {\n\t                        color: \"#e5e5e5\"\n\t                    }\n\t                },\n\t                candlestick: {\n\t                    downColor: \"#c7c7c7\",\n\t                    line: {\n\t                        color: \"#787878\"\n\t                    }\n\t                },\n\t                area: {\n\t                    opacity: 0.9\n\t                },\n\t                waterfall: {\n\t                    line: {\n\t                        color: \"#4d4d4d\"\n\t                    }\n\t                },\n\t                horizontalWaterfall: {\n\t                    line: {\n\t                        color: \"#4d4d4d\"\n\t                    }\n\t                },\n\t                overlay: {\n\t                    gradient: \"none\"\n\t                },\n\t                border: {\n\t                    _brightness: 1\n\t                }\n\t            },\n\t            chartArea: {\n\t                background: \"#1c1c1c\"\n\t            },\n\t            seriesColors: [\"#3f51b5\", \"#03a9f4\", \"#4caf50\", \"#f9ce1d\", \"#ff9800\", \"#ff5722\"],\n\t            axisDefaults: {\n\t                line: {\n\t                    color: \"#4d4d4d\"\n\t                },\n\t                labels: {\n\t                    color: \"#fff\"\n\t                },\n\t                minorGridLines: {\n\t                    color: \"#4d4d4d\"\n\t                },\n\t                majorGridLines: {\n\t                    color: \"#4d4d4d\"\n\t                },\n\t                title: {\n\t                    color: \"#fff\"\n\t                },\n\t                crosshair: {\n\t                    color: \"#7f7f7f\"\n\t                },\n\t                notes: {\n\t                    icon: {\n\t                        background: \"transparent\",\n\t                        border: {\n\t                            color: \"#4d4d4d\"\n\t                        }\n\t                    },\n\t                    label: {\n\t                        color: \"#fff\"\n\t                    },\n\t                    line: {\n\t                        color: \"#4d4d4d\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        gauge: {\n\t            pointer: {\n\t                color: \"#3f51b5\"\n\t            },\n\t            scale: {\n\t                rangePlaceholderColor: \"#4d4d4d\",\n\n\t                labels: {\n\t                    color: \"#fff\"\n\t                },\n\t                minorTicks: {\n\t                    color: \"#fff\"\n\t                },\n\t                majorTicks: {\n\t                    color: \"#fff\"\n\t                },\n\t                line: {\n\t                    color: \"#fff\"\n\t                }\n\t            }\n\t        },\n\t        diagram: {\n\t            shapeDefaults: {\n\t                fill: {\n\t                    color: \"#3f51b5\"\n\t                },\n\t                connectorDefaults: {\n\t                    fill: {\n\t                        color: \"#7f7f7f\"\n\t                    },\n\t                    stroke: {\n\t                        color: WHITE\n\t                    },\n\t                    hover: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#7f7f7f\"\n\t                        }\n\t                    }\n\t                },\n\t                content: {\n\t                    color: \"#fff\"\n\t                }\n\t            },\n\t            editable: {\n\t                resize: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#fff\"\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: \"#fff\"\n\t                            },\n\t                            stroke: {\n\t                                color: \"#fff\"\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                rotate: {\n\t                    thumb: {\n\t                        stroke: {\n\t                            color: \"#fff\"\n\t                        },\n\t                        fill: {\n\t                            color: \"#fff\"\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            selectable: {\n\t                stroke: {\n\t                    color: \"#fff\"\n\t                }\n\t            },\n\t            connectionDefaults: {\n\t                stroke: {\n\t                    color: \"#7f7f7f\"\n\t                },\n\t                content: {\n\t                    color: \"#fff\"\n\t                },\n\t                selection: {\n\t                    handles: {\n\t                        fill: {\n\t                            color: WHITE\n\t                        },\n\t                        stroke: {\n\t                            color: \"#fff\"\n\t                        }\n\t                    },\n\t                    stroke: {\n\t                        color: \"#fff\"\n\t                    }\n\t                }\n\t            }\n\t        },\n\t        treeMap: {\n\t            colors: [\n\t                [\"#3f51b5\", \"#cff3f0\"],\n\t                [\"#03a9f4\", \"#e5f6fe\"],\n\t                [\"#4caf50\", \"#edf7ed\"],\n\t                [\"#f9ce1d\", \"#fefae8\"],\n\t                [\"#ff9800\", \"#fff4e5\"],\n\t                [\"#ff5722\", \"#ffeee8\"]\n\t            ]\n\t        }\n\t    });\n\n\t    (function () {\n\t        var TEXT = \"#333333\";\n\t        var INACTIVE = \"#7f7f7f\";\n\t        var INACTIVE_SHAPE = \"#bdbdbd\";\n\t        var AXIS = \"#c8c8c8\";\n\t        var AXIS_MINOR = \"#dddddd\";\n\t        var SERIES = [\"#008fd3\", \"#99d101\", \"#f39b02\", \"#f05662\", \"#c03c53\", \"#acacac\"];\n\t        var SERIES_LIGHT = [\"#cbe8f5\", \"#eaf5cb\", \"#fceacc\", \"#fbdcdf\", \"#f2d7dc\", \"#eeeeee\"];\n\t        var PRIMARY = SERIES[0];\n\t        var DIAGRAM_HOVER = WHITE;\n\n\t        function noteStyle() {\n\t            return {\n\t                icon: {\n\t                    background: \"#007cc0\",\n\t                    border: {\n\t                        color: \"#007cc0\"\n\t                    }\n\t                },\n\t                label: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                line: {\n\t                    color: AXIS\n\t                }\n\t            };\n\t        }\n\n\t        registerTheme(\"fiori\", {\n\t            chart: {\n\t                title: {\n\t                    color: TEXT\n\t                },\n\t                legend: {\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    inactiveItems: {\n\t                        labels: {\n\t                            color: INACTIVE\n\t                        },\n\t                        markers: {\n\t                            color: INACTIVE\n\t                        }\n\t                    }\n\t                },\n\t                seriesDefaults: {\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    errorBars: {\n\t                        color: TEXT\n\t                    },\n\t                    notes: noteStyle(),\n\t                    candlestick: {\n\t                        downColor: AXIS,\n\t                        line: {\n\t                            color: INACTIVE_SHAPE\n\t                        }\n\t                    },\n\t                    area: {\n\t                        opacity: 0.8\n\t                    },\n\t                    waterfall: {\n\t                        line: {\n\t                            color: AXIS\n\t                        }\n\t                    },\n\t                    horizontalWaterfall: {\n\t                        line: {\n\t                            color: AXIS\n\t                        }\n\t                    },\n\t                    overlay: {\n\t                        gradient: \"none\"\n\t                    },\n\t                    border: {\n\t                        _brightness: 1\n\t                    }\n\t                },\n\t                seriesColors: SERIES,\n\t                axisDefaults: {\n\t                    line: {\n\t                        color: AXIS\n\t                    },\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    minorGridLines: {\n\t                        color: AXIS_MINOR\n\t                    },\n\t                    majorGridLines: {\n\t                        color: AXIS\n\t                    },\n\t                    title: {\n\t                        color: TEXT\n\t                    },\n\t                    crosshair: {\n\t                        color: INACTIVE\n\t                    },\n\t                    notes: noteStyle()\n\t                }\n\t            },\n\t            gauge: {\n\t                pointer: {\n\t                    color: PRIMARY\n\t                },\n\t                scale: {\n\t                    rangePlaceholderColor: AXIS,\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    minorTicks: {\n\t                        color: TEXT\n\t                    },\n\t                    majorTicks: {\n\t                        color: TEXT\n\t                    },\n\t                    line: {\n\t                        color: TEXT\n\t                    }\n\t                }\n\t            },\n\t            diagram: {\n\t                shapeDefaults: {\n\t                    fill: {\n\t                        color: PRIMARY\n\t                    },\n\t                    connectorDefaults: {\n\t                        fill: {\n\t                            color: TEXT\n\t                        },\n\t                        stroke: {\n\t                            color: DIAGRAM_HOVER\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: DIAGRAM_HOVER\n\t                            },\n\t                            stroke: {\n\t                                color: TEXT\n\t                            }\n\t                        }\n\t                    },\n\t                    content: {\n\t                        color: TEXT\n\t                    }\n\t                },\n\t                editable: {\n\t                    resize: {\n\t                        handles: {\n\t                            fill: {\n\t                                color: DIAGRAM_HOVER\n\t                            },\n\t                            stroke: {\n\t                                color: INACTIVE_SHAPE\n\t                            },\n\t                            hover: {\n\t                                fill: {\n\t                                    color: INACTIVE_SHAPE\n\t                                },\n\t                                stroke: {\n\t                                    color: INACTIVE_SHAPE\n\t                                }\n\t                            }\n\t                        }\n\t                    },\n\t                    rotate: {\n\t                        thumb: {\n\t                            stroke: {\n\t                                color: INACTIVE_SHAPE\n\t                            },\n\t                            fill: {\n\t                                color: INACTIVE_SHAPE\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                selectable: {\n\t                    stroke: {\n\t                        color: INACTIVE_SHAPE\n\t                    }\n\t                },\n\t                connectionDefaults: {\n\t                    stroke: {\n\t                        color: INACTIVE_SHAPE\n\t                    },\n\t                    content: {\n\t                        color: INACTIVE_SHAPE\n\t                    },\n\t                    selection: {\n\t                        handles: {\n\t                            fill: {\n\t                                color: DIAGRAM_HOVER\n\t                            },\n\t                            stroke: {\n\t                                color: INACTIVE_SHAPE\n\t                            }\n\t                        },\n\t                        stroke: {\n\t                            color: INACTIVE_SHAPE\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            treeMap: {\n\t                colors: fuse(SERIES, SERIES_LIGHT)\n\t            }\n\t        });\n\t    })();\n\n\t    (function() {\n\t        var TEXT            = \"#4e4e4e\";\n\t        var INACTIVE        = \"#7f7f7f\";\n\t        var INACTIVE_SHAPE  = \"#bdbdbd\";\n\t        var AXIS            = \"#c8c8c8\";\n\t        var AXIS_MINOR      = \"#e5e5e5\";\n\t        var SERIES          = [\"#0072c6\", \"#5db2ff\", \"#008a17\", \"#82ba00\", \"#ff8f32\", \"#ac193d\"];\n\t        var SERIES_LIGHT    = [\"#cbe2f3\", \"#deeffe\", \"#cbe7d0\", \"#e5f0cb\", \"#fee8d5\", \"#eed0d7\"];\n\t        var PRIMARY         = SERIES[0];\n\t        var DIAGRAM_HOVER   = WHITE;\n\n\t        function noteStyle() {\n\t            return {\n\t                icon: {\n\t                    background: \"#00b0ff\",\n\t                    border: {\n\t                        color: \"#00b0ff\"\n\t                    }\n\t                },\n\t                label: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                line: {\n\t                    color: AXIS\n\t                }\n\t            };\n\t        }\n\n\t        registerTheme(\"office365\", {\n\t            chart: {\n\t                title: {\n\t                    color: TEXT\n\t                },\n\t                legend: {\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    inactiveItems: {\n\t                        labels: {\n\t                            color: INACTIVE\n\t                        },\n\t                        markers: {\n\t                            color: INACTIVE\n\t                        }\n\t                    }\n\t                },\n\t                seriesDefaults: {\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    errorBars: {\n\t                        color: TEXT\n\t                    },\n\t                    notes: noteStyle(),\n\t                    candlestick: {\n\t                        downColor: AXIS,\n\t                        line: {\n\t                            color: INACTIVE_SHAPE\n\t                        }\n\t                    },\n\t                    area: {\n\t                        opacity: 0.8\n\t                    },\n\t                    waterfall: {\n\t                        line: {\n\t                            color: AXIS\n\t                        }\n\t                    },\n\t                    horizontalWaterfall: {\n\t                        line: {\n\t                            color: AXIS\n\t                        }\n\t                    },\n\t                    overlay: {\n\t                        gradient: \"none\"\n\t                    },\n\t                    border: {\n\t                        _brightness: 1\n\t                    }\n\t                },\n\t                seriesColors: SERIES,\n\t                axisDefaults: {\n\t                    line: {\n\t                        color: AXIS\n\t                    },\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    minorGridLines: {\n\t                        color: AXIS_MINOR\n\t                    },\n\t                    majorGridLines: {\n\t                        color: AXIS\n\t                    },\n\t                    title: {\n\t                        color: TEXT\n\t                    },\n\t                    crosshair: {\n\t                        color: INACTIVE\n\t                    },\n\t                    notes: noteStyle()\n\t                }\n\t            },\n\t            gauge: {\n\t                pointer: {\n\t                    color: PRIMARY\n\t                },\n\t                scale: {\n\t                    rangePlaceholderColor: AXIS,\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    minorTicks: {\n\t                        color: TEXT\n\t                    },\n\t                    majorTicks: {\n\t                        color: TEXT\n\t                    },\n\t                    line: {\n\t                        color: TEXT\n\t                    }\n\t                }\n\t            },\n\t            diagram: {\n\t                shapeDefaults: {\n\t                    fill: {\n\t                        color: PRIMARY\n\t                    },\n\t                    connectorDefaults: {\n\t                        fill: {\n\t                            color: TEXT\n\t                        },\n\t                        stroke: {\n\t                            color: DIAGRAM_HOVER\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: DIAGRAM_HOVER\n\t                            },\n\t                            stroke: {\n\t                                color: TEXT\n\t                            }\n\t                        }\n\t                    },\n\t                    content: {\n\t                        color: TEXT\n\t                    }\n\t                },\n\t                editable: {\n\t                    resize: {\n\t                        handles: {\n\t                            fill: {\n\t                                color: DIAGRAM_HOVER\n\t                            },\n\t                            stroke: {\n\t                                color: INACTIVE_SHAPE\n\t                            },\n\t                            hover: {\n\t                                fill: {\n\t                                    color: INACTIVE_SHAPE\n\t                                },\n\t                                stroke: {\n\t                                    color: INACTIVE_SHAPE\n\t                                }\n\t                            }\n\t                        }\n\t                    },\n\t                    rotate: {\n\t                        thumb: {\n\t                            stroke: {\n\t                                color: INACTIVE_SHAPE\n\t                            },\n\t                            fill: {\n\t                                color: INACTIVE_SHAPE\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                selectable: {\n\t                    stroke: {\n\t                        color: INACTIVE_SHAPE\n\t                    }\n\t                },\n\t                connectionDefaults: {\n\t                    stroke: {\n\t                        color: INACTIVE_SHAPE\n\t                    },\n\t                    content: {\n\t                        color: INACTIVE_SHAPE\n\t                    },\n\t                    selection: {\n\t                        handles: {\n\t                            fill: {\n\t                                color: DIAGRAM_HOVER\n\t                            },\n\t                            stroke: {\n\t                                color: INACTIVE_SHAPE\n\t                            }\n\t                        },\n\t                        stroke: {\n\t                            color: INACTIVE_SHAPE\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            treeMap: {\n\t                colors: fuse(SERIES, SERIES_LIGHT)\n\t            }\n\t        });\n\t    })();\n\n\t        (function () {\n\t        var TEXT = \"#32364c\";\n\t        var INACTIVE = \"#7f7f7f\";\n\t        var INACTIVE_SHAPE = \"#bdbdbd\";\n\t        var AXIS = \"#dfe0e1\";\n\t        var AXIS_MINOR = \"#dfe0e1\";\n\t        var SERIES = [\"#ff4350\", \"#ff9ea5\", \"#00acc1\", \"#80deea\", \"#ffbf46\", \"#ffd78c\"];\n\t        var SERIES_LIGHT = [\"#ffd9dc\", \"#ffeced\", \"#cceef3\", \"#e6f8fb\", \"#fff2da\", \"#fff7e8\"];\n\t        var PRIMARY = SERIES[0];\n\t        var DIAGRAM_HOVER = WHITE;\n\n\t        function noteStyle() {\n\t            return {\n\t                icon: {\n\t                    background: \"#007cc0\",\n\t                    border: {\n\t                        color: \"#007cc0\"\n\t                    }\n\t                },\n\t                label: {\n\t                    color: \"#ffffff\"\n\t                },\n\t                line: {\n\t                    color: AXIS\n\t                }\n\t            };\n\t        }\n\n\t        registerTheme(\"nova\", {\n\t            chart: {\n\t                title: {\n\t                    color: TEXT\n\t                },\n\t                legend: {\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    inactiveItems: {\n\t                        labels: {\n\t                            color: INACTIVE\n\t                        },\n\t                        markers: {\n\t                            color: INACTIVE\n\t                        }\n\t                    }\n\t                },\n\t                seriesDefaults: {\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    errorBars: {\n\t                        color: TEXT\n\t                    },\n\t                    notes: noteStyle(),\n\t                    candlestick: {\n\t                        downColor: AXIS,\n\t                        line: {\n\t                            color: INACTIVE_SHAPE\n\t                        }\n\t                    },\n\t                    area: {\n\t                        opacity: 0.8\n\t                    },\n\t                    waterfall: {\n\t                        line: {\n\t                            color: AXIS\n\t                        }\n\t                    },\n\t                    horizontalWaterfall: {\n\t                        line: {\n\t                            color: AXIS\n\t                        }\n\t                    },\n\t                    overlay: {\n\t                        gradient: \"none\"\n\t                    },\n\t                    border: {\n\t                        _brightness: 1\n\t                    }\n\t                },\n\t                seriesColors: SERIES,\n\t                axisDefaults: {\n\t                    line: {\n\t                        color: AXIS\n\t                    },\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    minorGridLines: {\n\t                        color: AXIS_MINOR\n\t                    },\n\t                    majorGridLines: {\n\t                        color: AXIS\n\t                    },\n\t                    title: {\n\t                        color: TEXT\n\t                    },\n\t                    crosshair: {\n\t                        color: TEXT\n\t                    },\n\t                    notes: noteStyle()\n\t                }\n\t            },\n\t            gauge: {\n\t                pointer: {\n\t                    color: PRIMARY\n\t                },\n\t                scale: {\n\t                    rangePlaceholderColor: AXIS,\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    minorTicks: {\n\t                        color: TEXT\n\t                    },\n\t                    majorTicks: {\n\t                        color: TEXT\n\t                    },\n\t                    line: {\n\t                        color: TEXT\n\t                    }\n\t                }\n\t            },\n\t            diagram: {\n\t                shapeDefaults: {\n\t                    fill: {\n\t                        color: PRIMARY\n\t                    },\n\t                    connectorDefaults: {\n\t                        fill: {\n\t                            color: TEXT\n\t                        },\n\t                        stroke: {\n\t                            color: DIAGRAM_HOVER\n\t                        },\n\t                        hover: {\n\t                            fill: {\n\t                                color: DIAGRAM_HOVER\n\t                            },\n\t                            stroke: {\n\t                                color: TEXT\n\t                            }\n\t                        }\n\t                    },\n\t                    content: {\n\t                        color: TEXT\n\t                    }\n\t                },\n\t                editable: {\n\t                    resize: {\n\t                        handles: {\n\t                            fill: {\n\t                                color: DIAGRAM_HOVER\n\t                            },\n\t                            stroke: {\n\t                                color: INACTIVE_SHAPE\n\t                            },\n\t                            hover: {\n\t                                fill: {\n\t                                    color: INACTIVE_SHAPE\n\t                                },\n\t                                stroke: {\n\t                                    color: INACTIVE_SHAPE\n\t                                }\n\t                            }\n\t                        }\n\t                    },\n\t                    rotate: {\n\t                        thumb: {\n\t                            stroke: {\n\t                                color: INACTIVE_SHAPE\n\t                            },\n\t                            fill: {\n\t                                color: INACTIVE_SHAPE\n\t                            }\n\t                        }\n\t                    }\n\t                },\n\t                selectable: {\n\t                    stroke: {\n\t                        color: INACTIVE_SHAPE\n\t                    }\n\t                },\n\t                connectionDefaults: {\n\t                    stroke: {\n\t                        color: INACTIVE_SHAPE\n\t                    },\n\t                    content: {\n\t                        color: INACTIVE_SHAPE\n\t                    },\n\t                    selection: {\n\t                        handles: {\n\t                            fill: {\n\t                                color: DIAGRAM_HOVER\n\t                            },\n\t                            stroke: {\n\t                                color: INACTIVE_SHAPE\n\t                            }\n\t                        },\n\t                        stroke: {\n\t                            color: INACTIVE_SHAPE\n\t                        }\n\t                    }\n\t                }\n\t            },\n\t            treeMap: {\n\t                colors: fuse(SERIES, SERIES_LIGHT)\n\t            }\n\t        });\n\t    })();\n\n\t    (function () {\n\t        var TEXT = \"#656565\";\n\t        var AXIS = \"rgba(0, 0, 0, .04)\";\n\t        var SERIES = [\"#ff6358\", \"#ffd246\", \"#78d237\", \"#28b4c8\", \"#2d73f5\", \"#aa46be\"];\n\t        var SERIES_LIGHT = [\"#ffd9dc\", \"#ffeced\", \"#cceef3\", \"#e6f8fb\", \"#fff2da\", \"#fff7e8\"];\n\t        var PRIMARY = SERIES[0];\n\n\t        registerTheme(\"default-v2\", {\n\t            chart: { /* read from DOM */ },\n\t            gauge: {\n\t                pointer: {\n\t                    color: PRIMARY\n\t                },\n\t                scale: {\n\t                    rangePlaceholderColor: AXIS,\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    minorTicks: {\n\t                        color: TEXT\n\t                    },\n\t                    majorTicks: {\n\t                        color: TEXT\n\t                    },\n\t                    line: {\n\t                        color: TEXT\n\t                    }\n\t                }\n\t            },\n\t            diagram: { /* read from DOM */ },\n\t            treeMap: {\n\t                colors: fuse(SERIES, SERIES_LIGHT)\n\t            }\n\t        });\n\n\t        themes.sass = themes[\"default-v2\"];\n\t    })();\n\n\n\n\t    (function () {\n\t        var TEXT = \"#292b2c\";\n\t        var AXIS = \"rgba(0, 0, 0, .04)\";\n\t        var SERIES = [\"#0275d8\", \"#5bc0de\", \"#5cb85c\", \"#f0ad4e\", \"#e67d4a\", \"#d9534f\"];\n\t        var SERIES_LIGHT = [\"#ffd9dc\", \"#ffeced\", \"#cceef3\", \"#e6f8fb\", \"#fff2da\", \"#fff7e8\"];\n\t        var PRIMARY = SERIES[0];\n\n\t        registerTheme(\"bootstrap-v4\", {\n\t            chart: { /* read from DOM */ },\n\t            gauge: {\n\t                pointer: {\n\t                    color: PRIMARY\n\t                },\n\t                scale: {\n\t                    rangePlaceholderColor: AXIS,\n\t                    labels: {\n\t                        color: TEXT\n\t                    },\n\t                    minorTicks: {\n\t                        color: TEXT\n\t                    },\n\t                    majorTicks: {\n\t                        color: TEXT\n\t                    },\n\t                    line: {\n\t                        color: TEXT\n\t                    }\n\t                }\n\t            },\n\t            diagram: { /* read from DOM */ },\n\t            treeMap: {\n\t                colors: fuse(SERIES, SERIES_LIGHT)\n\t            }\n\t        });\n\t    })();\n\n\t    function fuse(arr1, arr2) {\n\t        return $.map(arr1, function(item, index) {\n\t            return [\n\t                [item, arr2[index]]\n\t            ];\n\t        });\n\t    }\n\n\t})(window.kendo.jQuery);\n\n\treturn window.kendo;\n\n\t}, __webpack_require__(3));\n\n\n/***/ }),\n\n/***/ 908:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./chart-base-theme\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/dataviz/themes/themes.js\n// module id = 521\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1054);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1054:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n\t        __webpack_require__(1055),\r\n\t        __webpack_require__(1056)\r\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"dataviz.chart\",\r\n\t    name: \"Chart\",\r\n\t    category: \"dataviz\",\r\n\t    description: \"The Chart widget uses modern browser technologies to render high-quality data visualizations in the browser.\",\r\n\t    depends: [ \"data\", \"userevents\", \"drawing\", \"dataviz.core\", \"dataviz.themes\" ],\r\n\t    features: [{\r\n\t        id: \"dataviz.chart-pdf-export\",\r\n\t        name: \"PDF export\",\r\n\t        description: \"Export Chart as PDF\",\r\n\t        depends: [ \"pdf\" ]\r\n\t    }]\r\n\t};\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ }),\n\n/***/ 1055:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./dataviz/chart/kendo-chart\");\n\n/***/ }),\n\n/***/ 1056:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./dataviz/chart/chart\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.dataviz.chart.js\n// module id = 522\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(847);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 847:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n\t        __webpack_require__(848),\r\n\t        __webpack_require__(849),\r\n\t        __webpack_require__(850),\r\n\t        __webpack_require__(851),\r\n\t        __webpack_require__(852),\r\n\t        __webpack_require__(853)\r\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\t(function ($, undefined) {\r\n\r\n\t    var NS = \".kendoChart\";\r\n\t    var kendo = window.kendo;\r\n\t    var Class = kendo.Class;\r\n\t    var outerWidth = kendo._outerWidth;\r\n\t    var outerHeight = kendo._outerHeight;\r\n\t    var dataviz = kendo.dataviz;\r\n\t    var constants = dataviz.constants;\r\n\t    var KendoChart = dataviz.Chart;\r\n\t    var SeriesBinder = dataviz.SeriesBinder;\r\n\t    var Widget = kendo.ui.Widget;\r\n\t    var DataSource = kendo.data.DataSource;\r\n\t    var deepExtend = kendo.deepExtend;\r\n\t    var defined = dataviz.defined;\r\n\t    var getField = dataviz.getField;\r\n\t    var InstanceObserver = dataviz.InstanceObserver;\r\n\t    var inArray = dataviz.inArray;\r\n\t    var services = dataviz.services;\r\n\t    var proxy = $.proxy;\r\n\t    var isArray = $.isArray;\r\n\t    var extend = $.extend;\r\n\t    var template = kendo.template;\r\n\r\n\t    var MOUSELEAVE_NS = \"mouseleave\" + NS;\r\n\t    var AXIS_LABEL_CLICK = constants.AXIS_LABEL_CLICK;\r\n\t    var LEGEND_ITEM_CLICK = constants.LEGEND_ITEM_CLICK;\r\n\t    var LEGEND_ITEM_HOVER = constants.LEGEND_ITEM_HOVER;\r\n\t    var SERIES_CLICK = constants.SERIES_CLICK;\r\n\t    var SERIES_HOVER = constants.SERIES_HOVER;\r\n\t    var PLOT_AREA_CLICK = constants.PLOT_AREA_CLICK;\r\n\t    var PLOT_AREA_HOVER = constants.PLOT_AREA_HOVER;\r\n\t    var DRAG = constants.DRAG;\r\n\t    var DRAG_END = constants.DRAG_END;\r\n\t    var DRAG_START = constants.DRAG_START;\r\n\t    var ZOOM_START = constants.ZOOM_START;\r\n\t    var ZOOM = constants.ZOOM;\r\n\t    var ZOOM_END = constants.ZOOM_END;\r\n\t    var SELECT_START = constants.SELECT_START;\r\n\t    var SELECT = constants.SELECT;\r\n\t    var SELECT_END = constants.SELECT_END;\r\n\t    var RENDER = constants.RENDER;\r\n\t    var NOTE_CLICK = constants.NOTE_CLICK;\r\n\t    var NOTE_HOVER = constants.NOTE_HOVER;\r\n\r\n\t    var CHANGE = \"change\";\r\n\t    var DATABOUND = \"dataBound\";\r\n\t    var LEAVE = \"leave\";\r\n\r\n\t    var VALUE = constants.VALUE;\r\n\t    var PIE = constants.PIE;\r\n\t    var DONUT = constants.DONUT;\r\n\t    var FUNNEL = constants.FUNNEL;\r\n\r\n\t    var Observable = kendo.Observable;\r\n\t    var TOOLTIP_ANIMATION_DURATION = 150;\r\n\t    var TOOLTIP_SHOW_DELAY = 100;\r\n\t    var TOOLTIP_INVERSE = \"k-chart-tooltip-inverse\";\r\n\t    var SHARED_TOOLTIP_CLASS = \"k-chart-shared-tooltip\";\r\n\t    var RTL = \"rtl\";\r\n\r\n\t    services.DomEventsBuilder.register({\r\n\t        create: function(element, events) {\r\n\t             return new kendo.UserEvents(element, deepExtend({\r\n\t                 global: true,\r\n\t                 multiTouch: true,\r\n\t                 fastTap: true\r\n\t             }, events));\r\n\t        }\r\n\t    });\r\n\r\n\t    var ChartInstanceObserver = InstanceObserver.extend({\r\n\t        handlerMap: {\r\n\t            showTooltip: '_showTooltip',\r\n\t            hideTooltip: '_hideTooltip',\r\n\t            legendItemClick: '_onLegendItemClick',\r\n\t            render: '_onRender',\r\n\t            init: '_onInit'\r\n\t        }\r\n\t    });\r\n\r\n\t    var Chart = Widget.extend({\r\n\t        init: function(element, userOptions) {\r\n\t            var dataSource;\r\n\r\n\t            kendo.destroy(element);\r\n\r\n\t            Widget.fn.init.call(this, element);\r\n\r\n\t            if (userOptions) {\r\n\t                dataSource = userOptions.dataSource;\r\n\t                delete userOptions.dataSource;\r\n\t            }\r\n\r\n\t            this.options =  deepExtend({}, this.options, userOptions);\r\n\r\n\t            this.wrapper = this.element;\r\n\t            this._attachEvents();\r\n\r\n\t            if (userOptions) {\r\n\t                userOptions.dataSource = dataSource;\r\n\t            }\r\n\r\n\t            this._seriesVisibility = new SeriesVisibilityState();\r\n\r\n\t            this.bind(this.events, this.options);\r\n\t            this._initDataSource(userOptions);\r\n\r\n\t            kendo.notify(this, dataviz.ui);\r\n\t        },\r\n\r\n\t        events:[\r\n\t            DATABOUND,\r\n\t            SERIES_CLICK,\r\n\t            SERIES_HOVER,\r\n\t            AXIS_LABEL_CLICK,\r\n\t            LEGEND_ITEM_CLICK,\r\n\t            LEGEND_ITEM_HOVER,\r\n\t            PLOT_AREA_CLICK,\r\n\t            PLOT_AREA_HOVER,\r\n\t            DRAG_START,\r\n\t            DRAG,\r\n\t            DRAG_END,\r\n\t            ZOOM_START,\r\n\t            ZOOM,\r\n\t            ZOOM_END,\r\n\t            SELECT_START,\r\n\t            SELECT,\r\n\t            SELECT_END,\r\n\t            NOTE_CLICK,\r\n\t            NOTE_HOVER,\r\n\t            RENDER\r\n\t        ],\r\n\r\n\t        options: {\r\n\t            name: \"Chart\",\r\n\t            renderAs: \"\",\r\n\t            theme: \"default\",\r\n\t            axisDefaults: {},\r\n\t            chartArea: {},\r\n\t            legend: {},\r\n\t            categoryAxis: {},\r\n\t            autoBind: true,\r\n\t            seriesDefaults: {},\r\n\t            series: [],\r\n\t            seriesColors: null,\r\n\t            tooltip: {},\r\n\t            transitions: true,\r\n\t            valueAxis: {},\r\n\t            plotArea: {},\r\n\t            title: {},\r\n\t            xAxis: {},\r\n\t            yAxis: {},\r\n\t            panes: [{}],\r\n\t            pannable: false,\r\n\t            zoomable: false\r\n\t        },\r\n\r\n\t        items: function() {\r\n\t            return $();\r\n\t        },\r\n\r\n\t        refresh: function() {\r\n\t            var chart = this;\r\n\t            var instance = chart._instance;\r\n\t            instance.applyDefaults(chart.options);\r\n\t            instance.applySeriesColors();\r\n\r\n\t            chart._bindSeries();\r\n\t            chart._bindCategories();\r\n\r\n\t            chart.trigger(DATABOUND);\r\n\t            chart._redraw();\r\n\t        },\r\n\r\n\t        getSize: function() {\r\n\t            return kendo.dimensions(this.element);\r\n\t        },\r\n\r\n\t        redraw: function(paneName) {\r\n\t            this._size = null;\r\n\t            this._instance.redraw(paneName);\r\n\t        },\r\n\r\n\t        setOptions: function(options) {\r\n\t            var chart = this,\r\n\t                dataSource = options.dataSource;\r\n\r\n\t            delete options.dataSource;\r\n\r\n\t            Widget.fn._setEvents.call(chart, options);\r\n\r\n\t            this._instance.applyOptions(options, this._getThemeOptions(options));\r\n\t            this.options = this._instance.options;\r\n\t            this._tooltip.setOptions(this.options.tooltip);\r\n\t            this._sourceSeries = null;\r\n\r\n\t            if (dataSource) {\r\n\t                chart.setDataSource(dataSource);\r\n\t            }\r\n\r\n\t            if (chart._hasDataSource) {\r\n\t                chart._onDataChanged();\r\n\t            } else {\r\n\t                chart._bindCategories();\r\n\t                chart.redraw();\r\n\t            }\r\n\r\n\t            chart._instance.updateMouseMoveHandler();\r\n\t        },\r\n\r\n\t        setDataSource: function(dataSource) {\r\n\t            var chart = this;\r\n\r\n\t            chart.dataSource.unbind(CHANGE, chart._dataChangeHandler);\r\n\t            chart.dataSource = dataSource = DataSource.create(dataSource);\r\n\t            chart._hasDataSource = true;\r\n\t            chart._hasData = false;\r\n\r\n\t            dataSource.bind(CHANGE, chart._dataChangeHandler);\r\n\r\n\t            if (chart.options.autoBind) {\r\n\t                dataSource.fetch();\r\n\t            }\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            var chart = this,\r\n\t                dataSource = chart.dataSource;\r\n\r\n\t            chart.element.off(NS);\r\n\r\n\t            if (dataSource) {\r\n\t                dataSource.unbind(CHANGE, chart._dataChangeHandler);\r\n\t            }\r\n\r\n\t            if (chart._instance) {\r\n\t                chart._instance.destroy();\r\n\t                delete this._instance;\r\n\t            }\r\n\r\n\t            if (this._tooltip) {\r\n\t                this._tooltip.destroy();\r\n\t                delete this._tooltip;\r\n\t            }\r\n\r\n\t            this._destroyCrosshairTooltips();\r\n\r\n\t            Widget.fn.destroy.call(chart);\r\n\t        },\r\n\r\n\t        findPaneByName: function(name) {\r\n\t            var panes = this._plotArea.panes;\r\n\r\n\t            for (var idx = 0; idx < panes.length; idx++) {\r\n\t                if (panes[idx].options.name === name) {\r\n\t                    return new ChartPane(this, panes[idx]);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        findPaneByIndex: function(idx) {\r\n\t            var panes = this._plotArea.panes;\r\n\t            if (panes[idx]) {\r\n\t                return new ChartPane(this, panes[idx]);\r\n\t            }\r\n\t        },\r\n\r\n\t        findSeries: function(callback) {\r\n\t            var plotArea = this._plotArea;\r\n\t            var series = plotArea.srcSeries || plotArea.series;\r\n\t            for (var idx = 0; idx < series.length; idx++) {\r\n\t                if (callback(series[idx])) {\r\n\t                    return new ChartSeries(this, series[idx]);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        findSeriesByName: function(name) {\r\n\t            return this._createSeries({ name: name });\r\n\t        },\r\n\r\n\t        findSeriesByIndex: function(index) {\r\n\t            return this._createSeries({ index: index });\r\n\t        },\r\n\r\n\t        _createSeries: function(options) {\r\n\t            var seriesOptions = this._seriesOptions(options);\r\n\t            if (seriesOptions) {\r\n\t                return new ChartSeries(this, seriesOptions);\r\n\t            }\r\n\t        },\r\n\r\n\t        _seriesOptions: function(options) {\r\n\t            var plotArea = this._plotArea;\r\n\t            var series = plotArea.srcSeries || plotArea.series;\r\n\t            var seriesOptions;\r\n\r\n\t            if (defined(options.index)) {\r\n\t                seriesOptions = series[options.index];\r\n\t            } else if (defined(options.name)) {\r\n\t                for (var idx = 0; idx < series.length; idx++) {\r\n\t                    if (series[idx].name === options.name) {\r\n\t                        seriesOptions = series[idx];\r\n\t                        break;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\r\n\t            return seriesOptions;\r\n\t        },\r\n\r\n\t        _attachEvents: function() {\r\n\t             this.element.on(MOUSELEAVE_NS, proxy(this._mouseleave, this));\r\n\t        },\r\n\r\n\t        _mouseleave: function(e) {\r\n\t            var instance = this._instance;\r\n\t            var tooltip = this._tooltip;\r\n\t            var target = e.relatedTarget;\r\n\r\n\t            if (!(target && $(target).closest(tooltip.element).length) && instance && !instance.handlingTap) {\r\n\t                instance.hideElements();\r\n\t            }\r\n\t        },\r\n\r\n\t        _getThemeOptions: function(userOptions) {\r\n\t            var themeName = (userOptions || {}).theme;\r\n\t            if (themeName === \"sass\" || themeName === \"default-v2\" || themeName === \"bootstrap-v4\") {\r\n\t                return dataviz.autoTheme().chart;\r\n\t            }\r\n\r\n\t            if (defined(themeName)) {\r\n\t                var themes = dataviz.ui.themes || {};\r\n\t                var theme = themes[themeName] || themes[themeName.toLowerCase()] || {};\r\n\t                return theme.chart || {};\r\n\t            }\r\n\t        },\r\n\r\n\t        _initChart: function() {\r\n\t            this._createChart(this.options, this._getThemeOptions(this.options));\r\n\t            this.options = this._instance.options;\r\n\t        },\r\n\r\n\t        _createChart: function(options, themeOptions) {\r\n\t            this._instance = new KendoChart(this.element[0], options, themeOptions, {\r\n\t                observer: new ChartInstanceObserver(this),\r\n\t                sender: this,\r\n\t                rtl: this._isRtl()\r\n\t            });\r\n\t        },\r\n\r\n\t        _onInit: function(e) {\r\n\t            this._instance = e.sender;\r\n\t        },\r\n\r\n\t        _initDataSource: function(userOptions) {\r\n\t            var chart = this,\r\n\t                dataSource = (userOptions || {}).dataSource;\r\n\r\n\t            chart._dataChangeHandler = proxy(chart._onDataChanged, chart);\r\n\r\n\t            chart.dataSource = DataSource\r\n\t                .create(dataSource)\r\n\t                .bind(\"change\", chart._dataChangeHandler);\r\n\r\n\t            chart._bindCategories();\r\n\r\n\t            if (dataSource) {\r\n\t                chart._hasDataSource = true;\r\n\t            }\r\n\r\n\t            this._initChart();\r\n\t            this._initTooltip();\r\n\r\n\t            if (dataSource) {\r\n\t                if (chart.options.autoBind) {\r\n\t                    chart.dataSource.fetch();\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _destroyCrosshairTooltips: function() {\r\n\t            var tooltips = this._crosshairTooltips;\r\n\t            if (tooltips) {\r\n\t                for (var key in tooltips) {\r\n\t                    tooltips[key].destroy();\r\n\t                }\r\n\t            }\r\n\t            this._crosshairTooltips = {};\r\n\t        },\r\n\r\n\t        _getCrosshairTooltip: function(name, index) {\r\n\t            var tooltips = this._crosshairTooltips = this._crosshairTooltips || {};\r\n\t            var key = name + index;\r\n\t            var tooltip = tooltips[key];\r\n\t            if (!tooltip) {\r\n\t                tooltip = tooltips[key] = new CrosshairTooltip(this.element);\r\n\t            }\r\n\t            return tooltip;\r\n\t        },\r\n\r\n\t        _showTooltip: function(e) {\r\n\t            if (e.crosshair) {\r\n\t                var tooltip = this._getCrosshairTooltip(e.axisName, e.axisIndex);\r\n\t                tooltip.show(e);\r\n\t            } else if (this._tooltip) {\r\n\t                this._tooltip.show(e);\r\n\t            }\r\n\t        },\r\n\r\n\t        _hideTooltip: function(e) {\r\n\t            if (e.crosshair) {\r\n\t                 var tooltip = this._getCrosshairTooltip(e.axisName, e.axisIndex);\r\n\t                 tooltip.hide();\r\n\t            } else if (this._tooltip) {\r\n\t                this._tooltip.hide(e);\r\n\t            }\r\n\t        },\r\n\r\n\t        _onRender: function(e) {\r\n\t            this._destroyCrosshairTooltips();\r\n\t            this._copyMembers(e.sender);\r\n\t            if (!this._hasDataSource || this._hasData || !this.options.autoBind) {\r\n\t                this.trigger(RENDER);\r\n\t            }\r\n\t        },\r\n\r\n\t        _copyMembers: function(instance) {\r\n\t            this.options = instance.options;\r\n\t            this._originalOptions = instance._originalOptions;\r\n\t            this.surface = instance.surface;\r\n\t            this._plotArea = instance._plotArea;\r\n\t            this._model = instance._model;\r\n\t            this._highlight = instance._highlight;\r\n\t            this._selections = instance._selections;\r\n\t            this._pannable = instance._pannable;\r\n\t            this._zoomSelection = instance._zoomSelection;\r\n\t            this._mousewheelZoom = instance._mousewheelZoom;\r\n\t        },\r\n\r\n\t        requiresHandlers: function(names) {\r\n\t           var events = this._events;\r\n\t           for (var idx = 0; idx < names.length; idx++) {\r\n\t               if (defined(events[names[idx]])) {\r\n\t                   return true;\r\n\t               }\r\n\t           }\r\n\t        },\r\n\r\n\t        _initTooltip: function() {\r\n\t            this._tooltip = this._createTooltip();\r\n\r\n\t            this._tooltip.bind(LEAVE, proxy(this._tooltipleave, this));\r\n\t        },\r\n\r\n\t        _onLegendItemClick: function(e) {\r\n\t            if (!this.trigger(LEGEND_ITEM_CLICK, e)) {\r\n\t                this._legendItemClick(e.seriesIndex, e.pointIndex);\r\n\t            }\r\n\t        },\r\n\r\n\t        _legendItemClick: function(seriesIndex, pointIndex) {\r\n\t            var chart = this._instance,\r\n\t                plotArea = chart._plotArea,\r\n\t                currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\r\n\r\n\t            if ($.inArray(currentSeries.type, [PIE, DONUT, FUNNEL]) >= 0) {\r\n\t                var point = currentSeries.data[pointIndex];\r\n\t                if (point && defined(point.visible)) {\r\n\t                    point.visible = !point.visible;\r\n\t                } else {\r\n\t                    var pointVisibility = currentSeries.pointVisibility = currentSeries.pointVisibility || {};\r\n\t                    var visible = pointVisibility[pointIndex];\r\n\t                    pointVisibility[pointIndex] = defined(visible) ? !visible : false;\r\n\t                }\r\n\t            } else {\r\n\t                currentSeries.visible = !currentSeries.visible;\r\n\t                this._seriesVisibility.save(currentSeries);\r\n\t            }\r\n\r\n\t            chart._noTransitionsRedraw();\r\n\t        },\r\n\r\n\t        _createTooltip: function() {\r\n\t            return new Tooltip(this.element, extend({}, this.options.tooltip, {\r\n\t                rtl: this._isRtl()\r\n\t            }));\r\n\t        },\r\n\r\n\t        _tooltipleave: function() {\r\n\t            if (this._instance) {\r\n\t                this._instance.hideElements();\r\n\t            }\r\n\t        },\r\n\r\n\t        _bindData: function(e) {\r\n\t            var chart = this,\r\n\t                options = chart.options,\r\n\t                series = chart._sourceSeries || options.series,\r\n\t                seriesIx,\r\n\t                seriesLength = series.length,\r\n\t                data = chart.dataSource.view(),\r\n\t                grouped = (chart.dataSource.group() || []).length > 0,\r\n\t                processedSeries = [],\r\n\t                seriesVisibility = this._seriesVisibility,\r\n\t                currentSeries,\r\n\t                groupedSeries;\r\n\r\n\t            for (seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\r\n\t                currentSeries = series[seriesIx];\r\n\r\n\t                if (chart._isBindable(currentSeries) && grouped) {\r\n\t                    groupedSeries = groupSeries(currentSeries, data);\r\n\t                    processedSeries = processedSeries.concat(groupedSeries);\r\n\r\n\t                    seriesVisibility.applyByGroup(groupedSeries, e);\r\n\t                } else {\r\n\t                    currentSeries = extend({}, currentSeries);\r\n\t                    processedSeries.push(currentSeries);\r\n\r\n\t                    seriesVisibility.applyByIndex(currentSeries, e);\r\n\t                }\r\n\t            }\r\n\r\n\t            chart._sourceSeries = series;\r\n\t            options.series = processedSeries;\r\n\t            this._instance.applySeriesColors();\r\n\r\n\t            chart._bindSeries();\r\n\t            chart._bindCategories();\r\n\r\n\t            this._hasData = true;\r\n\t        },\r\n\r\n\t        _onDataChanged: function(e) {\r\n\t            this._bindData(e);\r\n\r\n\t            this.trigger(DATABOUND);\r\n\t            this._redraw();\r\n\t        },\r\n\r\n\t        _bindSeries: function() {\r\n\t            var chart = this,\r\n\t                data = chart.dataSource.view(),\r\n\t                series = chart.options.series,\r\n\t                seriesIx,\r\n\t                seriesLength = series.length,\r\n\t                currentSeries,\r\n\t                groupIx,\r\n\t                seriesData;\r\n\r\n\t            for (seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\r\n\t                currentSeries = series[seriesIx];\r\n\r\n\t                if (chart._isBindable(currentSeries)) {\r\n\t                    groupIx = currentSeries._groupIx;\r\n\t                    seriesData = defined(groupIx) ? (data[groupIx] || {}).items : data;\r\n\r\n\t                    if (currentSeries.autoBind !== false) {\r\n\t                        currentSeries.data = seriesData;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _bindCategories: function() {\r\n\t            var chart = this,\r\n\t                data = chart.dataSource.view() || [],\r\n\t                grouped = (chart.dataSource.group() || []).length > 0,\r\n\t                categoriesData = data,\r\n\t                options = chart.options,\r\n\t                definitions = [].concat(options.categoryAxis),\r\n\t                axisIx,\r\n\t                axis;\r\n\r\n\t            if (grouped) {\r\n\t                if (data.length) {\r\n\t                    categoriesData = data[0].items;\r\n\t                }\r\n\t            }\r\n\r\n\t            for (axisIx = 0; axisIx < definitions.length; axisIx++) {\r\n\t                axis = definitions[axisIx];\r\n\t                if (axis.autoBind !== false) {\r\n\t                    chart._bindCategoryAxis(axis, categoriesData, axisIx);\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        _bindCategoryAxis: function(axis, data, axisIx) {\r\n\t            var count = (data || []).length,\r\n\t                categoryIx,\r\n\t                category,\r\n\t                row;\r\n\r\n\t            if (axis.field) {\r\n\t                axis.categories = [];\r\n\t                for (categoryIx = 0; categoryIx < count; categoryIx++) {\r\n\t                    row = data[categoryIx];\r\n\r\n\t                    category = getField(axis.field, row);\r\n\t                    if (categoryIx === 0) {\r\n\t                        axis.categories = [category];\r\n\t                        axis.dataItems = [row];\r\n\t                    } else {\r\n\t                        axis.categories.push(category);\r\n\t                        axis.dataItems.push(row);\r\n\t                    }\r\n\t                }\r\n\t            } else if (this._instance) {\r\n\t                this._instance.bindCategoryAxisFromSeries(axis, axisIx);\r\n\t            }\r\n\t        },\r\n\r\n\t        _isBindable: function(series) {\r\n\t            var valueFields = SeriesBinder.current.valueFields(series),\r\n\t                result = true,\r\n\t                field, i;\r\n\r\n\t            for (i = 0; i < valueFields.length; i++) {\r\n\t                field = valueFields[i];\r\n\t                if (field === VALUE) {\r\n\t                    field = \"field\";\r\n\t                } else {\r\n\t                    field = field + \"Field\";\r\n\t                }\r\n\r\n\t                if (!defined(series[field])) {\r\n\t                    result = false;\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\r\n\t            return result;\r\n\t        },\r\n\r\n\t        _isRtl: function() {\r\n\t            return kendo.support.isRtl(this.element) && this.element.css(\"direction\") === RTL;\r\n\t        }\r\n\t    });\r\n\r\n\t    var proxyMembers = [\"getAxis\", \"findAxisByName\", \"plotArea\", \"toggleHighlight\", \"showTooltip\",\r\n\t        \"hideTooltip\", \"exportVisual\", \"_resize\", \"_redraw\", \"_noTransitionsRedraw\", \"_legendItemHover\", \"_eventCoordinates\"];\r\n\r\n\t    function createProxyMember(name) {\r\n\t        Chart.fn[name] = function() {\r\n\t            var instance = this._instance;\r\n\t            if (instance) {\r\n\t                return instance[name].apply(instance, arguments);\r\n\t            }\r\n\t        };\r\n\t    }\r\n\r\n\t    for (var idx = 0; idx < proxyMembers.length; idx++) {\r\n\t        createProxyMember(proxyMembers[idx]);\r\n\t    }\r\n\r\n\t    function groupSeries(series, data) {\r\n\t        var result = [],\r\n\t            nameTemplate,\r\n\t            legacyTemplate = series.groupNameTemplate,\r\n\t            groupIx,\r\n\t            dataLength = data.length,\r\n\t            seriesClone;\r\n\r\n\t        if (dataLength === 0) {\r\n\t            seriesClone = deepExtend({}, series);\r\n\t            seriesClone.visibleInLegend = false;\r\n\t            return [seriesClone];\r\n\t        }\r\n\r\n\t        if (defined(legacyTemplate)) {\r\n\t            kendo.logToConsole(\r\n\t                \"'groupNameTemplate' is obsolete and will be removed in future versions. \" +\r\n\t                \"Specify the group name template as 'series.name'\"\r\n\t            );\r\n\r\n\t            if (legacyTemplate) {\r\n\t                nameTemplate = template(legacyTemplate);\r\n\t            }\r\n\t        } else {\r\n\t            nameTemplate = template(series.name || \"\");\r\n\t            if (nameTemplate._slotCount === 0) {\r\n\t                nameTemplate = template(defined(series.name) ?\r\n\t                    \"#= group.value #: #= series.name #\" :\r\n\t                    \"#= group.value #\"\r\n\t                );\r\n\t            }\r\n\t        }\r\n\r\n\t        for (groupIx = 0; groupIx < dataLength; groupIx++) {\r\n\t            seriesClone = deepExtend({}, series);\r\n\r\n\t            if (!kendo.isFunction(seriesClone.color)) {\r\n\t                seriesClone.color = undefined;\r\n\t            }\r\n\r\n\t            seriesClone._groupIx = groupIx;\r\n\t            seriesClone._groupValue = data[groupIx].value;\r\n\t            result.push(seriesClone);\r\n\r\n\t            if (nameTemplate) {\r\n\t                seriesClone.name = nameTemplate({\r\n\t                    series: seriesClone, group: data[groupIx]\r\n\t                });\r\n\t            }\r\n\t        }\r\n\r\n\t        return result;\r\n\t    }\r\n\r\n\t    dataviz.ExportMixin.extend(Chart.fn);\r\n\r\n\t    if (kendo.PDFMixin) {\r\n\t        kendo.PDFMixin.extend(Chart.fn);\r\n\t    }\r\n\r\n\t    dataviz.ui.plugin(Chart);\r\n\r\n\t    var SeriesVisibilityState = Class.extend({\r\n\t        init: function() {\r\n\t            this.groups = {};\r\n\t            this.index = {};\r\n\t        },\r\n\r\n\t        applyByGroup: function(series, e) {\r\n\t            if (e && e.action) {\r\n\t                for (var idx = 0; idx < series.length; idx++) {\r\n\t                    if (this.groups[series[idx]._groupValue] === false) {\r\n\t                        series[idx].visible = false;\r\n\t                    }\r\n\t                }\r\n\t            } else {\r\n\t                this.groups = {};\r\n\t            }\r\n\t        },\r\n\r\n\t        applyByIndex: function(series, e) {\r\n\t            if (e && e.action) {\r\n\t                if (this.index[series.index] === false) {\r\n\t                    series.visible = false;\r\n\t                }\r\n\t            } else {\r\n\t                this.index = {};\r\n\t            }\r\n\t        },\r\n\r\n\t        save: function(series) {\r\n\t            if (!series) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            if (defined(series._groupValue)) {\r\n\t                this.groups[series._groupValue] = series.visible;\r\n\t            } else {\r\n\t                this.index[series.index] = series.visible;\r\n\t            }\r\n\t        }\r\n\t    });\r\n\r\n\t    var geom = kendo.geometry;\r\n\r\n\t    function normalizeStyle(style) {\r\n\t        for (var field in style) {\r\n\t            if (style[field] === undefined) {\r\n\t                style[field] = '';\r\n\t            }\r\n\t        }\r\n\r\n\t        return style;\r\n\t    }\r\n\r\n\t    var Tooltip = Observable.extend({\r\n\t        init: function(chartElement, options) {\r\n\t            var tooltip = this;\r\n\r\n\t            Observable.fn.init.call(tooltip);\r\n\r\n\t            this.setOptions(options);\r\n\r\n\t            tooltip.chartElement = chartElement;\r\n\r\n\t            tooltip.template = Tooltip.template;\r\n\t            if (!tooltip.template) {\r\n\t                tooltip.template = Tooltip.template = kendo.template(\r\n\t                    \"<div class='k-tooltip k-chart-tooltip#= d.rtl ? \\\" k-rtl\\\" : \\\"\\\"#' \" +\r\n\t                    \"style='display:none; position: absolute; font: #= d.font #;\" +\r\n\t                    \"#if (d.border) {# border: #= d.border.width #px solid; #}#\" +\r\n\t                    \"opacity: #= d.opacity #; filter: alpha(opacity=#= d.opacity * 100 #);'>\" +\r\n\t                    \"</div>\", { useWithBlock: false, paramName: \"d\" });\r\n\t            }\r\n\r\n\t            tooltip.element = $(tooltip.template(tooltip.options));\r\n\r\n\t            tooltip.move = proxy(tooltip.move, tooltip);\r\n\t            tooltip._mouseleave = proxy(tooltip._mouseleave, tooltip);\r\n\r\n\t            var mobileScrollerSelector = kendo.format(\"[{0}='content'],[{0}='scroller']\", kendo.attr(\"role\"));\r\n\t            tooltip._mobileScroller = chartElement.closest(mobileScrollerSelector).data(\"kendoMobileScroller\");\r\n\t        },\r\n\r\n\t        destroy: function() {\r\n\t            this._clearShowTimeout();\r\n\r\n\t            if (this.element) {\r\n\t                this.element.off(MOUSELEAVE_NS).remove();\r\n\t                this.element = null;\r\n\t            }\r\n\t        },\r\n\r\n\t        setOptions: function(options) {\r\n\t            this.options = deepExtend({}, this.options, options);\r\n\t        },\r\n\r\n\t        options: {\r\n\t            opacity: 1,\r\n\t            animation: {\r\n\t                duration: TOOLTIP_ANIMATION_DURATION\r\n\t            },\r\n\t            sharedTemplate:\r\n\t                \"<table>\" +\r\n\t                \"<th colspan='#= colspan #'>#= categoryText #</th>\" +\r\n\t                \"# for(var i = 0; i < points.length; i++) { #\" +\r\n\t                \"# var point = points[i]; #\" +\r\n\t                \"<tr>\" +\r\n\t                    \"# if(colorMarker) { # \" +\r\n\t                        \"<td><span class='k-chart-shared-tooltip-marker' style='background-color:#:point.series.color#'></span></td>\" +\r\n\t                    \"# } #\" +\r\n\t                    \"# if(nameColumn) { # \" +\r\n\t                        \"<td> #if (point.series.name) {# #: point.series.name #: #} else {# &nbsp; #}#</td>\" +\r\n\t                    \"# } #\" +\r\n\t                    \"<td>#= content(point) #</td>\" +\r\n\t                \"</tr>\" +\r\n\t                \"# } #\" +\r\n\t                \"</table>\",\r\n\t            categoryFormat: \"{0:d}\"\r\n\t        },\r\n\r\n\t        move: function() {\r\n\t            var tooltip = this,\r\n\t                options = tooltip.options,\r\n\t                element = tooltip.element,\r\n\t                offset;\r\n\r\n\t            if (!tooltip.anchor || !tooltip.element) {\r\n\t                return;\r\n\t            }\r\n\r\n\t            offset = tooltip._offset();\r\n\t            if (!tooltip.visible) {\r\n\t                element.css({ top: offset.top, left: offset.left });\r\n\t            }\r\n\r\n\t            tooltip.visible = true;\r\n\t            tooltip._ensureElement(document.body);\r\n\t            element\r\n\t                .stop(true, true)\r\n\t                .show()\r\n\t                .animate({\r\n\t                    left: offset.left,\r\n\t                    top: offset.top\r\n\t                }, options.animation.duration);\r\n\t        },\r\n\r\n\t        _clearShowTimeout: function() {\r\n\t            if (this.showTimeout) {\r\n\t                clearTimeout(this.showTimeout);\r\n\t                this.showTimeout = null;\r\n\t            }\r\n\t        },\r\n\r\n\t        getAnchor: function(size) {\r\n\t            var anchor = this.anchor;\r\n\t            var point = anchor.point;\r\n\t            var align = anchor.align;\r\n\t            var x = point.left;\r\n\t            var y = point.top;\r\n\t            if (align.horizontal === \"center\") {\r\n\t                x -= size.width / 2;\r\n\t            } else if (align.horizontal === \"right\") {\r\n\t                x -= size.width;\r\n\t            }\r\n\r\n\t            if (align.vertical === \"center\") {\r\n\t                y -= size.height / 2;\r\n\t            } else if (align.vertical === \"bottom\") {\r\n\t                y -= size.height;\r\n\t            }\r\n\r\n\t            return {\r\n\t                x: x,\r\n\t                y: y\r\n\t            };\r\n\t        },\r\n\r\n\t        _offset: function() {\r\n\t            var tooltip = this,\r\n\t                size = tooltip._measure(),\r\n\t                anchor = tooltip.getAnchor(size),\r\n\t                top = anchor.y,\r\n\t                left = anchor.x,\r\n\t                zoomLevel = kendo.support.zoomLevel(),\r\n\t                viewport = $(window),\r\n\t                scrollTop = window.pageYOffset || document.documentElement.scrollTop || 0,\r\n\t                scrollLeft = window.pageXOffset || document.documentElement.scrollLeft || 0,\r\n\t                movable = (this._mobileScroller || {}).movable;\r\n\r\n\t            if (!movable || movable.scale === 1) {\r\n\t                top += tooltip._fit(top - scrollTop, size.height, outerHeight(viewport) / zoomLevel);\r\n\t                left += tooltip._fit(left - scrollLeft, size.width, outerWidth(viewport) / zoomLevel);\r\n\t            } else {\r\n\t                var transform = geom.transform().scale(movable.scale, movable.scale, [movable.x, movable.y]);\r\n\t                var point = new geom.Point(left, top).transform(transform);\r\n\t                left = point.x;\r\n\t                top = point.y;\r\n\t            }\r\n\r\n\t            return {\r\n\t                top: top,\r\n\t                left: left\r\n\t            };\r\n\t        },\r\n\r\n\t        show: function(e) {\r\n\t            this.anchor = e.anchor;\r\n\t            this.element.css(normalizeStyle(e.style));\r\n\t            this.element.toggleClass(TOOLTIP_INVERSE, !!e.className);\r\n\t            this.element.toggleClass(SHARED_TOOLTIP_CLASS, !!e.shared);\r\n\r\n\t            var content = e.shared ? this._sharedContent(e) : this._pointContent(e.point);\r\n\t            this.element.html(content);\r\n\r\n\t            this._clearShowTimeout();\r\n\t            this.showTimeout = setTimeout(this.move, TOOLTIP_SHOW_DELAY);\r\n\t        },\r\n\r\n\t        hide: function() {\r\n\t            var tooltip = this;\r\n\r\n\t            clearTimeout(tooltip.showTimeout);\r\n\t            tooltip._hideElement();\r\n\r\n\t            if (tooltip.visible) {\r\n\t                tooltip.point = null;\r\n\t                tooltip.visible = false;\r\n\t                tooltip.index = null;\r\n\t            }\r\n\t        },\r\n\r\n\t        _sharedContent: function(e) {\r\n\t            var points = e.points;\r\n\t            var nameColumn = dataviz.grep(points, function(point) {\r\n\t                return defined(point.series.name);\r\n\t            }).length;\r\n\r\n\t            var colorMarker = e.series.length > 1;\r\n\t            var colspan = 1;\r\n\t            if (nameColumn) {\r\n\t                colspan++;\r\n\t            }\r\n\t            if (colorMarker) {\r\n\t                colspan++;\r\n\t            }\r\n\r\n\t            var template = kendo.template(this.options.sharedTemplate);\r\n\t            var content = template({\r\n\t                points: points,\r\n\t                category: e.category,\r\n\t                categoryText: e.categoryText,\r\n\t                content: this._pointContent,\r\n\t                colorMarker: colorMarker,\r\n\t                nameColumn: nameColumn,\r\n\t                colspan: colspan\r\n\t            });\r\n\r\n\t            return content;\r\n\t        },\r\n\r\n\t        _measure: function() {\r\n\t            this._ensureElement();\r\n\r\n\t            var size = {\r\n\t                width: outerWidth(this.element),\r\n\t                height: outerHeight(this.element)\r\n\t            };\r\n\r\n\t            return size;\r\n\t        },\r\n\r\n\t        _ensureElement: function() {\r\n\t            if (this.element) {\r\n\t                this.element\r\n\t                    .appendTo(document.body)\r\n\t                    .on(MOUSELEAVE_NS, this._mouseleave);\r\n\t            }\r\n\t        },\r\n\r\n\t        _mouseleave: function(e) {\r\n\t            var target = e.relatedTarget;\r\n\t            var chart = this.chartElement[0];\r\n\t            if (target && target !== chart && !$.contains(chart, target)) {\r\n\t                this.trigger(LEAVE);\r\n\t            }\r\n\t        },\r\n\r\n\t        _hideElement: function() {\r\n\t            var tooltip = this;\r\n\t            var element = this.element;\r\n\t            if (element) {\r\n\t                element.fadeOut({\r\n\t                    always: function(){\r\n\t                        if (!tooltip.visible) {\r\n\t                            element.off(MOUSELEAVE_NS).remove();\r\n\t                        }\r\n\t                    }\r\n\t                });\r\n\t            }\r\n\t        },\r\n\r\n\t        _pointContent: function(point) {\r\n\t            var tooltip = this,\r\n\t                options = deepExtend({}, tooltip.options, point.options.tooltip),\r\n\t                content, tooltipTemplate;\r\n\r\n\t            if (defined(point.value)) {\r\n\t                content = point.value.toString();\r\n\t            }\r\n\r\n\t            if (options.template) {\r\n\t                tooltipTemplate = template(options.template);\r\n\t                content = tooltipTemplate({\r\n\t                    value: point.value,\r\n\t                    category: point.category,\r\n\t                    series: point.series,\r\n\t                    dataItem: point.dataItem,\r\n\t                    percentage: point.percentage,\r\n\t                    runningTotal: point.runningTotal,\r\n\t                    total: point.total,\r\n\t                    low: point.low,\r\n\t                    high: point.high,\r\n\t                    xLow: point.xLow,\r\n\t                    xHigh: point.xHigh,\r\n\t                    yLow: point.yLow,\r\n\t                    yHigh: point.yHigh\r\n\t                });\r\n\t            } else if (options.format) {\r\n\t                content = point.formatValue(options.format);\r\n\t            }\r\n\r\n\t            return content;\r\n\t        },\r\n\r\n\t        _fit: function(offset, size, viewPortSize) {\r\n\t            var output = 0;\r\n\r\n\t            if (offset + size > viewPortSize) {\r\n\t                output = viewPortSize - (offset + size);\r\n\t            }\r\n\r\n\t            if (offset < 0) {\r\n\t                output = -offset;\r\n\t            }\r\n\r\n\t            return output;\r\n\t        }\r\n\t    });\r\n\r\n\t    var CrosshairTooltip = Tooltip.extend({\r\n\t        init: function(chartElement, options) {\r\n\t            Tooltip.fn.init.call(this, chartElement, options);\r\n\t            this.element.addClass(\"k-chart-crosshair-tooltip\");\r\n\t        },\r\n\r\n\t        show: function(e) {\r\n\t            var element = this.element;\r\n\r\n\t            if (element) {\r\n\t                this.anchor = e.anchor;\r\n\t                this.element.css(e.style);\r\n\t                this.element.html(this.content(e));\r\n\r\n\t                this.move();\r\n\t            }\r\n\t        },\r\n\r\n\t        move: function() {\r\n\t            var tooltip = this,\r\n\t                element = tooltip.element,\r\n\t                offset = tooltip._offset();\r\n\r\n\t            tooltip._ensureElement();\r\n\t            element.css({ top: offset.top, left: offset.left }).show();\r\n\t        },\r\n\r\n\t        content: function(e) {\r\n\t            var content = e.value,\r\n\t                options = e.crosshair.options.tooltip;\r\n\r\n\t            if (options.template) {\r\n\t                content = template(options.template)({\r\n\t                    value: content\r\n\t                });\r\n\t            }\r\n\r\n\t            return content;\r\n\t        },\r\n\r\n\t        hide: function() {\r\n\t            this.element.hide();\r\n\t        }\r\n\t    });\r\n\r\n\t    var ChartPane = Class.extend({\r\n\t        init: function(chart, pane) {\r\n\t            this._chart = chart;\r\n\t            this._pane = pane;\r\n\t            this.visual = pane.visual;\r\n\t            this.chartsVisual = pane.chartContainer.visual;\r\n\t            this.name = pane.options.name;\r\n\t        },\r\n\r\n\t        series: function() {\r\n\t            var chart = this._chart;\r\n\t            var seriesByPane = chart._plotArea.groupSeriesByPane();\r\n\t            var series = seriesByPane[this.name || \"default\"];\r\n\r\n\t            var result = [];\r\n\t            if (series) {\r\n\t                for (var idx = 0; idx < series.length; idx++) {\r\n\t                    result.push(new ChartSeries(chart, series[idx]));\r\n\t                }\r\n\t            }\r\n\r\n\t            return result;\r\n\t        }\r\n\t    });\r\n\r\n\t    var ChartSeries = Class.extend({\r\n\t        init: function(chart, options) {\r\n\t            this._chart = chart;\r\n\t            this._options = options;\r\n\t        },\r\n\r\n\t        points: function(filter) {\r\n\t            var points = this._points;\r\n\t            if (!points) {\r\n\t                var series = this._seriesOptions();\r\n\t                var plotArea = this._chart._plotArea;\r\n\t                this._points = points = plotArea.pointsBySeriesIndex(series.index);\r\n\t            }\r\n\t            if (kendo.isFunction(filter)) {\r\n\t                points = this._filterPoints(points, filter);\r\n\t            }\r\n\r\n\r\n\t            return points;\r\n\t        },\r\n\r\n\t        data: function(data) {\r\n\t            var series = this._seriesOptions();\r\n\t            if (data) {\r\n\t                var chart = this._chart;\r\n\t                var plotArea = chart._plotArea;\r\n\r\n\t                series.data = data;\r\n\r\n\t                if (series.categoryField) {\r\n\t                    var axis = plotArea.seriesCategoryAxis(series);\r\n\t                    var options = [].concat(chart.options.categoryAxis);\r\n\r\n\t                    chart._instance.bindCategoryAxisFromSeries(options[axis.axisIndex], axis.axisIndex);\r\n\t                }\r\n\r\n\t                chart._noTransitionsRedraw();\r\n\t                this._clearFields();\r\n\t            }\r\n\r\n\t            return series.data;\r\n\t        },\r\n\r\n\t        findPoint: function(filter) {\r\n\t            var points = this.points();\r\n\t            for (var idx = 0; idx < points.length; idx++) {\r\n\t                if (filter(points[idx])) {\r\n\t                    return points[idx];\r\n\t                }\r\n\t            }\r\n\t        },\r\n\r\n\t        toggleHighlight: function(show, elements) {\r\n\t            if (!elements) {\r\n\t                elements = this.points();\r\n\t            } else if (kendo.isFunction(elements)) {\r\n\t                elements = this.points(elements);\r\n\t            } else {\r\n\t                elements = isArray(elements) ? elements : [elements];\r\n\t            }\r\n\r\n\t            this._chart._instance.togglePointsHighlight(show, elements);\r\n\t        },\r\n\r\n\t        toggleVisibility: function(visible, filter) {\r\n\t            var chart = this._chart;\r\n\t            var seriesOptions = this._seriesOptions();\r\n\t            var hasFilter = kendo.isFunction(filter);\r\n\t            if (!hasFilter) {\r\n\t                seriesOptions.visible = visible;\r\n\t                chart._seriesVisibility.save(seriesOptions);\r\n\t            } else {\r\n\t                if (inArray(seriesOptions.type, [PIE, DONUT, FUNNEL])) {\r\n\t                    var data = this._filterData(filter);\r\n\t                    for (var idx = 0; idx < data.length; idx++) {\r\n\t                        data[idx].visible = visible;\r\n\t                    }\r\n\t                } else {\r\n\t                    seriesOptions.visible = function(data) {\r\n\t                        return filter(data.dataItem) ? visible : true;\r\n\t                    };\r\n\t                }\r\n\t            }\r\n\r\n\t            chart._noTransitionsRedraw();\r\n\r\n\t            this._clearFields();\r\n\t        },\r\n\r\n\t        _filterData: function(filter) {\r\n\t            var data = this._seriesOptions().data;\r\n\t            var length = data.length;\r\n\t            var result = [];\r\n\r\n\t            for (var idx = 0; idx < length; idx++) {\r\n\t                if (filter(data[idx])) {\r\n\t                    result.push(data[idx]);\r\n\t                }\r\n\t            }\r\n\t            return result;\r\n\t        },\r\n\r\n\t        _filterPoints: function(points, filter) {\r\n\t            var result = [];\r\n\t            var length = points.length;\r\n\t            for (var idx = 0; idx < length; idx++) {\r\n\t                if (filter(points[idx])) {\r\n\t                    result.push(points[idx]);\r\n\t                }\r\n\t            }\r\n\t            return result;\r\n\t        },\r\n\r\n\t        _seriesOptions: function() {\r\n\t            var series = this._series;\r\n\t            if (!series) {\r\n\t                series = this._series = this._chart._seriesOptions(this._options);\r\n\t            }\r\n\t            return series;\r\n\t        },\r\n\r\n\t        _clearFields: function() {\r\n\t            delete this._points;\r\n\t            delete this._series;\r\n\t        }\r\n\t    });\r\n\r\n\t    dataviz.Tooltip = Tooltip;\r\n\t    dataviz.CrosshairTooltip = CrosshairTooltip;\r\n\t    dataviz.ChartInstanceObserver = ChartInstanceObserver;\r\n\t    dataviz.ChartPane = ChartPane;\r\n\t    dataviz.ChartSeries = ChartSeries;\r\n\r\n\t})(window.kendo.jQuery);\r\n\r\n\treturn window.kendo;\r\n\r\n\t}, __webpack_require__(3));\r\n\n\n/***/ }),\n\n/***/ 848:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./kendo-chart\");\n\n/***/ }),\n\n/***/ 849:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.data\");\n\n/***/ }),\n\n/***/ 850:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.dataviz.core\");\n\n/***/ }),\n\n/***/ 851:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.dataviz.themes\");\n\n/***/ }),\n\n/***/ 852:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.drawing\");\n\n/***/ }),\n\n/***/ 853:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"../../kendo.userevents\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/dataviz/chart/chart.js\n// module id = 523\n// module chunks = 3","module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1057);\n\n\n/***/ }),\n\n/***/ 3:\n/***/ (function(module, exports) {\n\n\tmodule.exports = function() { throw new Error(\"define cannot be used indirect\"); };\r\n\n\n/***/ }),\n\n/***/ 1057:\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(f, define){\r\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\r\n\t        __webpack_require__(1058),\r\n\t        __webpack_require__(1059)\r\n\t    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (f), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t})(function(){\r\n\r\n\tvar __meta__ = { // jshint ignore:line\r\n\t    id: \"dataviz.core\",\r\n\t    name: \"Core\",\r\n\t    description: \"The DataViz core functions\",\r\n\t    category: \"dataviz\",\r\n\t    depends: [ \"core\", \"drawing\" ],\r\n\t    hidden: true\r\n\t};\r\n\r\n\t}, __webpack_require__(3));\n\n/***/ }),\n\n/***/ 1058:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./dataviz/core/kendo-core\");\n\n/***/ }),\n\n/***/ 1059:\n/***/ (function(module, exports) {\n\n\tmodule.exports = require(\"./dataviz/core/core\");\n\n/***/ })\n\n/******/ });\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@progress/kendo-ui/js/kendo.dataviz.core.js\n// module id = 64\n// module chunks = 3"],"sourceRoot":""}